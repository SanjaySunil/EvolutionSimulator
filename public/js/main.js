/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@canvasjs/charts/canvasjs.min.js":
/*!*******************************************************!*\
  !*** ./node_modules/@canvasjs/charts/canvasjs.min.js ***!
  \*******************************************************/
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* 
 CanvasJS Chart - v3.7.33 GA - https://canvasjs.com/ 
 Copyright 2023 fenopix

 --------------------- License Information --------------------
 CanvasJS Chart is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.
 https://canvasjs.com/license/


 ---------------------Free for Non-Commercial Use--------------------
 
 For non-commercial purposes you can use the software for free under Creative Commons Attribution-NonCommercial 3.0 License.
 A credit Link is added to the chart which should be preserved. Refer to the following link for further details on the same.
 https://creativecommons.org/licenses/by-nc/3.0/deed.en_US
 */

/*tslint:disable*/
/*eslint-disable*/
/*jshint ignore:start*/
(function(){function oa(h,p){h.prototype=db(p.prototype);h.prototype.constructor=h;h.base=p.prototype}function db(h){function p(){}p.prototype=h;return new p}function Xa(h,p,E){"millisecond"===E?h.setMilliseconds(h.getMilliseconds()+1*p):"second"===E?h.setSeconds(h.getSeconds()+1*p):"minute"===E?h.setMinutes(h.getMinutes()+1*p):"hour"===E?h.setHours(h.getHours()+1*p):"day"===E?h.setDate(h.getDate()+1*p):"week"===E?h.setDate(h.getDate()+7*p):"month"===E?h.setMonth(h.getMonth()+1*p):"year"===E&&h.setFullYear(h.getFullYear()+
1*p);return h}function ca(h,p){var E=!1;0>h&&(E=!0,h*=-1);h=""+h;for(p=p?p:1;h.length<p;)h="0"+h;return E?"-"+h:h}function Ha(h){if(!h)return h;h=h.replace(/^\s\s*/,"");for(var p=/\s/,E=h.length;p.test(h.charAt(--E)););return h.slice(0,E+1)}function Da(h){h.roundRect=function(h,E,r,w,qa,A,B,v){B&&(this.fillStyle=B);v&&(this.strokeStyle=v);"undefined"===typeof qa&&(qa=5);this.lineWidth=A;this.beginPath();this.moveTo(h+qa,E);this.lineTo(h+r-qa,E);this.quadraticCurveTo(h+r,E,h+r,E+qa);this.lineTo(h+
r,E+w-qa);this.quadraticCurveTo(h+r,E+w,h+r-qa,E+w);this.lineTo(h+qa,E+w);this.quadraticCurveTo(h,E+w,h,E+w-qa);this.lineTo(h,E+qa);this.quadraticCurveTo(h,E,h+qa,E);this.closePath();B&&this.fill();v&&0<A&&this.stroke()}}function Ra(h,p){return h-p}function X(h){var p=((h&16711680)>>16).toString(16),E=((h&65280)>>8).toString(16);h=((h&255)>>0).toString(16);p=2>p.length?"0"+p:p;E=2>E.length?"0"+E:E;h=2>h.length?"0"+h:h;return"#"+p+E+h}function eb(h,p){var E=this.length>>>0,r=Number(p)||0,r=0>r?Math.ceil(r):
Math.floor(r);for(0>r&&(r+=E);r<E;r++)if(r in this&&this[r]===h)return r;return-1}function r(h){return null===h||"undefined"===typeof h}function Ea(h){h.indexOf||(h.indexOf=eb);return h}function fb(h){if(va.fSDec)h[ia("`eeDwdouMhrudods")](ia("e`u`@ohl`uhnoHuds`uhnoDoe"),function(){va._fTWm&&va._fTWm(h)})}function Ya(h,p,E){E=E||"normal";var r=h+"_"+p+"_"+E,w=Za[r];if(isNaN(w)){try{if(!ra){var qa=document.body;ra=document.createElement("span");ra.innerHTML="";var A=document.createTextNode("Mpgyi");
ra.appendChild(A);qa.appendChild(ra)}ra.style.display="";V(ra,{position:"absolute",left:"0px",top:"-20000px",padding:"0px",margin:"0px",border:"none",whiteSpace:"pre",lineHeight:"normal",fontFamily:h,fontSize:p+"px",fontWeight:E});w=Math.round(ra.offsetHeight);ra.style.display="none"}catch(B){w=Math.ceil(1.1*p)}w=Math.max(w,p);Za[r]=w}return w}function J(h,p){var E=[];if(E={solid:[],shortDash:[3,1],shortDot:[1,1],shortDashDot:[3,1,1,1],shortDashDotDot:[3,1,1,1,1,1],dot:[1,2],dash:[4,2],dashDot:[4,
2,1,2],longDash:[8,2],longDashDot:[8,2,1,2],longDashDotDot:[8,2,1,2,1,2]}[h||"solid"])for(var r=0;r<E.length;r++)E[r]*=p;else E=[];return E}function P(h,p,E,w,ha){w=w||[];ha=r(ha)?gb?{passive:!1,capture:!1}:!1:ha;w.push([h,p,E,ha]);return h.addEventListener?(h.addEventListener(p,E,ha),E):h.attachEvent?(w=function(p){p=p||window.event;p.preventDefault=p.preventDefault||function(){p.returnValue=!1};p.stopPropagation=p.stopPropagation||function(){p.cancelBubble=!0};E.call(h,p)},h.attachEvent("on"+p,
w),w):!1}function hb(h){if(h._menuButton)h.exportEnabled?(V(h._menuButton,{backgroundColor:h.toolbar.itemBackgroundColor,color:h.toolbar.fontColor}),Ma(h._menuButton),sa(h,h._menuButton,"menu")):wa(h._menuButton);else if(h.exportEnabled&&w){var p=!1;h._menuButton=document.createElement("button");sa(h,h._menuButton,"menu");h._toolBar.appendChild(h._menuButton);P(h._menuButton,"touchstart",function(h){p=!0},h.allDOMEventHandlers);P(h._menuButton,"click",function(){"none"!==h._dropdownMenu.style.display||
h._dropDownCloseTime&&500>=(new Date).getTime()-h._dropDownCloseTime.getTime()||(h._dropdownMenu.style.display="block",h._menuButton.blur(),h._dropdownMenu.focus())},h.allDOMEventHandlers,!0);P(h._menuButton,"mousemove",function(){p||(V(h._menuButton,{backgroundColor:h.toolbar.itemBackgroundColorOnHover,color:h.toolbar.fontColorOnHover}),0>=navigator.userAgent.search("MSIE")&&V(h._menuButton.childNodes[0],{WebkitFilter:"invert(100%)",filter:"invert(100%)"}))},h.allDOMEventHandlers,!0);P(h._menuButton,
"mouseout",function(){p||(V(h._menuButton,{backgroundColor:h.toolbar.itemBackgroundColor,color:h.toolbar.fontColor}),0>=navigator.userAgent.search("MSIE")&&V(h._menuButton.childNodes[0],{WebkitFilter:"invert(0%)",filter:"invert(0%)"}))},h.allDOMEventHandlers,!0)}if(h.exportEnabled&&h._dropdownMenu){V(h._dropdownMenu,{backgroundColor:h.toolbar.itemBackgroundColor,color:h.toolbar.fontColor});for(var E=h._dropdownMenu.childNodes,r=[h._cultureInfo.printText,h._cultureInfo.saveJPGText,h._cultureInfo.savePNGText],
ha=0;ha<E.length;ha++)V(E[ha],{backgroundColor:h.toolbar.itemBackgroundColor,color:h.toolbar.fontColor}),E[ha].innerHTML=r[ha]}else!h._dropdownMenu&&(h.exportEnabled&&w)&&(p=!1,h._dropdownMenu=document.createElement("div"),h._dropdownMenu.setAttribute("tabindex",-1),E=-1!==h.theme.indexOf("dark")?"black":"#888888",V(h._dropdownMenu,{position:"absolute",zIndex:1,userSelect:"none",MozUserSeelct:"none",WebkitUserSelect:"none",msUserSelect:"none",cursor:"pointer",right:"0px",top:"25px",minWidth:"120px",
outline:0,fontSize:"14px",fontFamily:"Arial, Helvetica, sans-serif",padding:"5px 0px 5px 0px",textAlign:"left",lineHeight:"10px",backgroundColor:h.toolbar.itemBackgroundColor,boxShadow:"2px 2px 10px"+E}),h._dropdownMenu.style.display="none",h._toolBar.appendChild(h._dropdownMenu),P(h._dropdownMenu,"blur",function(){wa(h._dropdownMenu);h._dropDownCloseTime=new Date},h.allDOMEventHandlers,!0),E=document.createElement("div"),V(E,{padding:"12px 8px 12px 8px"}),E.innerHTML=h._cultureInfo.printText,E.style.backgroundColor=
h.toolbar.itemBackgroundColor,E.style.color=h.toolbar.fontColor,h._dropdownMenu.appendChild(E),P(E,"touchstart",function(h){p=!0},h.allDOMEventHandlers),P(E,"mousemove",function(){p||(this.style.backgroundColor=h.toolbar.itemBackgroundColorOnHover,this.style.color=h.toolbar.fontColorOnHover)},h.allDOMEventHandlers,!0),P(E,"mouseout",function(){p||(this.style.backgroundColor=h.toolbar.itemBackgroundColor,this.style.color=h.toolbar.fontColor)},h.allDOMEventHandlers,!0),P(E,"click",function(){h.print();
wa(h._dropdownMenu)},h.allDOMEventHandlers,!0),E=document.createElement("div"),V(E,{padding:"12px 8px 12px 8px"}),E.innerHTML=h._cultureInfo.saveJPGText,E.style.backgroundColor=h.toolbar.itemBackgroundColor,E.style.color=h.toolbar.fontColor,h._dropdownMenu.appendChild(E),P(E,"touchstart",function(h){p=!0},h.allDOMEventHandlers),P(E,"mousemove",function(){p||(this.style.backgroundColor=h.toolbar.itemBackgroundColorOnHover,this.style.color=h.toolbar.fontColorOnHover)},h.allDOMEventHandlers,!0),P(E,
"mouseout",function(){p||(this.style.backgroundColor=h.toolbar.itemBackgroundColor,this.style.color=h.toolbar.fontColor)},h.allDOMEventHandlers,!0),P(E,"click",function(){h.exportChart({format:"jpeg",fileName:h.exportFileName});wa(h._dropdownMenu)},h.allDOMEventHandlers,!0),E=document.createElement("div"),V(E,{padding:"12px 8px 12px 8px"}),E.innerHTML=h._cultureInfo.savePNGText,E.style.backgroundColor=h.toolbar.itemBackgroundColor,E.style.color=h.toolbar.fontColor,h._dropdownMenu.appendChild(E),P(E,
"touchstart",function(h){p=!0},h.allDOMEventHandlers),P(E,"mousemove",function(){p||(this.style.backgroundColor=h.toolbar.itemBackgroundColorOnHover,this.style.color=h.toolbar.fontColorOnHover)},h.allDOMEventHandlers,!0),P(E,"mouseout",function(){p||(this.style.backgroundColor=h.toolbar.itemBackgroundColor,this.style.color=h.toolbar.fontColor)},h.allDOMEventHandlers,!0),P(E,"click",function(){h.exportChart({format:"png",fileName:h.exportFileName});wa(h._dropdownMenu)},h.allDOMEventHandlers,!0))}function $a(h,
p,E){h*=la;p*=la;h=E.getImageData(h,p,2,2).data;p=!0;for(E=0;4>E;E++)if(h[E]!==h[E+4]|h[E]!==h[E+8]|h[E]!==h[E+12]){p=!1;break}return p?h[0]<<16|h[1]<<8|h[2]:0}function ma(h,p,E){return h in p?p[h]:E[h]}function Na(h,p,E,xa){w&&ab?(xa=!r(xa)&&xa?h.getContext("2d",{willReadFrequently:!0}):h.getContext("2d"),Oa=xa.webkitBackingStorePixelRatio||xa.mozBackingStorePixelRatio||xa.msBackingStorePixelRatio||xa.oBackingStorePixelRatio||xa.backingStorePixelRatio||1,la=Sa/Oa,h.width=p*la,h.height=E*la,Sa!==
Oa&&(h.style.width=p+"px",h.style.height=E+"px",xa.scale(la,la))):(h.width=p,h.height=E)}function ib(h){if(!jb){var p=!1,E=!1;"undefined"===typeof pa.Chart.creditHref?(h.creditHref=ia("iuuqr;..b`ow`rkr/bnl."),h.creditText=ia("B`ow`rKR/bnl")):(p=h.updateOption("creditText"),E=h.updateOption("creditHref"));if(h.creditHref&&h.creditText){h._creditLink||(h._creditLink=document.createElement("a"),h._creditLink.setAttribute("class","canvasjs-chart-credit"),h._creditLink.setAttribute("title","JavaScript Charts"),
V(h._creditLink,{outline:"none",margin:"0px",position:"absolute",right:"2px",top:h.height-14+"px",color:"dimgrey",textDecoration:"none",fontSize:"11px",fontFamily:"Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"}),h._creditLink.setAttribute("tabIndex",-1),h._creditLink.setAttribute("target","_blank"));if(0===h.renderCount||p||E)h._creditLink.setAttribute("href",h.creditHref),h._creditLink.innerHTML=h.creditText;h._creditLink&&h.creditHref&&h.creditText?(h._creditLink.parentElement||
h._canvasJSContainer.appendChild(h._creditLink),h._creditLink.style.top=h.height-14+"px"):h._creditLink.parentElement&&h._canvasJSContainer.removeChild(h._creditLink)}}}function ua(h,p,E){Ia&&(this.canvasCount|=0,window.console.log(++this.canvasCount));var r=document.createElement("canvas");r.setAttribute("class","canvasjs-chart-canvas");Na(r,h,p,E);w||"undefined"===typeof G_vmlCanvasManager||G_vmlCanvasManager.initElement(r);return r}function V(h,p){for(var r in p)h.style[r]=p[r]}function sa(h,p,
r){p.getAttribute("state")||(p.style.backgroundColor=h.toolbar.itemBackgroundColor,p.style.color=h.toolbar.fontColor,p.style.border="none",V(p,{WebkitUserSelect:"none",MozUserSelect:"none",msUserSelect:"none",userSelect:"none"}));p.getAttribute("state")!==r&&(p.setAttribute("state",r),p.setAttribute("type","button"),V(p,{padding:"5px 12px",cursor:"pointer","float":"left",width:"40px",height:"25px",outline:"0px",verticalAlign:"baseline",lineHeight:"0"}),p.innerHTML="<img src='"+kb[r].image+"' alt='"+
h._cultureInfo[r+"Text"]+"' />",V(p.childNodes[0],{height:"95%",pointerEvents:"none"}));p.setAttribute("title",h._cultureInfo[r+"Text"])}function Ma(){for(var h=null,p=0;p<arguments.length;p++)h=arguments[p],h.style&&(h.style.display="inline")}function wa(){for(var h=null,p=0;p<arguments.length;p++)(h=arguments[p])&&h.style&&(h.style.display="none")}function Ta(h,p,r,w,ha){if(null===h||"undefined"===typeof h)return"undefined"===typeof r?p:r;h=parseFloat(h.toString())*(0<=h.toString().indexOf("%")?
p/100:1);"undefined"!==typeof w&&(h=Math.min(w,h),"undefined"!==typeof ha&&(h=Math.max(ha,h)));return!isNaN(h)&&h<=p&&0<=h?h:"undefined"===typeof r?p:r}function G(h,p,E,w,ha){this._defaultsKey=h;this._themeOptionsKey=p;this._index=w;this.parent=ha;this._eventListeners=[];h={};this.theme&&r(this.parent)&&r(p)&&r(w)?h=r(this.predefinedThemes[this.theme])?this.predefinedThemes.light1:this.predefinedThemes[this.theme]:this.parent&&(this.parent.themeOptions&&this.parent.themeOptions[p])&&(null===w?h=this.parent.themeOptions[p]:
0<this.parent.themeOptions[p].length&&(w=Math.min(this.parent.themeOptions[p].length-1,w),h=this.parent.themeOptions[p][w]));this.themeOptions=h;this.options=E?E:{_isPlaceholder:!0};this.setOptions(this.options,h)}function Fa(h,p,r,w,ha){"undefined"===typeof ha&&(ha=0);this._padding=ha;this._x1=h;this._y1=p;this._x2=r;this._y2=w;this._rightOccupied=this._leftOccupied=this._bottomOccupied=this._topOccupied=this._padding}function ja(h,p){ja.base.constructor.call(this,"TextBlock",null,p,null,null);this.ctx=
h;this._isDirty=!0;this._wrappedText=null;this._initialize()}function Ua(h,p){Ua.base.constructor.call(this,"Toolbar","toolbar",p,null,h);this.chart=h;this.canvas=h.canvas;this.ctx=this.chart.ctx;this.optionsName="toolbar"}function za(h,p){za.base.constructor.call(this,"Title","title",p,null,h);this.chart=h;this.canvas=h.canvas;this.ctx=this.chart.ctx;this.optionsName="title";if(r(this.options.margin)&&h.options.subtitles)for(var E=h.options.subtitles,w=0;w<E.length;w++)if((r(E[w].horizontalAlign)&&
"center"===this.horizontalAlign||E[w].horizontalAlign===this.horizontalAlign)&&(r(E[w].verticalAlign)&&"top"===this.verticalAlign||E[w].verticalAlign===this.verticalAlign)&&!E[w].dockInsidePlotArea===!this.dockInsidePlotArea){this.margin=0;break}"undefined"===typeof this.options.fontSize&&(this.fontSize=this.chart.getAutoFontSize(this.fontSize));this.height=this.width=null;this.bounds={x1:null,y1:null,x2:null,y2:null}}function Ja(h,p,r){Ja.base.constructor.call(this,"Subtitle","subtitles",p,r,h);
this.chart=h;this.canvas=h.canvas;this.ctx=this.chart.ctx;this.optionsName="subtitles";this.isOptionsInArray=!0;"undefined"===typeof this.options.fontSize&&(this.fontSize=this.chart.getAutoFontSize(this.fontSize));this.height=this.width=null;this.bounds={x1:null,y1:null,x2:null,y2:null}}function Va(){this.pool=[]}function Ka(h){var p;h&&La[h]&&(p=La[h]);Ka.base.constructor.call(this,"CultureInfo",null,p,null,null)}var Ia=!1,va={},w=!!document.createElement("canvas").getContext,pa={Chart:{width:500,
height:400,zoomEnabled:!1,zoomType:"x",backgroundColor:"white",theme:"light1",animationEnabled:!1,animationDuration:1200,dataPointWidth:null,dataPointMinWidth:null,dataPointMaxWidth:null,colorSet:"colorSet1",culture:"en",creditText:"CanvasJS",interactivityEnabled:!0,exportEnabled:!1,exportFileName:"Chart",rangeChanging:null,rangeChanged:null,publicProperties:{title:"readWrite",subtitles:"readWrite",toolbar:"readWrite",toolTip:"readWrite",legend:"readWrite",axisX:"readWrite",axisY:"readWrite",axisX2:"readWrite",
axisY2:"readWrite",data:"readWrite",options:"readWrite",bounds:"readOnly",container:"readOnly",selectedColorSet:"readOnly"}},Title:{padding:0,text:null,verticalAlign:"top",horizontalAlign:"center",fontSize:20,fontFamily:"Calibri",fontWeight:"normal",fontColor:"black",fontStyle:"normal",borderThickness:0,borderColor:"black",cornerRadius:0,backgroundColor:w?"transparent":null,margin:5,wrap:!0,maxWidth:null,dockInsidePlotArea:!1,publicProperties:{options:"readWrite",bounds:"readOnly",chart:"readOnly"}},
Subtitle:{padding:0,text:null,verticalAlign:"top",horizontalAlign:"center",fontSize:14,fontFamily:"Calibri",fontWeight:"normal",fontColor:"black",fontStyle:"normal",borderThickness:0,borderColor:"black",cornerRadius:0,backgroundColor:null,margin:2,wrap:!0,maxWidth:null,dockInsidePlotArea:!1,publicProperties:{options:"readWrite",bounds:"readOnly",chart:"readOnly"}},Toolbar:{itemBackgroundColor:"white",itemBackgroundColorOnHover:"#2196f3",buttonBorderColor:"#2196f3",buttonBorderThickness:1,fontColor:"black",
fontColorOnHover:"white",publicProperties:{options:"readWrite",chart:"readOnly"}},Legend:{name:null,verticalAlign:"center",horizontalAlign:"right",fontSize:14,fontFamily:"calibri",fontWeight:"normal",fontColor:"black",fontStyle:"normal",cursor:null,itemmouseover:null,itemmouseout:null,itemmousemove:null,itemclick:null,dockInsidePlotArea:!1,reversed:!1,backgroundColor:w?"transparent":null,borderColor:w?"transparent":null,borderThickness:0,cornerRadius:0,maxWidth:null,maxHeight:null,markerMargin:null,
itemMaxWidth:null,itemWidth:null,itemWrap:!0,itemTextFormatter:null,publicProperties:{options:"readWrite",bounds:"readOnly",chart:"readOnly"}},ToolTip:{enabled:!0,shared:!1,animationEnabled:!0,content:null,contentFormatter:null,reversed:!1,backgroundColor:w?"rgba(255,255,255,.9)":"rgb(255,255,255)",borderColor:null,borderThickness:2,cornerRadius:5,fontSize:14,fontColor:"black",fontFamily:"Calibri, Arial, Georgia, serif;",fontWeight:"normal",fontStyle:"italic",updated:null,hidden:null,publicProperties:{options:"readWrite",
chart:"readOnly"}},Axis:{minimum:null,maximum:null,viewportMinimum:null,viewportMaximum:null,interval:null,intervalType:null,reversed:!1,logarithmic:!1,logarithmBase:10,title:null,titleFontColor:"black",titleFontSize:20,titleFontFamily:"arial",titleFontWeight:"normal",titleFontStyle:"normal",titleWrap:!0,titleMaxWidth:null,titleBackgroundColor:w?"transparent":null,titleBorderColor:w?"transparent":null,titleBorderThickness:0,titleCornerRadius:0,labelAngle:0,labelFontFamily:"arial",labelFontColor:"black",
labelFontSize:12,labelFontWeight:"normal",labelFontStyle:"normal",labelAutoFit:!0,labelWrap:!0,labelMaxWidth:null,labelFormatter:null,labelBackgroundColor:w?"transparent":null,labelBorderColor:w?"transparent":null,labelBorderThickness:0,labelCornerRadius:0,labelPlacement:"outside",labelTextAlign:"left",prefix:"",suffix:"",includeZero:!1,tickLength:5,tickColor:"black",tickThickness:1,tickPlacement:"outside",lineColor:"black",lineThickness:1,lineDashType:"solid",gridColor:"#A0A0A0",gridThickness:0,
gridDashType:"solid",interlacedColor:w?"transparent":null,valueFormatString:null,margin:2,publicProperties:{options:"readWrite",stripLines:"readWrite",scaleBreaks:"readWrite",crosshair:"readWrite",bounds:"readOnly",chart:"readOnly"}},StripLine:{value:null,startValue:null,endValue:null,color:"orange",opacity:null,thickness:2,lineDashType:"solid",label:"",labelPlacement:"inside",labelAlign:"far",labelWrap:!0,labelMaxWidth:null,labelBackgroundColor:null,labelBorderColor:w?"transparent":null,labelBorderThickness:0,
labelCornerRadius:0,labelFontFamily:"arial",labelFontColor:"orange",labelFontSize:12,labelFontWeight:"normal",labelFontStyle:"normal",labelFormatter:null,showOnTop:!1,publicProperties:{options:"readWrite",axis:"readOnly",bounds:"readOnly",chart:"readOnly"}},ScaleBreaks:{autoCalculate:!1,collapsibleThreshold:"25%",maxNumberOfAutoBreaks:2,spacing:8,type:"straight",color:"#FFFFFF",fillOpacity:0.9,lineThickness:2,lineColor:"#E16E6E",lineDashType:"solid",publicProperties:{options:"readWrite",customBreaks:"readWrite",
axis:"readOnly",autoBreaks:"readOnly",bounds:"readOnly",chart:"readOnly"}},Break:{startValue:null,endValue:null,spacing:8,type:"straight",color:"#FFFFFF",fillOpacity:0.9,lineThickness:2,lineColor:"#E16E6E",lineDashType:"solid",publicProperties:{options:"readWrite",scaleBreaks:"readOnly",bounds:"readOnly",chart:"readOnly"}},Crosshair:{enabled:!1,snapToDataPoint:!1,color:"grey",opacity:null,thickness:2,lineDashType:"solid",label:"",labelWrap:!0,labelMaxWidth:null,labelBackgroundColor:w?"grey":null,
labelBorderColor:w?"grey":null,labelBorderThickness:0,labelCornerRadius:0,labelFontFamily:w?"Calibri, Optima, Candara, Verdana, Geneva, sans-serif":"calibri",labelFontSize:12,labelFontColor:"#fff",labelFontWeight:"normal",labelFontStyle:"normal",labelFormatter:null,valueFormatString:null,updated:null,hidden:null,publicProperties:{options:"readWrite",axis:"readOnly",bounds:"readOnly",chart:"readOnly"}},DataSeries:{name:null,dataPoints:null,label:"",bevelEnabled:!1,highlightEnabled:!0,cursor:"default",
indexLabel:"",indexLabelPlacement:"auto",indexLabelOrientation:"horizontal",indexLabelTextAlign:"left",indexLabelFontColor:"black",indexLabelFontSize:12,indexLabelFontStyle:"normal",indexLabelFontFamily:"Arial",indexLabelFontWeight:"normal",indexLabelBackgroundColor:null,indexLabelLineColor:"gray",indexLabelLineThickness:1,indexLabelLineDashType:"solid",indexLabelMaxWidth:null,indexLabelWrap:!0,indexLabelFormatter:null,lineThickness:2,lineDashType:"solid",connectNullData:!1,nullDataLineDashType:"dash",
color:null,lineColor:null,risingColor:"white",fallingColor:"red",fillOpacity:null,startAngle:0,radius:null,innerRadius:null,neckHeight:null,neckWidth:null,reversed:!1,valueRepresents:null,linkedDataSeriesIndex:null,whiskerThickness:2,whiskerDashType:"solid",whiskerColor:null,whiskerLength:null,stemThickness:2,stemColor:null,stemDashType:"solid",upperBoxColor:"white",lowerBoxColor:"white",type:"column",xValueType:"number",axisXType:"primary",axisYType:"primary",axisXIndex:0,axisYIndex:0,xValueFormatString:null,
yValueFormatString:null,zValueFormatString:null,percentFormatString:null,showInLegend:null,legendMarkerType:null,legendMarkerColor:null,legendText:null,legendMarkerBorderColor:w?"transparent":null,legendMarkerBorderThickness:0,markerType:"circle",markerColor:null,markerSize:null,markerBorderColor:w?"transparent":null,markerBorderThickness:0,mouseover:null,mouseout:null,mousemove:null,click:null,toolTipContent:null,visible:!0,publicProperties:{options:"readWrite",axisX:"readWrite",axisY:"readWrite",
chart:"readOnly"}},TextBlock:{x:0,y:0,width:null,height:null,maxWidth:null,maxHeight:null,padding:0,angle:0,text:"",horizontalAlign:"center",textAlign:"left",fontSize:12,fontFamily:"calibri",fontWeight:"normal",fontColor:"black",fontStyle:"normal",borderThickness:0,borderColor:"black",cornerRadius:0,backgroundColor:null,textBaseline:"top"},CultureInfo:{decimalSeparator:".",digitGroupSeparator:",",zoomText:"Zoom",panText:"Pan",resetText:"Reset",menuText:"More Options",saveJPGText:"Save as JPEG",savePNGText:"Save as PNG",
printText:"Print",days:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),shortDays:"Sun Mon Tue Wed Thu Fri Sat".split(" "),months:"January February March April May June July August September October November December".split(" "),shortMonths:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")}},La={en:{}},B=w?"Trebuchet MS, Helvetica, sans-serif":"Arial",Ga=w?"Impact, Charcoal, sans-serif":"Arial",Aa={colorSet1:"#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "),
colorSet2:"#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "),colorSet3:"#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")},K,aa,Q,U,Z;aa="#333333";Q="#000000";K="#666666";Z=U="#000000";var fa=20,v=14,Wa={colorSet:"colorSet1",backgroundColor:"#FFFFFF",title:{fontFamily:Ga,fontSize:32,fontColor:aa,fontWeight:"normal",verticalAlign:"top",
margin:5},subtitles:[{fontFamily:Ga,fontSize:v,fontColor:aa,fontWeight:"normal",verticalAlign:"top",margin:5}],data:[{indexLabelFontFamily:B,indexLabelFontSize:v,indexLabelFontColor:aa,indexLabelFontWeight:"normal",indexLabelLineThickness:1}],axisX:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:aa,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:0,gridColor:K,stripLines:[{labelFontFamily:B,
labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,lineDashType:"solid"}}],axisX2:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:aa,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,
labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:0,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,
lineDashType:"solid"}}],axisY:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:aa,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:1,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",
labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,lineDashType:"solid"}}],axisY2:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:aa,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:1,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",
labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,lineDashType:"solid"}}],legend:{fontFamily:B,fontSize:14,fontColor:aa,fontWeight:"bold",verticalAlign:"bottom",horizontalAlign:"center"},toolTip:{fontFamily:B,fontSize:14,fontStyle:"normal",cornerRadius:0,borderThickness:1},
toolbar:{itemBackgroundColor:"white",itemBackgroundColorOnHover:"#2196f3",buttonBorderColor:"#2196f3",buttonBorderThickness:1,fontColor:"black",fontColorOnHover:"white"}};Q=aa="#F5F5F5";K="#FFFFFF";U="#40BAF1";Z="#F5F5F5";var fa=20,v=14,bb={colorSet:"colorSet2",title:{fontFamily:B,fontSize:33,fontColor:"#3A3A3A",fontWeight:"bold",verticalAlign:"top",margin:5},subtitles:[{fontFamily:B,fontSize:v,fontColor:"#3A3A3A",fontWeight:"normal",verticalAlign:"top",margin:5}],data:[{indexLabelFontFamily:B,indexLabelFontSize:v,
indexLabelFontColor:"#666666",indexLabelFontWeight:"normal",indexLabelLineThickness:1}],axisX:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:"#666666",titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:"#666666",labelFontWeight:"normal",lineThickness:1,lineColor:"#BBBBBB",tickThickness:1,tickColor:"#BBBBBB",gridThickness:1,gridColor:"#BBBBBB",stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FFA500",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FFA500",
thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",labelBackgroundColor:"black",color:"black",thickness:1,lineDashType:"dot"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,lineDashType:"solid"}}],axisX2:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:"#666666",titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:"#666666",labelFontWeight:"normal",lineThickness:1,lineColor:"#BBBBBB",tickColor:"#BBBBBB",
tickThickness:1,gridThickness:1,gridColor:"#BBBBBB",stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FFA500",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FFA500",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",labelBackgroundColor:"black",color:"black",thickness:1,lineDashType:"dot"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,lineDashType:"solid"}}],axisY:[{titleFontFamily:B,
titleFontSize:fa,titleFontColor:"#666666",titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:"#666666",labelFontWeight:"normal",lineThickness:0,lineColor:"#BBBBBB",tickColor:"#BBBBBB",tickThickness:1,gridThickness:1,gridColor:"#BBBBBB",stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FFA500",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FFA500",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",
labelBackgroundColor:"black",color:"black",thickness:1,lineDashType:"dot"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,lineDashType:"solid"}}],axisY2:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:"#666666",titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:"#666666",labelFontWeight:"normal",lineThickness:0,lineColor:"#BBBBBB",tickColor:"#BBBBBB",tickThickness:1,gridThickness:1,gridColor:"#BBBBBB",stripLines:[{labelFontFamily:B,labelFontSize:v,
labelFontColor:"#FFA500",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FFA500",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#EEEEEE",labelFontWeight:"normal",labelBackgroundColor:"black",color:"black",thickness:1,lineDashType:"dot"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#BBBBBB",lineThickness:1,lineDashType:"solid"}}],legend:{fontFamily:B,fontSize:14,fontColor:"#3A3A3A",fontWeight:"bold",verticalAlign:"bottom",horizontalAlign:"center"},toolTip:{fontFamily:B,
fontSize:14,fontStyle:"normal",cornerRadius:0,borderThickness:1},toolbar:{itemBackgroundColor:"white",itemBackgroundColorOnHover:"#2196f3",buttonBorderColor:"#2196f3",buttonBorderThickness:1,fontColor:"black",fontColorOnHover:"white"}};Q=aa="#F5F5F5";K="#FFFFFF";U="#40BAF1";Z="#F5F5F5";fa=20;v=14;Ga={colorSet:"colorSet12",backgroundColor:"#2A2A2A",title:{fontFamily:Ga,fontSize:32,fontColor:aa,fontWeight:"normal",verticalAlign:"top",margin:5},subtitles:[{fontFamily:Ga,fontSize:v,fontColor:aa,fontWeight:"normal",
verticalAlign:"top",margin:5}],toolbar:{itemBackgroundColor:"#666666",itemBackgroundColorOnHover:"#FF7372",buttonBorderColor:"#FF7372",buttonBorderThickness:1,fontColor:"#F5F5F5",fontColorOnHover:"#F5F5F5"},data:[{indexLabelFontFamily:B,indexLabelFontSize:v,indexLabelFontColor:Q,indexLabelFontWeight:"normal",indexLabelLineThickness:1}],axisX:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,
lineColor:K,tickThickness:1,tickColor:K,gridThickness:0,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],axisX2:[{titleFontFamily:B,
titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:0,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,
lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],axisY:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:1,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,
color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],axisY2:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,
tickColor:K,gridThickness:1,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],legend:{fontFamily:B,fontSize:14,
fontColor:aa,fontWeight:"bold",verticalAlign:"bottom",horizontalAlign:"center"},toolTip:{fontFamily:B,fontSize:14,fontStyle:"normal",cornerRadius:0,borderThickness:1,fontColor:Q,backgroundColor:"rgba(0, 0, 0, .7)"}};K="#FFFFFF";Q=aa="#FAFAFA";U="#40BAF1";Z="#F5F5F5";var fa=20,v=14,cb={light1:Wa,light2:bb,dark1:Ga,dark2:{colorSet:"colorSet2",backgroundColor:"#32373A",title:{fontFamily:B,fontSize:32,fontColor:aa,fontWeight:"normal",verticalAlign:"top",margin:5},subtitles:[{fontFamily:B,fontSize:v,fontColor:aa,
fontWeight:"normal",verticalAlign:"top",margin:5}],toolbar:{itemBackgroundColor:"#666666",itemBackgroundColorOnHover:"#FF7372",buttonBorderColor:"#FF7372",buttonBorderThickness:1,fontColor:"#F5F5F5",fontColorOnHover:"#F5F5F5"},data:[{indexLabelFontFamily:B,indexLabelFontSize:v,indexLabelFontColor:Q,indexLabelFontWeight:"normal",indexLabelLineThickness:1}],axisX:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",
lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:0,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],
axisX2:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:1,lineColor:K,tickThickness:1,tickColor:K,gridThickness:0,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,
color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],axisY:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:0,lineColor:K,tickThickness:1,tickColor:K,gridThickness:1,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,
color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],axisY2:[{titleFontFamily:B,titleFontSize:fa,titleFontColor:Q,titleFontWeight:"normal",labelFontFamily:B,labelFontSize:v,labelFontColor:Q,labelFontWeight:"normal",lineThickness:0,lineColor:K,tickThickness:1,
tickColor:K,gridThickness:1,gridColor:K,stripLines:[{labelFontFamily:B,labelFontSize:v,labelFontColor:"#FF7300",labelFontWeight:"normal",labelBackgroundColor:null,color:"#FF7300",thickness:1}],crosshair:{labelFontFamily:B,labelFontSize:v,labelFontColor:"#000000",labelFontWeight:"normal",labelBackgroundColor:Z,color:U,thickness:1,lineDashType:"dash"},scaleBreaks:{type:"zigzag",spacing:"2%",lineColor:"#777777",lineThickness:1,lineDashType:"solid",color:"#111111"}}],legend:{fontFamily:B,fontSize:14,
fontColor:aa,fontWeight:"bold",verticalAlign:"bottom",horizontalAlign:"center"},toolTip:{fontFamily:B,fontSize:14,fontStyle:"normal",cornerRadius:0,borderThickness:1,fontColor:Q,backgroundColor:"rgba(0, 0, 0, .7)"}},theme1:Wa,theme2:bb,theme3:Wa},T={numberDuration:1,yearDuration:314496E5,monthDuration:2592E6,weekDuration:6048E5,dayDuration:864E5,hourDuration:36E5,minuteDuration:6E4,secondDuration:1E3,millisecondDuration:1,dayOfWeekFromInt:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")};
(function(){va.fSDec=function(h){for(var p="",r=0;r<h.length;r++)p+=String.fromCharCode(Math.ceil(h.length/57/5)^h.charCodeAt(r));return p};delete pa[va.fSDec("Bi`su")][va.fSDec("bsdehuIsdg")];va.pro={sCH:pa[va.fSDec("Bi`su")][va.fSDec("bsdehuIsdg")]}})();var gb=function(){var h=!1;try{var p=Object.defineProperty&&Object.defineProperty({},"passive",{get:function(){h=!0;return!1}});window.addEventListener&&(window.addEventListener("test",null,p),window.removeEventListener("test",null,p))}catch(r){h=
!1}return h}(),Za={},ra=null,lb=function(){this.ctx.clearRect(0,0,this.width,this.height);this.backgroundColor&&(this.ctx.fillStyle=this.backgroundColor,this.ctx.fillRect(0,0,this.width,this.height))},ya=function(h){h.width=1;h.height=1;h.getContext("2d")&&h.getContext("2d").clearRect(0,0,1,1)},mb=function(h,p,r){p=Math.min(this.width,this.height);return Math.max("theme4"===this.theme?0:300<=p?12:11,Math.round(p*(h/400)))},Ba=function(){var h=/D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g,
p="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),r="Sun Mon Tue Wed Thu Fri Sat".split(" "),w="January February March April May June July August September October November December".split(" "),ha="Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),B=/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,A=/[^-+\dA-Z]/g;return function(v,J,N){var K=N?N.days:p,X=N?N.months:w,P=N?N.shortDays:
r,T=N?N.shortMonths:ha;N="";var V=!1;v=v&&v.getTime?v:v?new Date(v):new Date;if(isNaN(v))throw SyntaxError("invalid date");"UTC:"===J.slice(0,4)&&(J=J.slice(4),V=!0);N=V?"getUTC":"get";var G=v[N+"Date"](),M=v[N+"Day"](),W=v[N+"Month"](),a=v[N+"FullYear"](),d=v[N+"Hours"](),c=v[N+"Minutes"](),b=v[N+"Seconds"](),e=v[N+"Milliseconds"](),f=V?0:v.getTimezoneOffset();return N=J.replace(h,function(l){switch(l){case "D":return G;case "DD":return ca(G,2);case "DDD":return P[M];case "DDDD":return K[M];case "M":return W+
1;case "MM":return ca(W+1,2);case "MMM":return T[W];case "MMMM":return X[W];case "Y":return parseInt(String(a).slice(-2));case "YY":return ca(String(a).slice(-2),2);case "YYY":return ca(String(a).slice(-3),3);case "YYYY":return ca(a,4);case "h":return d%12||12;case "hh":return ca(d%12||12,2);case "H":return d;case "HH":return ca(d,2);case "m":return c;case "mm":return ca(c,2);case "s":return b;case "ss":return ca(b,2);case "f":return ca(String(e),3).slice(0,1);case "ff":return ca(String(e),3).slice(0,
2);case "fff":return ca(String(e),3).slice(0,3);case "t":return 12>d?"a":"p";case "tt":return 12>d?"am":"pm";case "T":return 12>d?"A":"P";case "TT":return 12>d?"AM":"PM";case "K":return V?"UTC":(String(v).match(B)||[""]).pop().replace(A,"");case "z":return(0<f?"-":"+")+Math.floor(Math.abs(f)/60);case "zz":return(0<f?"-":"+")+ca(Math.floor(Math.abs(f)/60),2);case "zzz":return(0<f?"-":"+")+ca(Math.floor(Math.abs(f)/60),2)+ca(Math.abs(f)%60,2);default:return l.slice(1,l.length-1)}})}}(),nb=function(h){var p=
0>h;if(1>Math.abs(h)){var r=parseInt(h.toString().split("e-")[1]);r&&(h=(p?-1*h:h)*Math.pow(10,r-1),h="0."+Array(r).join("0")+h.toString().substring(2),h=p?"-"+h:h)}else r=parseInt(h.toString().split("+")[1]),20<r&&(r-=20,h/=Math.pow(10,r),h=h.toString()+Array(r+1).join("0"));return String(h)},da=function(h,p,r){if(null===h)return"";if(!isFinite(h))return h;h=Number(h);var w=0>h?!0:!1;w&&(h*=-1);var B=r?r.decimalSeparator:".",v=r?r.digitGroupSeparator:",",A="";p=String(p);var A=1,J=r="",K=-1,N=[],
X=[],P=0,T=0,V=0,G=!1,Q=0,J=p.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);p=null;for(var M=0;J&&M<J.length;M++)if(p=J[M],"."===p&&0>K)K=M;else{if("%"===p)A*=100;else if("\u2030"===p){A*=1E3;continue}else if(","===p[0]&&"."===p[p.length-1]){A/=Math.pow(1E3,p.length-1);K=M+p.length-1;continue}else"E"!==p[0]&&"e"!==p[0]||"0"!==p[p.length-1]||(G=!0);0>K?(N.push(p),"#"===p||"0"===p?P++:","===p&&V++):(X.push(p),"#"!==p&&"0"!==p||T++)}G&&(p=Math.floor(h),J=-Math.floor(Math.log(h)/Math.LN10+
1),Q=0===h?0:0===p?-(P+J):nb(p).length-P,A/=Math.pow(10,Q));0>K&&(K=M);A=(h*A).toFixed(T);p=A.split(".");A=(p[0]+"").split("");h=(p[1]+"").split("");A&&"0"===A[0]&&A.shift();for(G=J=M=T=K=0;0<N.length;)if(p=N.pop(),"#"===p||"0"===p)if(K++,K===P){var W=A,A=[];if("0"===p)for(p=P-T-(W?W.length:0);0<p;)W.unshift("0"),p--;for(;0<W.length;)r=W.pop()+r,G++,0===G%J&&(M===V&&0<W.length)&&(r=v+r)}else 0<A.length?(r=A.pop()+r,T++,G++):"0"===p&&(r="0"+r,T++,G++),0===G%J&&(M===V&&0<A.length)&&(r=v+r);else"E"!==
p[0]&&"e"!==p[0]||"0"!==p[p.length-1]||!/[eE][+-]*[0]+/.test(p)?","===p?(M++,J=G,G=0,0<A.length&&(r=v+r)):r=1<p.length&&('"'===p[0]&&'"'===p[p.length-1]||"'"===p[0]&&"'"===p[p.length-1])?p.slice(1,p.length-1)+r:p+r:(p=0>Q?p.replace("+","").replace("-",""):p.replace("-",""),r+=p.replace(/[0]+/,function(a){return ca(Q,a.length)}));v="";for(N=!1;0<X.length;)p=X.shift(),"#"===p||"0"===p?0<h.length&&0!==Number(h.join(""))?(v+=h.shift(),N=!0):"0"===p&&(v+="0",N=!0):1<p.length&&('"'===p[0]&&'"'===p[p.length-
1]||"'"===p[0]&&"'"===p[p.length-1])?v+=p.slice(1,p.length-1):"E"!==p[0]&&"e"!==p[0]||"0"!==p[p.length-1]||!/[eE][+-]*[0]+/.test(p)?v+=p:(p=0>Q?p.replace("+","").replace("-",""):p.replace("-",""),v+=p.replace(/[0]+/,function(a){return ca(Q,a.length)}));r+=(N?B:"")+v;return w?"-"+r:r},Pa=function(h){var p=0,r=0;h=h||window.event;h.offsetX||0===h.offsetX?(p=h.offsetX,r=h.offsetY):h.layerX||0==h.layerX?(p=h.layerX,r=h.layerY):(p=h.pageX-h.target.offsetLeft,r=h.pageY-h.target.offsetTop);return{x:p,y:r}},
ab=!0,Sa=window.devicePixelRatio||1,Oa=1,la=ab?Sa/Oa:1,Y=function(h,p,r,w,v,B,A,J,K,N,X,T,P){"undefined"===typeof P&&(P=1);A=A||0;J=J||"black";var G=15<w-p&&15<v-r?8:0.35*Math.min(w-p,v-r);h.beginPath();h.moveTo(p,r);h.save();h.fillStyle=B;h.globalAlpha=P;h.fillRect(p,r,w-p,v-r);h.globalAlpha=1;0<A&&(P=0===A%2?0:0.5,h.beginPath(),h.lineWidth=A,h.strokeStyle=J,h.moveTo(p,r),h.rect(p-P,r-P,w-p+2*P,v-r+2*P),h.stroke());h.restore();!0===K&&(h.save(),h.beginPath(),h.moveTo(p,r),h.lineTo(p+G,r+G),h.lineTo(w-
G,r+G),h.lineTo(w,r),h.closePath(),A=h.createLinearGradient((w+p)/2,r+G,(w+p)/2,r),A.addColorStop(0,B),A.addColorStop(1,"rgba(255, 255, 255, .4)"),h.fillStyle=A,h.fill(),h.restore());!0===N&&(h.save(),h.beginPath(),h.moveTo(p,v),h.lineTo(p+G,v-G),h.lineTo(w-G,v-G),h.lineTo(w,v),h.closePath(),A=h.createLinearGradient((w+p)/2,v-G,(w+p)/2,v),A.addColorStop(0,B),A.addColorStop(1,"rgba(255, 255, 255, .4)"),h.fillStyle=A,h.fill(),h.restore());!0===X&&(h.save(),h.beginPath(),h.moveTo(p,r),h.lineTo(p+G,r+
G),h.lineTo(p+G,v-G),h.lineTo(p,v),h.closePath(),A=h.createLinearGradient(p+G,(v+r)/2,p,(v+r)/2),A.addColorStop(0,B),A.addColorStop(1,"rgba(255, 255, 255, 0.1)"),h.fillStyle=A,h.fill(),h.restore());!0===T&&(h.save(),h.beginPath(),h.moveTo(w,r),h.lineTo(w-G,r+G),h.lineTo(w-G,v-G),h.lineTo(w,v),A=h.createLinearGradient(w-G,(v+r)/2,w,(v+r)/2),A.addColorStop(0,B),A.addColorStop(1,"rgba(255, 255, 255, 0.1)"),h.fillStyle=A,A.addColorStop(0,B),A.addColorStop(1,"rgba(255, 255, 255, 0.1)"),h.fillStyle=A,h.fill(),
h.closePath(),h.restore())},ia=function(h){for(var p="",r=0;r<h.length;r++)p+=String.fromCharCode(Math.ceil(h.length/57/5)^h.charCodeAt(r));return p},jb=window&&(window[ia("mnb`uhno")]&&window[ia("mnb`uhno")].href&&window[ia("mnb`uhno")].href.indexOf&&(-1!==window[ia("mnb`uhno")].href.indexOf(ia("b`ow`rkr/bnl"))||-1!==window[ia("mnb`uhno")].href.indexOf(ia("gdonqhy/bnl"))||-1!==window[ia("mnb`uhno")].href.indexOf(ia("gheemd"))))&&-1===window[ia("mnb`uhno")].href.indexOf(ia("gheemd")),kb={reset:{image:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAeCAYAAABJ/8wUAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPjSURBVFhHxVdJaFNRFP1J/jwkP5MxsbaC1WJEglSxOFAXIsFpVRE3ggi1K90obioRRBA33XXnQnciirhQcMCdorgQxBkXWlREkFKsWkv5npvckp/XnzRpKh64kLw733fffe9L/wrL0+mVUdO8uTSZ3MBL/we2qg4rkuSpodCELstXE46ziVkLQ6FQcGOmeSSq6wd4aV50d3drWjj8kQKZJTUc9kxFGenv79dZrDksTSTWWJp2QYtEPiErysyzdX0LsxsCQR8keX8gs6RHIk8ysdgKFg2G53mhuOPsshTlBjKaFo1g7SqLNoShKLdFXT8huQ/paLSbxatYnc2mHMM4hr18Vi8TIvCmXF3vYrW6cF23gGTOk0M1wA4RKvOmq6vLZRVJipvmSWT6tZ6CSEYkco5V50VPT4+D7RwOqi6RiSZm0fJ+vggSqkeoypdsNmuyelNwbXsbgvkWYMtzDWNvWaijoyOBqE+hVK8abcssUeXQ/YfKyi0gFYv1Ipgfoj34fYGTJLOYJA0ODirok32GLN8XhUWCwSes1hIwBg6LydJ/tEeRRapAdUp+wSAiZchtZZWWgAZ+JNpD8peYXQVK9UwUxNpzOK8pq97kURZhYTCKBwPD7h2zK+js7Myi7D8Fod+0TkMI8+EMAngLGc/WtBFWawkFHFnoj/t9KLgGmF0B3QfkxC+EarxkdhnFYlFLY06USqUwL7UMjICHfh/wOc2sCqhpxGbCkLvL7EUDbF73+6DkmVWB6zi7xUDQSLeYvWjAILvm9zEnkJhlbRcDQZcv6Kg2AipyT/Axw6wKlqVSqxDdjF8Izfod13qURdrG/nxehY+xGh+h0CSzKygGvSNQIcc097BI24jb9hax6kj2E7OrMFX1il+ICEf2NrPbhiXLl+fYl+U7zK4iYdsDcyLGf+ofFlkwcN+s10KhmpuYhhtm0hCLVIFL0MDsqNlDIqy9x2CLs1jL6OvrI7vPRbtohXG6eFmsFnHDGAp6n9AgyuVySRZrGvROxRgIfLXhzjrNYnNBUxNX/dMgRWT1mt4XLDovaApD53E9W3ilNX5M55LJHpRtIsgAvciR4WWcgK2Dvb1YqgXevmF8z2zEBTcKG39EfSKsT9EbhVUaI2FZO+oZIqImxol6j66/hcAu4sSN4vc1ZPoKeoE6RGhYL2YYA+ymOSSi0Z0wWntbtkGUWCvfSDXIxONraZ/FY90KUfNTpfC5spnNLgxoYNnR9RO4F8ofXEHOgogCQE99w+fF2Xw+b7O59rEOsyRqGEfpVoaDMQQ1CZrG46bcM6AZ0C/wPqNfHliqejyTySxh9TqQpL+xmbIlkB9SlAAAAABJRU5ErkJggg=="},
pan:{image:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAICSURBVEhLxZbPahNRGMUn/5MpuAiBEAIufQGfzr5E40YptBXajYzudCEuGqS+gGlrFwquDGRTutBdYfydzJ3LzeQmJGZue+Dw/Z17Mnfmu5Pof9Hr9Z61Wq0bWZMKj263O6xWq99wU9lOpzPMKgEhEcRucNOcioOK+0RzBhNvt9tPV4nmVF19+OWhVqt9xXgFXZq+8lCv119UKpUJ7iX2FmvFTKz8RH34YdBsNk8wVtjE4fGYwm8wrrDi3WBG5oKXZGRSS9hGuNFojLTe2lFz5xThWZIktayyiE2FdT3rzXBXz7krKiL8c17wAKFDjCus2AvW+YGZ9y2JF0VFRuMPfI//rsCE/C+s26s4gQu9ul7r4NteKx7H8XOC724xNNGbaNu++IrBqbOV7Tj3FgMRvc/YKOr3+3sE47wgEt/Bl/gaK5cHbNU11vYSXylfpK7XOvjuumPp4Wcoipu30Qsez2uMXYz4lfI+mOmwothY+SLiXJy7mKVpWs3Si0CoOMfeI9Od43Wic+jO+ZVv+crsm9QSNhUW9LXSeoPBYLXopthGuFQgdIxxhY+UDwlt1x5CZ1hX+NTUdt/OIvjKaDSmuOJfaIVNPKX+W18j/PLA2/kR44p5Sd8HbHngT/yTfNRWUXX14ZcL3wmX0+TLf8YO7CGT8yFE5zB3/gney25/OETRP9CtPDFe5jShAAAAAElFTkSuQmCC"},
zoom:{image:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALWSURBVEhLvZZLaBNRFIabyftBIgEfqCCBoCC6MYqiXYiIj4U76U4X7sUHbhQhUBfixhZEUBDB16YuFERaUaQLK7ooCOJj4UKtYEFU0EptShO/A9Ph3js3k8lo/eHnP7n3nP/M3LlzMz1hkUwmNziOcyKRSFyFt+LxeD/c2Wq1Ym7Kv0M2m11Os1OxWGycn1OwZXCGuXfwIhezkd9/jRgNT2L4ldhs1pbkX5OLJe4euVxuGQaPCa3mnUjtJx7BDuKusJTCV6jVVGHTMuYRjxma7yIOhTgFY6jNaAKew2xPKpVay9ganmkvj+M448/MfJdT5K5Gg4HJacRngPFgqVRaRNwW1B4i7yehWfsEDdz1K+A01AoxPIqGAiuwGfkOTY8+1A6u7AyiFTB2Hu0KPIrdiOnzHLWDybeImvy+Wq2mZa5bUHsD0Zpz+KxHdWQymV6kAb1ElqeORgJLvgnRdj1+R1AfzkIvSUjxVjQSarVakrueIPT8+H1F5jSUy+WXiJrUYBVWyVxU4PEU8TzhfaijUqnMIWrjaY492eWRwdKOIqrnIxnXwLLeRLwk2GQzrEMjg0avEbXxkIxr4OoOImpj2QwyFgms1koa/SZUG8s+0iGnEhNfCNXEhzIXBVz0McTzEvJ+70P9oNFtxEzei3aFYrFYxmuSUPWSv9Yi9IMm2xE1We56Mp1OV4nDwqFmBDV9gk9AEh4gZtFHNt8W4kAUCoXF5MorY9Z/kDni9nDv7hc0i2fhgLvTtX8a99PoMPPagTFPxofRzmDJ9yM+AyEmTfgGysYbQcfhDzPPJDmX0c7gDg4gs9BqFIWhm/Nct5H8gtBq1I7UfIbtvmIuoaGQcp+fdpbbSM43eEH5wrwLbXmhm/fU63VHXjcuok7hEByFY/AeHGC8L5/PL3HT5xGH1uYwfPOICGo+CBcU0vwO1BqzUqILDl/z/9VYIMfpddiAc47jDP8BsUpb13wOLRwAAAAASUVORK5CYII="},
menu:{image:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAeCAYAAABE4bxTAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADoSURBVFhH7dc9CsJAFATgRxIIBCwCqZKATX5sbawsY2MvWOtF9AB6AU8gguAJbD2AnZ2VXQT/Ko2TYGCL2OYtYQc+BuYA+1hCtnCVwMm27SGaXpDJIAiCvCkVR05hGOZNN3HkFMdx3nQRR06+76/R1IcFLJlNQEWlmWlBTwJtKLKHynehZqnjOGM0PYWRVXk61C37p7xlZ3Hk5HneCk1dmMH811xGoKLSzDiQwIBZB4ocoPJdqNkDt2yKlueWRVGUtzy3rPwo3sWRU3nLjuLI6OO67oZM00wMw3hrmpZx0XU9syxrR0T0BeMpb9dneSR2AAAAAElFTkSuQmCC"}};
G.prototype.setOptions=function(h,p){if(pa[this._defaultsKey]){var r=pa[this._defaultsKey],w;for(w in r)"publicProperties"!==w&&r.hasOwnProperty(w)&&(this[w]=h&&w in h?h[w]:p&&w in p?p[w]:r[w])}else Ia&&window.console&&console.log("defaults not set")};G.prototype.get=function(h){var p=pa[this._defaultsKey];if("options"===h)return this.options&&this.options._isPlaceholder?null:this.options;if(p.hasOwnProperty(h)||p.publicProperties&&p.publicProperties.hasOwnProperty(h))return this[h];window.console&&
window.console.log('Property "'+h+"\" doesn't exist. Please check for typo.")};G.prototype.set=function(h,p,r){r="undefined"===typeof r?!0:r;var w=pa[this._defaultsKey];if("options"===h)this.createUserOptions(p);else if(w.hasOwnProperty(h)||w.publicProperties&&w.publicProperties.hasOwnProperty(h)&&"readWrite"===w.publicProperties[h])this.options._isPlaceholder&&this.createUserOptions(),this.options[h]=p;else{window.console&&(w.publicProperties&&w.publicProperties.hasOwnProperty(h)&&"readOnly"===w.publicProperties[h]?
window.console.log('Property "'+h+'" is read-only.'):window.console.log('Property "'+h+"\" doesn't exist. Please check for typo."));return}r&&(this.stockChart||this.chart||this).render()};G.prototype.addTo=function(h,p,r,w){w="undefined"===typeof w?!0:w;var v=pa[this._defaultsKey];v.hasOwnProperty(h)||v.publicProperties&&v.publicProperties.hasOwnProperty(h)&&"readWrite"===v.publicProperties[h]?(this.options._isPlaceholder&&this.createUserOptions(),"undefined"===typeof this.options[h]&&(this.options[h]=
[]),h=this.options[h],r="undefined"===typeof r||null===r?h.length:r,h.splice(r,0,p),w&&(this.stockChart||this.chart||this).render()):window.console&&(v.publicProperties&&v.publicProperties.hasOwnProperty(h)&&"readOnly"===v.publicProperties[h]?window.console.log('Property "'+h+'" is read-only.'):window.console.log('Property "'+h+"\" doesn't exist. Please check for typo."))};G.prototype.createUserOptions=function(h){if("undefined"!==typeof h||this.options._isPlaceholder)if(this.parent.options._isPlaceholder&&
this.parent.createUserOptions(),this.isOptionsInArray){this.parent.options[this.optionsName]||(this.parent.options[this.optionsName]=[]);var p=this.parent.options[this.optionsName],r=p.length;this.options._isPlaceholder||(Ea(p),r=p.indexOf(this.options));this.options="undefined"===typeof h?{}:h;p[r]=this.options}else this.options="undefined"===typeof h?{}:h,h=this.parent.options,this.optionsName?p=this.optionsName:(p=this._defaultsKey)&&0!==p.length?(r=p.charAt(0).toLowerCase(),1<p.length&&(r=r.concat(p.slice(1))),
p=r):p=void 0,h[p]=this.options};G.prototype.remove=function(h){h="undefined"===typeof h?!0:h;if(this.isOptionsInArray){var p=this.parent.options[this.optionsName];Ea(p);var r=p.indexOf(this.options);0<=r&&p.splice(r,1)}else delete this.parent.options[this.optionsName];h&&(this.stockChart||this.chart||this).render()};G.prototype.updateOption=function(h){!pa[this._defaultsKey]&&(Ia&&window.console)&&console.log("defaults not set");var p=pa[this._defaultsKey],w={},v=this[h],B=this._themeOptionsKey,
J=this._index;this.theme&&r(this.parent)&&r(B)&&r(J)?w=r(this.predefinedThemes[this.theme])?this.predefinedThemes.light1:this.predefinedThemes[this.theme]:this.parent&&(this.parent.themeOptions&&this.parent.themeOptions[B])&&(null===J?w=this.parent.themeOptions[B]:0<this.parent.themeOptions[B].length&&(w=Math.min(this.parent.themeOptions[B].length-1,J),w=this.parent.themeOptions[B][w]));this.themeOptions=w;h in p&&(v=h in this.options?this.options[h]:w&&h in w?w[h]:p[h]);if(v===this[h])return!1;this[h]=
v;return!0};G.prototype.trackChanges=function(h){if(!this.sessionVariables)throw"Session Variable Store not set";this.sessionVariables[h]=this.options[h]};G.prototype.isBeingTracked=function(h){this.options._oldOptions||(this.options._oldOptions={});return this.options._oldOptions[h]?!0:!1};G.prototype.hasOptionChanged=function(h){if(!this.sessionVariables)throw"Session Variable Store not set";return this.sessionVariables[h]!==this.options[h]};G.prototype.addEventListener=function(h,p,r){h&&p&&(this._eventListeners[h]=
this._eventListeners[h]||[],this._eventListeners[h].push({context:r||this,eventHandler:p}))};G.prototype.removeEventListener=function(h,p){if(h&&p&&this._eventListeners[h])for(var r=this._eventListeners[h],w=0;w<r.length;w++)if(r[w].eventHandler===p){r[w].splice(w,1);break}};G.prototype.removeAllEventListeners=function(){this._eventListeners=[]};G.prototype.dispatchEvent=function(h,p,r){if(h&&this._eventListeners[h]){p=p||{};for(var w=this._eventListeners[h],v=0;v<w.length;v++)w[v].eventHandler.call(w[v].context,
p)}"function"===typeof this[h]&&this[h].call(r||this.chart,p)};Fa.prototype.registerSpace=function(h,p){"top"===h?this._topOccupied+=p.height:"bottom"===h?this._bottomOccupied+=p.height:"left"===h?this._leftOccupied+=p.width:"right"===h&&(this._rightOccupied+=p.width)};Fa.prototype.unRegisterSpace=function(h,p){"top"===h?this._topOccupied-=p.height:"bottom"===h?this._bottomOccupied-=p.height:"left"===h?this._leftOccupied-=p.width:"right"===h&&(this._rightOccupied-=p.width)};Fa.prototype.getFreeSpace=
function(){return{x1:this._x1+this._leftOccupied,y1:this._y1+this._topOccupied,x2:this._x2-this._rightOccupied,y2:this._y2-this._bottomOccupied,width:this._x2-this._x1-this._rightOccupied-this._leftOccupied,height:this._y2-this._y1-this._bottomOccupied-this._topOccupied}};Fa.prototype.reset=function(){this._rightOccupied=this._leftOccupied=this._bottomOccupied=this._topOccupied=this._padding};oa(ja,G);ja.prototype._initialize=function(){r(this.padding)||"object"!==typeof this.padding?this.topPadding=
this.rightPadding=this.bottomPadding=this.leftPadding=Number(this.padding)|0:(this.topPadding=r(this.padding.top)?0:Number(this.padding.top)|0,this.rightPadding=r(this.padding.right)?0:Number(this.padding.right)|0,this.bottomPadding=r(this.padding.bottom)?0:Number(this.padding.bottom)|0,this.leftPadding=r(this.padding.left)?0:Number(this.padding.left)|0)};ja.prototype.render=function(h){if(0!==this.fontSize){h&&this.ctx.save();var p=this.ctx.font;this.ctx.textBaseline=this.textBaseline;var r=0;this._isDirty&&
this.measureText(this.ctx);this.ctx.translate(this.x,this.y+r);"middle"===this.textBaseline&&(r=-this._lineHeight/2);this.ctx.font=this._getFontString();this.ctx.rotate(Math.PI/180*this.angle);var w=0,v=this.topPadding,B=null;this.ctx.roundRect||Da(this.ctx);(0<this.borderThickness&&this.borderColor||this.backgroundColor)&&this.ctx.roundRect(0,r,this.width,this.height,this.cornerRadius,this.borderThickness,this.backgroundColor,this.borderColor);this.ctx.fillStyle=this.fontColor;for(r=0;r<this._wrappedText.lines.length;r++){B=
this._wrappedText.lines[r];if("right"===this.horizontalAlign||"right"===this.textAlign)w=this.width-B.width-this.rightPadding;else if("left"===this.horizontalAlign||"left"===this.textAlign)w=this.leftPadding;else if("center"===this.horizontalAlign||"center"===this.textAlign)w=(this.width-(this.leftPadding+this.rightPadding))/2-B.width/2+this.leftPadding;this.ctx.fillText(B.text,w,v);v+=B.height}this.ctx.font=p;h&&this.ctx.restore()}};ja.prototype.setText=function(h){this.text=h;this._isDirty=!0;this._wrappedText=
null};ja.prototype.measureText=function(){this._lineHeight=Ya(this.fontFamily,this.fontSize,this.fontWeight);if(null===this.maxWidth)throw"Please set maxWidth and height for TextBlock";this._wrapText(this.ctx);this._isDirty=!1;return{width:this.width,height:this.height}};ja.prototype._getLineWithWidth=function(h,p,r){h=String(h);if(!h)return{text:"",width:0};var w=r=0,v=h.length-1,B=Infinity;for(this.ctx.font=this._getFontString();w<=v;){var B=Math.floor((w+v)/2),A=h.substr(0,B+1);r=this.ctx.measureText(A).width;
if(r<p)w=B+1;else if(r>p)v=B-1;else break}r>p&&1<A.length&&(A=A.substr(0,A.length-1),r=this.ctx.measureText(A).width);p=!0;if(A.length===h.length||" "===h[A.length])p=!1;p&&(h=A.split(" "),1<h.length&&h.pop(),A=h.join(" "),r=this.ctx.measureText(A).width);return{text:A,width:r}};ja.prototype._wrapText=function(){var h=new String(Ha(String(this.text))),r=[],w=this.ctx.font,v=0,B=0;this.ctx.font=this._getFontString();if(0===this.frontSize)B=v=0;else for(;0<h.length;){var J=this.maxHeight-(this.topPadding+
this.bottomPadding),A=this._getLineWithWidth(h,this.maxWidth-(this.leftPadding+this.rightPadding),!1);A.height=this._lineHeight;r.push(A);var G=B,B=Math.max(B,A.width),v=v+A.height,h=Ha(h.slice(A.text.length,h.length));J&&v>J&&(A=r.pop(),v-=A.height,B=G)}this._wrappedText={lines:r,width:B,height:v};this.width=B+(this.leftPadding+this.rightPadding);this.height=v+(this.topPadding+this.bottomPadding);this.ctx.font=w};ja.prototype._getFontString=function(){var h;h=""+(this.fontStyle?this.fontStyle+" ":
"");h+=this.fontWeight?this.fontWeight+" ":"";h+=this.fontSize?this.fontSize+"px ":"";var r=this.fontFamily?this.fontFamily+"":"";!w&&r&&(r=r.split(",")[0],"'"!==r[0]&&'"'!==r[0]&&(r="'"+r+"'"));return h+=r};oa(Ua,G);oa(za,G);za.prototype.setLayout=function(){if(this.text){var h=this.dockInsidePlotArea?this.chart.plotArea:this.chart,p=h.layoutManager.getFreeSpace(),w=p.x1,v=p.y1,B=0,J=0,A=this.chart._menuButton&&this.chart.exportEnabled&&"top"===this.verticalAlign?40:0,G,K;"top"===this.verticalAlign||
"bottom"===this.verticalAlign?(null===this.maxWidth&&(this.maxWidth=p.width-4-A*("center"===this.horizontalAlign?2:1)),J=0.5*p.height-this.margin-2,B=0):"center"===this.verticalAlign&&("left"===this.horizontalAlign||"right"===this.horizontalAlign?(null===this.maxWidth&&(this.maxWidth=p.height-4),J=0.5*p.width-this.margin-2):"center"===this.horizontalAlign&&(null===this.maxWidth&&(this.maxWidth=p.width-4),J=0.5*p.height-4));var N;r(this.padding)||"number"!==typeof this.padding?r(this.padding)||"object"!==
typeof this.padding||(N=this.padding.top?this.padding.top:this.padding.bottom?this.padding.bottom:0,N+=this.padding.bottom?this.padding.bottom:this.padding.top?this.padding.top:0):N=2*this.padding;this.wrap||(J=Math.min(J,1.5*this.fontSize+N));J=new ja(this.ctx,{fontSize:this.fontSize,fontFamily:this.fontFamily,fontColor:this.fontColor,fontStyle:this.fontStyle,fontWeight:this.fontWeight,horizontalAlign:this.horizontalAlign,textAlign:this.horizontalAlign,verticalAlign:this.verticalAlign,borderColor:this.borderColor,
borderThickness:this.borderThickness,backgroundColor:this.backgroundColor,maxWidth:this.maxWidth,maxHeight:J,cornerRadius:this.cornerRadius,text:this.text,padding:this.padding,textBaseline:"middle"});N=J.measureText();"top"===this.verticalAlign||"bottom"===this.verticalAlign?("top"===this.verticalAlign?(v=p.y1+2+this.fontSize/2+4,K="top"):"bottom"===this.verticalAlign&&(v=p.y2-2-N.height+this.fontSize/2+4,K="bottom"),"left"===this.horizontalAlign?w=p.x1+2:"center"===this.horizontalAlign?w=p.x1+p.width/
2-N.width/2:"right"===this.horizontalAlign&&(w=p.x2-2-N.width-A),G=this.horizontalAlign,this.width=N.width,this.height=N.height):"center"===this.verticalAlign&&("left"===this.horizontalAlign?(w=p.x1+2+(this.fontSize/2+4),v=p.y2-2-(this.maxWidth/2-N.width/2),B=-90,K="left",this.width=N.height,this.height=N.width):"right"===this.horizontalAlign?(w=p.x2-2-(this.fontSize/2+4),v=p.y1+2+(this.maxWidth/2-N.width/2),B=90,K="right",this.width=N.height,this.height=N.width):"center"===this.horizontalAlign&&
(v=h.y1+(h.height/2-N.height/2)+this.fontSize/2+4,w=h.x1+(h.width/2-N.width/2),K="center",this.width=N.width,this.height=N.height),G="center");J.x=w;J.y=v;J.angle=B;J.horizontalAlign=G;this._textBlock=J;h.layoutManager.registerSpace(K,{width:this.width+("left"===K||"right"===K?this.margin+2:0),height:this.height+("top"===K||"bottom"===K?this.margin+2:0)});this.bounds={x1:w,y1:v,x2:w+this.width,y2:v+this.height};this.ctx.textBaseline="top"}};za.prototype.render=function(){this._textBlock&&this._textBlock.render(!0)};
oa(Ja,G);Ja.prototype.setLayout=za.prototype.setLayout;Ja.prototype.render=za.prototype.render;Va.prototype.get=function(h,r){var w=null;0<this.pool.length?(w=this.pool.pop(),Na(w,h,r)):w=ua(h,r);return w};Va.prototype.release=function(h){this.pool.push(h)};oa(Ka,G);var Qa={addTheme:function(h,r){cb[h]=r},addColorSet:function(h,r){Aa[h]=r},addCultureInfo:function(h,r){La[h]=r},formatNumber:function(h,r,w){w=w||"en";if(La[w])return da(h,r||"#,##0.##",new Ka(w));throw"Unknown Culture Name";},formatDate:function(h,
r,w){w=w||"en";if(La[w])return Ba(h,r||"DD MMM YYYY",new Ka(w));throw"Unknown Culture Name";}}; true&&"undefined"!==typeof module.exports?module.exports=Qa: true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return Qa}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):(0);B=Qa.Chart=function(){function h(a,d){return a.x-d.x}function p(a,d,c){d=d||{};r(c)?(this.predefinedThemes=cb,this.optionsName=this.parent=this.index=null):(this.parent=c.parent,this.index=c.index,this.predefinedThemes=c.predefinedThemes,this.optionsName=c.optionsName,this.stockChart=c.stockChart,this.panel=a,this.isOptionsInArray=c.isOptionsInArray);this.theme=r(d.theme)||r(this.predefinedThemes[d.theme])?"light1":d.theme;p.base.constructor.call(this,"Chart",this.optionsName,d,this.index,this.parent);
var b=this;this._containerId=a;this._objectsInitialized=!1;this.overlaidCanvasCtx=this.ctx=null;this._indexLabels=[];this._panTimerId=0;this._lastTouchEventType="";this._lastTouchData=null;this.isAnimating=!1;this.renderCount=0;this.disableToolTip=this.animatedRender=!1;this.canvasPool=new Va;this.allDOMEventHandlers=[];this.panEnabled=!1;this._defaultCursor="default";this.plotArea={canvas:null,ctx:null,x1:0,y1:0,x2:0,y2:0,width:0,height:0};this._dataInRenderedOrder=[];(this.container="string"===
typeof this._containerId?document.getElementById(this._containerId):this._containerId)?(this.container.innerHTML="",d=a=0,a=this.options.width?this.width:0<this.container.clientWidth?this.container.clientWidth:this.width,d=this.options.height?this.height:0<this.container.clientHeight?this.container.clientHeight:this.height,this.width=a,this.height=d,this.x1=this.y1=0,this.x2=this.width,this.y2=this.height,this.selectedColorSet="undefined"!==typeof Aa[this.colorSet]?Aa[this.colorSet]:Aa.colorSet1,
this._canvasJSContainer=document.createElement("div"),this._canvasJSContainer.setAttribute("class","canvasjs-chart-container"),this._canvasJSContainer.style.position="relative",this._canvasJSContainer.style.textAlign="left",this._canvasJSContainer.style.cursor="auto",this._canvasJSContainer.style.direction="ltr",w||(this._canvasJSContainer.style.height="0px"),this.container.appendChild(this._canvasJSContainer),this.canvas=ua(a,d),this._preRenderCanvas=ua(a,d),this.canvas.style.position="absolute",
this.canvas.style.WebkitUserSelect="none",this.canvas.style.MozUserSelect="none",this.canvas.style.msUserSelect="none",this.canvas.style.userSelect="none",this.canvas.getContext&&(this._canvasJSContainer.appendChild(this.canvas),this.ctx=this.canvas.getContext("2d"),this.ctx.textBaseline="top",Da(this.ctx),this._preRenderCtx=this._preRenderCanvas.getContext("2d"),this._preRenderCtx.textBaseline="top",Da(this._preRenderCtx),w?this.plotArea.ctx=this.ctx:(this.plotArea.canvas=ua(a,d),this.plotArea.canvas.style.position=
"absolute",this.plotArea.canvas.setAttribute("class","plotAreaCanvas"),this._canvasJSContainer.appendChild(this.plotArea.canvas),this.plotArea.ctx=this.plotArea.canvas.getContext("2d")),this.overlaidCanvas=ua(a,d),this.overlaidCanvas.style.position="absolute",this.overlaidCanvas.style.webkitTapHighlightColor="transparent",this.overlaidCanvas.style.WebkitUserSelect="none",this.overlaidCanvas.style.MozUserSelect="none",this.overlaidCanvas.style.msUserSelect="none",this.overlaidCanvas.style.userSelect=
"none",this.overlaidCanvas.getContext&&(this._canvasJSContainer.appendChild(this.overlaidCanvas),this.overlaidCanvasCtx=this.overlaidCanvas.getContext("2d"),this.overlaidCanvasCtx.textBaseline="top",Da(this.overlaidCanvasCtx)),this._eventManager=new Z(this),this.windowResizeHandler=P(window,"resize",function(){b._updateSize()&&b.render()},this.allDOMEventHandlers),this._toolBar=document.createElement("div"),this._toolBar.setAttribute("class","canvasjs-chart-toolbar"),V(this._toolBar,{position:"absolute",
right:"1px",top:"1px"}),this._canvasJSContainer.appendChild(this._toolBar),this.bounds={x1:0,y1:0,x2:this.width,y2:this.height},P(this.overlaidCanvas,"click",function(a){b._mouseEventHandler(a)},this.allDOMEventHandlers),P(this.overlaidCanvas,"mousemove",function(a){b._mouseEventHandler(a)},this.allDOMEventHandlers),P(this.overlaidCanvas,"mouseup",function(a){b._mouseEventHandler(a)},this.allDOMEventHandlers),P(this.overlaidCanvas,"mousedown",function(a){b._mouseEventHandler(a);wa(b._dropdownMenu)},
this.allDOMEventHandlers),P(this.overlaidCanvas,"mouseout",function(a){b._mouseEventHandler(a)},this.allDOMEventHandlers),P(this.overlaidCanvas,window.navigator.msPointerEnabled?"MSPointerDown":"touchstart",function(a){b._touchEventHandler(a)},this.allDOMEventHandlers),P(this.overlaidCanvas,window.navigator.msPointerEnabled?"MSPointerMove":"touchmove",function(a){b._touchEventHandler(a)},this.allDOMEventHandlers),P(this.overlaidCanvas,window.navigator.msPointerEnabled?"MSPointerUp":"touchend",function(a){b._touchEventHandler(a)},
this.allDOMEventHandlers),P(this.overlaidCanvas,window.navigator.msPointerEnabled?"MSPointerCancel":"touchcancel",function(a){b._touchEventHandler(a)},this.allDOMEventHandlers),this.toolTip=new U(this,this.options.toolTip),this.data=null,this.axisX=[],this.axisX2=[],this.axisY=[],this.axisY2=[],this.sessionVariables={axisX:[],axisX2:[],axisY:[],axisY2:[]})):window.console&&window.console.log('CanvasJS Error: Chart Container with id "'+this._containerId+'" was not found')}function v(a,d){for(var c=
[],b,e=0;e<a.length;e++)if(0==e)c.push(a[0]);else{var f,l,t;t=e-1;f=0===t?0:t-1;l=t===a.length-1?t:t+1;b=Math.abs((a[l].x-a[f].x)/(0===a[l].x-a[t].x?0.01:a[l].x-a[t].x))*(d-1)/2+1;var C=(a[l].x-a[f].x)/b;b=(a[l].y-a[f].y)/b;c[c.length]=a[t].x>a[f].x&&0<C||a[t].x<a[f].x&&0>C?{x:a[t].x+C/3,y:a[t].y+b/3}:{x:a[t].x,y:a[t].y+(1===c.length?0:b/9)};t=e;f=0===t?0:t-1;l=t===a.length-1?t:t+1;b=Math.abs((a[l].x-a[f].x)/(0===a[t].x-a[f].x?0.01:a[t].x-a[f].x))*(d-1)/2+1;C=(a[l].x-a[f].x)/b;b=(a[l].y-a[f].y)/b;
c[c.length]=a[t].x>a[f].x&&0<C||a[t].x<a[f].x&&0>C?{x:a[t].x-C/3,y:a[t].y-b/3}:{x:a[t].x,y:a[t].y-b/9};c[c.length]=a[e]}return c}function B(a,d,c,b,e,f,l,t,C,k){var m=0;k?(l.color=f,t.color=f):k=1;m=C?Math.abs(e-c):Math.abs(b-d);m=0<l.trimLength?Math.abs(m*l.trimLength/100):Math.abs(m-l.length);C?(c+=m/2,e-=m/2):(d+=m/2,b-=m/2);var m=1===Math.round(l.thickness)%2?0.5:0,n=1===Math.round(t.thickness)%2?0.5:0;a.save();a.globalAlpha=k;a.strokeStyle=t.color||f;a.lineWidth=t.thickness||2;a.setLineDash&&
a.setLineDash(J(t.dashType,t.thickness));a.beginPath();C&&0<t.thickness?(a.moveTo(b-l.thickness/2,Math.round((c+e)/2)-n),a.lineTo(d+l.thickness/2,Math.round((c+e)/2)-n)):0<t.thickness&&(a.moveTo(Math.round((d+b)/2)-n,c+l.thickness/2),a.lineTo(Math.round((d+b)/2)-n,e-l.thickness/2));a.stroke();a.strokeStyle=l.color||f;a.lineWidth=l.thickness||2;a.setLineDash&&a.setLineDash(J(l.dashType,l.thickness));a.beginPath();C&&0<l.thickness?(a.moveTo(b-m,c),a.lineTo(b-m,e),a.moveTo(d+m,c),a.lineTo(d+m,e)):0<
l.thickness&&(a.moveTo(d,c+m),a.lineTo(b,c+m),a.moveTo(d,e-m),a.lineTo(b,e-m));a.stroke();a.restore()}function K(a,d){K.base.constructor.call(this,"Legend","legend",d,null,a);this.chart=a;this.canvas=a.canvas;this.ctx=this.chart.ctx;this.ghostCtx=this.chart._eventManager.ghostCtx;this.items=[];this.optionsName="legend";this.height=this.width=0;this.orientation=null;this.dataSeries=[];this.bounds={x1:null,y1:null,x2:null,y2:null};"undefined"===typeof this.options.fontSize&&(this.fontSize=this.chart.getAutoFontSize(this.fontSize));
this.lineHeight=Ya(this.fontFamily,this.fontSize,this.fontWeight);this.horizontalSpacing=this.fontSize}function Q(a,d,c,b){Q.base.constructor.call(this,"DataSeries","data",d,c,a);this.chart=a;this.canvas=a.canvas;this._ctx=a.canvas.ctx;this.index=c;this.noDataPointsInPlotArea=0;this.id=b;this.chart._eventManager.objectMap[b]={id:b,objectType:"dataSeries",dataSeriesIndex:c};a=d.dataPoints?d.dataPoints.length:0;this.dataPointEOs=[];for(d=0;d<a;d++)this.dataPointEOs[d]={};this.dataPointIds=[];this.plotUnit=
[];this.axisY=this.axisX=null;this.optionsName="data";this.isOptionsInArray=!0;null===this.fillOpacity&&(this.type.match(/area/i)?this.fillOpacity=0.7:this.fillOpacity=1);this.axisPlacement=this.getDefaultAxisPlacement();"undefined"===typeof this.options.indexLabelFontSize&&(this.indexLabelFontSize=this.chart.getAutoFontSize(this.indexLabelFontSize))}function A(a,d,c,b,e,f){A.base.constructor.call(this,"Axis",d,c,b,a);this.chart=a;this.canvas=a.canvas;this.ctx=a.ctx;this.intervalStartPosition=this.maxHeight=
this.maxWidth=0;this.labels=[];this.dataSeries=[];this._stripLineLabels=this._ticks=this._labels=null;this.dataInfo={min:Infinity,max:-Infinity,viewPortMin:Infinity,viewPortMax:-Infinity,minDiff:Infinity};this.isOptionsInArray=!0;"axisX"===e?("left"===f||"bottom"===f?(this.optionsName="axisX",r(this.chart.sessionVariables.axisX[b])&&(this.chart.sessionVariables.axisX[b]={}),this.sessionVariables=this.chart.sessionVariables.axisX[b]):(this.optionsName="axisX2",r(this.chart.sessionVariables.axisX2[b])&&
(this.chart.sessionVariables.axisX2[b]={}),this.sessionVariables=this.chart.sessionVariables.axisX2[b]),this.options.interval||(this.intervalType=null)):"left"===f||"bottom"===f?(this.optionsName="axisY",r(this.chart.sessionVariables.axisY[b])&&(this.chart.sessionVariables.axisY[b]={}),this.sessionVariables=this.chart.sessionVariables.axisY[b]):(this.optionsName="axisY2",r(this.chart.sessionVariables.axisY2[b])&&(this.chart.sessionVariables.axisY2[b]={}),this.sessionVariables=this.chart.sessionVariables.axisY2[b]);
"undefined"===typeof this.options.titleFontSize&&(this.titleFontSize=this.chart.getAutoFontSize(this.titleFontSize));"undefined"===typeof this.options.labelFontSize&&(this.labelFontSize=this.chart.getAutoFontSize(this.labelFontSize));this.type=e;"axisX"!==e||c&&"undefined"!==typeof c.gridThickness||(this.gridThickness=0);this._position=f;this.lineCoordinates={x1:null,y1:null,x2:null,y2:null,width:null};this.labelAngle=(this.labelAngle%360+360)%360;90<this.labelAngle&&270>this.labelAngle?this.labelAngle-=
180:270<=this.labelAngle&&360>=this.labelAngle&&(this.labelAngle-=360);this.options.scaleBreaks&&(this.scaleBreaks=new fa(this.chart,this.options.scaleBreaks,++this.chart._eventManager.lastObjectId,this));this.stripLines=[];if(this.options.stripLines&&0<this.options.stripLines.length)for(a=0;a<this.options.stripLines.length;a++)this.stripLines.push(new N(this.chart,this.options.stripLines[a],a,++this.chart._eventManager.lastObjectId,this));this.options.crosshair&&(this.crosshair=new ca(this.chart,
this.options.crosshair,this));this._titleTextBlock=null;this.hasOptionChanged("viewportMinimum")&&null===this.viewportMinimum&&(this.options.viewportMinimum=void 0,this.sessionVariables.viewportMinimum=null);this.hasOptionChanged("viewportMinimum")||isNaN(this.sessionVariables.newViewportMinimum)||null===this.sessionVariables.newViewportMinimum?this.sessionVariables.newViewportMinimum=null:this.viewportMinimum=this.sessionVariables.newViewportMinimum;this.hasOptionChanged("viewportMaximum")&&null===
this.viewportMaximum&&(this.options.viewportMaximum=void 0,this.sessionVariables.viewportMaximum=null);this.hasOptionChanged("viewportMaximum")||isNaN(this.sessionVariables.newViewportMaximum)||null===this.sessionVariables.newViewportMaximum?this.sessionVariables.newViewportMaximum=null:this.viewportMaximum=this.sessionVariables.newViewportMaximum;null!==this.minimum&&null!==this.viewportMinimum&&(this.viewportMinimum=Math.max(this.viewportMinimum,this.minimum));null!==this.maximum&&null!==this.viewportMaximum&&
(this.viewportMaximum=Math.min(this.viewportMaximum,this.maximum));this.trackChanges("viewportMinimum");this.trackChanges("viewportMaximum")}function fa(a,d,c,b){fa.base.constructor.call(this,"ScaleBreaks","scaleBreaks",d,null,b);this.id=c;this.chart=a;this.ctx=this.chart.ctx;this.axis=b;this.optionsName="scaleBreaks";this.isOptionsInArray=!1;this._appliedBreaks=[];this.customBreaks=[];this.autoBreaks=[];"string"===typeof this.spacing?(this.spacing=parseFloat(this.spacing),this.spacing=isNaN(this.spacing)?
8:(10<this.spacing?10:this.spacing)+"%"):"number"!==typeof this.spacing&&(this.spacing=8);this.autoCalculate&&(this.maxNumberOfAutoBreaks=Math.min(this.maxNumberOfAutoBreaks,5));if(this.options.customBreaks&&0<this.options.customBreaks.length){for(a=0;a<this.options.customBreaks.length;a++)this.customBreaks.push(new aa(this.chart,"customBreaks",this.options.customBreaks[a],a,++this.chart._eventManager.lastObjectId,this)),"number"===typeof this.customBreaks[a].startValue&&("number"===typeof this.customBreaks[a].endValue&&
this.customBreaks[a].endValue!==this.customBreaks[a].startValue)&&this._appliedBreaks.push(this.customBreaks[a]);this._appliedBreaks.sort(function(a,b){return a.startValue-b.startValue});for(a=0;a<this._appliedBreaks.length-1;a++)this._appliedBreaks[a].endValue>=this._appliedBreaks[a+1].startValue&&(this._appliedBreaks[a].endValue=Math.max(this._appliedBreaks[a].endValue,this._appliedBreaks[a+1].endValue),window.console&&window.console.log("CanvasJS Error: Breaks "+a+" and "+(a+1)+" are overlapping."),
this._appliedBreaks.splice(a,2),a--)}}function aa(a,d,c,b,e,f){aa.base.constructor.call(this,"Break",d,c,b,f);this.id=e;this.chart=a;this.ctx=this.chart.ctx;this.scaleBreaks=f;this.optionsName=d;this.isOptionsInArray=!0;this.type=c.type?this.type:f.type;this.fillOpacity=r(c.fillOpacity)?f.fillOpacity:this.fillOpacity;this.lineThickness=r(c.lineThickness)?f.lineThickness:this.lineThickness;this.color=c.color?this.color:f.color;this.lineColor=c.lineColor?this.lineColor:f.lineColor;this.lineDashType=
c.lineDashType?this.lineDashType:f.lineDashType;!r(this.startValue)&&this.startValue.getTime&&(this.startValue=this.startValue.getTime());!r(this.endValue)&&this.endValue.getTime&&(this.endValue=this.endValue.getTime());"number"===typeof this.startValue&&("number"===typeof this.endValue&&this.endValue<this.startValue)&&(a=this.startValue,this.startValue=this.endValue,this.endValue=a);this.spacing="undefined"===typeof c.spacing?f.spacing:c.spacing;"string"===typeof this.options.spacing?(this.spacing=
parseFloat(this.spacing),this.spacing=isNaN(this.spacing)?0:(10<this.spacing?10:this.spacing)+"%"):"number"!==typeof this.options.spacing&&(this.spacing=f.spacing);this.size=f.parent.logarithmic?1:0}function N(a,d,c,b,e){N.base.constructor.call(this,"StripLine","stripLines",d,c,e);this.id=b;this.chart=a;this.ctx=this.chart.ctx;this.label=this.label;this.axis=e;this.optionsName="stripLines";this.isOptionsInArray=!0;this._thicknessType="pixel";null!==this.startValue&&null!==this.endValue&&(this.value=
e.logarithmic?Math.sqrt((this.startValue.getTime?this.startValue.getTime():this.startValue)*(this.endValue.getTime?this.endValue.getTime():this.endValue)):((this.startValue.getTime?this.startValue.getTime():this.startValue)+(this.endValue.getTime?this.endValue.getTime():this.endValue))/2,this._thicknessType=null)}function ca(a,d,c){ca.base.constructor.call(this,"Crosshair","crosshair",d,null,c);this.chart=a;this.ctx=this.chart.ctx;this.axis=c;this.optionsName="crosshair";this._thicknessType="pixel"}
function U(a,d){U.base.constructor.call(this,"ToolTip","toolTip",d,null,a);this.chart=a;this.canvas=a.canvas;this.ctx=this.chart.ctx;this.currentDataPointIndex=this.currentSeriesIndex=-1;this._prevY=this._prevX=NaN;this.containerTransitionDuration=0.1;this.mozContainerTransition=this.getContainerTransition(this.containerTransitionDuration);this.optionsName="toolTip";this._initialize()}function Z(a){this.chart=a;this.lastObjectId=0;this.objectMap=[];this.rectangularRegionEventSubscriptions=[];this.previousDataPointEventObject=
null;this.ghostCanvas=ua(this.chart.width,this.chart.height,!0);this.ghostCtx=this.ghostCanvas.getContext("2d");this.mouseoveredObjectMaps=[]}function ia(a){this.chart=a;this.ctx=this.chart.plotArea.ctx;this.animations=[];this.animationRequestId=null}oa(p,G);p.prototype.destroy=function(){var a=this.allDOMEventHandlers;this._animator&&this._animator.cancelAllAnimations();this._panTimerId&&clearTimeout(this._panTimerId);for(var d=0;d<a.length;d++){var c=a[d][0],b=a[d][1],e=a[d][2],f=a[d][3],f=f||!1;
c.removeEventListener?c.removeEventListener(b,e,f):c.detachEvent&&c.detachEvent("on"+b,e)}this.allDOMEventHandlers=[];for(this.removeAllEventListeners();this._canvasJSContainer&&this._canvasJSContainer.hasChildNodes();)this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);for(;this.container&&this.container.hasChildNodes();)this.container.removeChild(this.container.lastChild);for(;this._dropdownMenu&&this._dropdownMenu.hasChildNodes();)this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
this.container=this._canvasJSContainer=null;this.toolTip.container=null;this.canvas&&ya(this.canvas);this.overlaidCanvas&&ya(this.overlaidCanvas);this._preRenderCanvas&&ya(this._preRenderCanvas);this._breaksCanvas&&ya(this._breaksCanvas);this._eventManager&&this._eventManager.ghostCanvas&&ya(this._eventManager.ghostCanvas);this._toolBar=this._dropdownMenu=this._menuButton=this._resetButton=this._zoomButton=null};p.prototype._updateOptions=function(){var a=this;this.updateOption("width");this.updateOption("height");
this.updateOption("dataPointWidth");this.updateOption("dataPointMinWidth");this.updateOption("dataPointMaxWidth");this.updateOption("interactivityEnabled");this.updateOption("theme");this.updateOption("colorSet")&&(this.selectedColorSet="undefined"!==typeof Aa[this.colorSet]?Aa[this.colorSet]:Aa.colorSet1);this.updateOption("backgroundColor");this.backgroundColor||(this.backgroundColor="rgba(0,0,0,0)");this.updateOption("culture");this._cultureInfo=new Ka(this.options.culture);this.updateOption("animationEnabled");
this.animationEnabled=this.animationEnabled&&w;this.updateOption("animationDuration");this.updateOption("rangeChanging");this.updateOption("rangeChanged");this.updateOption("exportEnabled");this.updateOption("exportFileName");this.updateOption("zoomType");this.toolbar=new Ua(this,this.options.toolbar);if(this.options.zoomEnabled||this.panEnabled){if(this._zoomButton)V(this._zoomButton,{borderRight:this.toolbar.buttonBorderThickness+"px solid "+this.toolbar.buttonBorderColor,backgroundColor:a.toolbar.itemBackgroundColor,
color:a.toolbar.fontColor}),sa(this,this._zoomButton,"zoom");else{var d=!1;wa(this._zoomButton=document.createElement("button"));sa(this,this._zoomButton,"pan");this._toolBar.appendChild(this._zoomButton);this._zoomButton.style.borderRight=this.toolbar.buttonBorderThickness+"px solid "+this.toolbar.buttonBorderColor;P(this._zoomButton,"touchstart",function(a){d=!0},this.allDOMEventHandlers);P(this._zoomButton,"click",function(){a.zoomEnabled?(a.zoomEnabled=!1,a.panEnabled=!0,sa(a,a._zoomButton,"zoom")):
(a.zoomEnabled=!0,a.panEnabled=!1,sa(a,a._zoomButton,"pan"));a.render()},this.allDOMEventHandlers);P(this._zoomButton,"mousemove",function(){d?d=!1:(V(a._zoomButton,{backgroundColor:a.toolbar.itemBackgroundColorOnHover,color:a.toolbar.fontColorOnHover,transition:"0.4s",WebkitTransition:"0.4s"}),0>=navigator.userAgent.search("MSIE")&&V(a._zoomButton.childNodes[0],{WebkitFilter:"invert(100%)",filter:"invert(100%)"}))},this.allDOMEventHandlers);P(this._zoomButton,"mouseout",function(){d||(V(a._zoomButton,
{backgroundColor:a.toolbar.itemBackgroundColor,color:a.toolbar.fontColor,transition:"0.4s",WebkitTransition:"0.4s"}),0>=navigator.userAgent.search("MSIE")&&V(a._zoomButton.childNodes[0],{WebkitFilter:"invert(0%)",filter:"invert(0%)"}))},this.allDOMEventHandlers)}this._resetButton?(V(this._resetButton,{borderRight:this.toolbar.buttonBorderThickness+"px solid "+this.toolbar.buttonBorderColor,backgroundColor:a.toolbar.itemBackgroundColor,color:a.toolbar.fontColor}),this._resetButton.title=this._cultureInfo.resetText):
(d=!1,wa(this._resetButton=document.createElement("button")),sa(this,this._resetButton,"reset"),this._resetButton.style.borderRight=(this.exportEnabled?this.toolbar.buttonBorderThickness:0)+"px solid "+this.toolbar.buttonBorderColor,this._toolBar.appendChild(this._resetButton),P(this._resetButton,"touchstart",function(a){d=!0},this.allDOMEventHandlers),P(this._resetButton,"click",function(){a.toolTip.hide();a.toolTip&&a.toolTip.enabled&&a.toolTip.dispatchEvent("hidden",{chart:a,toolTip:a.toolTip},
a.toolTip);a.zoomEnabled||a.panEnabled?(a.zoomEnabled=!0,a.panEnabled=!1,sa(a,a._zoomButton,"pan"),a._defaultCursor="default",a.overlaidCanvas.style.cursor=a._defaultCursor):(a.zoomEnabled=!1,a.panEnabled=!1);if(a.sessionVariables.axisX)for(var b=0;b<a.sessionVariables.axisX.length;b++)a.sessionVariables.axisX[b].newViewportMinimum=null,a.sessionVariables.axisX[b].newViewportMaximum=null;if(a.sessionVariables.axisX2)for(b=0;b<a.sessionVariables.axisX2.length;b++)a.sessionVariables.axisX2[b].newViewportMinimum=
null,a.sessionVariables.axisX2[b].newViewportMaximum=null;if(a.sessionVariables.axisY)for(b=0;b<a.sessionVariables.axisY.length;b++)a.sessionVariables.axisY[b].newViewportMinimum=null,a.sessionVariables.axisY[b].newViewportMaximum=null;if(a.sessionVariables.axisY2)for(b=0;b<a.sessionVariables.axisY2.length;b++)a.sessionVariables.axisY2[b].newViewportMinimum=null,a.sessionVariables.axisY2[b].newViewportMaximum=null;a.resetOverlayedCanvas();0>=navigator.userAgent.search("MSIE")&&V(a._resetButton.childNodes[0],
{WebkitFilter:"invert(0%)",filter:"invert(0%)"});wa(a._zoomButton,a._resetButton);a.stockChart&&(a.stockChart._rangeEventParameter={stockChart:a.stockChart,source:"chart",index:a.stockChart.charts.indexOf(a),minimum:null,maximum:null});a._dispatchRangeEvent("rangeChanging","reset");a.stockChart&&(a.stockChart._rangeEventParameter.type="rangeChanging",a.stockChart.dispatchEvent("rangeChanging",a.stockChart._rangeEventParameter,a.stockChart));a.render();a.syncCharts&&a.syncCharts(null,null);a._dispatchRangeEvent("rangeChanged",
"reset");a.stockChart&&(a.stockChart._rangeEventParameter.type="rangeChanged",a.stockChart.dispatchEvent("rangeChanged",a.stockChart._rangeEventParameter,a.stockChart))},this.allDOMEventHandlers),P(this._resetButton,"mousemove",function(){d||(V(a._resetButton,{backgroundColor:a.toolbar.itemBackgroundColorOnHover,color:a.toolbar.fontColorOnHover,transition:"0.4s",WebkitTransition:"0.4s"}),0>=navigator.userAgent.search("MSIE")&&V(a._resetButton.childNodes[0],{WebkitFilter:"invert(100%)",filter:"invert(100%)"}))},
this.allDOMEventHandlers),P(this._resetButton,"mouseout",function(){d||(V(a._resetButton,{backgroundColor:a.toolbar.itemBackgroundColor,color:a.toolbar.fontColor,transition:"0.4s",WebkitTransition:"0.4s"}),0>=navigator.userAgent.search("MSIE")&&V(a._resetButton.childNodes[0],{WebkitFilter:"invert(0%)",filter:"invert(0%)"}))},this.allDOMEventHandlers),this.overlaidCanvas.style.cursor=a._defaultCursor);this.zoomEnabled||this.panEnabled||(this._zoomButton?(a._zoomButton.getAttribute("state")===a._cultureInfo.zoomText?
(this.panEnabled=!0,this.zoomEnabled=!1):(this.zoomEnabled=!0,this.panEnabled=!1),Ma(a._zoomButton,a._resetButton)):(this.zoomEnabled=!0,this.panEnabled=!1))}else this.panEnabled=this.zoomEnabled=!1;hb(this);"none"!==this._toolBar.style.display&&this._zoomButton&&(this.panEnabled?sa(a,a._zoomButton,"zoom"):sa(a,a._zoomButton,"pan"),a._resetButton.getAttribute("state")!==a._cultureInfo.resetText&&sa(a,a._resetButton,"reset"));this.options.toolTip&&this.toolTip.options!==this.options.toolTip&&(this.toolTip.options=
this.options.toolTip);for(var c in this.toolTip.options)this.toolTip.options.hasOwnProperty(c)&&this.toolTip.updateOption(c)};p.prototype._updateSize=function(){var a;a=[this.canvas,this.overlaidCanvas,this._eventManager.ghostCanvas];var d=0,c=0;this.options.width?d=this.width:this.width=d=0<this.container.clientWidth?this.container.clientWidth:this.width;this.options.height?c=this.height:this.height=c=0<this.container.clientHeight?this.container.clientHeight:this.height;if(this.canvas.width!==d*
la||this.canvas.height!==c*la){for(var b=0;b<a.length;b++)Na(a[b],d,c);this.bounds={x1:0,y1:0,x2:this.width,y2:this.height,width:this.width,height:this.height};a=!0}else a=!1;return a};p.prototype._initialize=function(){this.isNavigator=r(this.parent)||r(this.parent._defaultsKey)||"Navigator"!==this.parent._defaultsKey?!1:!0;this._animator?this._animator.cancelAllAnimations():this._animator=new ia(this);this.removeAllEventListeners();this.disableToolTip=!1;this._axes=[];this.funnelPyramidClickHandler=
this.pieDoughnutClickHandler=null;this._updateOptions();this.animatedRender=w&&this.animationEnabled&&0===this.renderCount;this._updateSize();this.clearCanvas();this.ctx.beginPath();this.axisX=[];this.axisX2=[];this.axisY=[];this.axisY2=[];this._indexLabels=[];this._dataInRenderedOrder=[];this._events=[];this._eventManager&&this._eventManager.reset();this.plotInfo={axisPlacement:null,plotTypes:[]};this.layoutManager=new Fa(0,0,this.width,this.height,this.isNavigator?0:2);this.plotArea.layoutManager&&
this.plotArea.layoutManager.reset();this.data=[];this.title=null;this.subtitles=[];var a=0,d=null;if(this.options.data){for(var c=0;c<this.options.data.length;c++)if(a++,!this.options.data[c].type||0<=p._supportedChartTypes.indexOf(this.options.data[c].type)){var b=new Q(this,this.options.data[c],a-1,++this._eventManager.lastObjectId);"error"===b.type&&(b.linkedDataSeriesIndex=r(this.options.data[c].linkedDataSeriesIndex)?c-1:this.options.data[c].linkedDataSeriesIndex,0>b.linkedDataSeriesIndex||b.linkedDataSeriesIndex>=
this.options.data.length||"number"!==typeof b.linkedDataSeriesIndex||"error"===this.options.data[b.linkedDataSeriesIndex].type)&&(b.linkedDataSeriesIndex=null);null===b.name&&(b.name="DataSeries "+a);null===b.color?1<this.options.data.length?(b._colorSet=[this.selectedColorSet[b.index%this.selectedColorSet.length]],b.color=this.selectedColorSet[b.index%this.selectedColorSet.length]):b._colorSet="line"===b.type||"stepLine"===b.type||"spline"===b.type||"area"===b.type||"stepArea"===b.type||"splineArea"===
b.type||"stackedArea"===b.type||"stackedArea100"===b.type||"rangeArea"===b.type||"rangeSplineArea"===b.type||"candlestick"===b.type||"ohlc"===b.type||"waterfall"===b.type||"boxAndWhisker"===b.type?[this.selectedColorSet[0]]:this.selectedColorSet:b._colorSet=[b.color];null===b.markerSize&&(("line"===b.type||"stepLine"===b.type||"spline"===b.type||0<=b.type.toLowerCase().indexOf("area"))&&b.dataPoints&&b.dataPoints.length<this.width/16||"scatter"===b.type)&&(b.markerSize=8);"bubble"!==b.type&&"scatter"!==
b.type||!b.dataPoints||(b.dataPoints.some?b.dataPoints.some(function(a){return a.x})&&b.dataPoints.sort(h):b.dataPoints.sort(h));this.data.push(b);var e=b.axisPlacement,d=d||e,f;"normal"===e?"xySwapped"===this.plotInfo.axisPlacement?f='You cannot combine "'+b.type+'" with bar chart':"none"===this.plotInfo.axisPlacement?f='You cannot combine "'+b.type+'" with pie chart':null===this.plotInfo.axisPlacement&&(this.plotInfo.axisPlacement="normal"):"xySwapped"===e?"normal"===this.plotInfo.axisPlacement?
f='You cannot combine "'+b.type+'" with line, area, column or pie chart':"none"===this.plotInfo.axisPlacement?f='You cannot combine "'+b.type+'" with pie chart':null===this.plotInfo.axisPlacement&&(this.plotInfo.axisPlacement="xySwapped"):"none"===e?"normal"===this.plotInfo.axisPlacement?f='You cannot combine "'+b.type+'" with line, area, column or bar chart':"xySwapped"===this.plotInfo.axisPlacement?f='You cannot combine "'+b.type+'" with bar chart':null===this.plotInfo.axisPlacement&&(this.plotInfo.axisPlacement=
"none"):null===e&&"none"===this.plotInfo.axisPlacement&&(f='You cannot combine "'+b.type+'" with pie chart');if(f&&window.console){window.console.log(f);return}}for(c=0;c<this.data.length;c++){if("none"==d&&"error"===this.data[c].type&&window.console){window.console.log('You cannot combine "'+b.type+'" with error chart');return}"error"===this.data[c].type&&(this.data[c].axisPlacement=this.plotInfo.axisPlacement=d||"normal",this.data[c]._linkedSeries=null===this.data[c].linkedDataSeriesIndex?null:
this.data[this.data[c].linkedDataSeriesIndex])}}this._objectsInitialized=!0;this._plotAreaElements=[]};p._supportedChartTypes=Ea("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" "));p.prototype.setLayout=function(){for(var a=this._plotAreaElements,d=0;d<this.data.length;d++)if("normal"===
this.plotInfo.axisPlacement||"xySwapped"===this.plotInfo.axisPlacement){if(!this.data[d].axisYType||"primary"===this.data[d].axisYType)if(this.options.axisY&&0<this.options.axisY.length){if(!this.axisY.length)for(var c=0;c<this.options.axisY.length;c++)"normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisY[c]=new A(this,"axisY",this.options.axisY[c],c,"axisY","left")):"xySwapped"===this.plotInfo.axisPlacement&&this._axes.push(this.axisY[c]=new A(this,"axisY",this.options.axisY[c],c,"axisY",
"bottom"));this.data[d].axisY=this.axisY[0<=this.data[d].axisYIndex&&this.data[d].axisYIndex<this.axisY.length?this.data[d].axisYIndex:0];this.axisY[0<=this.data[d].axisYIndex&&this.data[d].axisYIndex<this.axisY.length?this.data[d].axisYIndex:0].dataSeries.push(this.data[d])}else this.axisY.length||("normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisY[0]=new A(this,"axisY",this.options.axisY,0,"axisY","left")):"xySwapped"===this.plotInfo.axisPlacement&&this._axes.push(this.axisY[0]=new A(this,
"axisY",this.options.axisY,0,"axisY","bottom"))),this.data[d].axisY=this.axisY[0],this.axisY[0].dataSeries.push(this.data[d]);if("secondary"===this.data[d].axisYType)if(this.options.axisY2&&0<this.options.axisY2.length){if(!this.axisY2.length)for(c=0;c<this.options.axisY2.length;c++)"normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisY2[c]=new A(this,"axisY2",this.options.axisY2[c],c,"axisY","right")):"xySwapped"===this.plotInfo.axisPlacement&&this._axes.push(this.axisY2[c]=new A(this,
"axisY2",this.options.axisY2[c],c,"axisY","top"));this.data[d].axisY=this.axisY2[0<=this.data[d].axisYIndex&&this.data[d].axisYIndex<this.axisY2.length?this.data[d].axisYIndex:0];this.axisY2[0<=this.data[d].axisYIndex&&this.data[d].axisYIndex<this.axisY2.length?this.data[d].axisYIndex:0].dataSeries.push(this.data[d])}else this.axisY2.length||("normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisY2[0]=new A(this,"axisY2",this.options.axisY2,0,"axisY","right")):"xySwapped"===this.plotInfo.axisPlacement&&
this._axes.push(this.axisY2[0]=new A(this,"axisY2",this.options.axisY2,0,"axisY","top"))),this.data[d].axisY=this.axisY2[0],this.axisY2[0].dataSeries.push(this.data[d]);if(!this.data[d].axisXType||"primary"===this.data[d].axisXType)if(this.options.axisX&&0<this.options.axisX.length){if(!this.axisX.length)for(c=0;c<this.options.axisX.length;c++)"normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisX[c]=new A(this,"axisX",this.options.axisX[c],c,"axisX","bottom")):"xySwapped"===this.plotInfo.axisPlacement&&
this._axes.push(this.axisX[c]=new A(this,"axisX",this.options.axisX[c],c,"axisX","left"));this.data[d].axisX=this.axisX[0<=this.data[d].axisXIndex&&this.data[d].axisXIndex<this.axisX.length?this.data[d].axisXIndex:0];this.axisX[0<=this.data[d].axisXIndex&&this.data[d].axisXIndex<this.axisX.length?this.data[d].axisXIndex:0].dataSeries.push(this.data[d])}else this.axisX.length||("normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisX[0]=new A(this,"axisX",this.options.axisX,0,"axisX","bottom")):
"xySwapped"===this.plotInfo.axisPlacement&&this._axes.push(this.axisX[0]=new A(this,"axisX",this.options.axisX,0,"axisX","left"))),this.data[d].axisX=this.axisX[0],this.axisX[0].dataSeries.push(this.data[d]);if("secondary"===this.data[d].axisXType)if(this.options.axisX2&&0<this.options.axisX2.length){if(!this.axisX2.length)for(c=0;c<this.options.axisX2.length;c++)"normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisX2[c]=new A(this,"axisX2",this.options.axisX2[c],c,"axisX","top")):"xySwapped"===
this.plotInfo.axisPlacement&&this._axes.push(this.axisX2[c]=new A(this,"axisX2",this.options.axisX2[c],c,"axisX","right"));this.data[d].axisX=this.axisX2[0<=this.data[d].axisXIndex&&this.data[d].axisXIndex<this.axisX2.length?this.data[d].axisXIndex:0];this.axisX2[0<=this.data[d].axisXIndex&&this.data[d].axisXIndex<this.axisX2.length?this.data[d].axisXIndex:0].dataSeries.push(this.data[d])}else this.axisX2.length||("normal"===this.plotInfo.axisPlacement?this._axes.push(this.axisX2[0]=new A(this,"axisX2",
this.options.axisX2,0,"axisX","top")):"xySwapped"===this.plotInfo.axisPlacement&&this._axes.push(this.axisX2[0]=new A(this,"axisX2",this.options.axisX2,0,"axisX","right"))),this.data[d].axisX=this.axisX2[0],this.axisX2[0].dataSeries.push(this.data[d])}if(this.axisY){for(c=1;c<this.axisY.length;c++)"undefined"===typeof this.axisY[c].options.gridThickness&&(this.axisY[c].gridThickness=0);for(c=0;c<this.axisY.length-1;c++)"undefined"===typeof this.axisY[c].options.margin&&(this.axisY[c].margin=10)}if(this.axisY2){for(c=
1;c<this.axisY2.length;c++)"undefined"===typeof this.axisY2[c].options.gridThickness&&(this.axisY2[c].gridThickness=0);for(c=0;c<this.axisY2.length-1;c++)"undefined"===typeof this.axisY2[c].options.margin&&(this.axisY2[c].margin=10)}this.axisY&&0<this.axisY.length&&(this.axisY2&&0<this.axisY2.length)&&(0<this.axisY[0].gridThickness&&"undefined"===typeof this.axisY2[0].options.gridThickness?this.axisY2[0].gridThickness=0:0<this.axisY2[0].gridThickness&&"undefined"===typeof this.axisY[0].options.gridThickness&&
(this.axisY[0].gridThickness=0));if(this.axisX)for(c=0;c<this.axisX.length;c++)"undefined"===typeof this.axisX[c].options.gridThickness&&(this.axisX[c].gridThickness=0);if(this.axisX2)for(c=0;c<this.axisX2.length;c++)"undefined"===typeof this.axisX2[c].options.gridThickness&&(this.axisX2[c].gridThickness=0);this.axisX&&0<this.axisX.length&&(this.axisX2&&0<this.axisX2.length)&&(0<this.axisX[0].gridThickness&&"undefined"===typeof this.axisX2[0].options.gridThickness?this.axisX2[0].gridThickness=0:0<
this.axisX2[0].gridThickness&&"undefined"===typeof this.axisX[0].options.gridThickness&&(this.axisX[0].gridThickness=0));c=!1;if(0<this._axes.length&&this.options.zoomEnabled&&(this.zoomEnabled||this.panEnabled))for(d=0;d<this._axes.length;d++)if(!r(this._axes[d].viewportMinimum)||!r(this._axes[d].viewportMaximum)){c=!0;break}c?(Ma(this._zoomButton,this._resetButton),this._toolBar.style.border=this.toolbar.buttonBorderThickness+"px solid "+this.toolbar.buttonBorderColor,this._zoomButton.style.borderRight=
this.toolbar.buttonBorderThickness+"px solid "+this.toolbar.buttonBorderColor,this._resetButton.style.borderRight=(this.exportEnabled?this.toolbar.buttonBorderThickness:0)+"px solid "+this.toolbar.buttonBorderColor):(wa(this._zoomButton,this._resetButton),this._toolBar.style.border=this.toolbar.buttonBorderThickness+"px solid transparent",this.options.zoomEnabled&&(this.zoomEnabled=!0,this.panEnabled=!1));fb(this);this._processData();this.options.title&&(this.title=new za(this,this.options.title),
this.title.dockInsidePlotArea?a.push(this.title):this.title.setLayout());if(this.options.subtitles)for(d=0;d<this.options.subtitles.length;d++)c=new Ja(this,this.options.subtitles[d],d),this.subtitles.push(c),c.dockInsidePlotArea?a.push(c):c.setLayout();this.legend=new K(this,this.options.legend);for(d=0;d<this.data.length;d++)(this.data[d].showInLegend||"pie"===this.data[d].type||"doughnut"===this.data[d].type||"funnel"===this.data[d].type||"pyramid"===this.data[d].type)&&this.legend.dataSeries.push(this.data[d]);
this.legend.dockInsidePlotArea?a.push(this.legend):this.legend.setLayout();for(d=0;d<this._axes.length;d++)if(this._axes[d].scaleBreaks&&this._axes[d].scaleBreaks._appliedBreaks.length){w?(this._breaksCanvas=ua(this.width,this.height,!0),this._breaksCanvasCtx=this._breaksCanvas.getContext("2d")):(this._breaksCanvas=this.canvas,this._breaksCanvasCtx=this.ctx);break}this._preRenderCanvas=ua(this.width,this.height);this._preRenderCtx=this._preRenderCanvas.getContext("2d");"normal"!==this.plotInfo.axisPlacement&&
"xySwapped"!==this.plotInfo.axisPlacement||A.setLayout(this.axisX,this.axisX2,this.axisY,this.axisY2,this.plotInfo.axisPlacement,this.layoutManager.getFreeSpace())};p.prototype.renderElements=function(){if(this.height){var a=this._plotAreaElements;this.title&&!this.title.dockInsidePlotArea&&this.title.render();for(var d=0;d<this.subtitles.length;d++)this.subtitles[d].dockInsidePlotArea||this.subtitles[d].render();this.legend.dockInsidePlotArea||this.legend.render();if("normal"===this.plotInfo.axisPlacement||
"xySwapped"===this.plotInfo.axisPlacement)A.render(this.axisX,this.axisX2,this.axisY,this.axisY2,this.plotInfo.axisPlacement);else if("none"===this.plotInfo.axisPlacement)this.preparePlotArea();else return;for(d=0;d<a.length;d++)a[d].setLayout(),a[d].render();var c=[];if(this.animatedRender){var b=ua(this.width,this.height);b.getContext("2d").drawImage(this.canvas,0,0,this.width,this.height)}ib(this);var a=this.ctx.miterLimit,e;this.ctx.miterLimit=3;w&&this._breaksCanvas&&(this._preRenderCtx.drawImage(this.canvas,
0,0,this.width,this.height),this._preRenderCtx.drawImage(this._breaksCanvas,0,0,this.width,this.height),this._breaksCanvasCtx.globalCompositeOperation="source-atop",this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),this._preRenderCtx.clearRect(0,0,this.width,this.height));for(d=0;d<this.plotInfo.plotTypes.length;d++)for(var f=this.plotInfo.plotTypes[d],l=0;l<f.plotUnits.length;l++){var t=f.plotUnits[l],C=null;t.targetCanvas&&ya(t.targetCanvas);t.targetCanvas=null;this.animatedRender&&
(t.targetCanvas=ua(this.width,this.height),t.targetCanvasCtx=t.targetCanvas.getContext("2d"),e=t.targetCanvasCtx.miterLimit,t.targetCanvasCtx.miterLimit=3);"line"===t.type?C=this.renderLine(t):"stepLine"===t.type?C=this.renderStepLine(t):"spline"===t.type?C=this.renderSpline(t):"column"===t.type?C=this.renderColumn(t):"bar"===t.type?C=this.renderBar(t):"area"===t.type?C=this.renderArea(t):"stepArea"===t.type?C=this.renderStepArea(t):"splineArea"===t.type?C=this.renderSplineArea(t):"stackedColumn"===
t.type?C=this.renderStackedColumn(t):"stackedColumn100"===t.type?C=this.renderStackedColumn100(t):"stackedBar"===t.type?C=this.renderStackedBar(t):"stackedBar100"===t.type?C=this.renderStackedBar100(t):"stackedArea"===t.type?C=this.renderStackedArea(t):"stackedArea100"===t.type?C=this.renderStackedArea100(t):"bubble"===t.type?C=C=this.renderBubble(t):"scatter"===t.type?C=this.renderScatter(t):"pie"===t.type?this.renderPie(t):"doughnut"===t.type?this.renderPie(t):"funnel"===t.type?C=this.renderFunnel(t):
"pyramid"===t.type?C=this.renderFunnel(t):"candlestick"===t.type?C=this.renderCandlestick(t):"ohlc"===t.type?C=this.renderCandlestick(t):"rangeColumn"===t.type?C=this.renderRangeColumn(t):"error"===t.type?C=this.renderError(t):"rangeBar"===t.type?C=this.renderRangeBar(t):"rangeArea"===t.type?C=this.renderRangeArea(t):"rangeSplineArea"===t.type?C=this.renderRangeSplineArea(t):"waterfall"===t.type?C=this.renderWaterfall(t):"boxAndWhisker"===t.type&&(C=this.renderBoxAndWhisker(t));for(var k=0;k<t.dataSeriesIndexes.length;k++)this._dataInRenderedOrder.push(this.data[t.dataSeriesIndexes[k]]);
this.animatedRender&&(t.targetCanvasCtx.miterLimit=e,C&&c.push(C))}this.ctx.miterLimit=a;this.animatedRender&&this._breaksCanvasCtx&&c.push({source:this._breaksCanvasCtx,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0,startTimePercent:0.7});this.animatedRender&&0<this._indexLabels.length&&(e=ua(this.width,this.height).getContext("2d"),c.push(this.renderIndexLabels(e)));var m=this;if(0<c.length)m.disableToolTip=!0,m._animator.animate(200,
m.animationDuration,function(a){m.ctx.clearRect(0,0,m.width,m.height);m.ctx.drawImage(b,0,0,Math.floor(m.width*la),Math.floor(m.height*la),0,0,m.width,m.height);for(var e=0;e<c.length;e++)C=c[e],1>a&&"undefined"!==typeof C.startTimePercent?a>=C.startTimePercent&&C.animationCallback(C.easingFunction(a-C.startTimePercent,0,1,1-C.startTimePercent),C):C.animationCallback(C.easingFunction(a,0,1,1),C);m.dispatchEvent("dataAnimationIterationEnd",{chart:m})},function(){c=[];for(var a=0;a<m.plotInfo.plotTypes.length;a++)for(var e=
m.plotInfo.plotTypes[a],d=0;d<e.plotUnits.length;d++){var f=e.plotUnits[d];f.targetCanvas&&ya(f.targetCanvas);f.targetCanvas=null}b=null;m.disableToolTip=!1;m.dispatchEvent("dataAnimationEnd",{chart:m})});else{if(m._breaksCanvas)if(w)m.plotArea.ctx.drawImage(m._breaksCanvas,0,0,this.width,this.height);else for(k=0;k<m._axes.length;k++)m._axes[k].createMask();0<m._indexLabels.length&&m.renderIndexLabels();m.dispatchEvent("dataAnimationIterationEnd",{chart:m});m.dispatchEvent("dataAnimationEnd",{chart:m})}this.attachPlotAreaEventHandlers();
this.zoomEnabled||(this.panEnabled||!this._zoomButton||"none"===this._zoomButton.style.display)||wa(this._zoomButton,this._resetButton);this.toolTip._updateToolTip();this.renderCount++;Ia&&(m=this,setTimeout(function(){var a=document.getElementById("ghostCanvasCopy");a&&(Na(a,m.width,m.height),a.getContext("2d").drawImage(m._eventManager.ghostCanvas,0,0))},2E3));this._breaksCanvas&&(delete this._breaksCanvas,delete this._breaksCanvasCtx);for(k=0;k<this._axes.length;k++)this._axes[k].maskCanvas&&(delete this._axes[k].maskCanvas,
delete this._axes[k].maskCtx)}};p.prototype.render=function(a){a&&(this.options=a);this._initialize();this.setLayout();this.renderElements();this._preRenderCanvas&&ya(this._preRenderCanvas)};p.prototype.attachPlotAreaEventHandlers=function(){this.attachEvent({context:this,chart:this,mousedown:this._plotAreaMouseDown,mouseup:this._plotAreaMouseUp,mousemove:this._plotAreaMouseMove,cursor:this.panEnabled?"move":"default",capture:!0,bounds:this.plotArea})};p.prototype.categoriseDataSeries=function(){for(var a=
"",d=0;d<this.data.length;d++)if(a=this.data[d],a.dataPoints&&(0!==a.dataPoints.length&&a.visible)&&0<=p._supportedChartTypes.indexOf(a.type)){for(var c=null,b=!1,e=null,f=!1,l=0;l<this.plotInfo.plotTypes.length;l++)if(this.plotInfo.plotTypes[l].type===a.type){b=!0;c=this.plotInfo.plotTypes[l];break}b||(c={type:a.type,totalDataSeries:0,plotUnits:[]},this.plotInfo.plotTypes.push(c));for(l=0;l<c.plotUnits.length;l++)if(c.plotUnits[l].axisYType===a.axisYType&&c.plotUnits[l].axisXType===a.axisXType&&
c.plotUnits[l].axisYIndex===a.axisYIndex&&c.plotUnits[l].axisXIndex===a.axisXIndex){f=!0;e=c.plotUnits[l];break}f||(e={type:a.type,previousDataSeriesCount:0,index:c.plotUnits.length,plotType:c,axisXType:a.axisXType,axisYType:a.axisYType,axisYIndex:a.axisYIndex,axisXIndex:a.axisXIndex,axisY:"primary"===a.axisYType?this.axisY[0<=a.axisYIndex&&a.axisYIndex<this.axisY.length?a.axisYIndex:0]:this.axisY2[0<=a.axisYIndex&&a.axisYIndex<this.axisY2.length?a.axisYIndex:0],axisX:"primary"===a.axisXType?this.axisX[0<=
a.axisXIndex&&a.axisXIndex<this.axisX.length?a.axisXIndex:0]:this.axisX2[0<=a.axisXIndex&&a.axisXIndex<this.axisX2.length?a.axisXIndex:0],dataSeriesIndexes:[],yTotals:[],yAbsTotals:[]},c.plotUnits.push(e));c.totalDataSeries++;e.dataSeriesIndexes.push(d);a.plotUnit=e}for(d=0;d<this.plotInfo.plotTypes.length;d++)for(c=this.plotInfo.plotTypes[d],l=a=0;l<c.plotUnits.length;l++)c.plotUnits[l].previousDataSeriesCount=a,a+=c.plotUnits[l].dataSeriesIndexes.length};p.prototype.assignIdToDataPoints=function(){for(var a=
0;a<this.data.length;a++){var d=this.data[a];if(d.dataPoints)for(var c=d.dataPoints.length,b=0;b<c;b++)d.dataPointIds[b]=++this._eventManager.lastObjectId}};p.prototype._processData=function(){this.assignIdToDataPoints();this.categoriseDataSeries();for(var a=0;a<this.plotInfo.plotTypes.length;a++)for(var d=this.plotInfo.plotTypes[a],c=0;c<d.plotUnits.length;c++){var b=d.plotUnits[c];"line"===b.type||"stepLine"===b.type||"spline"===b.type||"column"===b.type||"area"===b.type||"stepArea"===b.type||"splineArea"===
b.type||"bar"===b.type||"bubble"===b.type||"scatter"===b.type?this._processMultiseriesPlotUnit(b):"stackedColumn"===b.type||"stackedBar"===b.type||"stackedArea"===b.type?this._processStackedPlotUnit(b):"stackedColumn100"===b.type||"stackedBar100"===b.type||"stackedArea100"===b.type?this._processStacked100PlotUnit(b):"candlestick"===b.type||"ohlc"===b.type||"rangeColumn"===b.type||"rangeBar"===b.type||"rangeArea"===b.type||"rangeSplineArea"===b.type||"error"===b.type||"boxAndWhisker"===b.type?this._processMultiYPlotUnit(b):
"waterfall"===b.type&&this._processSpecificPlotUnit(b)}this.calculateAutoBreaks()};p.prototype._processMultiseriesPlotUnit=function(a){if(a.dataSeriesIndexes&&!(1>a.dataSeriesIndexes.length))for(var d=a.axisY.dataInfo,c=a.axisX.dataInfo,b,e,f=!1,l=0;l<a.dataSeriesIndexes.length;l++){var t=this.data[a.dataSeriesIndexes[l]],C=0,k=!1,m=!1,n;if("normal"===t.axisPlacement||"xySwapped"===t.axisPlacement)var q=a.axisX.sessionVariables.newViewportMinimum?a.axisX.sessionVariables.newViewportMinimum:a.axisX.options&&
a.axisX.options.viewportMinimum?a.axisX.options.viewportMinimum:a.axisX.options&&a.axisX.options.minimum?a.axisX.options.minimum:a.axisX.logarithmic?0:-Infinity,g=a.axisX.sessionVariables.newViewportMaximum?a.axisX.sessionVariables.newViewportMaximum:a.axisX.options&&a.axisX.options.viewportMaximum?a.axisX.options.viewportMaximum:a.axisX.options&&a.axisX.options.maximum?a.axisX.options.maximum:Infinity;if(t.dataPoints[C].x&&t.dataPoints[C].x.getTime||"dateTime"===t.xValueType)f=!0;for(C=0;C<t.dataPoints.length;C++){"undefined"===
typeof t.dataPoints[C].x&&(t.dataPoints[C].x=C+(a.axisX.logarithmic?1:0));t.dataPoints[C].x.getTime?(f=!0,b=t.dataPoints[C].x.getTime()):b=t.dataPoints[C].x;e=t.dataPoints[C].y;b<c.min&&(c.min=b);b>c.max&&(c.max=b);e<d.min&&"number"===typeof e&&(d.min=e);e>d.max&&"number"===typeof e&&(d.max=e);if(0<C){if(a.axisX.logarithmic){var s=b/t.dataPoints[C-1].x;1>s&&(s=1/s);c.minDiff>s&&1!==s&&(c.minDiff=s)}else s=b-t.dataPoints[C-1].x,0>s&&(s*=-1),c.minDiff>s&&0!==s&&(c.minDiff=s);null!==e&&null!==t.dataPoints[C-
1].y&&(a.axisY.logarithmic?(s=e/t.dataPoints[C-1].y,1>s&&(s=1/s),d.minDiff>s&&1!==s&&(d.minDiff=s)):(s=e-t.dataPoints[C-1].y,0>s&&(s*=-1),d.minDiff>s&&0!==s&&(d.minDiff=s)))}if(b<q&&!k)null!==e&&(n=b);else{if(!k&&(k=!0,0<C)){C-=2;continue}if(b>g&&!m)m=!0;else if(b>g&&m)continue;t.dataPoints[C].label&&(a.axisX.labels[b]=t.dataPoints[C].label);b<c.viewPortMin&&(c.viewPortMin=b);b>c.viewPortMax&&(c.viewPortMax=b);null===e?c.viewPortMin===b&&n<b&&(c.viewPortMin=n):(e<d.viewPortMin&&"number"===typeof e&&
(d.viewPortMin=e),e>d.viewPortMax&&"number"===typeof e&&(d.viewPortMax=e))}}t.axisX.valueType=t.xValueType=f?"dateTime":"number"}};p.prototype._processStackedPlotUnit=function(a){if(a.dataSeriesIndexes&&!(1>a.dataSeriesIndexes.length)){for(var d=a.axisY.dataInfo,c=a.axisX.dataInfo,b,e,f=!1,l=[],t=[],C=Infinity,k=-Infinity,m=0;m<a.dataSeriesIndexes.length;m++){var n=this.data[a.dataSeriesIndexes[m]],q=0,g=!1,s=!1,h;if("normal"===n.axisPlacement||"xySwapped"===n.axisPlacement)var ba=a.axisX.sessionVariables.newViewportMinimum?
a.axisX.sessionVariables.newViewportMinimum:a.axisX.options&&a.axisX.options.viewportMinimum?a.axisX.options.viewportMinimum:a.axisX.options&&a.axisX.options.minimum?a.axisX.options.minimum:-Infinity,u=a.axisX.sessionVariables.newViewportMaximum?a.axisX.sessionVariables.newViewportMaximum:a.axisX.options&&a.axisX.options.viewportMaximum?a.axisX.options.viewportMaximum:a.axisX.options&&a.axisX.options.maximum?a.axisX.options.maximum:Infinity;if(n.dataPoints[q].x&&n.dataPoints[q].x.getTime||"dateTime"===
n.xValueType)f=!0;for(q=0;q<n.dataPoints.length;q++){"undefined"===typeof n.dataPoints[q].x&&(n.dataPoints[q].x=q+(a.axisX.logarithmic?1:0));n.dataPoints[q].x.getTime?(f=!0,b=n.dataPoints[q].x.getTime()):b=n.dataPoints[q].x;e=r(n.dataPoints[q].y)?0:n.dataPoints[q].y;b<c.min&&(c.min=b);b>c.max&&(c.max=b);if(0<q){if(a.axisX.logarithmic){var y=b/n.dataPoints[q-1].x;1>y&&(y=1/y);c.minDiff>y&&1!==y&&(c.minDiff=y)}else y=b-n.dataPoints[q-1].x,0>y&&(y*=-1),c.minDiff>y&&0!==y&&(c.minDiff=y);null!==e&&null!==
n.dataPoints[q-1].y&&(a.axisY.logarithmic?0<e&&(y=e/n.dataPoints[q-1].y,1>y&&(y=1/y),d.minDiff>y&&1!==y&&(d.minDiff=y)):(y=e-n.dataPoints[q-1].y,0>y&&(y*=-1),d.minDiff>y&&0!==y&&(d.minDiff=y)))}if(b<ba&&!g)null!==n.dataPoints[q].y&&(h=b);else{if(!g&&(g=!0,0<q)){q-=2;continue}if(b>u&&!s)s=!0;else if(b>u&&s)continue;n.dataPoints[q].label&&(a.axisX.labels[b]=n.dataPoints[q].label);b<c.viewPortMin&&(c.viewPortMin=b);b>c.viewPortMax&&(c.viewPortMax=b);null===n.dataPoints[q].y?c.viewPortMin===b&&h<b&&(c.viewPortMin=
h):(a.yTotals[b]=(a.yTotals[b]?a.yTotals[b]:0)+e,a.yAbsTotals[b]=(a.yAbsTotals[b]?a.yAbsTotals[b]:0)+Math.abs(e),0<=e?l[b]?l[b]+=e:(l[b]=e,C=Math.min(e,C)):t[b]?t[b]+=e:(t[b]=e,k=Math.max(e,k)))}}a.axisY.scaleBreaks&&(a.axisY.scaleBreaks.autoCalculate&&1<=a.axisY.scaleBreaks.maxNumberOfAutoBreaks)&&(d.dataPointYPositiveSums?(d.dataPointYPositiveSums.push.apply(d.dataPointYPositiveSums,l),d.dataPointYNegativeSums.push.apply(d.dataPointYPositiveSums,t)):(d.dataPointYPositiveSums=l,d.dataPointYNegativeSums=
t));n.axisX.valueType=n.xValueType=f?"dateTime":"number"}for(q in l)l.hasOwnProperty(q)&&!isNaN(q)&&(a=l[q],a<d.min&&(d.min=Math.min(a,C)),a>d.max&&(d.max=a),q<c.viewPortMin||q>c.viewPortMax||(a<d.viewPortMin&&(d.viewPortMin=Math.min(a,C)),a>d.viewPortMax&&(d.viewPortMax=a)));for(q in t)t.hasOwnProperty(q)&&!isNaN(q)&&(a=t[q],a<d.min&&(d.min=a),a>d.max&&(d.max=Math.max(a,k)),q<c.viewPortMin||q>c.viewPortMax||(a<d.viewPortMin&&(d.viewPortMin=a),a>d.viewPortMax&&(d.viewPortMax=Math.max(a,k))))}};p.prototype._processStacked100PlotUnit=
function(a){if(a.dataSeriesIndexes&&!(1>a.dataSeriesIndexes.length)){for(var d=a.axisY.dataInfo,c=a.axisX.dataInfo,b,e,f=!1,l=!1,t=!1,C=[],k=0;k<a.dataSeriesIndexes.length;k++){var m=this.data[a.dataSeriesIndexes[k]],n=0,q=!1,g=!1,s;if("normal"===m.axisPlacement||"xySwapped"===m.axisPlacement)var h=a.axisX.sessionVariables.newViewportMinimum?a.axisX.sessionVariables.newViewportMinimum:a.axisX.options&&a.axisX.options.viewportMinimum?a.axisX.options.viewportMinimum:a.axisX.options&&a.axisX.options.minimum?
a.axisX.options.minimum:-Infinity,ba=a.axisX.sessionVariables.newViewportMaximum?a.axisX.sessionVariables.newViewportMaximum:a.axisX.options&&a.axisX.options.viewportMaximum?a.axisX.options.viewportMaximum:a.axisX.options&&a.axisX.options.maximum?a.axisX.options.maximum:Infinity;if(m.dataPoints[n].x&&m.dataPoints[n].x.getTime||"dateTime"===m.xValueType)f=!0;for(n=0;n<m.dataPoints.length;n++){"undefined"===typeof m.dataPoints[n].x&&(m.dataPoints[n].x=n+(a.axisX.logarithmic?1:0));m.dataPoints[n].x.getTime?
(f=!0,b=m.dataPoints[n].x.getTime()):b=m.dataPoints[n].x;e=r(m.dataPoints[n].y)?null:m.dataPoints[n].y;b<c.min&&(c.min=b);b>c.max&&(c.max=b);if(0<n){if(a.axisX.logarithmic){var u=b/m.dataPoints[n-1].x;1>u&&(u=1/u);c.minDiff>u&&1!==u&&(c.minDiff=u)}else u=b-m.dataPoints[n-1].x,0>u&&(u*=-1),c.minDiff>u&&0!==u&&(c.minDiff=u);r(e)||null===m.dataPoints[n-1].y||(a.axisY.logarithmic?0<e&&(u=e/m.dataPoints[n-1].y,1>u&&(u=1/u),d.minDiff>u&&1!==u&&(d.minDiff=u)):(u=e-m.dataPoints[n-1].y,0>u&&(u*=-1),d.minDiff>
u&&0!==u&&(d.minDiff=u)))}if(b<h&&!q)null!==e&&(s=b);else{if(!q&&(q=!0,0<n)){n-=2;continue}if(b>ba&&!g)g=!0;else if(b>ba&&g)continue;m.dataPoints[n].label&&(a.axisX.labels[b]=m.dataPoints[n].label);b<c.viewPortMin&&(c.viewPortMin=b);b>c.viewPortMax&&(c.viewPortMax=b);null===e?c.viewPortMin===b&&s<b&&(c.viewPortMin=s):(a.yTotals[b]=(a.yTotals[b]?a.yTotals[b]:0)+e,a.yAbsTotals[b]=(a.yAbsTotals[b]?a.yAbsTotals[b]:0)+Math.abs(e),0<=e?l=!0:0>e&&(t=!0),C[b]=C[b]?C[b]+Math.abs(e):Math.abs(e))}}m.axisX.valueType=
m.xValueType=f?"dateTime":"number"}a.axisY.logarithmic?(d.max=r(d.viewPortMax)?99*Math.pow(a.axisY.logarithmBase,-0.05):Math.max(d.viewPortMax,99*Math.pow(a.axisY.logarithmBase,-0.05)),d.min=r(d.viewPortMin)?1:Math.min(d.viewPortMin,1)):l&&!t?(d.max=r(d.viewPortMax)?99:Math.max(d.viewPortMax,99),d.min=r(d.viewPortMin)?1:Math.min(d.viewPortMin,1)):l&&t?(d.max=r(d.viewPortMax)?99:Math.max(d.viewPortMax,99),d.min=r(d.viewPortMin)?-99:Math.min(d.viewPortMin,-99)):!l&&t&&(d.max=r(d.viewPortMax)?-1:Math.max(d.viewPortMax,
-1),d.min=r(d.viewPortMin)?-99:Math.min(d.viewPortMin,-99));d.viewPortMin=d.min;d.viewPortMax=d.max;a.dataPointYSums=C}};p.prototype._processMultiYPlotUnit=function(a){if(a.dataSeriesIndexes&&!(1>a.dataSeriesIndexes.length))for(var d=a.axisY.dataInfo,c=a.axisX.dataInfo,b,e,f,l,t=!1,C=0;C<a.dataSeriesIndexes.length;C++){var k=this.data[a.dataSeriesIndexes[C]],m=0,n=!1,q=!1,g,s,h;if("normal"===k.axisPlacement||"xySwapped"===k.axisPlacement)var r=a.axisX.sessionVariables.newViewportMinimum?a.axisX.sessionVariables.newViewportMinimum:
a.axisX.options&&a.axisX.options.viewportMinimum?a.axisX.options.viewportMinimum:a.axisX.options&&a.axisX.options.minimum?a.axisX.options.minimum:a.axisX.logarithmic?0:-Infinity,u=a.axisX.sessionVariables.newViewportMaximum?a.axisX.sessionVariables.newViewportMaximum:a.axisX.options&&a.axisX.options.viewportMaximum?a.axisX.options.viewportMaximum:a.axisX.options&&a.axisX.options.maximum?a.axisX.options.maximum:Infinity;if(k.dataPoints[m].x&&k.dataPoints[m].x.getTime||"dateTime"===k.xValueType)t=!0;
for(m=0;m<k.dataPoints.length;m++){"undefined"===typeof k.dataPoints[m].x&&(k.dataPoints[m].x=m+(a.axisX.logarithmic?1:0));k.dataPoints[m].x.getTime?(t=!0,b=k.dataPoints[m].x.getTime()):b=k.dataPoints[m].x;if((e=k.dataPoints[m].y)&&e.length){f=Math.min.apply(null,e);l=Math.max.apply(null,e);s=!0;for(var y=0;y<e.length;y++)null===e.k&&(s=!1);s&&(n||(h=g),g=b)}b<c.min&&(c.min=b);b>c.max&&(c.max=b);f<d.min&&(d.min=f);l>d.max&&(d.max=l);0<m&&(a.axisX.logarithmic?(s=b/k.dataPoints[m-1].x,1>s&&(s=1/s),
c.minDiff>s&&1!==s&&(c.minDiff=s)):(s=b-k.dataPoints[m-1].x,0>s&&(s*=-1),c.minDiff>s&&0!==s&&(c.minDiff=s)),e&&(null!==e[0]&&k.dataPoints[m-1].y&&null!==k.dataPoints[m-1].y[0])&&(a.axisY.logarithmic?(s=e[0]/k.dataPoints[m-1].y[0],1>s&&(s=1/s),d.minDiff>s&&1!==s&&(d.minDiff=s)):(s=e[0]-k.dataPoints[m-1].y[0],0>s&&(s*=-1),d.minDiff>s&&0!==s&&(d.minDiff=s))));if(!(b<r)||n){if(!n&&(n=!0,0<m)){m-=2;g=h;continue}if(b>u&&!q)q=!0;else if(b>u&&q)continue;k.dataPoints[m].label&&(a.axisX.labels[b]=k.dataPoints[m].label);
b<c.viewPortMin&&(c.viewPortMin=b);b>c.viewPortMax&&(c.viewPortMax=b);if(c.viewPortMin===b&&e)for(y=0;y<e.length;y++)if(null===e[y]&&g<b){c.viewPortMin=g;break}null===e?c.viewPortMin===b&&g<b&&(c.viewPortMin=g):(f<d.viewPortMin&&(d.viewPortMin=f),l>d.viewPortMax&&(d.viewPortMax=l))}}k.axisX.valueType=k.xValueType=t?"dateTime":"number"}};p.prototype._processSpecificPlotUnit=function(a){if("waterfall"===a.type&&a.dataSeriesIndexes&&!(1>a.dataSeriesIndexes.length))for(var d=a.axisY.dataInfo,c=a.axisX.dataInfo,
b,e,f=!1,l=0;l<a.dataSeriesIndexes.length;l++){var t=this.data[a.dataSeriesIndexes[l]],C=0,k=!1,m=!1,n=b=0;if("normal"===t.axisPlacement||"xySwapped"===t.axisPlacement)var q=a.axisX.sessionVariables.newViewportMinimum?a.axisX.sessionVariables.newViewportMinimum:a.axisX.options&&a.axisX.options.viewportMinimum?a.axisX.options.viewportMinimum:a.axisX.options&&a.axisX.options.minimum?a.axisX.options.minimum:a.axisX.logarithmic?0:-Infinity,g=a.axisX.sessionVariables.newViewportMaximum?a.axisX.sessionVariables.newViewportMaximum:
a.axisX.options&&a.axisX.options.viewportMaximum?a.axisX.options.viewportMaximum:a.axisX.options&&a.axisX.options.maximum?a.axisX.options.maximum:Infinity;if(t.dataPoints[C].x&&t.dataPoints[C].x.getTime||"dateTime"===t.xValueType)f=!0;for(C=0;C<t.dataPoints.length;C++)"undefined"!==typeof t.dataPoints[C].isCumulativeSum&&!0===t.dataPoints[C].isCumulativeSum?(t.dataPointEOs[C].cumulativeSumYStartValue=0,t.dataPointEOs[C].cumulativeSum=0===C?0:t.dataPointEOs[C-1].cumulativeSum,t.dataPoints[C].y=0===
C?0:t.dataPointEOs[C-1].cumulativeSum):"undefined"!==typeof t.dataPoints[C].isIntermediateSum&&!0===t.dataPoints[C].isIntermediateSum?(t.dataPointEOs[C].cumulativeSumYStartValue=n,t.dataPointEOs[C].cumulativeSum=0===C?0:t.dataPointEOs[C-1].cumulativeSum,t.dataPoints[C].y=0===C?0:b,n=0===C?0:t.dataPointEOs[C-1].cumulativeSum,b=0):(e="number"!==typeof t.dataPoints[C].y?0:t.dataPoints[C].y,t.dataPointEOs[C].cumulativeSumYStartValue=0===C?0:t.dataPointEOs[C-1].cumulativeSum,t.dataPointEOs[C].cumulativeSum=
0===C?e:t.dataPointEOs[C-1].cumulativeSum+e,b+=e);for(C=0;C<t.dataPoints.length;C++)if("undefined"===typeof t.dataPoints[C].x&&(t.dataPoints[C].x=C+(a.axisX.logarithmic?1:0)),t.dataPoints[C].x.getTime?(f=!0,b=t.dataPoints[C].x.getTime()):b=t.dataPoints[C].x,e=t.dataPoints[C].y,b<c.min&&(c.min=b),b>c.max&&(c.max=b),t.dataPointEOs[C].cumulativeSum<d.min&&(d.min=t.dataPointEOs[C].cumulativeSum),t.dataPointEOs[C].cumulativeSum>d.max&&(d.max=t.dataPointEOs[C].cumulativeSum),0<C&&(a.axisX.logarithmic?(n=
b/t.dataPoints[C-1].x,1>n&&(n=1/n),c.minDiff>n&&1!==n&&(c.minDiff=n)):(n=b-t.dataPoints[C-1].x,0>n&&(n*=-1),c.minDiff>n&&0!==n&&(c.minDiff=n)),null!==e&&null!==t.dataPoints[C-1].y&&(a.axisY.logarithmic?(e=t.dataPointEOs[C].cumulativeSum/t.dataPointEOs[C-1].cumulativeSum,1>e&&(e=1/e),d.minDiff>e&&1!==e&&(d.minDiff=e)):(e=t.dataPointEOs[C].cumulativeSum-t.dataPointEOs[C-1].cumulativeSum,0>e&&(e*=-1),d.minDiff>e&&0!==e&&(d.minDiff=e)))),!(b<q)||k){if(!k&&(k=!0,0<C)){C-=2;continue}if(b>g&&!m)m=!0;else if(b>
g&&m)continue;t.dataPoints[C].label&&(a.axisX.labels[b]=t.dataPoints[C].label);b<c.viewPortMin&&(c.viewPortMin=b);b>c.viewPortMax&&(c.viewPortMax=b);0<C&&(t.dataPointEOs[C-1].cumulativeSum<d.viewPortMin&&(d.viewPortMin=t.dataPointEOs[C-1].cumulativeSum),t.dataPointEOs[C-1].cumulativeSum>d.viewPortMax&&(d.viewPortMax=t.dataPointEOs[C-1].cumulativeSum));t.dataPointEOs[C].cumulativeSum<d.viewPortMin&&(d.viewPortMin=t.dataPointEOs[C].cumulativeSum);t.dataPointEOs[C].cumulativeSum>d.viewPortMax&&(d.viewPortMax=
t.dataPointEOs[C].cumulativeSum)}t.axisX.valueType=t.xValueType=f?"dateTime":"number"}};p.prototype.calculateAutoBreaks=function(){function a(a,b,c,e){if(e)return c=Math.pow(Math.min(c*a/b,b/a),0.2),1>=c&&(c=Math.pow(1>a?1/a:Math.min(b/a,a),0.25)),{startValue:a*c,endValue:b/c};c=0.2*Math.min(c-b+a,b-a);0>=c&&(c=0.25*Math.min(b-a,Math.abs(a)));return{startValue:a+c,endValue:b-c}}function d(a){if(a.dataSeriesIndexes&&!(1>a.dataSeriesIndexes.length)){var b=a.axisX.scaleBreaks&&a.axisX.scaleBreaks.autoCalculate&&
1<=a.axisX.scaleBreaks.maxNumberOfAutoBreaks,c=a.axisY.scaleBreaks&&a.axisY.scaleBreaks.autoCalculate&&1<=a.axisY.scaleBreaks.maxNumberOfAutoBreaks;if(b||c)for(var d=a.axisY.dataInfo,g=a.axisX.dataInfo,f,l=g.min,k=g.max,m=d.min,n=d.max,g=g._dataRanges,d=d._dataRanges,q,t=0,C=0;C<a.dataSeriesIndexes.length;C++){var h=e.data[a.dataSeriesIndexes[C]];if(!(4>h.dataPoints.length))for(t=0;t<h.dataPoints.length;t++)if(b&&(q=(k+1-l)*Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold)||10,10)/100,
f=h.dataPoints[t].x.getTime?h.dataPoints[t].x.getTime():h.dataPoints[t].x,q=Math.floor((f-l)/q),f<g[q].min&&(g[q].min=f),f>g[q].max&&(g[q].max=f)),c){var p=(n+1-m)*Math.max(parseFloat(a.axisY.scaleBreaks.collapsibleThreshold)||10,10)/100;if((f="waterfall"===a.type?h.dataPointEOs[t].cumulativeSum:h.dataPoints[t].y)&&f.length)for(var w=0;w<f.length;w++)q=Math.floor((f[w]-m)/p),f[w]<d[q].min&&(d[q].min=f[w]),f[w]>d[q].max&&(d[q].max=f[w]);else r(f)||(q=Math.floor((f-m)/p),f<d[q].min&&(d[q].min=f),f>
d[q].max&&(d[q].max=f))}}}}function c(a){if(a.dataSeriesIndexes&&!(1>a.dataSeriesIndexes.length)&&a.axisX.scaleBreaks&&a.axisX.scaleBreaks.autoCalculate&&1<=a.axisX.scaleBreaks.maxNumberOfAutoBreaks)for(var b=a.axisX.dataInfo,c=b.min,d=b.max,f=b._dataRanges,g,l=0,k=0;k<a.dataSeriesIndexes.length;k++){var m=e.data[a.dataSeriesIndexes[k]];if(!(4>m.dataPoints.length))for(l=0;l<m.dataPoints.length;l++)g=(d+1-c)*Math.max(parseFloat(a.axisX.scaleBreaks.collapsibleThreshold)||10,10)/100,b=m.dataPoints[l].x.getTime?
m.dataPoints[l].x.getTime():m.dataPoints[l].x,g=Math.floor((b-c)/g),b<f[g].min&&(f[g].min=b),b>f[g].max&&(f[g].max=b)}}for(var b,e=this,f=!1,l=0;l<this._axes.length;l++)if(this._axes[l].scaleBreaks&&this._axes[l].scaleBreaks.autoCalculate&&1<=this._axes[l].scaleBreaks.maxNumberOfAutoBreaks){f=!0;this._axes[l].dataInfo._dataRanges=[];for(var t=0;t<100/Math.max(parseFloat(this._axes[l].scaleBreaks.collapsibleThreshold)||10,10);t++)this._axes[l].dataInfo._dataRanges.push({min:Infinity,max:-Infinity})}if(f){for(l=
0;l<this.plotInfo.plotTypes.length;l++)for(f=this.plotInfo.plotTypes[l],t=0;t<f.plotUnits.length;t++)b=f.plotUnits[t],"line"===b.type||"stepLine"===b.type||"spline"===b.type||"column"===b.type||"area"===b.type||"stepArea"===b.type||"splineArea"===b.type||"bar"===b.type||"bubble"===b.type||"scatter"===b.type||"candlestick"===b.type||"ohlc"===b.type||"rangeColumn"===b.type||"rangeBar"===b.type||"rangeArea"===b.type||"rangeSplineArea"===b.type||"waterfall"===b.type||"error"===b.type||"boxAndWhisker"===
b.type?d(b):0<=b.type.indexOf("stacked")&&c(b);for(l=0;l<this._axes.length;l++)if(this._axes[l].dataInfo._dataRanges){var C=this._axes[l].dataInfo.min;b=(this._axes[l].dataInfo.max+1-C)*Math.max(parseFloat(this._axes[l].scaleBreaks.collapsibleThreshold)||10,10)/100;var k=this._axes[l].dataInfo._dataRanges,m,n,f=[];if(this._axes[l].dataInfo.dataPointYPositiveSums){var q=this._axes[l].dataInfo.dataPointYPositiveSums;m=k;for(t in q)if(q.hasOwnProperty(t)&&!isNaN(t)&&(n=q[t],!r(n))){var g=Math.floor((n-
C)/b);n<m[g].min&&(m[g].min=n);n>m[g].max&&(m[g].max=n)}delete this._axes[l].dataInfo.dataPointYPositiveSums}if(this._axes[l].dataInfo.dataPointYNegativeSums){q=this._axes[l].dataInfo.dataPointYNegativeSums;m=k;for(t in q)q.hasOwnProperty(t)&&!isNaN(t)&&(n=-1*q[t],r(n)||(g=Math.floor((n-C)/b),n<m[g].min&&(m[g].min=n),n>m[g].max&&(m[g].max=n)));delete this._axes[l].dataInfo.dataPointYNegativeSums}for(t=0;t<k.length-1;t++)if(m=k[t].max,isFinite(m))for(;t<k.length-1;)if(C=k[t+1].min,isFinite(C)){n=C-
m;n>b&&f.push({diff:n,start:m,end:C});break}else t++;if(this._axes[l].scaleBreaks.customBreaks)for(t=0;t<this._axes[l].scaleBreaks.customBreaks.length;t++)for(b=0;b<f.length;b++)if(this._axes[l].scaleBreaks.customBreaks[t].startValue<=f[b].start&&f[b].start<=this._axes[l].scaleBreaks.customBreaks[t].endValue||this._axes[l].scaleBreaks.customBreaks[t].startValue<=f[b].start&&f[b].start<=this._axes[l].scaleBreaks.customBreaks[t].endValue||f[b].start<=this._axes[l].scaleBreaks.customBreaks[t].startValue&&
this._axes[l].scaleBreaks.customBreaks[t].startValue<=f[b].end||f[b].start<=this._axes[l].scaleBreaks.customBreaks[t].endValue&&this._axes[l].scaleBreaks.customBreaks[t].endValue<=f[b].end)f.splice(b,1),b--;f.sort(function(a,b){return b.diff-a.diff});for(t=0;t<Math.min(f.length,this._axes[l].scaleBreaks.maxNumberOfAutoBreaks);t++)b=a(f[t].start,f[t].end,this._axes[l].logarithmic?this._axes[l].dataInfo.max/this._axes[l].dataInfo.min:this._axes[l].dataInfo.max-this._axes[l].dataInfo.min,this._axes[l].logarithmic),
this._axes[l].scaleBreaks.autoBreaks.push(new aa(this,"autoBreaks",b,t,++this._eventManager.lastObjectId,this._axes[l].scaleBreaks)),this._axes[l].scaleBreaks._appliedBreaks.push(this._axes[l].scaleBreaks.autoBreaks[this._axes[l].scaleBreaks.autoBreaks.length-1]);this._axes[l].scaleBreaks._appliedBreaks.sort(function(a,b){return a.startValue-b.startValue})}}};p.prototype.renderCrosshairs=function(a){for(var d=0;d<this.axisX.length;d++)this.axisX[d]!=a&&(this.axisX[d].crosshair&&this.axisX[d].crosshair.enabled&&
!this.axisX[d].crosshair._hidden)&&this.axisX[d].showCrosshair(this.axisX[d].crosshair._updatedValue);for(d=0;d<this.axisX2.length;d++)this.axisX2[d]!=a&&(this.axisX2[d].crosshair&&this.axisX2[d].crosshair.enabled&&!this.axisX2[d].crosshair._hidden)&&this.axisX2[d].showCrosshair(this.axisX2[d].crosshair._updatedValue);for(d=0;d<this.axisY.length;d++)this.axisY[d]!=a&&(this.axisY[d].crosshair&&this.axisY[d].crosshair.enabled&&!this.axisY[d].crosshair._hidden)&&this.axisY[d].showCrosshair(this.axisY[d].crosshair._updatedValue);
for(d=0;d<this.axisY2.length;d++)this.axisY2[d]!=a&&(this.axisY2[d].crosshair&&this.axisY2[d].crosshair.enabled&&!this.axisY2[d].crosshair._hidden)&&this.axisY2[d].showCrosshair(this.axisY2[d].crosshair._updatedValue)};p.prototype.getDataPointAtXY=function(a,d,c){c=c||!1;for(var b=[],e=this._dataInRenderedOrder.length-1;0<=e;e--){var f=null;(f=this._dataInRenderedOrder[e].getDataPointAtXY(a,d,c))&&b.push(f)}a=null;d=!1;for(c=0;c<b.length;c++)if("line"===b[c].dataSeries.type||"stepLine"===b[c].dataSeries.type||
"area"===b[c].dataSeries.type||"stepArea"===b[c].dataSeries.type)if(e=ma("markerSize",b[c].dataPoint,b[c].dataSeries)||8,b[c].distance<=e/2){d=!0;break}for(c=0;c<b.length;c++)d&&"line"!==b[c].dataSeries.type&&"stepLine"!==b[c].dataSeries.type&&"area"!==b[c].dataSeries.type&&"stepArea"!==b[c].dataSeries.type||(a?b[c].distance<=a.distance&&(a=b[c]):a=b[c]);return a};p.prototype.getObjectAtXY=function(a,d,c){var b=null;if(c=this.getDataPointAtXY(a,d,c||!1))b=c.dataSeries.dataPointIds[c.dataPointIndex];
else if(w)b=$a(a,d,this._eventManager.ghostCtx);else for(c=0;c<this.legend.items.length;c++){var e=this.legend.items[c];a>=e.x1&&(a<=e.x2&&d>=e.y1&&d<=e.y2)&&(b=e.id)}return b};p.prototype.getAutoFontSize=mb;p.prototype.resetOverlayedCanvas=function(){this.overlaidCanvasCtx.clearRect(0,0,this.width,this.height)};p.prototype.clearCanvas=lb;p.prototype.attachEvent=function(a){this._events.push(a)};p.prototype._touchEventHandler=function(a){if(a.changedTouches&&this.interactivityEnabled){var d=[],c=
a.changedTouches,b=c?c[0]:a,e=null;switch(a.type){case "touchstart":case "MSPointerDown":d=["mousemove","mousedown"];this._lastTouchData=Pa(b);this._lastTouchData.time=new Date;break;case "touchmove":case "MSPointerMove":d=["mousemove"];break;case "touchend":case "MSPointerUp":var f=this._lastTouchData&&this._lastTouchData.time?new Date-this._lastTouchData.time:0,d="touchstart"===this._lastTouchEventType||"MSPointerDown"===this._lastTouchEventType||300>f?["mouseup","click"]:["mouseup"];break;default:return}if(!(c&&
1<c.length)){e=Pa(b);e.time=new Date;try{var l=e.y-this._lastTouchData.y,f=e.time-this._lastTouchData.time;if(1<Math.abs(l)&&this._lastTouchData.scroll||5<Math.abs(l)&&250>f)this._lastTouchData.scroll=!0}catch(t){}this._lastTouchEventType=a.type;if(this._lastTouchData.scroll&&this.zoomEnabled)this.isDrag&&this.resetOverlayedCanvas(),this.isDrag=!1;else for(c=0;c<d.length;c++)if(e=d[c],l=document.createEvent("MouseEvent"),l.initMouseEvent(e,!0,!0,window,1,b.screenX,b.screenY,b.clientX,b.clientY,!1,
!1,!1,!1,0,null),b.target.dispatchEvent(l),!r(this._lastTouchData.scroll)&&!this._lastTouchData.scroll||!this._lastTouchData.scroll&&250<f||"click"===e)a.preventManipulation&&a.preventManipulation(),a.preventDefault&&a.cancelable&&a.preventDefault()}}};p.prototype._dispatchRangeEvent=function(a,d){var c={chart:this};c.type=a;c.trigger=d;var b=[];this.axisX&&0<this.axisX.length&&b.push("axisX");this.axisX2&&0<this.axisX2.length&&b.push("axisX2");this.axisY&&0<this.axisY.length&&b.push("axisY");this.axisY2&&
0<this.axisY2.length&&b.push("axisY2");for(var e=0;e<b.length;e++)if(r(c[b[e]])&&(c[b[e]]=[]),"axisY"===b[e])for(var f=0;f<this.axisY.length;f++)c[b[e]].push({viewportMinimum:this[b[e]][f].sessionVariables.newViewportMinimum,viewportMaximum:this[b[e]][f].sessionVariables.newViewportMaximum});else if("axisY2"===b[e])for(f=0;f<this.axisY2.length;f++)c[b[e]].push({viewportMinimum:this[b[e]][f].sessionVariables.newViewportMinimum,viewportMaximum:this[b[e]][f].sessionVariables.newViewportMaximum});else if("axisX"===
b[e])for(f=0;f<this.axisX.length;f++)c[b[e]].push({viewportMinimum:this[b[e]][f].sessionVariables.newViewportMinimum,viewportMaximum:this[b[e]][f].sessionVariables.newViewportMaximum});else if("axisX2"===b[e])for(f=0;f<this.axisX2.length;f++)c[b[e]].push({viewportMinimum:this[b[e]][f].sessionVariables.newViewportMinimum,viewportMaximum:this[b[e]][f].sessionVariables.newViewportMaximum});this.dispatchEvent(a,c,this)};p.prototype._mouseEventHandler=function(a){"undefined"===typeof a.target&&a.srcElement&&
(a.target=a.srcElement);var d=Pa(a),c=a.type,b,e;a.which?e=3==a.which:a.button&&(e=2==a.button);p.capturedEventParam&&(b=p.capturedEventParam,"mouseup"===c&&(p.capturedEventParam=null,b.chart.overlaidCanvas.releaseCapture?b.chart.overlaidCanvas.releaseCapture():document.documentElement.removeEventListener("mouseup",b.chart._mouseEventHandler,!1)),b.hasOwnProperty(c)&&("mouseup"!==c||b.chart.overlaidCanvas.releaseCapture?a.target!==b.chart.overlaidCanvas&&w||b[c].call(b.context,d.x,d.y):a.target!==
b.chart.overlaidCanvas&&(b.chart.isDrag=!1)));if(this.interactivityEnabled)if(this._ignoreNextEvent)this._ignoreNextEvent=!1;else if(a.preventManipulation&&a.preventManipulation(),a.preventDefault&&a.preventDefault(),Ia&&window.console&&(window.console.log(c+" --\x3e x: "+d.x+"; y:"+d.y),e&&window.console.log(a.which),"mouseup"===c&&window.console.log("mouseup")),!e){if(!p.capturedEventParam&&this._events){for(var f=0;f<this._events.length;f++)if(this._events[f].hasOwnProperty(c))if(b=this._events[f],
e=b.bounds,d.x>=e.x1&&d.x<=e.x2&&d.y>=e.y1&&d.y<=e.y2){b[c].call(b.context,d.x,d.y);"mousedown"===c&&!0===b.capture?(p.capturedEventParam=b,this.overlaidCanvas.setCapture?this.overlaidCanvas.setCapture():document.documentElement.addEventListener("mouseup",this._mouseEventHandler,!1)):"mouseup"===c&&(b.chart.overlaidCanvas.releaseCapture?b.chart.overlaidCanvas.releaseCapture():document.documentElement.removeEventListener("mouseup",this._mouseEventHandler,!1));break}else b=null;a.target.style.cursor=
b&&b.cursor?b.cursor:this._defaultCursor}c=this.plotArea;if(d.x<c.x1||d.x>c.x2||d.y<c.y1||d.y>c.y2){this.toolTip&&this.toolTip.enabled?(this.toolTip.hide(),this.toolTip.dispatchEvent("hidden",{chart:this,toolTip:this.toolTip},this.toolTip)):this.resetOverlayedCanvas();for(f=0;f<this.axisX.length;f++)this.axisX[f].crosshair&&this.axisX[f].crosshair.enabled&&(this.axisX[f].crosshair.hide(),this.axisX[f].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisX[f].options},this.axisX[f].crosshair));
for(f=0;f<this.axisX2.length;f++)this.axisX2[f].crosshair&&this.axisX2[f].crosshair.enabled&&(this.axisX2[f].crosshair.hide(),this.axisX2[f].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisX2[f].options},this.axisX2[f].crosshair));for(f=0;f<this.axisY.length;f++)this.axisY[f].crosshair&&this.axisY[f].crosshair.enabled&&(this.axisY[f].crosshair.hide(),this.axisY[f].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisY[f].options},this.axisY[f].crosshair));for(f=0;f<this.axisY2.length;f++)this.axisY2[f].crosshair&&
this.axisY2[f].crosshair.enabled&&(this.axisY2[f].crosshair.hide(),this.axisY2[f].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisY2[f].options},this.axisY2[f].crosshair))}this.isDrag&&this.zoomEnabled||!this._eventManager||this._eventManager.mouseEventHandler(a)}};p.prototype._plotAreaMouseDown=function(a,d){this.isDrag=!0;this.dragStartPoint={x:a,y:d}};p.prototype._plotAreaMouseUp=function(a,d){if(("normal"===this.plotInfo.axisPlacement||"xySwapped"===this.plotInfo.axisPlacement)&&this.isDrag){var c=
d-this.dragStartPoint.y,b=a-this.dragStartPoint.x,e=0<=this.zoomType.indexOf("x"),f=0<=this.zoomType.indexOf("y"),l=!1;this.resetOverlayedCanvas();if("xySwapped"===this.plotInfo.axisPlacement)var t=f,f=e,e=t;if(this.panEnabled||this.zoomEnabled){if(this.panEnabled)for(e=f=0;e<this._axes.length;e++)c=this._axes[e],c.logarithmic?c.viewportMinimum<c.minimum?(f=c.minimum/c.viewportMinimum,c.sessionVariables.newViewportMinimum=c.viewportMinimum*f,c.sessionVariables.newViewportMaximum=c.viewportMaximum*
f,l=!0):c.viewportMaximum>c.maximum&&(f=c.viewportMaximum/c.maximum,c.sessionVariables.newViewportMinimum=c.viewportMinimum/f,c.sessionVariables.newViewportMaximum=c.viewportMaximum/f,l=!0):c.viewportMinimum<c.minimum?(f=c.minimum-c.viewportMinimum,c.sessionVariables.newViewportMinimum=c.viewportMinimum+f,c.sessionVariables.newViewportMaximum=c.viewportMaximum+f,l=!0):c.viewportMaximum>c.maximum&&(f=c.viewportMaximum-c.maximum,c.sessionVariables.newViewportMinimum=c.viewportMinimum-f,c.sessionVariables.newViewportMaximum=
c.viewportMaximum-f,l=!0);else if((!e||2<Math.abs(b))&&(!f||2<Math.abs(c))&&this.zoomEnabled){if(!this.dragStartPoint)return;c=e?this.dragStartPoint.x:this.plotArea.x1;b=f?this.dragStartPoint.y:this.plotArea.y1;e=e?a:this.plotArea.x2;f=f?d:this.plotArea.y2;2<Math.abs(c-e)&&2<Math.abs(b-f)&&this._zoomPanToSelectedRegion(c,b,e,f)&&(l=!0)}l&&(this._ignoreNextEvent=!0,this._dispatchRangeEvent("rangeChanging","zoom"),this.stockChart&&(this.stockChart.navigator&&this.stockChart.navigator.enabled)&&(this.stockChart._rangeEventParameter||
(this.stockChart._rangeEventParameter={stockChart:this.stockChart,source:"chart",index:this.stockChart.charts.indexOf(this),minimum:this.stockChart.sessionVariables._axisXMin,maximum:this.stockChart.sessionVariables._axisXMax}),this.stockChart._rangeEventParameter.type="rangeChanging",this.stockChart.dispatchEvent("rangeChanging",this.stockChart._rangeEventParameter,this.stockChart)),this.render(),this._dispatchRangeEvent("rangeChanged","zoom"),this.stockChart&&(this.stockChart.navigator&&this.stockChart.navigator.enabled)&&
(this.stockChart._rangeEventParameter.type="rangeChanged",this.stockChart.dispatchEvent("rangeChanged",this.stockChart._rangeEventParameter,this.stockChart)),l&&(this.zoomEnabled&&"none"===this._zoomButton.style.display)&&(Ma(this._zoomButton,this._resetButton),sa(this,this._zoomButton,"pan"),sa(this,this._resetButton,"reset")))}}this.isDrag=!1;if("none"!==this.plotInfo.axisPlacement){this.resetOverlayedCanvas();if(this.axisX&&0<this.axisX.length)for(l=0;l<this.axisX.length;l++)this.axisX[l].crosshair&&
this.axisX[l].crosshair.enabled&&this.axisX[l].renderCrosshair(a,d);if(this.axisX2&&0<this.axisX2.length)for(l=0;l<this.axisX2.length;l++)this.axisX2[l].crosshair&&this.axisX2[l].crosshair.enabled&&this.axisX2[l].renderCrosshair(a,d);if(this.axisY&&0<this.axisY.length)for(l=0;l<this.axisY.length;l++)this.axisY[l].crosshair&&this.axisY[l].crosshair.enabled&&this.axisY[l].renderCrosshair(a,d);if(this.axisY2&&0<this.axisY2.length)for(l=0;l<this.axisY2.length;l++)this.axisY2[l].crosshair&&this.axisY2[l].crosshair.enabled&&
this.axisY2[l].renderCrosshair(a,d);if(this.axisX&&0<this.axisX.length)for(l=0;l<this.axisX.length;l++)this.axisX[l].crosshair&&this.axisX[l].crosshair.enabled&&this.axisX[l].crosshair.renderLabel();if(this.axisX2&&0<this.axisX2.length)for(l=0;l<this.axisX2.length;l++)this.axisX2[l].crosshair&&this.axisX2[l].crosshair.enabled&&this.axisX2[l].crosshair.renderLabel();if(this.axisY&&0<this.axisY.length)for(l=0;l<this.axisY.length;l++)this.axisY[l].crosshair&&this.axisY[l].crosshair.enabled&&this.axisY[l].crosshair.renderLabel();
if(this.axisY2&&0<this.axisY2.length)for(l=0;l<this.axisY2.length;l++)this.axisY2[l].crosshair&&this.axisY2[l].crosshair.enabled&&this.axisY2[l].crosshair.renderLabel()}};p.prototype._plotAreaMouseMove=function(a,d){if(this.isDrag&&"none"!==this.plotInfo.axisPlacement){var c=0,b=0,e=c=null,e=0<=this.zoomType.indexOf("x"),f=0<=this.zoomType.indexOf("y"),l=this;"xySwapped"===this.plotInfo.axisPlacement&&(c=f,f=e,e=c);c=this.dragStartPoint.x-a;b=this.dragStartPoint.y-d;if(2<Math.abs(c)&&8>Math.abs(c)&&
(this.panEnabled||this.zoomEnabled)){this.toolTip.hide();this.toolTip&&this.toolTip.enabled&&this.toolTip.dispatchEvent("hidden",{chart:this,toolTip:this.toolTip},this.toolTip);for(var t=0;t<this.axisX.length;t++)this.axisX[t].crosshair&&this.axisX[t].crosshair.enabled&&(this.axisX[t].crosshair.hide(),this.axisX[t].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisX[t].options},this.axisX[t].crosshair));for(t=0;t<this.axisX2.length;t++)this.axisX2[t].crosshair&&this.axisX2[t].crosshair.enabled&&
(this.axisX2[t].crosshair.hide(),this.axisX2[t].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisX2[t].options},this.axisX2[t].crosshair));for(t=0;t<this.axisY.length;t++)this.axisY[t].crosshair&&this.axisY[t].crosshair.enabled&&(this.axisY[t].crosshair.hide(),this.axisY[t].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisY[t].options},this.axisY[t].crosshair));for(t=0;t<this.axisY2.length;t++)this.axisY2[t].crosshair&&this.axisY2[t].crosshair.enabled&&(this.axisY2[t].crosshair.hide(),
this.axisY2[t].crosshair.dispatchEvent("hidden",{chart:this,axis:this.axisY2[t].options},this.axisY2[t].crosshair))}else this.panEnabled||this.zoomEnabled||this.toolTip.mouseMoveHandler(a,d);if((!e||2<Math.abs(c)||!f||2<Math.abs(b))&&(this.panEnabled||this.zoomEnabled))if(this.panEnabled)e={x1:e?this.plotArea.x1+c:this.plotArea.x1,y1:f?this.plotArea.y1+b:this.plotArea.y1,x2:e?this.plotArea.x2+c:this.plotArea.x2,y2:f?this.plotArea.y2+b:this.plotArea.y2},clearTimeout(l._panTimerId),l._panTimerId=setTimeout(function(b,
c,e,f){return function(){l._zoomPanToSelectedRegion(b,c,e,f,!0)&&(l._dispatchRangeEvent("rangeChanging","pan"),l.stockChart&&(l.stockChart.navigator&&l.stockChart.navigator.enabled)&&(l.stockChart._rangeEventParameter.type="rangeChanging",l.stockChart.dispatchEvent("rangeChanging",l.stockChart._rangeEventParameter,l.stockChart)),l.render(),l._dispatchRangeEvent("rangeChanged","pan"),l.stockChart&&(l.stockChart.navigator&&l.stockChart.navigator.enabled)&&(l.stockChart._rangeEventParameter.type="rangeChanged",
l.stockChart.dispatchEvent("rangeChanged",l.stockChart._rangeEventParameter,l.stockChart)),l.dragStartPoint.x=a,l.dragStartPoint.y=d)}}(e.x1,e.y1,e.x2,e.y2),0);else if(this.zoomEnabled){this.resetOverlayedCanvas();c=this.overlaidCanvasCtx.globalAlpha;this.overlaidCanvasCtx.fillStyle="#A89896";var b=e?this.dragStartPoint.x:this.plotArea.x1,t=f?this.dragStartPoint.y:this.plotArea.y1,C=e?a-this.dragStartPoint.x:this.plotArea.x2-this.plotArea.x1,k=f?d-this.dragStartPoint.y:this.plotArea.y2-this.plotArea.y1;
this.validateRegion(b,t,e?a:this.plotArea.x2-this.plotArea.x1,f?d:this.plotArea.y2-this.plotArea.y1,"xy"!==this.zoomType).isValid&&(this.resetOverlayedCanvas(),this.overlaidCanvasCtx.fillStyle="#99B2B5");this.overlaidCanvasCtx.globalAlpha=0.7;this.overlaidCanvasCtx.fillRect(b,t,C,k);this.overlaidCanvasCtx.globalAlpha=c}}else if(this.toolTip.mouseMoveHandler(a,d),"none"!==this.plotInfo.axisPlacement){if(this.axisX&&0<this.axisX.length)for(e=0;e<this.axisX.length;e++)this.axisX[e].crosshair&&this.axisX[e].crosshair.enabled&&
this.axisX[e].renderCrosshair(a,d);if(this.axisX2&&0<this.axisX2.length)for(e=0;e<this.axisX2.length;e++)this.axisX2[e].crosshair&&this.axisX2[e].crosshair.enabled&&this.axisX2[e].renderCrosshair(a,d);if(this.axisY&&0<this.axisY.length)for(e=0;e<this.axisY.length;e++)this.axisY[e].crosshair&&this.axisY[e].crosshair.enabled&&this.axisY[e].renderCrosshair(a,d);if(this.axisY2&&0<this.axisY2.length)for(e=0;e<this.axisY2.length;e++)this.axisY2[e].crosshair&&this.axisY2[e].crosshair.enabled&&this.axisY2[e].renderCrosshair(a,
d);if(this.axisX&&0<this.axisX.length)for(e=0;e<this.axisX.length;e++)this.axisX[e].crosshair&&this.axisX[e].crosshair.enabled&&this.axisX[e].crosshair.renderLabel();if(this.axisX2&&0<this.axisX2.length)for(e=0;e<this.axisX2.length;e++)this.axisX2[e].crosshair&&this.axisX2[e].crosshair.enabled&&this.axisX2[e].crosshair.renderLabel();if(this.axisY&&0<this.axisY.length)for(e=0;e<this.axisY.length;e++)this.axisY[e].crosshair&&this.axisY[e].crosshair.enabled&&this.axisY[e].crosshair.renderLabel();if(this.axisY2&&
0<this.axisY2.length)for(e=0;e<this.axisY2.length;e++)this.axisY2[e].crosshair&&this.axisY2[e].crosshair.enabled&&this.axisY2[e].crosshair.renderLabel()}};p.prototype._zoomPanToSelectedRegion=function(a,d,c,b,e){a=this.validateRegion(a,d,c,b,e);d=a.axesWithValidRange;c=a.axesRanges;if(a.isValid)for(b=0;b<d.length;b++)e=c[b],d[b].setViewPortRange(e.val1,e.val2),this.syncCharts&&"y"!=this.zoomType&&this.syncCharts(e.val1,e.val2),this.stockChart&&(this.stockChart._rangeEventParameter={stockChart:this.stockChart,
source:"chart",index:this.stockChart.charts.indexOf(this),minimum:e.val1,maximum:e.val2});return a.isValid};p.prototype.validateRegion=function(a,d,c,b,e){e=e||!1;for(var f=0<=this.zoomType.indexOf("x"),l=0<=this.zoomType.indexOf("y"),t=!1,C=[],k=[],m=[],n=0;n<this._axes.length;n++)("axisX"===this._axes[n].type&&f||"axisY"===this._axes[n].type&&l)&&k.push(this._axes[n]);for(l=0;l<k.length;l++){var n=k[l],f=!1,q=n.convertPixelToValue({x:a,y:d}),g=n.convertPixelToValue({x:c,y:b});if(q>g)var s=g,g=q,
q=s;if(n.scaleBreaks)for(s=0;!f&&s<n.scaleBreaks._appliedBreaks.length;s++)f=n.scaleBreaks._appliedBreaks[s].startValue<=q&&n.scaleBreaks._appliedBreaks[s].endValue>=g;if(isFinite(n.dataInfo.minDiff))if(s=n.getApparentDifference(q,g,null,!0),!(f||!(this.panEnabled&&n.scaleBreaks&&n.scaleBreaks._appliedBreaks.length)&&(n.logarithmic&&s<Math.pow(n.dataInfo.minDiff,3)||!n.logarithmic&&s<3*Math.abs(n.dataInfo.minDiff))||q<n.minimum||g>n.maximum))C.push(n),m.push({val1:q,val2:g}),t=!0;else if(!e){t=!1;
break}}return{isValid:t,axesWithValidRange:C,axesRanges:m}};p.prototype.preparePlotArea=function(){var a=this.plotArea;!w&&(0<a.x1||0<a.y1)&&a.ctx.translate(a.x1,a.y1);if((this.axisX[0]||this.axisX2[0])&&(this.axisY[0]||this.axisY2[0])){var d=this.axisX[0]?this.axisX[0].lineCoordinates:this.axisX2[0].lineCoordinates;if(this.axisY&&0<this.axisY.length&&this.axisY[0]){var c=this.axisY[0];a.x1=d.x1<d.x2?d.x1:c.lineCoordinates.x1;a.y1=d.y1<c.lineCoordinates.y1?d.y1:c.lineCoordinates.y1;a.x2=d.x2>c.lineCoordinates.x2?
d.x2:c.lineCoordinates.x2;a.y2=d.y2>d.y1?d.y2:c.lineCoordinates.y2;a.width=a.x2-a.x1;a.height=a.y2-a.y1}this.axisY2&&0<this.axisY2.length&&this.axisY2[0]&&(c=this.axisY2[0],a.x1=d.x1<d.x2?d.x1:c.lineCoordinates.x1,a.y1=d.y1<c.lineCoordinates.y1?d.y1:c.lineCoordinates.y1,a.x2=d.x2>c.lineCoordinates.x2?d.x2:c.lineCoordinates.x2,a.y2=d.y2>d.y1?d.y2:c.lineCoordinates.y2,a.width=a.x2-a.x1,a.height=a.y2-a.y1)}else d=this.layoutManager.getFreeSpace(),a.x1=d.x1,a.x2=d.x2,a.y1=d.y1,a.y2=d.y2,a.width=d.width,
a.height=d.height;w||(a.canvas.width=a.width,a.canvas.height=a.height,a.canvas.style.left=a.x1+"px",a.canvas.style.top=a.y1+"px",(0<a.x1||0<a.y1)&&a.ctx.translate(-a.x1,-a.y1));a.layoutManager=new Fa(a.x1,a.y1,a.x2,a.y2,2)};p.prototype.renderIndexLabels=function(a){var d=a||this.plotArea.ctx,c=this.plotArea,b=0,e=0,f=0,l=f=e=0,t=0,C=b=0,k=0;for(a=0;a<this._indexLabels.length;a++){var m=this._indexLabels[a],n=m.chartType.toLowerCase(),q,g,l=ma("indexLabelFontColor",m.dataPoint,m.dataSeries),s=ma("indexLabelFontSize",
m.dataPoint,m.dataSeries),t=ma("indexLabelFontFamily",m.dataPoint,m.dataSeries),C=ma("indexLabelFontStyle",m.dataPoint,m.dataSeries),k=ma("indexLabelFontWeight",m.dataPoint,m.dataSeries),h=ma("indexLabelBackgroundColor",m.dataPoint,m.dataSeries);q=ma("indexLabelMaxWidth",m.dataPoint,m.dataSeries);g=ma("indexLabelWrap",m.dataPoint,m.dataSeries);var ba=ma("indexLabelLineDashType",m.dataPoint,m.dataSeries),u=ma("indexLabelLineColor",m.dataPoint,m.dataSeries),p=r(m.dataPoint.indexLabelLineThickness)?
r(m.dataSeries.options.indexLabelLineThickness)?0:m.dataSeries.options.indexLabelLineThickness:m.dataPoint.indexLabelLineThickness,b=0<p?Math.min(10,("normal"===this.plotInfo.axisPlacement?this.plotArea.height:this.plotArea.width)<<0):0,x={percent:null,total:null},z=null;if(0<=m.dataSeries.type.indexOf("stacked")||"pie"===m.dataSeries.type||"doughnut"===m.dataSeries.type)x=this.getPercentAndTotal(m.dataSeries,m.dataPoint);if(m.dataSeries.indexLabelFormatter||m.dataPoint.indexLabelFormatter)z={chart:this,
dataSeries:m.dataSeries,dataPoint:m.dataPoint,index:m.indexKeyword,total:x.total,percent:x.percent};var H=m.dataPoint.indexLabelFormatter?m.dataPoint.indexLabelFormatter(z):m.dataPoint.indexLabel?this.replaceKeywordsWithValue(m.dataPoint.indexLabel,m.dataPoint,m.dataSeries,null,m.indexKeyword):m.dataSeries.indexLabelFormatter?m.dataSeries.indexLabelFormatter(z):m.dataSeries.indexLabel?this.replaceKeywordsWithValue(m.dataSeries.indexLabel,m.dataPoint,m.dataSeries,null,m.indexKeyword):null;if(null!==
H&&""!==H){var x=ma("indexLabelPlacement",m.dataPoint,m.dataSeries),z=ma("indexLabelOrientation",m.dataPoint,m.dataSeries),D=ma("indexLabelTextAlign",m.dataPoint,m.dataSeries),v=m.direction,e=m.dataSeries.axisX,f=m.dataSeries.axisY,A=!1,h=new ja(d,{x:0,y:0,maxWidth:q?q:0.5*this.width,maxHeight:g?5*s:1.5*s,angle:"horizontal"===z?0:-90,text:H,padding:0,backgroundColor:h,textAlign:D,fontSize:s,fontFamily:t,fontWeight:k,fontColor:l,fontStyle:C,textBaseline:"middle"});h.measureText();m.dataSeries.indexLabelMaxWidth=
h.maxWidth;if("stackedarea100"===n){if(m.point.x<c.x1||m.point.x>c.x2||m.point.y<c.y1-1||m.point.y>c.y2+1)continue}else if("rangearea"===n||"rangesplinearea"===n){if(m.dataPoint.x<e.viewportMinimum||m.dataPoint.x>e.viewportMaximum||Math.max.apply(null,m.dataPoint.y)<f.viewportMinimum||Math.min.apply(null,m.dataPoint.y)>f.viewportMaximum)continue}else if(0<=n.indexOf("line")||0<=n.indexOf("area")||0<=n.indexOf("bubble")||0<=n.indexOf("scatter")){if(m.dataPoint.x<e.viewportMinimum||m.dataPoint.x>e.viewportMaximum||
m.dataPoint.y<f.viewportMinimum||m.dataPoint.y>f.viewportMaximum)continue}else if(0<=n.indexOf("column")||"waterfall"===n||"error"===n&&!m.axisSwapped){if(m.dataPoint.x<e.viewportMinimum||m.dataPoint.x>e.viewportMaximum||m.bounds.y1>c.y2||m.bounds.y2<c.y1)continue}else if(0<=n.indexOf("bar")||"error"===n){if(m.dataPoint.x<e.viewportMinimum||m.dataPoint.x>e.viewportMaximum||m.bounds.x1>c.x2||m.bounds.x2<c.x1)continue}else if("candlestick"===n||"ohlc"===n){if(m.dataPoint.x<e.viewportMinimum||m.dataPoint.x>
e.viewportMaximum||Math.max.apply(null,m.dataPoint.y)<f.viewportMinimum||Math.min.apply(null,m.dataPoint.y)>f.viewportMaximum)continue}else if(m.dataPoint.x<e.viewportMinimum||m.dataPoint.x>e.viewportMaximum)continue;l=t=2;"horizontal"===z?(C=h.width,k=h.height):(k=h.width,C=h.height);if("normal"===this.plotInfo.axisPlacement){if(0<=n.indexOf("line")||0<=n.indexOf("area"))x="auto",t=4;else if(0<=n.indexOf("stacked"))"auto"===x&&(x="inside");else if("bubble"===n||"scatter"===n)x="inside";q=m.point.x-
("horizontal"===z?C/2:C/2-s/2);"inside"!==x?(e=c.y1,f=c.y2,0<v?(g=m.point.y+("horizontal"===z?s/2:0)-k-t-b,g<e&&(g="auto"===x?Math.max(m.point.y,e)+s/2+t:e+s/2+t,A=g+k>m.point.y)):(g=m.point.y+s/2+t+b,g>f-k&&(g="auto"===x?Math.min(m.point.y,f)+s/2-k-t:f+s/2-k,A=g<m.point.y))):(e=Math.max(m.bounds.y1,c.y1),f=Math.min(m.bounds.y2,c.y2-k+s/2),b=0<=n.indexOf("range")||"error"===n?0<v?Math.max(m.bounds.y1,c.y1)+s/2+t:Math.min(m.bounds.y2,c.y2)+s/2-k+t:(Math.max(m.bounds.y1,c.y1)+Math.min(m.bounds.y2,c.y2))/
2-k/2+s/2+("horizontal"===z?t:0),0<v?(g=Math.max(m.point.y,b),g<e&&("bubble"===n||"scatter"===n)&&(g=Math.max(m.point.y-k-t,c.y1+t))):(g=Math.min(m.point.y,b),g>f-k-t&&("bubble"===n||"scatter"===n)&&(g=Math.min(m.point.y+t,c.y2-k-t))),g=Math.min(g,f))}else 0<=n.indexOf("line")||0<=n.indexOf("area")||0<=n.indexOf("scatter")?(x="auto",l=4):0<=n.indexOf("stacked")?"auto"===x&&(x="inside"):"bubble"===n&&(x="inside"),g=m.point.y+s/2-k/2+t,"inside"!==x?(e=c.x1,f=c.x2,0>v?(q=m.point.x-("horizontal"===z?
C:C-s/2)-l-b,q<e&&(q="auto"===x?Math.max(m.point.x,e)+l:e+l,A=q+C>m.point.x)):(q=m.point.x+("horizontal"===z?0:s/2)+l+b,q>f-C-l-b&&(q="auto"===x?Math.min(m.point.x,f)-("horizontal"===z?C:C/2)-l:f-C-l,A=q<m.point.x))):(e=Math.max(m.bounds.x1,c.x1),Math.min(m.bounds.x2,c.x2),b=0<=n.indexOf("range")||"error"===n?0>v?Math.max(m.bounds.x1,c.x1)+s/2+l:Math.min(m.bounds.x2,c.x2)-C/2-l+("horizontal"===z?0:s/2):(Math.max(m.bounds.x1,c.x1)+Math.min(m.bounds.x2,c.x2))/2+("horizontal"===z?0:s/2),q=0>v?Math.max(m.point.x,
b)-("horizontal"===z?C/2:0):Math.min(m.point.x,b)-C/2,q=Math.max(q,e));"vertical"===z&&(g+=k-s/2);h.x=q;h.y=g;h.render(!0);p&&("inside"!==x&&(0>n.indexOf("bar")&&("error"!==n||!m.axisSwapped)&&m.point.x>c.x1&&m.point.x<c.x2||!A)&&(0>n.indexOf("column")&&("error"!==n||m.axisSwapped)&&m.point.y>c.y1&&m.point.y<c.y2||!A))&&(d.lineWidth=p,d.strokeStyle=u?u:"gray",d.setLineDash&&d.setLineDash(J(ba,p)),d.beginPath(),d.moveTo(m.point.x,m.point.y),0<=n.indexOf("bar")||"error"===n&&m.axisSwapped?d.lineTo(q+
(0<m.direction?-l:C+l)+("vertical"===z?-s/2:0),g+("vertical"===z?-k/2:k/2-s/2)-t):0<=n.indexOf("column")||"error"===n&&!m.axisSwapped?d.lineTo(q+C/2-("horizontal"===z?0:s/2),g+("vertical"===z?(g-k<m.point.y?0:-k)+t:(g-s/2<m.point.y?k:0)-s/2)):0<=n.indexOf("waterfall")?d.lineTo(q+C/2-("horizontal"===z?0:s/2),"vertical"===z?0<v&&g<m.point.y?g:0>v&&g-k>m.point.y?g-k:m.point.y:0<v&&g+k-s/2<m.point.y?g+k-s/2:0>v&&g-s/2>m.point.y?g-s/2-2:m.point.y):d.lineTo(q+C/2-("horizontal"===z?0:s/2),g+("vertical"===
z?g-k<m.point.y?0:-k:(g+k<m.point.y?k:0)-s/2)),d.stroke())}}d={source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0,startTimePercent:0.7};for(a=0;a<this._indexLabels.length;a++)m=this._indexLabels[a],h=ma("indexLabelBackgroundColor",m.dataPoint,m.dataSeries),m.dataSeries.indexLabelBackgroundColor=r(h)?w?"transparent":null:h;return d};p.prototype.renderLine=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:
d;if(!(0>=a.dataSeriesIndexes.length)){var b=this._eventManager.ghostCtx;c.save();var e=this.plotArea;c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();for(var f=[],l,t=0;t<a.dataSeriesIndexes.length;t++){var C=a.dataSeriesIndexes[t],k=this.data[C];c.lineWidth=k.lineThickness;var m=k.dataPoints,n="solid";if(c.setLineDash){var q=J(k.nullDataLineDashType,k.lineThickness),n=k.lineDashType,g=J(n,k.lineThickness);c.setLineDash(g)}var s=k.id;this._eventManager.objectMap[s]={objectType:"dataSeries",
dataSeriesIndex:C};s=X(s);b.strokeStyle=s;b.lineWidth=0<k.lineThickness?Math.max(k.lineThickness,4):0;var s=k._colorSet,h=s=k.lineColor=k.options.lineColor?k.options.lineColor:s[0];c.strokeStyle=s;var r=!0,u=0,p,x;c.beginPath();if(0<m.length){for(var z=!1,u=0;u<m.length;u++)if(p=m[u].x.getTime?m[u].x.getTime():m[u].x,!(p<a.axisX.dataInfo.viewPortMin||p>a.axisX.dataInfo.viewPortMax&&(!k.connectNullData||!z)))if("number"!==typeof m[u].y)0<u&&!(k.connectNullData||z||r)&&(c.stroke(),w&&b.stroke()),z=
!0;else{p=a.axisX.convertValueToPixel(p);x=a.axisY.convertValueToPixel(m[u].y);var H=k.dataPointIds[u];this._eventManager.objectMap[H]={id:H,objectType:"dataPoint",dataSeriesIndex:C,dataPointIndex:u,x1:p,y1:x};r||z?(!r&&k.connectNullData?(c.setLineDash&&(k.options.nullDataLineDashType||n===k.lineDashType&&k.lineDashType!==k.nullDataLineDashType)&&(c.stroke(),c.beginPath(),c.moveTo(l.x,l.y),n=k.nullDataLineDashType,c.setLineDash(q)),c.lineTo(p,x),w&&b.lineTo(p,x)):(c.beginPath(),c.moveTo(p,x),w&&(b.beginPath(),
b.moveTo(p,x))),z=r=!1):(c.lineTo(p,x),w&&b.lineTo(p,x),0==u%500&&(c.stroke(),c.beginPath(),c.moveTo(p,x),w&&(b.stroke(),b.beginPath(),b.moveTo(p,x))));l={x:p,y:x};u<m.length-1&&(h!==(m[u].lineColor||s)||n!==(m[u].lineDashType||k.lineDashType))&&(c.stroke(),c.beginPath(),c.moveTo(p,x),h=m[u].lineColor||s,c.strokeStyle=h,c.setLineDash&&(m[u].lineDashType?(n=m[u].lineDashType,c.setLineDash(J(n,k.lineThickness))):(n=k.lineDashType,c.setLineDash(g))));if(0!==m[u].markerSize&&(0<m[u].markerSize||0<k.markerSize)){var D=
k.getMarkerProperties(u,p,x,c);f.push(D);H=X(H);w&&f.push({x:p,y:x,ctx:b,type:D.type,size:D.size,color:H,borderColor:H,borderThickness:D.borderThickness})}(m[u].indexLabel||k.indexLabel||m[u].indexLabelFormatter||k.indexLabelFormatter)&&this._indexLabels.push({chartType:"line",dataPoint:m[u],dataSeries:k,point:{x:p,y:x},direction:0>m[u].y===a.axisY.reversed?1:-1,color:s})}c.stroke();w&&b.stroke()}}W.drawMarkers(f);w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation=
"source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),b.beginPath());c.restore();c.beginPath();return{source:d,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderStepLine=
function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=this._eventManager.ghostCtx;c.save();var e=this.plotArea;c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();for(var f=[],l,t=0;t<a.dataSeriesIndexes.length;t++){var C=a.dataSeriesIndexes[t],k=this.data[C];c.lineWidth=k.lineThickness;var m=k.dataPoints,n="solid";if(c.setLineDash){var q=J(k.nullDataLineDashType,k.lineThickness),n=k.lineDashType,g=J(n,k.lineThickness);c.setLineDash(g)}var s=
k.id;this._eventManager.objectMap[s]={objectType:"dataSeries",dataSeriesIndex:C};s=X(s);b.strokeStyle=s;b.lineWidth=0<k.lineThickness?Math.max(k.lineThickness,4):0;var s=k._colorSet,h=s=k.lineColor=k.options.lineColor?k.options.lineColor:s[0];c.strokeStyle=s;var r=!0,u=0,p,x;c.beginPath();if(0<m.length){for(var z=!1,u=0;u<m.length;u++)if(p=m[u].getTime?m[u].x.getTime():m[u].x,!(p<a.axisX.dataInfo.viewPortMin||p>a.axisX.dataInfo.viewPortMax&&(!k.connectNullData||!z)))if("number"!==typeof m[u].y)0<
u&&!(k.connectNullData||z||r)&&(c.stroke(),w&&b.stroke()),z=!0;else{var H=x;p=a.axisX.convertValueToPixel(p);x=a.axisY.convertValueToPixel(m[u].y);var D=k.dataPointIds[u];this._eventManager.objectMap[D]={id:D,objectType:"dataPoint",dataSeriesIndex:C,dataPointIndex:u,x1:p,y1:x};r||z?(!r&&k.connectNullData?(c.setLineDash&&(k.options.nullDataLineDashType||n===k.lineDashType&&k.lineDashType!==k.nullDataLineDashType)&&(c.stroke(),c.beginPath(),c.moveTo(l.x,l.y),n=k.nullDataLineDashType,c.setLineDash(q)),
c.lineTo(p,H),c.lineTo(p,x),w&&(b.lineTo(p,H),b.lineTo(p,x))):(c.beginPath(),c.moveTo(p,x),w&&(b.beginPath(),b.moveTo(p,x))),z=r=!1):(c.lineTo(p,H),w&&b.lineTo(p,H),c.lineTo(p,x),w&&b.lineTo(p,x),0==u%500&&(c.stroke(),c.beginPath(),c.moveTo(p,x),w&&(b.stroke(),b.beginPath(),b.moveTo(p,x))));l={x:p,y:x};u<m.length-1&&(h!==(m[u].lineColor||s)||n!==(m[u].lineDashType||k.lineDashType))&&(c.stroke(),c.beginPath(),c.moveTo(p,x),h=m[u].lineColor||s,c.strokeStyle=h,c.setLineDash&&(m[u].lineDashType?(n=m[u].lineDashType,
c.setLineDash(J(n,k.lineThickness))):(n=k.lineDashType,c.setLineDash(g))));0!==m[u].markerSize&&(0<m[u].markerSize||0<k.markerSize)&&(H=k.getMarkerProperties(u,p,x,c),f.push(H),D=X(D),w&&f.push({x:p,y:x,ctx:b,type:H.type,size:H.size,color:D,borderColor:D,borderThickness:H.borderThickness}));(m[u].indexLabel||k.indexLabel||m[u].indexLabelFormatter||k.indexLabelFormatter)&&this._indexLabels.push({chartType:"stepLine",dataPoint:m[u],dataSeries:k,point:{x:p,y:x},direction:0>m[u].y===a.axisY.reversed?
1:-1,color:s})}c.stroke();w&&b.stroke()}}W.drawMarkers(f);w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),b.beginPath());c.restore();c.beginPath();
return{source:d,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderSpline=function(a){function d(a){a=v(a,2);if(0<a.length){b.beginPath();w&&e.beginPath();b.moveTo(a[0].x,a[0].y);a[0].newStrokeStyle&&(b.strokeStyle=a[0].newStrokeStyle);a[0].newLineDashArray&&b.setLineDash(a[0].newLineDashArray);w&&e.moveTo(a[0].x,a[0].y);for(var c=0;c<a.length-3;c+=3)if(b.bezierCurveTo(a[c+1].x,a[c+1].y,a[c+2].x,a[c+2].y,a[c+3].x,a[c+3].y),
w&&e.bezierCurveTo(a[c+1].x,a[c+1].y,a[c+2].x,a[c+2].y,a[c+3].x,a[c+3].y),0<c&&0===c%3E3||a[c+3].newStrokeStyle||a[c+3].newLineDashArray)b.stroke(),b.beginPath(),b.moveTo(a[c+3].x,a[c+3].y),a[c+3].newStrokeStyle&&(b.strokeStyle=a[c+3].newStrokeStyle),a[c+3].newLineDashArray&&b.setLineDash(a[c+3].newLineDashArray),w&&(e.stroke(),e.beginPath(),e.moveTo(a[c+3].x,a[c+3].y));b.stroke();w&&e.stroke()}}var c=a.targetCanvasCtx||this.plotArea.ctx,b=w?this._preRenderCtx:c;if(!(0>=a.dataSeriesIndexes.length)){var e=
this._eventManager.ghostCtx;b.save();var f=this.plotArea;b.beginPath();b.rect(f.x1,f.y1,f.width,f.height);b.clip();for(var l=[],t=0;t<a.dataSeriesIndexes.length;t++){var C=a.dataSeriesIndexes[t],k=this.data[C];b.lineWidth=k.lineThickness;var m=k.dataPoints,n="solid";if(b.setLineDash){var q=J(k.nullDataLineDashType,k.lineThickness),n=k.lineDashType,g=J(n,k.lineThickness);b.setLineDash(g)}var s=k.id;this._eventManager.objectMap[s]={objectType:"dataSeries",dataSeriesIndex:C};s=X(s);e.strokeStyle=s;e.lineWidth=
0<k.lineThickness?Math.max(k.lineThickness,4):0;var s=k._colorSet,h=s=k.lineColor=k.options.lineColor?k.options.lineColor:s[0];b.strokeStyle=s;var r=0,u,p,x=[];b.beginPath();if(0<m.length)for(p=!1,r=0;r<m.length;r++)if(u=m[r].getTime?m[r].x.getTime():m[r].x,!(u<a.axisX.dataInfo.viewPortMin||u>a.axisX.dataInfo.viewPortMax&&(!k.connectNullData||!p)))if("number"!==typeof m[r].y)0<r&&!p&&(k.connectNullData?b.setLineDash&&(0<x.length&&(k.options.nullDataLineDashType||!m[r-1].lineDashType))&&(x[x.length-
1].newLineDashArray=q,n=k.nullDataLineDashType):(d(x),x=[])),p=!0;else{u=a.axisX.convertValueToPixel(u);p=a.axisY.convertValueToPixel(m[r].y);var z=k.dataPointIds[r];this._eventManager.objectMap[z]={id:z,objectType:"dataPoint",dataSeriesIndex:C,dataPointIndex:r,x1:u,y1:p};x[x.length]={x:u,y:p};r<m.length-1&&(h!==(m[r].lineColor||s)||n!==(m[r].lineDashType||k.lineDashType))&&(h=m[r].lineColor||s,x[x.length-1].newStrokeStyle=h,b.setLineDash&&(m[r].lineDashType?(n=m[r].lineDashType,x[x.length-1].newLineDashArray=
J(n,k.lineThickness)):(n=k.lineDashType,x[x.length-1].newLineDashArray=g)));if(0!==m[r].markerSize&&(0<m[r].markerSize||0<k.markerSize)){var H=k.getMarkerProperties(r,u,p,b);l.push(H);z=X(z);w&&l.push({x:u,y:p,ctx:e,type:H.type,size:H.size,color:z,borderColor:z,borderThickness:H.borderThickness})}(m[r].indexLabel||k.indexLabel||m[r].indexLabelFormatter||k.indexLabelFormatter)&&this._indexLabels.push({chartType:"spline",dataPoint:m[r],dataSeries:k,point:{x:u,y:p},direction:0>m[r].y===a.axisY.reversed?
1:-1,color:s});p=!1}d(x)}W.drawMarkers(l);w&&(c.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&b.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&b.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.clearRect(f.x1,f.y1,f.width,f.height),e.beginPath());b.restore();b.beginPath();return{source:c,
dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderColumn=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=0,l,t,C,k=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),f=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,m=this.options.dataPointMaxWidth?
this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:Math.min(0.15*this.width,0.9*(this.plotArea.width/a.plotType.totalDataSeries))<<0,n=a.axisX.dataInfo.minDiff;isFinite(n)||(n=0.3*Math.abs(a.axisX.range));n=this.dataPointWidth=this.options.dataPointWidth?this.dataPointWidth:0.9*(e.width*(a.axisX.logarithmic?Math.log(n)/Math.log(a.axisX.range):Math.abs(n)/Math.abs(a.axisX.range))/a.plotType.totalDataSeries)<<0;this.dataPointMaxWidth&&f>m&&(f=Math.min(this.options.dataPointWidth?
this.dataPointWidth:Infinity,m));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&m<f)&&(m=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,f));n<f&&(n=f);n>m&&(n=m);c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(m=0;m<a.dataSeriesIndexes.length;m++){var q=a.dataSeriesIndexes[m],
g=this.data[q],s=g.dataPoints;if(0<s.length)for(var h=5<n&&g.bevelEnabled?!0:!1,f=0;f<s.length;f++)if(s[f].getTime?C=s[f].x.getTime():C=s[f].x,!(C<a.axisX.dataInfo.viewPortMin||C>a.axisX.dataInfo.viewPortMax)&&"number"===typeof s[f].y){l=a.axisX.convertValueToPixel(C);t=a.axisY.convertValueToPixel(s[f].y);l=a.axisX.reversed?l+a.plotType.totalDataSeries*n/2-(a.previousDataSeriesCount+m)*n<<0:l-a.plotType.totalDataSeries*n/2+(a.previousDataSeriesCount+m)*n<<0;var r=a.axisX.reversed?l-n<<0:l+n<<0,u;
0<=s[f].y?u=k:(u=t,t=k);t>u&&(b=t,t=u,u=b);b=s[f].color?s[f].color:g._colorSet[f%g._colorSet.length];Y(c,a.axisX.reversed?r:l,t,a.axisX.reversed?l:r,u,b,0,null,h&&(a.axisY.reversed?0>s[f].y:0<=s[f].y),(a.axisY.reversed?0<=s[f].y:0>s[f].y)&&h,!1,!1,g.fillOpacity);b=g.dataPointIds[f];this._eventManager.objectMap[b]={id:b,objectType:"dataPoint",dataSeriesIndex:q,dataPointIndex:f,x1:l,y1:t,x2:r,y2:u};b=X(b);w&&Y(this._eventManager.ghostCtx,a.axisX.reversed?r:l,t,a.axisX.reversed?l:r,u,b,0,null,!1,!1,
!1,!1);(s[f].indexLabel||g.indexLabel||s[f].indexLabelFormatter||g.indexLabelFormatter)&&this._indexLabels.push({chartType:"column",dataPoint:s[f],dataSeries:g,point:{x:l+(r-l)/2,y:0>s[f].y===a.axisY.reversed?t:u},direction:0>s[f].y===a.axisY.reversed?1:-1,bounds:{x1:l,y1:Math.min(t,u),x2:r,y2:Math.max(t,u)},color:b})}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),
a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.yScaleAnimation,easingFunction:M.easing.easeOutQuart,animationBase:k<a.axisY.bounds.y1?a.axisY.bounds.y1:k>a.axisY.bounds.y2?a.axisY.bounds.y2:k}}};p.prototype.renderStackedColumn=
function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=[],l=[],t=[],C=[],k=0,m,n,q=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),k=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,g=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:0.15*this.width<<0,s=a.axisX.dataInfo.minDiff;
isFinite(s)||(s=0.3*Math.abs(a.axisX.range));s=this.options.dataPointWidth?this.dataPointWidth:0.9*(e.width*(a.axisX.logarithmic?Math.log(s)/Math.log(a.axisX.range):Math.abs(s)/Math.abs(a.axisX.range))/a.plotType.plotUnits.length)<<0;this.dataPointMaxWidth&&k>g&&(k=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,g));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&g<k)&&(g=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,k));s<k&&(s=k);s>g&&(s=g);c.save();w&&this._eventManager.ghostCtx.save();
c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(g=0;g<a.dataSeriesIndexes.length;g++){var h=a.dataSeriesIndexes[g],r=this.data[h],u=r.dataPoints;if(0<u.length){var p=5<s&&r.bevelEnabled?!0:!1;c.strokeStyle="#4572A7 ";for(k=0;k<u.length;k++)if(b=u[k].x.getTime?u[k].x.getTime():u[k].x,!(b<a.axisX.dataInfo.viewPortMin||b>a.axisX.dataInfo.viewPortMax)&&
"number"===typeof u[k].y){m=a.axisX.convertValueToPixel(b);m=m-a.plotType.plotUnits.length*s/2+a.index*s<<0;var x=m+s<<0,z;if(a.axisY.logarithmic||a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&0<u[k].y)t[b]=u[k].y+(t[b]?t[b]:0),0<t[b]&&(n=a.axisY.convertValueToPixel(t[b]),z="undefined"!==typeof f[b]?f[b]:q,f[b]=n);else if(a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&0>=u[k].y)C[b]=u[k].y+(C[b]?C[b]:0),z=a.axisY.convertValueToPixel(C[b]),n="undefined"!==typeof l[b]?
l[b]:q,l[b]=z;else if(n=a.axisY.convertValueToPixel(u[k].y),0<=u[k].y){var H="undefined"!==typeof f[b]?f[b]:0;n-=H;z=q-H;f[b]=H+(z-n)}else H=l[b]?l[b]:0,z=n+H,n=q+H,l[b]=H+(z-n);b=u[k].color?u[k].color:r._colorSet[k%r._colorSet.length];Y(c,m,a.axisY.reversed?z:n,x,a.axisY.reversed?n:z,b,0,null,p&&(a.axisY.reversed?0>u[k].y:0<=u[k].y),(a.axisY.reversed?0<=u[k].y:0>u[k].y)&&p,!1,!1,r.fillOpacity);b=r.dataPointIds[k];this._eventManager.objectMap[b]={id:b,objectType:"dataPoint",dataSeriesIndex:h,dataPointIndex:k,
x1:m,y1:n,x2:x,y2:z};b=X(b);w&&Y(this._eventManager.ghostCtx,m,n,x,z,b,0,null,!1,!1,!1,!1);(u[k].indexLabel||r.indexLabel||u[k].indexLabelFormatter||r.indexLabelFormatter)&&this._indexLabels.push({chartType:"stackedColumn",dataPoint:u[k],dataSeries:r,point:{x:m+(x-m)/2,y:0<=u[k].y?n:z},direction:0>u[k].y===a.axisY.reversed?1:-1,bounds:{x1:m,y1:Math.min(n,z),x2:x,y2:Math.max(n,z)},color:b})}}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",
a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.yScaleAnimation,easingFunction:M.easing.easeOutQuart,animationBase:q<a.axisY.bounds.y1?a.axisY.bounds.y1:
q>a.axisY.bounds.y2?a.axisY.bounds.y2:q}}};p.prototype.renderStackedColumn100=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=[],l=[],t=[],C=[],k=0,m,n,q=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),k=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,g=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?
this.dataPointWidth:0.15*this.width<<0,s=a.axisX.dataInfo.minDiff;isFinite(s)||(s=0.3*Math.abs(a.axisX.range));s=this.options.dataPointWidth?this.dataPointWidth:0.9*(e.width*(a.axisX.logarithmic?Math.log(s)/Math.log(a.axisX.range):Math.abs(s)/Math.abs(a.axisX.range))/a.plotType.plotUnits.length)<<0;this.dataPointMaxWidth&&k>g&&(k=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,g));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&g<k)&&(g=Math.max(this.options.dataPointWidth?this.dataPointWidth:
-Infinity,k));s<k&&(s=k);s>g&&(s=g);c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(g=0;g<a.dataSeriesIndexes.length;g++){var h=a.dataSeriesIndexes[g],r=this.data[h],u=r.dataPoints;if(0<u.length)for(var p=5<s&&r.bevelEnabled?!0:!1,k=0;k<u.length;k++)if(b=u[k].x.getTime?u[k].x.getTime():u[k].x,!(b<a.axisX.dataInfo.viewPortMin||
b>a.axisX.dataInfo.viewPortMax)&&"number"===typeof u[k].y){m=a.axisX.convertValueToPixel(b);n=0!==a.dataPointYSums[b]?100*(u[k].y/a.dataPointYSums[b]):0;m=m-a.plotType.plotUnits.length*s/2+a.index*s<<0;var x=m+s<<0,z;if(a.axisY.logarithmic||a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&0<u[k].y){t[b]=n+("undefined"!==typeof t[b]?t[b]:0);if(0>=t[b])continue;n=a.axisY.convertValueToPixel(t[b]);z=f[b]?f[b]:q;f[b]=n}else if(a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&
0>=u[k].y)C[b]=n+("undefined"!==typeof C[b]?C[b]:0),z=a.axisY.convertValueToPixel(C[b]),n=l[b]?l[b]:q,l[b]=z;else if(n=a.axisY.convertValueToPixel(n),0<=u[k].y){var H="undefined"!==typeof f[b]?f[b]:0;n-=H;z=q-H;a.dataSeriesIndexes.length-1===g&&1>=Math.abs(e.y1-n)&&(n=e.y1);f[b]=H+(z-n)}else H="undefined"!==typeof l[b]?l[b]:0,z=n+H,n=q+H,a.dataSeriesIndexes.length-1===g&&1>=Math.abs(e.y2-z)&&(z=e.y2),l[b]=H+(z-n);b=u[k].color?u[k].color:r._colorSet[k%r._colorSet.length];Y(c,m,a.axisY.reversed?z:n,
x,a.axisY.reversed?n:z,b,0,null,p&&(a.axisY.reversed?0>u[k].y:0<=u[k].y),(a.axisY.reversed?0<=u[k].y:0>u[k].y)&&p,!1,!1,r.fillOpacity);b=r.dataPointIds[k];this._eventManager.objectMap[b]={id:b,objectType:"dataPoint",dataSeriesIndex:h,dataPointIndex:k,x1:m,y1:n,x2:x,y2:z};b=X(b);w&&Y(this._eventManager.ghostCtx,m,n,x,z,b,0,null,!1,!1,!1,!1);(u[k].indexLabel||r.indexLabel||u[k].indexLabelFormatter||r.indexLabelFormatter)&&this._indexLabels.push({chartType:"stackedColumn100",dataPoint:u[k],dataSeries:r,
point:{x:m+(x-m)/2,y:0<=u[k].y?n:z},direction:0>u[k].y===a.axisY.reversed?1:-1,bounds:{x1:m,y1:Math.min(n,z),x2:x,y2:Math.max(n,z)},color:b})}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),
c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.yScaleAnimation,easingFunction:M.easing.easeOutQuart,animationBase:q<a.axisY.bounds.y1?a.axisY.bounds.y1:q>a.axisY.bounds.y2?a.axisY.bounds.y2:q}}};p.prototype.renderBar=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=0,l,t,C,k=a.axisY.convertValueToPixel(a.axisY.logarithmic?
a.axisY.viewportMinimum:0),f=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,m=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:Math.min(0.15*this.height,0.9*(this.plotArea.height/a.plotType.totalDataSeries))<<0,n=a.axisX.dataInfo.minDiff;isFinite(n)||(n=0.3*Math.abs(a.axisX.range));n=this.options.dataPointWidth?this.dataPointWidth:0.9*(e.height*(a.axisX.logarithmic?Math.log(n)/Math.log(a.axisX.range):
Math.abs(n)/Math.abs(a.axisX.range))/a.plotType.totalDataSeries)<<0;this.dataPointMaxWidth&&f>m&&(f=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,m));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&m<f)&&(m=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,f));n<f&&(n=f);n>m&&(n=m);c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,
e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(m=0;m<a.dataSeriesIndexes.length;m++){var q=a.dataSeriesIndexes[m],g=this.data[q],s=g.dataPoints;if(0<s.length){var h=5<n&&g.bevelEnabled?!0:!1;c.strokeStyle="#4572A7 ";for(f=0;f<s.length;f++)if(s[f].getTime?C=s[f].x.getTime():C=s[f].x,!(C<a.axisX.dataInfo.viewPortMin||C>a.axisX.dataInfo.viewPortMax)&&"number"===typeof s[f].y){t=a.axisX.convertValueToPixel(C);l=a.axisY.convertValueToPixel(s[f].y);t=a.axisX.reversed?t+a.plotType.totalDataSeries*
n/2-(a.previousDataSeriesCount+m)*n<<0:t-a.plotType.totalDataSeries*n/2+(a.previousDataSeriesCount+m)*n<<0;var r=a.axisX.reversed?t-n<<0:t+n<<0,u;0<=s[f].y?u=k:(u=l,l=k);b=s[f].color?s[f].color:g._colorSet[f%g._colorSet.length];Y(c,a.axisY.reversed?l:u,a.axisX.reversed?r:t,a.axisY.reversed?u:l,a.axisX.reversed?t:r,b,0,null,h,!1,!1,!1,g.fillOpacity);b=g.dataPointIds[f];this._eventManager.objectMap[b]={id:b,objectType:"dataPoint",dataSeriesIndex:q,dataPointIndex:f,x1:u,y1:t,x2:l,y2:r};b=X(b);w&&Y(this._eventManager.ghostCtx,
u,a.axisX.reversed?r:t,l,a.axisX.reversed?t:r,b,0,null,!1,!1,!1,!1);(s[f].indexLabel||g.indexLabel||s[f].indexLabelFormatter||g.indexLabelFormatter)&&this._indexLabels.push({chartType:"bar",dataPoint:s[f],dataSeries:g,point:{x:0<=s[f].y?l:u,y:t+(r-t)/2},direction:0>s[f].y===a.axisY.reversed?1:-1,bounds:{x1:Math.min(u,l),y1:t,x2:Math.max(u,l),y2:r},color:b})}}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,
0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.xScaleAnimation,easingFunction:M.easing.easeOutQuart,animationBase:k<a.axisY.bounds.x1?a.axisY.bounds.x1:k>a.axisY.bounds.x2?a.axisY.bounds.x2:
k}}};p.prototype.renderStackedBar=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=[],l=[],t=[],C=[],k=0,m,n,q=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),k=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,g=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:0.15*this.height<<
0,s=a.axisX.dataInfo.minDiff;isFinite(s)||(s=0.3*Math.abs(a.axisX.range));s=this.options.dataPointWidth?this.dataPointWidth:0.9*(e.height*(a.axisX.logarithmic?Math.log(s)/Math.log(a.axisX.range):Math.abs(s)/Math.abs(a.axisX.range))/a.plotType.plotUnits.length)<<0;this.dataPointMaxWidth&&k>g&&(k=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,g));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&g<k)&&(g=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,k));s<k&&
(s=k);s>g&&(s=g);c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(g=0;g<a.dataSeriesIndexes.length;g++){var h=a.dataSeriesIndexes[g],r=this.data[h],u=r.dataPoints;if(0<u.length){var p=5<s&&r.bevelEnabled?!0:!1;c.strokeStyle="#4572A7 ";for(k=0;k<u.length;k++)if(b=u[k].x.getTime?u[k].x.getTime():u[k].x,
!(b<a.axisX.dataInfo.viewPortMin||b>a.axisX.dataInfo.viewPortMax)&&"number"===typeof u[k].y){n=a.axisX.convertValueToPixel(b);n=n-a.plotType.plotUnits.length*s/2+a.index*s<<0;var x=n+s<<0,z;if(a.axisY.logarithmic||a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&0<u[k].y)t[b]=u[k].y+(t[b]?t[b]:0),0<t[b]&&(z=f[b]?f[b]:q,f[b]=m=a.axisY.convertValueToPixel(t[b]));else if(a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&0>=u[k].y)C[b]=u[k].y+(C[b]?C[b]:0),m=l[b]?l[b]:
q,l[b]=z=a.axisY.convertValueToPixel(C[b]);else if(m=a.axisY.convertValueToPixel(u[k].y),0<=u[k].y){var H=f[b]?f[b]:0;z=q+H;m+=H;f[b]=H+(m-z)}else H=l[b]?l[b]:0,z=m-H,m=q-H,l[b]=H+(m-z);b=u[k].color?u[k].color:r._colorSet[k%r._colorSet.length];Y(c,a.axisY.reversed?m:z,n,a.axisY.reversed?z:m,x,b,0,null,p,!1,!1,!1,r.fillOpacity);b=r.dataPointIds[k];this._eventManager.objectMap[b]={id:b,objectType:"dataPoint",dataSeriesIndex:h,dataPointIndex:k,x1:z,y1:n,x2:m,y2:x};b=X(b);w&&Y(this._eventManager.ghostCtx,
z,n,m,x,b,0,null,!1,!1,!1,!1);(u[k].indexLabel||r.indexLabel||u[k].indexLabelFormatter||r.indexLabelFormatter)&&this._indexLabels.push({chartType:"stackedBar",dataPoint:u[k],dataSeries:r,point:{x:0<=u[k].y?m:z,y:n+(x-n)/2},direction:0>u[k].y===a.axisY.reversed?1:-1,bounds:{x1:Math.min(z,m),y1:n,x2:Math.max(z,m),y2:x},color:b})}}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,
this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.xScaleAnimation,easingFunction:M.easing.easeOutQuart,animationBase:q<a.axisY.bounds.x1?a.axisY.bounds.x1:q>a.axisY.bounds.x2?a.axisY.bounds.x2:q}}};p.prototype.renderStackedBar100=
function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=[],l=[],t=[],C=[],k=0,m,n,q=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),k=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,g=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:0.15*this.height<<0,s=a.axisX.dataInfo.minDiff;
isFinite(s)||(s=0.3*Math.abs(a.axisX.range));s=this.options.dataPointWidth?this.dataPointWidth:0.9*(e.height*(a.axisX.logarithmic?Math.log(s)/Math.log(a.axisX.range):Math.abs(s)/Math.abs(a.axisX.range))/a.plotType.plotUnits.length)<<0;this.dataPointMaxWidth&&k>g&&(k=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,g));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&g<k)&&(g=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,k));s<k&&(s=k);s>g&&(s=g);c.save();w&&
this._eventManager.ghostCtx.save();c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(g=0;g<a.dataSeriesIndexes.length;g++){var h=a.dataSeriesIndexes[g],r=this.data[h],u=r.dataPoints;if(0<u.length){var p=5<s&&r.bevelEnabled?!0:!1;c.strokeStyle="#4572A7 ";for(k=0;k<u.length;k++)if(b=u[k].x.getTime?u[k].x.getTime():u[k].x,!(b<a.axisX.dataInfo.viewPortMin||
b>a.axisX.dataInfo.viewPortMax)&&"number"===typeof u[k].y){n=a.axisX.convertValueToPixel(b);var x;x=0!==a.dataPointYSums[b]?100*(u[k].y/a.dataPointYSums[b]):0;n=n-a.plotType.plotUnits.length*s/2+a.index*s<<0;var z=n+s<<0;if(a.axisY.logarithmic||a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&0<u[k].y){t[b]=x+(t[b]?t[b]:0);if(0>=t[b])continue;x=f[b]?f[b]:q;f[b]=m=a.axisY.convertValueToPixel(t[b])}else if(a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length&&0>=u[k].y)C[b]=
x+(C[b]?C[b]:0),m=l[b]?l[b]:q,l[b]=x=a.axisY.convertValueToPixel(C[b]);else if(m=a.axisY.convertValueToPixel(x),0<=u[k].y){var H=f[b]?f[b]:0;x=q+H;m+=H;a.dataSeriesIndexes.length-1===g&&1>=Math.abs(e.x2-m)&&(m=e.x2);f[b]=H+(m-x)}else H=l[b]?l[b]:0,x=m-H,m=q-H,a.dataSeriesIndexes.length-1===g&&1>=Math.abs(e.x1-x)&&(x=e.x1),l[b]=H+(m-x);b=u[k].color?u[k].color:r._colorSet[k%r._colorSet.length];Y(c,a.axisY.reversed?m:x,n,a.axisY.reversed?x:m,z,b,0,null,p,!1,!1,!1,r.fillOpacity);b=r.dataPointIds[k];this._eventManager.objectMap[b]=
{id:b,objectType:"dataPoint",dataSeriesIndex:h,dataPointIndex:k,x1:x,y1:n,x2:m,y2:z};b=X(b);w&&Y(this._eventManager.ghostCtx,x,n,m,z,b,0,null,!1,!1,!1,!1);(u[k].indexLabel||r.indexLabel||u[k].indexLabelFormatter||r.indexLabelFormatter)&&this._indexLabels.push({chartType:"stackedBar100",dataPoint:u[k],dataSeries:r,point:{x:0<=u[k].y?m:x,y:n+(z-n)/2},direction:0>u[k].y===a.axisY.reversed?1:-1,bounds:{x1:Math.min(x,m),y1:n,x2:Math.max(x,m),y2:z},color:b})}}}w&&(d.drawImage(this._preRenderCanvas,0,0,
this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.xScaleAnimation,easingFunction:M.easing.easeOutQuart,
animationBase:q<a.axisY.bounds.x1?a.axisY.bounds.x1:q>a.axisY.bounds.x2?a.axisY.bounds.x2:q}}};p.prototype.renderArea=function(a){var d,c;function b(){H&&(0<g.lineThickness&&f.stroke(),a.axisY.logarithmic||0>=a.axisY.viewportMinimum&&0<=a.axisY.viewportMaximum?z=x:0>a.axisY.viewportMaximum?z=t.y1:0<a.axisY.viewportMinimum&&(z=x),f.lineTo(r,z),f.lineTo(H.x,z),f.closePath(),f.globalAlpha=g.fillOpacity,f.fill(),f.globalAlpha=1,w&&(l.lineTo(r,z),l.lineTo(H.x,z),l.closePath(),l.fill()),f.beginPath(),f.moveTo(r,
u),l.beginPath(),l.moveTo(r,u),H={x:r,y:u})}var e=a.targetCanvasCtx||this.plotArea.ctx,f=w?this._preRenderCtx:e;if(!(0>=a.dataSeriesIndexes.length)){var l=this._eventManager.ghostCtx,t=a.axisY.lineCoordinates,C=[],k=this.plotArea,m;f.save();w&&l.save();f.beginPath();f.rect(k.x1,k.y1,k.width,k.height);f.clip();w&&(l.beginPath(),l.rect(k.x1,k.y1,k.width,k.height),l.clip());for(var n=0;n<a.dataSeriesIndexes.length;n++){var q=a.dataSeriesIndexes[n],g=this.data[q],s=g.dataPoints,C=g.id;this._eventManager.objectMap[C]=
{objectType:"dataSeries",dataSeriesIndex:q};C=X(C);l.fillStyle=C;C=[];d=!0;var h=0,r,u,p,x=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),z,H=null;if(0<s.length){var D=g._colorSet[h%g._colorSet.length],v=g.lineColor=g.options.lineColor||D,A=v;f.fillStyle=D;f.strokeStyle=v;f.lineWidth=g.lineThickness;c="solid";if(f.setLineDash){var L=J(g.nullDataLineDashType,g.lineThickness);c=g.lineDashType;var S=J(c,g.lineThickness);f.setLineDash(S)}for(var ea=!0;h<s.length;h++)if(p=s[h].x.getTime?
s[h].x.getTime():s[h].x,!(p<a.axisX.dataInfo.viewPortMin||p>a.axisX.dataInfo.viewPortMax&&(!g.connectNullData||!ea)))if("number"!==typeof s[h].y)g.connectNullData||(ea||d)||b(),ea=!0;else{r=a.axisX.convertValueToPixel(p);u=a.axisY.convertValueToPixel(s[h].y);d||ea?(!d&&g.connectNullData?(f.setLineDash&&(g.options.nullDataLineDashType||c===g.lineDashType&&g.lineDashType!==g.nullDataLineDashType)&&(d=r,c=u,r=m.x,u=m.y,b(),f.moveTo(m.x,m.y),r=d,u=c,H=m,c=g.nullDataLineDashType,f.setLineDash(L)),f.lineTo(r,
u),w&&l.lineTo(r,u)):(f.beginPath(),f.moveTo(r,u),w&&(l.beginPath(),l.moveTo(r,u)),H={x:r,y:u}),ea=d=!1):(f.lineTo(r,u),w&&l.lineTo(r,u),0==h%250&&b());m={x:r,y:u};h<s.length-1&&(A!==(s[h].lineColor||v)||c!==(s[h].lineDashType||g.lineDashType))&&(b(),A=s[h].lineColor||v,f.strokeStyle=A,f.setLineDash&&(s[h].lineDashType?(c=s[h].lineDashType,f.setLineDash(J(c,g.lineThickness))):(c=g.lineDashType,f.setLineDash(S))));var $=g.dataPointIds[h];this._eventManager.objectMap[$]={id:$,objectType:"dataPoint",
dataSeriesIndex:q,dataPointIndex:h,x1:r,y1:u};0!==s[h].markerSize&&(0<s[h].markerSize||0<g.markerSize)&&(p=g.getMarkerProperties(h,r,u,f),C.push(p),$=X($),w&&C.push({x:r,y:u,ctx:l,type:p.type,size:p.size,color:$,borderColor:$,borderThickness:p.borderThickness}));(s[h].indexLabel||g.indexLabel||s[h].indexLabelFormatter||g.indexLabelFormatter)&&this._indexLabels.push({chartType:"area",dataPoint:s[h],dataSeries:g,point:{x:r,y:u},direction:0>s[h].y===a.axisY.reversed?1:-1,color:D})}b();W.drawMarkers(C)}}w&&
(e.drawImage(this._preRenderCanvas,0,0,this.width,this.height),f.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&f.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&f.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),f.clearRect(k.x1,k.y1,k.width,k.height),this._eventManager.ghostCtx.restore());f.restore();return{source:e,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,
easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderSplineArea=function(a){function d(){var c=v(y,2);if(0<c.length){if(0<m.lineThickness){b.beginPath();b.moveTo(c[0].x,c[0].y);c[0].newStrokeStyle&&(b.strokeStyle=c[0].newStrokeStyle);c[0].newLineDashArray&&b.setLineDash(c[0].newLineDashArray);for(var d=0;d<c.length-3;d+=3)if(b.bezierCurveTo(c[d+1].x,c[d+1].y,c[d+2].x,c[d+2].y,c[d+3].x,c[d+3].y),w&&e.bezierCurveTo(c[d+1].x,c[d+1].y,c[d+2].x,c[d+2].y,c[d+3].x,c[d+3].y),c[d+3].newStrokeStyle||
c[d+3].newLineDashArray)b.stroke(),b.beginPath(),b.moveTo(c[d+3].x,c[d+3].y),c[d+3].newStrokeStyle&&(b.strokeStyle=c[d+3].newStrokeStyle),c[d+3].newLineDashArray&&b.setLineDash(c[d+3].newLineDashArray);b.stroke()}b.beginPath();b.moveTo(c[0].x,c[0].y);w&&(e.beginPath(),e.moveTo(c[0].x,c[0].y));for(d=0;d<c.length-3;d+=3)b.bezierCurveTo(c[d+1].x,c[d+1].y,c[d+2].x,c[d+2].y,c[d+3].x,c[d+3].y),w&&e.bezierCurveTo(c[d+1].x,c[d+1].y,c[d+2].x,c[d+2].y,c[d+3].x,c[d+3].y);a.axisY.logarithmic||0>=a.axisY.viewportMinimum&&
0<=a.axisY.viewportMaximum?p=r:0>a.axisY.viewportMaximum?p=f.y1:0<a.axisY.viewportMinimum&&(p=r);u={x:c[0].x,y:c[0].y};b.lineTo(c[c.length-1].x,p);b.lineTo(u.x,p);b.closePath();b.globalAlpha=m.fillOpacity;b.fill();b.globalAlpha=1;w&&(e.lineTo(c[c.length-1].x,p),e.lineTo(u.x,p),e.closePath(),e.fill())}}var c=a.targetCanvasCtx||this.plotArea.ctx,b=w?this._preRenderCtx:c;if(!(0>=a.dataSeriesIndexes.length)){var e=this._eventManager.ghostCtx,f=a.axisY.lineCoordinates,l=[],t=this.plotArea;b.save();w&&
e.save();b.beginPath();b.rect(t.x1,t.y1,t.width,t.height);b.clip();w&&(e.beginPath(),e.rect(t.x1,t.y1,t.width,t.height),e.clip());for(var h=0;h<a.dataSeriesIndexes.length;h++){var k=a.dataSeriesIndexes[h],m=this.data[k],n=m.dataPoints,l=m.id;this._eventManager.objectMap[l]={objectType:"dataSeries",dataSeriesIndex:k};l=X(l);e.fillStyle=l;var l=[],q=0,g,s,r=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),p,u=null,y=[];if(0<n.length){var x=m._colorSet[q%m._colorSet.length],
z=m.lineColor=m.options.lineColor||x,H=z;b.fillStyle=x;b.strokeStyle=z;b.lineWidth=m.lineThickness;var D="solid";if(b.setLineDash){var A=J(m.nullDataLineDashType,m.lineThickness),D=m.lineDashType,B=J(D,m.lineThickness);b.setLineDash(B)}for(s=!1;q<n.length;q++)if(g=n[q].x.getTime?n[q].x.getTime():n[q].x,!(g<a.axisX.dataInfo.viewPortMin||g>a.axisX.dataInfo.viewPortMax&&(!m.connectNullData||!s)))if("number"!==typeof n[q].y)0<q&&!s&&(m.connectNullData?b.setLineDash&&(0<y.length&&(m.options.nullDataLineDashType||
!n[q-1].lineDashType))&&(y[y.length-1].newLineDashArray=A,D=m.nullDataLineDashType):(d(),y=[])),s=!0;else{g=a.axisX.convertValueToPixel(g);s=a.axisY.convertValueToPixel(n[q].y);var L=m.dataPointIds[q];this._eventManager.objectMap[L]={id:L,objectType:"dataPoint",dataSeriesIndex:k,dataPointIndex:q,x1:g,y1:s};y[y.length]={x:g,y:s};q<n.length-1&&(H!==(n[q].lineColor||z)||D!==(n[q].lineDashType||m.lineDashType))&&(H=n[q].lineColor||z,y[y.length-1].newStrokeStyle=H,b.setLineDash&&(n[q].lineDashType?(D=
n[q].lineDashType,y[y.length-1].newLineDashArray=J(D,m.lineThickness)):(D=m.lineDashType,y[y.length-1].newLineDashArray=B)));if(0!==n[q].markerSize&&(0<n[q].markerSize||0<m.markerSize)){var S=m.getMarkerProperties(q,g,s,b);l.push(S);L=X(L);w&&l.push({x:g,y:s,ctx:e,type:S.type,size:S.size,color:L,borderColor:L,borderThickness:S.borderThickness})}(n[q].indexLabel||m.indexLabel||n[q].indexLabelFormatter||m.indexLabelFormatter)&&this._indexLabels.push({chartType:"splineArea",dataPoint:n[q],dataSeries:m,
point:{x:g,y:s},direction:0>n[q].y===a.axisY.reversed?1:-1,color:x});s=!1}d();W.drawMarkers(l)}}w&&(c.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&b.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&b.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.clearRect(t.x1,t.y1,t.width,t.height),
this._eventManager.ghostCtx.restore());b.restore();return{source:c,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderStepArea=function(a){var d,c;function b(){H&&(0<g.lineThickness&&f.stroke(),a.axisY.logarithmic||0>=a.axisY.viewportMinimum&&0<=a.axisY.viewportMaximum?z=x:0>a.axisY.viewportMaximum?z=t.y1:0<a.axisY.viewportMinimum&&(z=x),f.lineTo(p,z),f.lineTo(H.x,z),f.closePath(),f.globalAlpha=g.fillOpacity,f.fill(),f.globalAlpha=
1,w&&(l.lineTo(p,z),l.lineTo(H.x,z),l.closePath(),l.fill()),f.beginPath(),f.moveTo(p,u),l.beginPath(),l.moveTo(p,u),H={x:p,y:u})}var e=a.targetCanvasCtx||this.plotArea.ctx,f=w?this._preRenderCtx:e;if(!(0>=a.dataSeriesIndexes.length)){var l=this._eventManager.ghostCtx,t=a.axisY.lineCoordinates,h=[],k=this.plotArea,m;f.save();w&&l.save();f.beginPath();f.rect(k.x1,k.y1,k.width,k.height);f.clip();w&&(l.beginPath(),l.rect(k.x1,k.y1,k.width,k.height),l.clip());for(var n=0;n<a.dataSeriesIndexes.length;n++){var q=
a.dataSeriesIndexes[n],g=this.data[q],s=g.dataPoints,h=g.id;this._eventManager.objectMap[h]={objectType:"dataSeries",dataSeriesIndex:q};h=X(h);l.fillStyle=h;h=[];d=!0;var r=0,p,u,y,x=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),z,H=null;c=!1;if(0<s.length){var D=g._colorSet[r%g._colorSet.length],v=g.lineColor=g.options.lineColor||D,A=v;f.fillStyle=D;f.strokeStyle=v;f.lineWidth=g.lineThickness;var L="solid";if(f.setLineDash){var S=J(g.nullDataLineDashType,g.lineThickness),
L=g.lineDashType,B=J(L,g.lineThickness);f.setLineDash(B)}for(;r<s.length;r++)if(y=s[r].x.getTime?s[r].x.getTime():s[r].x,!(y<a.axisX.dataInfo.viewPortMin||y>a.axisX.dataInfo.viewPortMax&&(!g.connectNullData||!c))){var $=u;"number"!==typeof s[r].y?(g.connectNullData||(c||d)||b(),c=!0):(p=a.axisX.convertValueToPixel(y),u=a.axisY.convertValueToPixel(s[r].y),d||c?(!d&&g.connectNullData?(f.setLineDash&&(g.options.nullDataLineDashType||L===g.lineDashType&&g.lineDashType!==g.nullDataLineDashType)&&(d=p,
c=u,p=m.x,u=m.y,b(),f.moveTo(m.x,m.y),p=d,u=c,H=m,L=g.nullDataLineDashType,f.setLineDash(S)),f.lineTo(p,$),f.lineTo(p,u),w&&(l.lineTo(p,$),l.lineTo(p,u))):(f.beginPath(),f.moveTo(p,u),w&&(l.beginPath(),l.moveTo(p,u)),H={x:p,y:u}),c=d=!1):(f.lineTo(p,$),w&&l.lineTo(p,$),f.lineTo(p,u),w&&l.lineTo(p,u),0==r%250&&b()),m={x:p,y:u},r<s.length-1&&(A!==(s[r].lineColor||v)||L!==(s[r].lineDashType||g.lineDashType))&&(b(),A=s[r].lineColor||v,f.strokeStyle=A,f.setLineDash&&(s[r].lineDashType?(L=s[r].lineDashType,
f.setLineDash(J(L,g.lineThickness))):(L=g.lineDashType,f.setLineDash(B)))),y=g.dataPointIds[r],this._eventManager.objectMap[y]={id:y,objectType:"dataPoint",dataSeriesIndex:q,dataPointIndex:r,x1:p,y1:u},0!==s[r].markerSize&&(0<s[r].markerSize||0<g.markerSize)&&($=g.getMarkerProperties(r,p,u,f),h.push($),y=X(y),w&&h.push({x:p,y:u,ctx:l,type:$.type,size:$.size,color:y,borderColor:y,borderThickness:$.borderThickness})),(s[r].indexLabel||g.indexLabel||s[r].indexLabelFormatter||g.indexLabelFormatter)&&
this._indexLabels.push({chartType:"stepArea",dataPoint:s[r],dataSeries:g,point:{x:p,y:u},direction:0>s[r].y===a.axisY.reversed?1:-1,color:D}))}b();W.drawMarkers(h)}}w&&(e.drawImage(this._preRenderCanvas,0,0,this.width,this.height),f.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&f.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&f.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
0,0,this.width,this.height),f.clearRect(k.x1,k.y1,k.width,k.height),this._eventManager.ghostCtx.restore());f.restore();return{source:e,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderStackedArea=function(a){function d(){if(!(1>k.length)){for(0<D.lineThickness&&b.stroke();0<k.length;){var a=k.pop();b.lineTo(a.x,a.y);w&&p.lineTo(a.x,a.y)}b.closePath();b.globalAlpha=D.fillOpacity;b.fill();b.globalAlpha=1;b.beginPath();w&&(p.closePath(),
p.fill(),p.beginPath());k=[]}}var c=a.targetCanvasCtx||this.plotArea.ctx,b=w?this._preRenderCtx:c;if(!(0>=a.dataSeriesIndexes.length)){var e=null,f=null,l=[],t=this.plotArea,h=[],k=[],m=[],n=[],q=0,g,s,r=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),p=this._eventManager.ghostCtx,u,y,x;w&&p.beginPath();b.save();w&&p.save();b.beginPath();b.rect(t.x1,t.y1,t.width,t.height);b.clip();w&&(p.beginPath(),p.rect(t.x1,t.y1,t.width,t.height),p.clip());for(var e=[],z=0;z<a.dataSeriesIndexes.length;z++){var H=
a.dataSeriesIndexes[z],D=this.data[H],v=D.dataPoints;D.dataPointIndexes=[];for(q=0;q<v.length;q++)H=v[q].x.getTime?v[q].x.getTime():v[q].x,D.dataPointIndexes[H]=q,e[H]||(m.push(H),e[H]=!0);m.sort(Ra)}for(z=0;z<a.dataSeriesIndexes.length;z++){H=a.dataSeriesIndexes[z];D=this.data[H];v=D.dataPoints;y=!0;k=[];q=D.id;this._eventManager.objectMap[q]={objectType:"dataSeries",dataSeriesIndex:H};q=X(q);p.fillStyle=q;if(0<m.length){var e=D._colorSet[0],A=D.lineColor=D.options.lineColor||e,L=A;b.fillStyle=e;
b.strokeStyle=A;b.lineWidth=D.lineThickness;x="solid";if(b.setLineDash){var S=J(D.nullDataLineDashType,D.lineThickness);x=D.lineDashType;var B=J(x,D.lineThickness);b.setLineDash(B)}for(var $=!0,q=0;q<m.length;q++){var f=m[q],ga=null,ga=0<=D.dataPointIndexes[f]?v[D.dataPointIndexes[f]]:{x:f,y:null};if(!(f<a.axisX.dataInfo.viewPortMin||f>a.axisX.dataInfo.viewPortMax&&(!D.connectNullData||!$)))if("number"!==typeof ga.y)D.connectNullData||($||y)||d(),$=!0;else{g=a.axisX.convertValueToPixel(f);var na=
h[f]?h[f]:0;if(a.axisY.logarithmic||a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length){n[f]=ga.y+(n[f]?n[f]:0);if(0>=n[f]&&a.axisY.logarithmic)continue;s=a.axisY.convertValueToPixel(n[f])}else s=a.axisY.convertValueToPixel(ga.y),s-=na;k.push({x:g,y:r-na});h[f]=r-s;y||$?(!y&&D.connectNullData?(b.setLineDash&&(D.options.nullDataLineDashType||x===D.lineDashType&&D.lineDashType!==D.nullDataLineDashType)&&(y=k.pop(),x=k[k.length-1],d(),b.moveTo(u.x,u.y),k.push(x),k.push(y),x=D.nullDataLineDashType,
b.setLineDash(S)),b.lineTo(g,s),w&&p.lineTo(g,s)):(b.beginPath(),b.moveTo(g,s),w&&(p.beginPath(),p.moveTo(g,s))),$=y=!1):(b.lineTo(g,s),w&&p.lineTo(g,s),0==q%250&&(d(),b.moveTo(g,s),w&&p.moveTo(g,s),k.push({x:g,y:r-na})));u={x:g,y:s};q<v.length-1&&(L!==(v[q].lineColor||A)||x!==(v[q].lineDashType||D.lineDashType))&&(d(),b.beginPath(),b.moveTo(g,s),k.push({x:g,y:r-na}),L=v[q].lineColor||A,b.strokeStyle=L,b.setLineDash&&(v[q].lineDashType?(x=v[q].lineDashType,b.setLineDash(J(x,D.lineThickness))):(x=
D.lineDashType,b.setLineDash(B))));if(0<=D.dataPointIndexes[f]){var ka=D.dataPointIds[D.dataPointIndexes[f]];this._eventManager.objectMap[ka]={id:ka,objectType:"dataPoint",dataSeriesIndex:H,dataPointIndex:D.dataPointIndexes[f],x1:g,y1:s}}0<=D.dataPointIndexes[f]&&0!==ga.markerSize&&(0<ga.markerSize||0<D.markerSize)&&(na=D.getMarkerProperties(D.dataPointIndexes[f],g,s,b),l.push(na),f=X(ka),w&&l.push({x:g,y:s,ctx:p,type:na.type,size:na.size,color:f,borderColor:f,borderThickness:na.borderThickness}));
(ga.indexLabel||D.indexLabel||ga.indexLabelFormatter||D.indexLabelFormatter)&&this._indexLabels.push({chartType:"stackedArea",dataPoint:ga,dataSeries:D,point:{x:g,y:s},direction:0>v[q].y===a.axisY.reversed?1:-1,color:e})}}d();b.moveTo(g,s);w&&p.moveTo(g,s)}delete D.dataPointIndexes}W.drawMarkers(l);w&&(c.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&b.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&
b.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.clearRect(t.x1,t.y1,t.width,t.height),p.restore());b.restore();return{source:c,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderStackedArea100=function(a){function d(){for(0<D.lineThickness&&b.stroke();0<k.length;){var a=k.pop();b.lineTo(a.x,a.y);w&&x.lineTo(a.x,
a.y)}b.closePath();b.globalAlpha=D.fillOpacity;b.fill();b.globalAlpha=1;b.beginPath();w&&(x.closePath(),x.fill(),x.beginPath());k=[]}var c=a.targetCanvasCtx||this.plotArea.ctx,b=w?this._preRenderCtx:c;if(!(0>=a.dataSeriesIndexes.length)){var e=null,f=null,l=this.plotArea,t=[],h=[],k=[],m=[],n=[],q=0,g,s,r,p,u,y=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),x=this._eventManager.ghostCtx;b.save();w&&x.save();b.beginPath();b.rect(l.x1,l.y1,l.width,l.height);b.clip();w&&(x.beginPath(),
x.rect(l.x1,l.y1,l.width,l.height),x.clip());for(var e=[],z=0;z<a.dataSeriesIndexes.length;z++){var H=a.dataSeriesIndexes[z],D=this.data[H],v=D.dataPoints;D.dataPointIndexes=[];for(q=0;q<v.length;q++)H=v[q].x.getTime?v[q].x.getTime():v[q].x,D.dataPointIndexes[H]=q,e[H]||(m.push(H),e[H]=!0);m.sort(Ra)}for(z=0;z<a.dataSeriesIndexes.length;z++){H=a.dataSeriesIndexes[z];D=this.data[H];v=D.dataPoints;p=!0;e=D.id;this._eventManager.objectMap[e]={objectType:"dataSeries",dataSeriesIndex:H};e=X(e);x.fillStyle=
e;k=[];if(0<m.length){var e=D._colorSet[q%D._colorSet.length],A=D.lineColor=D.options.lineColor||e,L=A;b.fillStyle=e;b.strokeStyle=A;b.lineWidth=D.lineThickness;u="solid";if(b.setLineDash){var S=J(D.nullDataLineDashType,D.lineThickness);u=D.lineDashType;var B=J(u,D.lineThickness);b.setLineDash(B)}for(var $=!0,q=0;q<m.length;q++){var f=m[q],ga=null,ga=0<=D.dataPointIndexes[f]?v[D.dataPointIndexes[f]]:{x:f,y:null};if(!(f<a.axisX.dataInfo.viewPortMin||f>a.axisX.dataInfo.viewPortMax&&(!D.connectNullData||
!$)))if("number"!==typeof ga.y)D.connectNullData||($||p)||d(),$=!0;else{var na;na=0!==a.dataPointYSums[f]?100*(ga.y/a.dataPointYSums[f]):0;g=a.axisX.convertValueToPixel(f);var ka=h[f]?h[f]:0;if(a.axisY.logarithmic||a.axisY.scaleBreaks&&0<a.axisY.scaleBreaks._appliedBreaks.length){n[f]=na+(n[f]?n[f]:0);if(0>=n[f]&&a.axisY.logarithmic)continue;s=a.axisY.convertValueToPixel(n[f])}else s=a.axisY.convertValueToPixel(na),s-=ka;k.push({x:g,y:y-ka});h[f]=y-s;p||$?(!p&&D.connectNullData?(b.setLineDash&&(D.options.nullDataLineDashType||
u===D.lineDashType&&D.lineDashType!==D.nullDataLineDashType)&&(p=k.pop(),u=k[k.length-1],d(),b.moveTo(r.x,r.y),k.push(u),k.push(p),u=D.nullDataLineDashType,b.setLineDash(S)),b.lineTo(g,s),w&&x.lineTo(g,s)):(b.beginPath(),b.moveTo(g,s),w&&(x.beginPath(),x.moveTo(g,s))),$=p=!1):(b.lineTo(g,s),w&&x.lineTo(g,s),0==q%250&&(d(),b.moveTo(g,s),w&&x.moveTo(g,s),k.push({x:g,y:y-ka})));r={x:g,y:s};q<v.length-1&&(L!==(v[q].lineColor||A)||u!==(v[q].lineDashType||D.lineDashType))&&(d(),b.beginPath(),b.moveTo(g,
s),k.push({x:g,y:y-ka}),L=v[q].lineColor||A,b.strokeStyle=L,b.setLineDash&&(v[q].lineDashType?(u=v[q].lineDashType,b.setLineDash(J(u,D.lineThickness))):(u=D.lineDashType,b.setLineDash(B))));if(0<=D.dataPointIndexes[f]){var F=D.dataPointIds[D.dataPointIndexes[f]];this._eventManager.objectMap[F]={id:F,objectType:"dataPoint",dataSeriesIndex:H,dataPointIndex:D.dataPointIndexes[f],x1:g,y1:s}}0<=D.dataPointIndexes[f]&&0!==ga.markerSize&&(0<ga.markerSize||0<D.markerSize)&&(ka=D.getMarkerProperties(q,g,s,
b),t.push(ka),f=X(F),w&&t.push({x:g,y:s,ctx:x,type:ka.type,size:ka.size,color:f,borderColor:f,borderThickness:ka.borderThickness}));(ga.indexLabel||D.indexLabel||ga.indexLabelFormatter||D.indexLabelFormatter)&&this._indexLabels.push({chartType:"stackedArea100",dataPoint:ga,dataSeries:D,point:{x:g,y:s},direction:0>v[q].y===a.axisY.reversed?1:-1,color:e})}}d();b.moveTo(g,s);w&&x.moveTo(g,s)}delete D.dataPointIndexes}W.drawMarkers(t);w&&(c.drawImage(this._preRenderCanvas,0,0,this.width,this.height),
b.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&b.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&b.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.clearRect(l.x1,l.y1,l.width,l.height),x.restore());b.restore();return{source:c,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderBubble=
function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=this.plotArea,e=0,f,l;c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(b.x1,b.y1,b.width,b.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(b.x1,b.y1,b.width,b.height),this._eventManager.ghostCtx.clip());for(var t=-Infinity,h=Infinity,k=0;k<a.dataSeriesIndexes.length;k++)for(var m=a.dataSeriesIndexes[k],n=this.data[m],
q=n.dataPoints,g=0,e=0;e<q.length;e++)f=q[e].getTime?f=q[e].x.getTime():f=q[e].x,f<a.axisX.dataInfo.viewPortMin||f>a.axisX.dataInfo.viewPortMax||"undefined"===typeof q[e].z||(g=q[e].z,g>t&&(t=g),g<h&&(h=g));for(var s=25*Math.PI,r=Math.max(Math.pow(0.25*Math.min(b.height,b.width)/2,2)*Math.PI,s),k=0;k<a.dataSeriesIndexes.length;k++)if(m=a.dataSeriesIndexes[k],n=this.data[m],q=n.dataPoints,0<q.length)for(c.strokeStyle="#4572A7 ",e=0;e<q.length;e++)if(f=q[e].getTime?f=q[e].x.getTime():f=q[e].x,!(f<a.axisX.dataInfo.viewPortMin||
f>a.axisX.dataInfo.viewPortMax)&&"number"===typeof q[e].y){f=a.axisX.convertValueToPixel(f);l=a.axisY.convertValueToPixel(q[e].y);var g=q[e].z,p=2*Math.max(Math.sqrt((t===h?r/2:s+(r-s)/(t-h)*(g-h))/Math.PI)<<0,1),g=n.getMarkerProperties(e,c);g.size=p;c.globalAlpha=n.fillOpacity;W.drawMarker(f,l,c,g.type,g.size,g.color,g.borderColor,g.borderThickness);c.globalAlpha=1;var u=n.dataPointIds[e];this._eventManager.objectMap[u]={id:u,objectType:"dataPoint",dataSeriesIndex:m,dataPointIndex:e,x1:f,y1:l,size:p};
p=X(u);w&&W.drawMarker(f,l,this._eventManager.ghostCtx,g.type,g.size,p,p,g.borderThickness);(q[e].indexLabel||n.indexLabel||q[e].indexLabelFormatter||n.indexLabelFormatter)&&this._indexLabels.push({chartType:"bubble",dataPoint:q[e],dataSeries:n,point:{x:f,y:l},direction:1,bounds:{x1:f-g.size/2,y1:l-g.size/2,x2:f+g.size/2,y2:l+g.size/2},color:null})}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,
0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(b.x1,b.y1,b.width,b.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0}}};p.prototype.renderScatter=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,
c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=this.plotArea,e=0,f,l;c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(b.x1,b.y1,b.width,b.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(b.x1,b.y1,b.width,b.height),this._eventManager.ghostCtx.clip());for(var t=0;t<a.dataSeriesIndexes.length;t++){var h=a.dataSeriesIndexes[t],k=this.data[h],m=k.dataPoints;if(0<m.length){c.strokeStyle="#4572A7 ";Math.pow(0.3*Math.min(b.height,
b.width)/2,2);for(var n=0,q=0,e=0;e<m.length;e++)if(f=m[e].getTime?f=m[e].x.getTime():f=m[e].x,!(f<a.axisX.dataInfo.viewPortMin||f>a.axisX.dataInfo.viewPortMax)&&"number"===typeof m[e].y){f=a.axisX.convertValueToPixel(f);l=a.axisY.convertValueToPixel(m[e].y);var g=k.getMarkerProperties(e,f,l,c);c.globalAlpha=k.fillOpacity;W.drawMarker(g.x,g.y,g.ctx,g.type,g.size,g.color,g.borderColor,g.borderThickness);c.globalAlpha=1;Math.sqrt((n-f)*(n-f)+(q-l)*(q-l))<Math.min(g.size,5)&&m.length>Math.min(this.plotArea.width,
this.plotArea.height)||(n=k.dataPointIds[e],this._eventManager.objectMap[n]={id:n,objectType:"dataPoint",dataSeriesIndex:h,dataPointIndex:e,x1:f,y1:l},n=X(n),w&&W.drawMarker(g.x,g.y,this._eventManager.ghostCtx,g.type,g.size,n,n,g.borderThickness),(m[e].indexLabel||k.indexLabel||m[e].indexLabelFormatter||k.indexLabelFormatter)&&this._indexLabels.push({chartType:"scatter",dataPoint:m[e],dataSeries:k,point:{x:f,y:l},direction:1,bounds:{x1:f-g.size/2,y1:l-g.size/2,x2:f+g.size/2,y2:l+g.size/2},color:null}),
n=f,q=l)}}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(b.x1,b.y1,b.width,b.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,
animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0}}};p.prototype.renderCandlestick=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d,b=this._eventManager.ghostCtx;if(!(0>=a.dataSeriesIndexes.length)){var e=null,f=null,l=this.plotArea,t=0,h,k,m,n,q,g,e=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,f=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?
this.dataPointWidth:0.015*this.width,s=a.axisX.dataInfo.minDiff;isFinite(s)||(s=0.3*Math.abs(a.axisX.range));s=this.options.dataPointWidth?this.dataPointWidth:0.7*l.width*(a.axisX.logarithmic?Math.log(s)/Math.log(a.axisX.range):Math.abs(s)/Math.abs(a.axisX.range))<<0;this.dataPointMaxWidth&&e>f&&(e=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,f));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&f<e)&&(f=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,e));s<
e&&(s=e);s>f&&(s=f);c.save();w&&b.save();c.beginPath();c.rect(l.x1,l.y1,l.width,l.height);c.clip();w&&(b.beginPath(),b.rect(l.x1,l.y1,l.width,l.height),b.clip());for(var p=0;p<a.dataSeriesIndexes.length;p++){var ba=a.dataSeriesIndexes[p],u=this.data[ba],y=u.dataPoints;if(0<y.length)for(var x=5<s&&u.bevelEnabled?!0:!1,t=0;t<y.length;t++)if(y[t].getTime?g=y[t].x.getTime():g=y[t].x,!(g<a.axisX.dataInfo.viewPortMin||g>a.axisX.dataInfo.viewPortMax)&&!r(y[t].y)&&y[t].y.length&&"number"===typeof y[t].y[0]&&
"number"===typeof y[t].y[1]&&"number"===typeof y[t].y[2]&&"number"===typeof y[t].y[3]){h=a.axisX.convertValueToPixel(g);k=a.axisY.convertValueToPixel(y[t].y[0]);m=a.axisY.convertValueToPixel(y[t].y[1]);n=a.axisY.convertValueToPixel(y[t].y[2]);q=a.axisY.convertValueToPixel(y[t].y[3]);var z=h-s/2<<0,H=z+s<<0,f=u.options.fallingColor?u.fallingColor:u._colorSet[0],e=y[t].color?y[t].color:u._colorSet[0],D=Math.round(Math.max(1,0.15*s)),v=0===D%2?0:0.5,A=u.dataPointIds[t];this._eventManager.objectMap[A]=
{id:A,objectType:"dataPoint",dataSeriesIndex:ba,dataPointIndex:t,x1:z,y1:k,x2:H,y2:m,x3:h,y3:n,x4:h,y4:q,borderThickness:D,color:e};c.strokeStyle=e;c.beginPath();c.lineWidth=D;b.lineWidth=Math.max(D,4);"candlestick"===u.type?(c.moveTo(h-v,m),c.lineTo(h-v,Math.min(k,q)),c.stroke(),c.moveTo(h-v,Math.max(k,q)),c.lineTo(h-v,n),c.stroke(),Y(c,z,Math.min(k,q),H,Math.max(k,q),y[t].y[0]<=y[t].y[3]?u.risingColor:f,D,e,x,x,!1,!1,u.fillOpacity),w&&(e=X(A),b.strokeStyle=e,b.moveTo(h-v,m),b.lineTo(h-v,Math.min(k,
q)),b.stroke(),b.moveTo(h-v,Math.max(k,q)),b.lineTo(h-v,n),b.stroke(),Y(b,z,Math.min(k,q),H,Math.max(k,q),e,0,null,!1,!1,!1,!1))):"ohlc"===u.type&&(c.moveTo(h-v,m),c.lineTo(h-v,n),c.stroke(),c.beginPath(),c.moveTo(h,k),c.lineTo(z,k),c.stroke(),c.beginPath(),c.moveTo(h,q),c.lineTo(H,q),c.stroke(),w&&(e=X(A),b.strokeStyle=e,b.moveTo(h-v,m),b.lineTo(h-v,n),b.stroke(),b.beginPath(),b.moveTo(h,k),b.lineTo(z,k),b.stroke(),b.beginPath(),b.moveTo(h,q),b.lineTo(H,q),b.stroke()));(y[t].indexLabel||u.indexLabel||
y[t].indexLabelFormatter||u.indexLabelFormatter)&&this._indexLabels.push({chartType:u.type,dataPoint:y[t],dataSeries:u,point:{x:z+(H-z)/2,y:a.axisY.reversed?n:m},direction:1,bounds:{x1:z,y1:Math.min(m,n),x2:H,y2:Math.max(m,n)},color:e})}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),
this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(l.x1,l.y1,l.width,l.height),b.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0}}};p.prototype.renderBoxAndWhisker=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d,b=this._eventManager.ghostCtx;if(!(0>=a.dataSeriesIndexes.length)){var e=null,f=this.plotArea,
l=0,t,h,k,m,n,q,g,e=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1,l=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:0.015*this.width,s=a.axisX.dataInfo.minDiff;isFinite(s)||(s=0.3*Math.abs(a.axisX.range));s=this.options.dataPointWidth?this.dataPointWidth:0.7*f.width*(a.axisX.logarithmic?Math.log(s)/Math.log(a.axisX.range):Math.abs(s)/Math.abs(a.axisX.range))<<0;this.dataPointMaxWidth&&e>
l&&(e=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,l));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&l<e)&&(l=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,e));s<e&&(s=e);s>l&&(s=l);c.save();w&&b.save();c.beginPath();c.rect(f.x1,f.y1,f.width,f.height);c.clip();w&&(b.beginPath(),b.rect(f.x1,f.y1,f.width,f.height),b.clip());for(var p=!1,p=!!a.axisY.reversed,ba=0;ba<a.dataSeriesIndexes.length;ba++){var u=a.dataSeriesIndexes[ba],y=this.data[u],x=y.dataPoints;
if(0<x.length)for(var z=5<s&&y.bevelEnabled?!0:!1,l=0;l<x.length;l++)if(x[l].getTime?g=x[l].x.getTime():g=x[l].x,!(g<a.axisX.dataInfo.viewPortMin||g>a.axisX.dataInfo.viewPortMax)&&!r(x[l].y)&&x[l].y.length&&"number"===typeof x[l].y[0]&&"number"===typeof x[l].y[1]&&"number"===typeof x[l].y[2]&&"number"===typeof x[l].y[3]&&"number"===typeof x[l].y[4]&&5===x[l].y.length){t=a.axisX.convertValueToPixel(g);h=a.axisY.convertValueToPixel(x[l].y[0]);k=a.axisY.convertValueToPixel(x[l].y[1]);m=a.axisY.convertValueToPixel(x[l].y[2]);
n=a.axisY.convertValueToPixel(x[l].y[3]);q=a.axisY.convertValueToPixel(x[l].y[4]);var v=t-s/2<<0,D=t+s/2<<0,e=x[l].color?x[l].color:y._colorSet[0],A=Math.round(Math.max(1,0.15*s)),B=0===A%2?0:0.5,L=x[l].whiskerColor?x[l].whiskerColor:x[l].color?y.whiskerColor?y.whiskerColor:x[l].color:y.whiskerColor?y.whiskerColor:e,S="number"===typeof x[l].whiskerThickness?x[l].whiskerThickness:"number"===typeof y.options.whiskerThickness?y.whiskerThickness:A,ea=x[l].whiskerDashType?x[l].whiskerDashType:y.whiskerDashType,
$=r(x[l].whiskerLength)?r(y.options.whiskerLength)?s:y.whiskerLength:x[l].whiskerLength,$="number"===typeof $?0>=$?0:$>=s?s:$:"string"===typeof $?parseInt($)*s/100>s?s:parseInt($)*s/100:s,ga=1===Math.round(S)%2?0.5:0,na=x[l].stemColor?x[l].stemColor:x[l].color?y.stemColor?y.stemColor:x[l].color:y.stemColor?y.stemColor:e,ka="number"===typeof x[l].stemThickness?x[l].stemThickness:"number"===typeof y.options.stemThickness?y.stemThickness:A,F=1===Math.round(ka)%2?0.5:0,E=x[l].stemDashType?x[l].stemDashType:
y.stemDashType,K=x[l].lineColor?x[l].lineColor:x[l].color?y.lineColor?y.lineColor:x[l].color:y.lineColor?y.lineColor:e,G="number"===typeof x[l].lineThickness?x[l].lineThickness:"number"===typeof y.options.lineThickness?y.lineThickness:A,N=x[l].lineDashType?x[l].lineDashType:y.lineDashType,O=1===Math.round(G)%2?0.5:0,P=y.upperBoxColor,Q=y.lowerBoxColor,ta=r(y.options.fillOpacity)?1:y.fillOpacity,R=y.dataPointIds[l];this._eventManager.objectMap[R]={id:R,objectType:"dataPoint",dataSeriesIndex:u,dataPointIndex:l,
x1:v,y1:h,x2:D,y2:k,x3:t,y3:m,x4:t,y4:n,y5:q,borderThickness:A,color:e,stemThickness:ka,stemColor:na,whiskerThickness:S,whiskerLength:$,whiskerColor:L,lineThickness:G,lineColor:K};c.save();0<ka&&(c.beginPath(),c.strokeStyle=na,c.lineWidth=ka,c.setLineDash&&c.setLineDash(J(E,ka)),c.moveTo(t-F,k),c.lineTo(t-F,h),c.stroke(),c.moveTo(t-F,n),c.lineTo(t-F,m),c.stroke());c.restore();b.lineWidth=Math.max(A,4);c.beginPath();Y(c,v,Math.min(q,k),D,Math.max(k,q),Q,0,e,p?z:!1,p?!1:z,!1,!1,ta);c.beginPath();Y(c,
v,Math.min(m,q),D,Math.max(q,m),P,0,e,p?!1:z,p?z:!1,!1,!1,ta);c.beginPath();c.lineWidth=A;c.strokeStyle=e;c.rect(v-B,Math.min(k,m)-B,D-v+2*B,Math.max(k,m)-Math.min(k,m)+2*B);c.stroke();c.save();0<G&&(c.beginPath(),c.globalAlpha=1,c.setLineDash&&c.setLineDash(J(N,G)),c.strokeStyle=K,c.lineWidth=G,c.moveTo(v,q-O),c.lineTo(D,q-O),c.stroke());c.restore();c.save();0<S&&(c.beginPath(),c.setLineDash&&c.setLineDash(J(ea,S)),c.strokeStyle=L,c.lineWidth=S,c.moveTo(t-$/2<<0,n-ga),c.lineTo(t+$/2<<0,n-ga),c.stroke(),
c.moveTo(t-$/2<<0,h+ga),c.lineTo(t+$/2<<0,h+ga),c.stroke());c.restore();w&&(e=X(R),b.strokeStyle=e,b.lineWidth=ka,0<ka&&(b.moveTo(t-B-F,k),b.lineTo(t-B-F,Math.max(h,n)),b.stroke(),b.moveTo(t-B-F,Math.min(h,n)),b.lineTo(t-B-F,m),b.stroke()),Y(b,v,Math.max(k,m),D,Math.min(k,m),e,0,null,!1,!1,!1,!1),0<S&&(b.beginPath(),b.lineWidth=S,b.moveTo(t+$/2,n-ga),b.lineTo(t-$/2,n-ga),b.stroke(),b.moveTo(t+$/2,h+ga),b.lineTo(t-$/2,h+ga),b.stroke()));(x[l].indexLabel||y.indexLabel||x[l].indexLabelFormatter||y.indexLabelFormatter)&&
this._indexLabels.push({chartType:y.type,dataPoint:x[l],dataSeries:y,point:{x:v+(D-v)/2,y:a.axisY.reversed?h:n},direction:1,bounds:{x1:v,y1:Math.min(h,n),x2:D,y2:Math.max(h,n)},color:e})}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,
0,0,this.width,this.height),c.clearRect(f.x1,f.y1,f.width,f.height),b.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0}}};p.prototype.renderRangeColumn=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=0,l,t,h,f=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:
1;l=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:0.03*this.width;var k=a.axisX.dataInfo.minDiff;isFinite(k)||(k=0.3*Math.abs(a.axisX.range));k=this.options.dataPointWidth?this.dataPointWidth:0.9*(e.width*(a.axisX.logarithmic?Math.log(k)/Math.log(a.axisX.range):Math.abs(k)/Math.abs(a.axisX.range))/a.plotType.totalDataSeries)<<0;this.dataPointMaxWidth&&f>l&&(f=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,l));!this.dataPointMaxWidth&&
(this.dataPointMinWidth&&l<f)&&(l=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,f));k<f&&(k=f);k>l&&(k=l);c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(var m=0;m<a.dataSeriesIndexes.length;m++){var n=a.dataSeriesIndexes[m],q=this.data[n],g=q.dataPoints;if(0<g.length)for(var s=
5<k&&q.bevelEnabled?!0:!1,f=0;f<g.length;f++)if(g[f].getTime?h=g[f].x.getTime():h=g[f].x,!(h<a.axisX.dataInfo.viewPortMin||h>a.axisX.dataInfo.viewPortMax)&&!r(g[f].y)&&g[f].y.length&&"number"===typeof g[f].y[0]&&"number"===typeof g[f].y[1]){b=a.axisX.convertValueToPixel(h);l=a.axisY.convertValueToPixel(g[f].y[0]);t=a.axisY.convertValueToPixel(g[f].y[1]);var p=a.axisX.reversed?b+a.plotType.totalDataSeries*k/2-(a.previousDataSeriesCount+m)*k<<0:b-a.plotType.totalDataSeries*k/2+(a.previousDataSeriesCount+
m)*k<<0,ba=a.axisX.reversed?p-k<<0:p+k<<0,b=g[f].color?g[f].color:q._colorSet[f%q._colorSet.length];if(l>t){var u=l;l=t;t=u}u=q.dataPointIds[f];this._eventManager.objectMap[u]={id:u,objectType:"dataPoint",dataSeriesIndex:n,dataPointIndex:f,x1:p,y1:l,x2:ba,y2:t};Y(c,a.axisX.reversed?ba:p,l,a.axisX.reversed?p:ba,t,b,0,b,s,s,!1,!1,q.fillOpacity);b=X(u);w&&Y(this._eventManager.ghostCtx,a.axisX.reversed?ba:p,l,a.axisX.reversed?p:ba,t,b,0,null,!1,!1,!1,!1);if(g[f].indexLabel||q.indexLabel||g[f].indexLabelFormatter||
q.indexLabelFormatter)this._indexLabels.push({chartType:"rangeColumn",dataPoint:g[f],dataSeries:q,indexKeyword:0,point:{x:p+(ba-p)/2,y:g[f].y[1]>=g[f].y[0]?t:l},direction:g[f].y[1]>=g[f].y[0]?-1:1,bounds:{x1:p,y1:Math.min(l,t),x2:ba,y2:Math.max(l,t)},color:b}),this._indexLabels.push({chartType:"rangeColumn",dataPoint:g[f],dataSeries:q,indexKeyword:1,point:{x:p+(ba-p)/2,y:g[f].y[1]>=g[f].y[0]?l:t},direction:g[f].y[1]>=g[f].y[0]?1:-1,bounds:{x1:p,y1:Math.min(l,t),x2:ba,y2:Math.max(l,t)},color:b})}}w&&
(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,
easingFunction:M.easing.easeInQuad,animationBase:0}}};p.prototype.renderError=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,c=w?this._preRenderCtx:d,b=a.axisY._position?"left"===a.axisY._position||"right"===a.axisY._position?!1:!0:!1;if(!(0>=a.dataSeriesIndexes.length)){var e=null,f=!1,l=this.plotArea,t=0,h,k,m,n,q,g,s,p=a.axisX.dataInfo.minDiff;isFinite(p)||(p=0.3*Math.abs(a.axisX.range));c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(l.x1,l.y1,l.width,l.height);c.clip();
w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(l.x1,l.y1,l.width,l.height),this._eventManager.ghostCtx.clip());for(var ba=0,u=0;u<this.data.length;u++)!this.data[u].type.match(/(bar|column)/ig)||!this.data[u].visible||this.data[u].type.match(/(stacked)/ig)&&ba||ba++;for(var y=0;y<a.dataSeriesIndexes.length;y++){var x=a.dataSeriesIndexes[y],z=this.data[x],v=z.dataPoints,D=r(z._linkedSeries)?!1:z._linkedSeries.type.match(/(bar|column)/ig)&&z._linkedSeries.visible?!0:!1,
A=0;if(D)for(e=z._linkedSeries.id,u=0;u<e;u++)!this.data[u].type.match(/(bar|column)/ig)||!this.data[u].visible||this.data[u].type.match(/(stacked)/ig)&&A||(this.data[u].type.match(/(range)/ig)&&(f=!0),A++);e=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1;t=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:b?Math.min(0.15*this.height,0.9*(this.plotArea.height/(D?ba:1)))<<0:0.3*this.width;f&&
(t=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:b?Math.min(0.15*this.height,0.9*(this.plotArea.height/(D?ba:1)))<<0:0.03*this.width);u=this.options.dataPointWidth?this.dataPointWidth:0.9*((b?l.height:l.width)*(a.axisX.logarithmic?Math.log(p)/Math.log(a.axisX.range):Math.abs(p)/Math.abs(a.axisX.range))/(D?ba:1))<<0;this.dataPointMaxWidth&&e>t&&(e=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,t));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&
t<e)&&(t=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,e));u<e&&(u=e);u>t&&(u=t);if(0<v.length)for(var E=z._colorSet,t=0;t<v.length;t++){var e=z.lineColor=z.options.color?z.options.color:E[0],L={color:v[t].whiskerColor?v[t].whiskerColor:v[t].color?z.whiskerColor?z.whiskerColor:v[t].color:z.whiskerColor?z.whiskerColor:e,thickness:r(v[t].whiskerThickness)?z.whiskerThickness:v[t].whiskerThickness,dashType:v[t].whiskerDashType?v[t].whiskerDashType:z.whiskerDashType,length:r(v[t].whiskerLength)?
r(z.options.whiskerLength)?u:z.options.whiskerLength:v[t].whiskerLength,trimLength:r(v[t].whiskerLength)?r(z.options.whiskerLength)?50:0:0};L.length="number"===typeof L.length?0>=L.length?0:L.length>=u?u:L.length:"string"===typeof L.length?parseInt(L.length)*u/100>u?u:parseInt(L.length)*u/100>u:u;L.thickness="number"===typeof L.thickness?0>L.thickness?0:Math.round(L.thickness):2;var S={color:v[t].stemColor?v[t].stemColor:v[t].color?z.stemColor?z.stemColor:v[t].color:z.stemColor?z.stemColor:e,thickness:v[t].stemThickness?
v[t].stemThickness:z.stemThickness,dashType:v[t].stemDashType?v[t].stemDashType:z.stemDashType};S.thickness="number"===typeof S.thickness?0>S.thickness?0:Math.round(S.thickness):2;v[t].getTime?s=v[t].x.getTime():s=v[t].x;if(!(s<a.axisX.dataInfo.viewPortMin||s>a.axisX.dataInfo.viewPortMax)&&!r(v[t].y)&&v[t].y.length&&"number"===typeof v[t].y[0]&&"number"===typeof v[t].y[1]){var ea=a.axisX.convertValueToPixel(s);b?k=ea:h=ea;ea=a.axisY.convertValueToPixel(v[t].y[0]);b?m=ea:q=ea;ea=a.axisY.convertValueToPixel(v[t].y[1]);
b?n=ea:g=ea;b?(q=a.axisX.reversed?k+(D?ba:1)*u/2-(D?A-1:0)*u<<0:k-(D?ba:1)*u/2+(D?A-1:0)*u<<0,g=a.axisX.reversed?q-u<<0:q+u<<0):(m=a.axisX.reversed?h+(D?ba:1)*u/2-(D?A-1:0)*u<<0:h-(D?ba:1)*u/2+(D?A-1:0)*u<<0,n=a.axisX.reversed?m-u<<0:m+u<<0);!b&&q>g&&(ea=q,q=g,g=ea);b&&m>n&&(ea=m,m=n,n=ea);ea=z.dataPointIds[t];this._eventManager.objectMap[ea]={id:ea,objectType:"dataPoint",dataSeriesIndex:x,dataPointIndex:t,x1:Math.min(m,n),y1:Math.min(q,g),x2:Math.max(n,m),y2:Math.max(g,q),isXYSwapped:b,stemProperties:S,
whiskerProperties:L};B(c,Math.min(m,n),Math.min(q,g),Math.max(n,m),Math.max(g,q),e,L,S,b);w&&B(this._eventManager.ghostCtx,m,q,n,g,e,L,S,b);if(v[t].indexLabel||z.indexLabel||v[t].indexLabelFormatter||z.indexLabelFormatter)this._indexLabels.push({chartType:"error",dataPoint:v[t],dataSeries:z,indexKeyword:0,point:{x:b?v[t].y[1]>=v[t].y[0]?m:n:m+(n-m)/2,y:b?q+(g-q)/2:v[t].y[1]>=v[t].y[0]?g:q},direction:v[t].y[1]>=v[t].y[0]?-1:1,bounds:{x1:b?Math.min(m,n):m,y1:b?q:Math.min(q,g),x2:b?Math.max(m,n):n,y2:b?
g:Math.max(q,g)},color:e,axisSwapped:b}),this._indexLabels.push({chartType:"error",dataPoint:v[t],dataSeries:z,indexKeyword:1,point:{x:b?v[t].y[1]>=v[t].y[0]?n:m:m+(n-m)/2,y:b?q+(g-q)/2:v[t].y[1]>=v[t].y[0]?q:g},direction:v[t].y[1]>=v[t].y[0]?1:-1,bounds:{x1:b?Math.min(m,n):m,y1:b?q:Math.min(q,g),x2:b?Math.max(m,n):n,y2:b?g:Math.max(q,g)},color:e,axisSwapped:b})}}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,
0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(l.x1,l.y1,l.width,l.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0}}};p.prototype.renderRangeBar=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,
c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=null,e=this.plotArea,f=0,l,t,h,k,f=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1;l=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:Math.min(0.15*this.height,0.9*(this.plotArea.height/a.plotType.totalDataSeries))<<0;var m=a.axisX.dataInfo.minDiff;isFinite(m)||(m=0.3*Math.abs(a.axisX.range));m=this.options.dataPointWidth?
this.dataPointWidth:0.9*(e.height*(a.axisX.logarithmic?Math.log(m)/Math.log(a.axisX.range):Math.abs(m)/Math.abs(a.axisX.range))/a.plotType.totalDataSeries)<<0;this.dataPointMaxWidth&&f>l&&(f=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,l));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&l<f)&&(l=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,f));m<f&&(m=f);m>l&&(m=l);c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(e.x1,e.y1,e.width,e.height);
c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.clip());for(var n=0;n<a.dataSeriesIndexes.length;n++){var q=a.dataSeriesIndexes[n],g=this.data[q],s=g.dataPoints;if(0<s.length){var p=5<m&&g.bevelEnabled?!0:!1;c.strokeStyle="#4572A7 ";for(f=0;f<s.length;f++)if(s[f].getTime?k=s[f].x.getTime():k=s[f].x,!(k<a.axisX.dataInfo.viewPortMin||k>a.axisX.dataInfo.viewPortMax)&&!r(s[f].y)&&s[f].y.length&&"number"===typeof s[f].y[0]&&
"number"===typeof s[f].y[1]){l=a.axisY.convertValueToPixel(s[f].y[0]);t=a.axisY.convertValueToPixel(s[f].y[1]);h=a.axisX.convertValueToPixel(k);h=a.axisX.reversed?h+a.plotType.totalDataSeries*m/2-(a.previousDataSeriesCount+n)*m<<0:h-a.plotType.totalDataSeries*m/2+(a.previousDataSeriesCount+n)*m<<0;var v=a.axisX.reversed?h-m<<0:h+m<<0;l>t&&(b=l,l=t,t=b);b=s[f].color?s[f].color:g._colorSet[f%g._colorSet.length];Y(c,l,a.axisX.reversed?v:h,t,a.axisX.reversed?h:v,b,0,null,p,!1,!1,!1,g.fillOpacity);b=g.dataPointIds[f];
this._eventManager.objectMap[b]={id:b,objectType:"dataPoint",dataSeriesIndex:q,dataPointIndex:f,x1:l,y1:h,x2:t,y2:v};b=X(b);w&&Y(this._eventManager.ghostCtx,l,a.axisX.reversed?v:h,t,a.axisX.reversed?h:v,b,0,null,!1,!1,!1,!1);if(s[f].indexLabel||g.indexLabel||s[f].indexLabelFormatter||g.indexLabelFormatter)this._indexLabels.push({chartType:"rangeBar",dataPoint:s[f],dataSeries:g,indexKeyword:0,point:{x:s[f].y[1]>=s[f].y[0]?l:t,y:h+(v-h)/2},direction:s[f].y[1]>=s[f].y[0]?-1:1,bounds:{x1:Math.min(l,t),
y1:h,x2:Math.max(l,t),y2:v},color:b}),this._indexLabels.push({chartType:"rangeBar",dataPoint:s[f],dataSeries:g,indexKeyword:1,point:{x:s[f].y[1]>=s[f].y[0]?t:l,y:h+(v-h)/2},direction:s[f].y[1]>=s[f].y[0]?1:-1,bounds:{x1:Math.min(l,t),y1:h,x2:Math.max(l,t),y2:v},color:b})}}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,
0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(e.x1,e.y1,e.width,e.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0}}};p.prototype.renderRangeArea=function(a){function d(){if(y){for(var a=null,c=h.length-1;0<=c;c--)a=h[c],b.lineTo(a.x,a.y2),e.lineTo(a.x,a.y2);b.closePath();
b.globalAlpha=m.fillOpacity;b.fill();b.globalAlpha=1;e.fill();if(0<m.lineThickness){b.beginPath();b.moveTo(a.x,a.y2);for(c=0;c<h.length;c++)a=h[c],b.lineTo(a.x,a.y2);b.moveTo(h[0].x,h[0].y1);for(c=0;c<h.length;c++)a=h[c],b.lineTo(a.x,a.y1);b.stroke()}b.beginPath();b.moveTo(s,r);e.beginPath();e.moveTo(s,r);y={x:s,y:r};h=[];h.push({x:s,y1:r,y2:p})}}var c=a.targetCanvasCtx||this.plotArea.ctx,b=w?this._preRenderCtx:c;if(!(0>=a.dataSeriesIndexes.length)){var e=this._eventManager.ghostCtx,f=[],l=this.plotArea;
b.save();w&&e.save();b.beginPath();b.rect(l.x1,l.y1,l.width,l.height);b.clip();w&&(e.beginPath(),e.rect(l.x1,l.y1,l.width,l.height),e.clip());for(var t=0;t<a.dataSeriesIndexes.length;t++){var h=[],k=a.dataSeriesIndexes[t],m=this.data[k],n=m.dataPoints,f=m.id;this._eventManager.objectMap[f]={objectType:"dataSeries",dataSeriesIndex:k};f=X(f);e.fillStyle=f;var f=[],q=!0,g=0,s,r,p,u,y=null;if(0<n.length){var x=m._colorSet[g%m._colorSet.length],v=m.lineColor=m.options.lineColor||x,A=v;b.fillStyle=x;b.strokeStyle=
v;b.lineWidth=m.lineThickness;var D="solid";if(b.setLineDash){var B=J(m.nullDataLineDashType,m.lineThickness),D=m.lineDashType,E=J(D,m.lineThickness);b.setLineDash(E)}for(var L=!0;g<n.length;g++)if(u=n[g].x.getTime?n[g].x.getTime():n[g].x,!(u<a.axisX.dataInfo.viewPortMin||u>a.axisX.dataInfo.viewPortMax&&(!m.connectNullData||!L)))if(null!==n[g].y&&n[g].y.length&&"number"===typeof n[g].y[0]&&"number"===typeof n[g].y[1]){s=a.axisX.convertValueToPixel(u);r=a.axisY.convertValueToPixel(n[g].y[0]);p=a.axisY.convertValueToPixel(n[g].y[1]);
q||L?(m.connectNullData&&!q?(b.setLineDash&&(m.options.nullDataLineDashType||D===m.lineDashType&&m.lineDashType!==m.nullDataLineDashType)&&(h[h.length-1].newLineDashArray=E,D=m.nullDataLineDashType,b.setLineDash(B)),b.lineTo(s,r),w&&e.lineTo(s,r),h.push({x:s,y1:r,y2:p})):(b.beginPath(),b.moveTo(s,r),y={x:s,y:r},h=[],h.push({x:s,y1:r,y2:p}),w&&(e.beginPath(),e.moveTo(s,r))),L=q=!1):(b.lineTo(s,r),h.push({x:s,y1:r,y2:p}),w&&e.lineTo(s,r),0==g%250&&d());u=m.dataPointIds[g];this._eventManager.objectMap[u]=
{id:u,objectType:"dataPoint",dataSeriesIndex:k,dataPointIndex:g,x1:s,y1:r,y2:p};g<n.length-1&&(A!==(n[g].lineColor||v)||D!==(n[g].lineDashType||m.lineDashType))&&(d(),A=n[g].lineColor||v,h[h.length-1].newStrokeStyle=A,b.strokeStyle=A,b.setLineDash&&(n[g].lineDashType?(D=n[g].lineDashType,h[h.length-1].newLineDashArray=J(D,m.lineThickness),b.setLineDash(h[h.length-1].newLineDashArray)):(D=m.lineDashType,h[h.length-1].newLineDashArray=E,b.setLineDash(E))));if(0!==n[g].markerSize&&(0<n[g].markerSize||
0<m.markerSize)){var S=m.getMarkerProperties(g,s,p,b);f.push(S);var ea=X(u);w&&f.push({x:s,y:p,ctx:e,type:S.type,size:S.size,color:ea,borderColor:ea,borderThickness:S.borderThickness});S=m.getMarkerProperties(g,s,r,b);f.push(S);ea=X(u);w&&f.push({x:s,y:r,ctx:e,type:S.type,size:S.size,color:ea,borderColor:ea,borderThickness:S.borderThickness})}if(n[g].indexLabel||m.indexLabel||n[g].indexLabelFormatter||m.indexLabelFormatter)this._indexLabels.push({chartType:"rangeArea",dataPoint:n[g],dataSeries:m,
indexKeyword:0,point:{x:s,y:r},direction:n[g].y[0]>n[g].y[1]===a.axisY.reversed?-1:1,color:x}),this._indexLabels.push({chartType:"rangeArea",dataPoint:n[g],dataSeries:m,indexKeyword:1,point:{x:s,y:p},direction:n[g].y[0]>n[g].y[1]===a.axisY.reversed?1:-1,color:x})}else L||q||d(),L=!0;d();W.drawMarkers(f)}}w&&(c.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&b.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&
b.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.clearRect(l.x1,l.y1,l.width,l.height),this._eventManager.ghostCtx.restore());b.restore();return{source:c,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderRangeSplineArea=function(a){function d(a,c){var d=v(p,2);if(0<d.length){if(0<k.lineThickness){b.strokeStyle=
c;b.setLineDash&&b.setLineDash(a);b.beginPath();b.moveTo(d[0].x,d[0].y);for(var f=0;f<d.length-3;f+=3){if(d[f].newStrokeStyle||d[f].newLineDashArray)b.stroke(),b.beginPath(),b.moveTo(d[f].x,d[f].y),d[f].newStrokeStyle&&(b.strokeStyle=d[f].newStrokeStyle),d[f].newLineDashArray&&b.setLineDash(d[f].newLineDashArray);b.bezierCurveTo(d[f+1].x,d[f+1].y,d[f+2].x,d[f+2].y,d[f+3].x,d[f+3].y)}}b.beginPath();b.moveTo(d[0].x,d[0].y);w&&(e.beginPath(),e.moveTo(d[0].x,d[0].y));for(f=0;f<d.length-3;f+=3)b.bezierCurveTo(d[f+
1].x,d[f+1].y,d[f+2].x,d[f+2].y,d[f+3].x,d[f+3].y),w&&e.bezierCurveTo(d[f+1].x,d[f+1].y,d[f+2].x,d[f+2].y,d[f+3].x,d[f+3].y);d=v(ba,2);b.lineTo(ba[ba.length-1].x,ba[ba.length-1].y);for(f=d.length-1;2<f;f-=3)b.bezierCurveTo(d[f-1].x,d[f-1].y,d[f-2].x,d[f-2].y,d[f-3].x,d[f-3].y),w&&e.bezierCurveTo(d[f-1].x,d[f-1].y,d[f-2].x,d[f-2].y,d[f-3].x,d[f-3].y);b.closePath();b.globalAlpha=k.fillOpacity;b.fill();w&&(e.closePath(),e.fill());b.globalAlpha=1;if(0<k.lineThickness){b.strokeStyle=c;b.setLineDash&&b.setLineDash(a);
b.beginPath();b.moveTo(d[0].x,d[0].y);for(var g=f=0;f<d.length-3;f+=3,g++){if(p[g].newStrokeStyle||p[g].newLineDashArray)b.stroke(),b.beginPath(),b.moveTo(d[f].x,d[f].y),p[g].newStrokeStyle&&(b.strokeStyle=p[g].newStrokeStyle),p[g].newLineDashArray&&b.setLineDash(p[g].newLineDashArray);b.bezierCurveTo(d[f+1].x,d[f+1].y,d[f+2].x,d[f+2].y,d[f+3].x,d[f+3].y)}d=v(p,2);b.moveTo(d[0].x,d[0].y);for(g=f=0;f<d.length-3;f+=3,g++){if(p[g].newStrokeStyle||p[g].newLineDashArray)b.stroke(),b.beginPath(),b.moveTo(d[f].x,
d[f].y),p[g].newStrokeStyle&&(b.strokeStyle=p[g].newStrokeStyle),p[g].newLineDashArray&&b.setLineDash(p[g].newLineDashArray);b.bezierCurveTo(d[f+1].x,d[f+1].y,d[f+2].x,d[f+2].y,d[f+3].x,d[f+3].y)}b.stroke()}b.beginPath()}}var c=a.targetCanvasCtx||this.plotArea.ctx,b=w?this._preRenderCtx:c;if(!(0>=a.dataSeriesIndexes.length)){var e=this._eventManager.ghostCtx,f=[],l=this.plotArea;b.save();w&&e.save();b.beginPath();b.rect(l.x1,l.y1,l.width,l.height);b.clip();w&&(e.beginPath(),e.rect(l.x1,l.y1,l.width,
l.height),e.clip());for(var h=0;h<a.dataSeriesIndexes.length;h++){var r=a.dataSeriesIndexes[h],k=this.data[r],m=k.dataPoints,f=k.id;this._eventManager.objectMap[f]={objectType:"dataSeries",dataSeriesIndex:r};f=X(f);e.fillStyle=f;var f=[],n=0,q,g,s,p=[],ba=[];if(0<m.length){var u=k._colorSet[n%k._colorSet.length],y=k.lineColor=k.options.lineColor||u,x=y;b.fillStyle=u;b.lineWidth=k.lineThickness;var z="solid",A;if(b.setLineDash){var D=J(k.nullDataLineDashType,k.lineThickness),z=k.lineDashType;A=J(z,
k.lineThickness)}for(g=!1;n<m.length;n++)if(q=m[n].x.getTime?m[n].x.getTime():m[n].x,!(q<a.axisX.dataInfo.viewPortMin||q>a.axisX.dataInfo.viewPortMax&&(!k.connectNullData||!g)))if(null!==m[n].y&&m[n].y.length&&"number"===typeof m[n].y[0]&&"number"===typeof m[n].y[1]){q=a.axisX.convertValueToPixel(q);g=a.axisY.convertValueToPixel(m[n].y[0]);s=a.axisY.convertValueToPixel(m[n].y[1]);var B=k.dataPointIds[n];this._eventManager.objectMap[B]={id:B,objectType:"dataPoint",dataSeriesIndex:r,dataPointIndex:n,
x1:q,y1:g,y2:s};p[p.length]={x:q,y:g};ba[ba.length]={x:q,y:s};n<m.length-1&&(x!==(m[n].lineColor||y)||z!==(m[n].lineDashType||k.lineDashType))&&(x=m[n].lineColor||y,p[p.length-1].newStrokeStyle=x,b.setLineDash&&(m[n].lineDashType?(z=m[n].lineDashType,p[p.length-1].newLineDashArray=J(z,k.lineThickness)):(z=k.lineDashType,p[p.length-1].newLineDashArray=A)));if(0!==m[n].markerSize&&(0<m[n].markerSize||0<k.markerSize)){var G=k.getMarkerProperties(n,q,g,b);f.push(G);var L=X(B);w&&f.push({x:q,y:g,ctx:e,
type:G.type,size:G.size,color:L,borderColor:L,borderThickness:G.borderThickness});G=k.getMarkerProperties(n,q,s,b);f.push(G);L=X(B);w&&f.push({x:q,y:s,ctx:e,type:G.type,size:G.size,color:L,borderColor:L,borderThickness:G.borderThickness})}if(m[n].indexLabel||k.indexLabel||m[n].indexLabelFormatter||k.indexLabelFormatter)this._indexLabels.push({chartType:"rangeSplineArea",dataPoint:m[n],dataSeries:k,indexKeyword:0,point:{x:q,y:g},direction:m[n].y[0]<=m[n].y[1]?-1:1,color:u}),this._indexLabels.push({chartType:"rangeSplineArea",
dataPoint:m[n],dataSeries:k,indexKeyword:1,point:{x:q,y:s},direction:m[n].y[0]<=m[n].y[1]?1:-1,color:u});g=!1}else 0<n&&!g&&(k.connectNullData?b.setLineDash&&(0<p.length&&(k.options.nullDataLineDashType||!m[n-1].lineDashType))&&(p[p.length-1].newLineDashArray=D,z=k.nullDataLineDashType):(d(A,y),p=[],ba=[])),g=!0;d(A,y);W.drawMarkers(f)}}w&&(c.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&b.drawImage(a.axisX.maskCanvas,0,0,
this.width,this.height),a.axisY.maskCanvas&&b.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),b.clearRect(l.x1,l.y1,l.width,l.height),this._eventManager.ghostCtx.restore());b.restore();return{source:c,dest:this.plotArea.ctx,animationCallback:M.xClipAnimation,easingFunction:M.easing.linear,animationBase:0}}};p.prototype.renderWaterfall=function(a){var d=a.targetCanvasCtx||this.plotArea.ctx,
c=w?this._preRenderCtx:d;if(!(0>=a.dataSeriesIndexes.length)){var b=this._eventManager.ghostCtx,e=null,f=this.plotArea,l=0,h,r,k,m,n=a.axisY.convertValueToPixel(a.axisY.logarithmic?a.axisY.viewportMinimum:0),l=this.options.dataPointMinWidth?this.dataPointMinWidth:this.options.dataPointWidth?this.dataPointWidth:1;r=this.options.dataPointMaxWidth?this.dataPointMaxWidth:this.options.dataPointWidth?this.dataPointWidth:Math.min(0.15*this.width,0.9*(this.plotArea.width/a.plotType.totalDataSeries))<<0;var q=
a.axisX.dataInfo.minDiff;isFinite(q)||(q=0.3*Math.abs(a.axisX.range));q=this.options.dataPointWidth?this.dataPointWidth:0.6*(f.width*(a.axisX.logarithmic?Math.log(q)/Math.log(a.axisX.range):Math.abs(q)/Math.abs(a.axisX.range))/a.plotType.totalDataSeries)<<0;this.dataPointMaxWidth&&l>r&&(l=Math.min(this.options.dataPointWidth?this.dataPointWidth:Infinity,r));!this.dataPointMaxWidth&&(this.dataPointMinWidth&&r<l)&&(r=Math.max(this.options.dataPointWidth?this.dataPointWidth:-Infinity,l));q<l&&(q=l);
q>r&&(q=r);c.save();w&&this._eventManager.ghostCtx.save();c.beginPath();c.rect(f.x1,f.y1,f.width,f.height);c.clip();w&&(this._eventManager.ghostCtx.beginPath(),this._eventManager.ghostCtx.rect(f.x1,f.y1,f.width,f.height),this._eventManager.ghostCtx.clip());for(var g=0;g<a.dataSeriesIndexes.length;g++){var s=a.dataSeriesIndexes[g],p=this.data[s],v=p.dataPoints,e=p._colorSet[0];p.risingColor=p.options.risingColor?p.options.risingColor:e;p.fallingColor=p.options.fallingColor?p.options.fallingColor:"#e40a0a";
var u="number"===typeof p.options.lineThickness?Math.round(p.lineThickness):1,y=1===Math.round(u)%2?-0.5:0;if(0<v.length)for(var x=5<q&&p.bevelEnabled?!0:!1,z=!1,A=null,D=null,l=0;l<v.length;l++)if(v[l].getTime?m=v[l].x.getTime():m=v[l].x,"number"!==typeof v[l].y){if(0<l&&!z&&p.connectNullData)var B=p.options.nullDataLineDashType||!v[l-1].lineDashType?p.nullDataLineDashType:v[l-1].lineDashType;z=!0}else{h=a.axisX.convertValueToPixel(m);r=0===p.dataPointEOs[l].cumulativeSum?n:a.axisY.convertValueToPixel(p.dataPointEOs[l].cumulativeSum);
k=0===p.dataPointEOs[l].cumulativeSumYStartValue?n:a.axisY.convertValueToPixel(p.dataPointEOs[l].cumulativeSumYStartValue);h=a.axisX.reversed?h+a.plotType.totalDataSeries*q/2-(a.previousDataSeriesCount+g)*q<<0:h-a.plotType.totalDataSeries*q/2+(a.previousDataSeriesCount+g)*q<<0;var E=a.axisX.reversed?h-q<<0:h+q<<0;r>k&&(e=r,r=k,k=e);a.axisY.reversed&&(e=r,r=k,k=e);e=p.dataPointIds[l];this._eventManager.objectMap[e]={id:e,objectType:"dataPoint",dataSeriesIndex:s,dataPointIndex:l,x1:h,y1:r,x2:E,y2:k};
var L=v[l].color?v[l].color:0<v[l].y?p.risingColor:p.fallingColor;Y(c,a.axisX.reversed?E:h,a.axisY.reversed?k:r,a.axisX.reversed?h:E,a.axisY.reversed?r:k,L,0,L,x,x,!1,!1,p.fillOpacity);e=X(e);w&&Y(this._eventManager.ghostCtx,a.axisX.reversed?E:h,r,a.axisX.reversed?h:E,k,e,0,null,!1,!1,!1,!1);var S,L=h;S="undefined"!==typeof v[l].isIntermediateSum&&!0===v[l].isIntermediateSum||"undefined"!==typeof v[l].isCumulativeSum&&!0===v[l].isCumulativeSum?0<v[l].y?r:k:0<v[l].y?k:r;0<l&&A&&(!z||p.connectNullData)&&
(z&&c.setLineDash&&c.setLineDash(J(B,u)),c.beginPath(),c.moveTo(A,D-y),c.lineTo(L,S-y),0<u&&c.stroke(),w&&(b.beginPath(),b.moveTo(A,D-y),b.lineTo(L,S-y),0<u&&b.stroke()));z=!1;A=E;D=0<v[l].y?r:k;L=v[l].lineDashType?v[l].lineDashType:p.options.lineDashType?p.options.lineDashType:"shortDash";c.strokeStyle=v[l].lineColor?v[l].lineColor:p.options.lineColor?p.options.lineColor:"#9e9e9e";c.lineWidth=u;c.setLineDash&&(L=J(L,u),c.setLineDash(L));(v[l].indexLabel||p.indexLabel||v[l].indexLabelFormatter||p.indexLabelFormatter)&&
this._indexLabels.push({chartType:"waterfall",dataPoint:v[l],dataSeries:p,point:{x:h+(E-h)/2,y:0<=v[l].y?r:k},direction:0>v[l].y===a.axisY.reversed?1:-1,bounds:{x1:h,y1:Math.min(r,k),x2:E,y2:Math.max(r,k)},color:e})}}w&&(d.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.globalCompositeOperation="source-atop",a.axisX.maskCanvas&&c.drawImage(a.axisX.maskCanvas,0,0,this.width,this.height),a.axisY.maskCanvas&&c.drawImage(a.axisY.maskCanvas,0,0,this.width,this.height),this._breaksCanvasCtx&&
this._breaksCanvasCtx.drawImage(this._preRenderCanvas,0,0,this.width,this.height),c.clearRect(f.x1,f.y1,f.width,f.height),this._eventManager.ghostCtx.restore());c.restore();return{source:d,dest:this.plotArea.ctx,animationCallback:M.fadeInAnimation,easingFunction:M.easing.easeInQuad,animationBase:0}}};var pa=function(a,d,c,b,e,f,l,h,r){if(!(0>c)){"undefined"===typeof h&&(h=1);if(!w){var k=Number((l%(2*Math.PI)).toFixed(8));Number((f%(2*Math.PI)).toFixed(8))===k&&(l-=1E-4)}a.save();a.globalAlpha=h;
"pie"===e?(a.beginPath(),a.moveTo(d.x,d.y),a.arc(d.x,d.y,c,f,l,!1),a.fillStyle=b,a.strokeStyle="white",a.lineWidth=2,a.closePath(),a.fill()):"doughnut"===e&&(a.beginPath(),a.arc(d.x,d.y,c,f,l,!1),0<=r&&a.arc(d.x,d.y,r*c,l,f,!0),a.closePath(),a.fillStyle=b,a.strokeStyle="white",a.lineWidth=2,a.fill());a.globalAlpha=1;a.restore()}};p.prototype.renderPie=function(a){function d(){if(k&&m){for(var a=0,b=0,c=0,d=0,e=0;e<m.length;e++){var f=m[e],l=k.dataPointIds[e];g[e].id=l;g[e].objectType="dataPoint";
g[e].dataPointIndex=e;g[e].dataSeriesIndex=0;var n=g[e],h={percent:null,total:null},t=null,h=p.getPercentAndTotal(k,f);if(k.indexLabelFormatter||f.indexLabelFormatter)t={chart:p.options,dataSeries:k,dataPoint:f,total:h.total,percent:h.percent};h=f.indexLabelFormatter?f.indexLabelFormatter(t):f.indexLabel?p.replaceKeywordsWithValue(f.indexLabel,f,k,e):k.indexLabelFormatter?k.indexLabelFormatter(t):k.indexLabel?p.replaceKeywordsWithValue(k.indexLabel,f,k,e):f.label?f.label:"";p._eventManager.objectMap[l]=
n;n.center={x:x.x,y:x.y};n.y=f.y;n.radius=D;n.percentInnerRadius=E;n.indexLabelText=h;n.indexLabelPlacement=k.indexLabelPlacement;n.indexLabelLineColor=f.indexLabelLineColor?f.indexLabelLineColor:k.options.indexLabelLineColor?k.options.indexLabelLineColor:f.color?f.color:k._colorSet[e%k._colorSet.length];n.indexLabelLineThickness=r(f.indexLabelLineThickness)?k.indexLabelLineThickness:f.indexLabelLineThickness;n.indexLabelLineDashType=f.indexLabelLineDashType?f.indexLabelLineDashType:k.indexLabelLineDashType;
n.indexLabelFontColor=f.indexLabelFontColor?f.indexLabelFontColor:k.indexLabelFontColor;n.indexLabelFontStyle=f.indexLabelFontStyle?f.indexLabelFontStyle:k.indexLabelFontStyle;n.indexLabelFontWeight=f.indexLabelFontWeight?f.indexLabelFontWeight:k.indexLabelFontWeight;n.indexLabelFontSize=r(f.indexLabelFontSize)?k.indexLabelFontSize:f.indexLabelFontSize;n.indexLabelFontFamily=f.indexLabelFontFamily?f.indexLabelFontFamily:k.indexLabelFontFamily;n.indexLabelBackgroundColor=f.indexLabelBackgroundColor?
f.indexLabelBackgroundColor:k.options.indexLabelBackgroundColor?k.options.indexLabelBackgroundColor:k.indexLabelBackgroundColor;n.indexLabelMaxWidth=f.indexLabelMaxWidth?f.indexLabelMaxWidth:k.indexLabelMaxWidth?k.indexLabelMaxWidth:0.33*q.width;n.indexLabelWrap="undefined"!==typeof f.indexLabelWrap?f.indexLabelWrap:k.indexLabelWrap;n.indexLabelTextAlign=f.indexLabelTextAlign?f.indexLabelTextAlign:k.indexLabelTextAlign?k.indexLabelTextAlign:"left";n.startAngle=0===e?k.startAngle?k.startAngle/180*
Math.PI:0:g[e-1].endAngle;n.startAngle=(n.startAngle+2*Math.PI)%(2*Math.PI);n.endAngle=n.startAngle+2*Math.PI/z*Math.abs(f.y);f=(n.endAngle+n.startAngle)/2;f=(f+2*Math.PI)%(2*Math.PI);n.midAngle=f;if(n.midAngle>Math.PI/2-u&&n.midAngle<Math.PI/2+u){if(0===a||g[c].midAngle>n.midAngle)c=e;a++}else if(n.midAngle>3*Math.PI/2-u&&n.midAngle<3*Math.PI/2+u){if(0===b||g[d].midAngle>n.midAngle)d=e;b++}n.hemisphere=f>Math.PI/2&&f<=3*Math.PI/2?"left":"right";n.indexLabelTextBlock=new ja(p.plotArea.ctx,{fontSize:n.indexLabelFontSize,
fontFamily:n.indexLabelFontFamily,fontColor:n.indexLabelFontColor,fontStyle:n.indexLabelFontStyle,fontWeight:n.indexLabelFontWeight,textAlign:n.indexLabelTextAlign,backgroundColor:n.indexLabelBackgroundColor,maxWidth:n.indexLabelMaxWidth,maxHeight:n.indexLabelWrap?5*n.indexLabelFontSize:1.5*n.indexLabelFontSize,text:n.indexLabelText,padding:0,textBaseline:"top"});n.indexLabelTextBlock.measureText()}l=f=0;h=!1;for(e=0;e<m.length;e++)n=g[(c+e)%m.length],1<a&&(n.midAngle>Math.PI/2-u&&n.midAngle<Math.PI/
2+u)&&(f<=a/2&&!h?(n.hemisphere="right",f++):(n.hemisphere="left",h=!0));h=!1;for(e=0;e<m.length;e++)n=g[(d+e)%m.length],1<b&&(n.midAngle>3*Math.PI/2-u&&n.midAngle<3*Math.PI/2+u)&&(l<=b/2&&!h?(n.hemisphere="left",l++):(n.hemisphere="right",h=!0))}}function c(a){var b=p.plotArea.ctx;b.clearRect(q.x1,q.y1,q.width,q.height);b.fillStyle=p.backgroundColor;b.fillRect(q.x1,q.y1,q.width,q.height);for(b=0;b<m.length;b++){var c=g[b].startAngle,d=g[b].endAngle;if(d>c){var e=0.07*D*Math.cos(g[b].midAngle),f=
0.07*D*Math.sin(g[b].midAngle),l=!1;if(m[b].exploded){if(1E-9<Math.abs(g[b].center.x-(x.x+e))||1E-9<Math.abs(g[b].center.y-(x.y+f)))g[b].center.x=x.x+e*a,g[b].center.y=x.y+f*a,l=!0}else if(0<Math.abs(g[b].center.x-x.x)||0<Math.abs(g[b].center.y-x.y))g[b].center.x=x.x+e*(1-a),g[b].center.y=x.y+f*(1-a),l=!0;l&&(e={},e.dataSeries=k,e.dataPoint=k.dataPoints[b],e.index=b,p.toolTip.highlightObjects([e]));pa(p.plotArea.ctx,g[b].center,g[b].radius,m[b].color?m[b].color:k._colorSet[b%k._colorSet.length],k.type,
c,d,k.fillOpacity,g[b].percentInnerRadius)}}a=p.plotArea.ctx;a.save();a.fillStyle="black";a.strokeStyle="grey";a.textBaseline="middle";a.lineJoin="round";for(b=b=0;b<m.length;b++)c=g[b],c.indexLabelText&&(c.indexLabelTextBlock.y-=c.indexLabelTextBlock.height/2,d=0,d="left"===c.hemisphere?"inside"!==k.indexLabelPlacement?-(c.indexLabelTextBlock.width+n):-c.indexLabelTextBlock.width/2:"inside"!==k.indexLabelPlacement?n:-c.indexLabelTextBlock.width/2,c.indexLabelTextBlock.x+=d,c.indexLabelTextBlock.render(!0),
c.indexLabelTextBlock.x-=d,c.indexLabelTextBlock.y+=c.indexLabelTextBlock.height/2,"inside"!==c.indexLabelPlacement&&0<c.indexLabelLineThickness&&(d=c.center.x+D*Math.cos(c.midAngle),e=c.center.y+D*Math.sin(c.midAngle),a.strokeStyle=c.indexLabelLineColor,a.lineWidth=c.indexLabelLineThickness,a.setLineDash&&a.setLineDash(J(c.indexLabelLineDashType,c.indexLabelLineThickness)),a.beginPath(),a.moveTo(d,e),a.lineTo(c.indexLabelTextBlock.x,c.indexLabelTextBlock.y),a.lineTo(c.indexLabelTextBlock.x+("left"===
c.hemisphere?-n:n),c.indexLabelTextBlock.y),a.stroke()),a.lineJoin="miter");a.save()}function b(a,b){var c=0,c=a.indexLabelTextBlock.y-a.indexLabelTextBlock.height/2,d=a.indexLabelTextBlock.y+a.indexLabelTextBlock.height/2,e=b.indexLabelTextBlock.y-b.indexLabelTextBlock.height/2,f=b.indexLabelTextBlock.y+b.indexLabelTextBlock.height/2;return c=b.indexLabelTextBlock.y>a.indexLabelTextBlock.y?e-d:c-f}function e(a){for(var c=null,d=1;d<m.length;d++)if(c=(a+d+g.length)%g.length,g[c].hemisphere!==g[a].hemisphere){c=
null;break}else if(g[c].indexLabelText&&c!==a&&(0>b(g[c],g[a])||("right"===g[a].hemisphere?g[c].indexLabelTextBlock.y>=g[a].indexLabelTextBlock.y:g[c].indexLabelTextBlock.y<=g[a].indexLabelTextBlock.y)))break;else c=null;return c}function f(a,c,d){d=(d||0)+1;if(1E3<d)return 0;c=c||0;var l=0,k=x.y-1*w,n=x.y+1*w;if(0<=a&&a<m.length){var h=g[a];if(0>c&&h.indexLabelTextBlock.y<k||0<c&&h.indexLabelTextBlock.y>n)return 0;var q=0,t=0,t=q=q=0;0>c?h.indexLabelTextBlock.y-h.indexLabelTextBlock.height/2>k&&
h.indexLabelTextBlock.y-h.indexLabelTextBlock.height/2+c<k&&(c=-(k-(h.indexLabelTextBlock.y-h.indexLabelTextBlock.height/2+c))):h.indexLabelTextBlock.y+h.indexLabelTextBlock.height/2<k&&h.indexLabelTextBlock.y+h.indexLabelTextBlock.height/2+c>n&&(c=h.indexLabelTextBlock.y+h.indexLabelTextBlock.height/2+c-n);c=h.indexLabelTextBlock.y+c;k=0;k="right"===h.hemisphere?x.x+Math.sqrt(Math.pow(w,2)-Math.pow(c-x.y,2)):x.x-Math.sqrt(Math.pow(w,2)-Math.pow(c-x.y,2));t=x.x+D*Math.cos(h.midAngle);q=x.y+D*Math.sin(h.midAngle);
q=Math.sqrt(Math.pow(k-t,2)+Math.pow(c-q,2));t=Math.acos(D/w);q=Math.acos((w*w+D*D-q*q)/(2*D*w));c=q<t?c-h.indexLabelTextBlock.y:0;k=null;for(n=1;n<m.length;n++)if(k=(a-n+g.length)%g.length,g[k].hemisphere!==g[a].hemisphere){k=null;break}else if(g[k].indexLabelText&&g[k].hemisphere===g[a].hemisphere&&k!==a&&(0>b(g[k],g[a])||("right"===g[a].hemisphere?g[k].indexLabelTextBlock.y<=g[a].indexLabelTextBlock.y:g[k].indexLabelTextBlock.y>=g[a].indexLabelTextBlock.y)))break;else k=null;t=k;q=e(a);n=k=0;0>
c?(n="right"===h.hemisphere?t:q,l=c,null!==n&&(t=-c,c=h.indexLabelTextBlock.y-h.indexLabelTextBlock.height/2-(g[n].indexLabelTextBlock.y+g[n].indexLabelTextBlock.height/2),c-t<s&&(k=-t,n=f(n,k,d+1),+n.toFixed(y)>+k.toFixed(y)&&(l=c>s?-(c-s):-(t-(n-k)))))):0<c&&(n="right"===h.hemisphere?q:t,l=c,null!==n&&(t=c,c=g[n].indexLabelTextBlock.y-g[n].indexLabelTextBlock.height/2-(h.indexLabelTextBlock.y+h.indexLabelTextBlock.height/2),c-t<s&&(k=t,n=f(n,k,d+1),+n.toFixed(y)<+k.toFixed(y)&&(l=c>s?c-s:t-(k-n)))));
l&&(d=h.indexLabelTextBlock.y+l,c=0,c="right"===h.hemisphere?x.x+Math.sqrt(Math.pow(w,2)-Math.pow(d-x.y,2)):x.x-Math.sqrt(Math.pow(w,2)-Math.pow(d-x.y,2)),h.midAngle>Math.PI/2-u&&h.midAngle<Math.PI/2+u?(k=(a-1+g.length)%g.length,k=g[k],a=g[(a+1+g.length)%g.length],"left"===h.hemisphere&&"right"===k.hemisphere&&c>k.indexLabelTextBlock.x?c=k.indexLabelTextBlock.x-15:"right"===h.hemisphere&&("left"===a.hemisphere&&c<a.indexLabelTextBlock.x)&&(c=a.indexLabelTextBlock.x+15)):h.midAngle>3*Math.PI/2-u&&
h.midAngle<3*Math.PI/2+u&&(k=(a-1+g.length)%g.length,k=g[k],a=g[(a+1+g.length)%g.length],"right"===h.hemisphere&&"left"===k.hemisphere&&c<k.indexLabelTextBlock.x?c=k.indexLabelTextBlock.x+15:"left"===h.hemisphere&&("right"===a.hemisphere&&c>a.indexLabelTextBlock.x)&&(c=a.indexLabelTextBlock.x-15)),h.indexLabelTextBlock.y=d,h.indexLabelTextBlock.x=c,h.indexLabelAngle=Math.atan2(h.indexLabelTextBlock.y-x.y,h.indexLabelTextBlock.x-x.x))}return l}function l(){var a=p.plotArea.ctx;a.fillStyle="grey";a.strokeStyle=
"grey";a.font="16px Arial";a.textBaseline="middle";for(var c=a=0,d=0,l=!0,c=0;10>c&&(1>c||0<d);c++){if(k.radius||!k.radius&&"undefined"!==typeof k.innerRadius&&null!==k.innerRadius&&D-d<=B)l=!1;l&&(D-=d);d=0;if("inside"!==k.indexLabelPlacement){w=D*v;for(a=0;a<m.length;a++){var h=g[a];h.indexLabelTextBlock.x=x.x+w*Math.cos(h.midAngle);h.indexLabelTextBlock.y=x.y+w*Math.sin(h.midAngle);h.indexLabelAngle=h.midAngle;h.radius=D;h.percentInnerRadius=E}for(var t,r,a=0;a<m.length;a++){var h=g[a],u=e(a);
if(null!==u){t=g[a];r=g[u];var z=0,z=b(t,r)-s;if(0>z){for(var A=r=0,H=0;H<m.length;H++)H!==a&&g[H].hemisphere===h.hemisphere&&(g[H].indexLabelTextBlock.y<h.indexLabelTextBlock.y?r++:A++);r=z/(r+A||1)*A;var A=-1*(z-r),J=H=0;"right"===h.hemisphere?(H=f(a,r),A=-1*(z-H),J=f(u,A),+J.toFixed(y)<+A.toFixed(y)&&+H.toFixed(y)<=+r.toFixed(y)&&f(a,-(A-J))):(H=f(u,r),A=-1*(z-H),J=f(a,A),+J.toFixed(y)<+A.toFixed(y)&&+H.toFixed(y)<=+r.toFixed(y)&&f(u,-(A-J)))}}}}else for(a=0;a<m.length;a++)h=g[a],w="pie"===k.type?
0.7*D:0.85*D,u=x.x+w*Math.cos(h.midAngle),r=x.y+w*Math.sin(h.midAngle),h.indexLabelTextBlock.x=u,h.indexLabelTextBlock.y=r;for(a=0;a<m.length;a++)if(h=g[a],u=h.indexLabelTextBlock.measureText(),0!==u.height&&0!==u.width)u=u=0,"right"===h.hemisphere?(u=q.x2-(h.indexLabelTextBlock.x+h.indexLabelTextBlock.width+n),u*=-1):u=q.x1-(h.indexLabelTextBlock.x-h.indexLabelTextBlock.width-n),0<u&&(!l&&h.indexLabelText&&(r="right"===h.hemisphere?q.x2-h.indexLabelTextBlock.x:h.indexLabelTextBlock.x-q.x1,0.3*h.indexLabelTextBlock.maxWidth>
r?h.indexLabelText="":h.indexLabelTextBlock.maxWidth=0.85*r,0.3*h.indexLabelTextBlock.maxWidth<r&&(h.indexLabelTextBlock.x-="right"===h.hemisphere?2:-2)),Math.abs(h.indexLabelTextBlock.y-h.indexLabelTextBlock.height/2-x.y)<D||Math.abs(h.indexLabelTextBlock.y+h.indexLabelTextBlock.height/2-x.y)<D)&&(u/=Math.abs(Math.cos(h.indexLabelAngle)),9<u&&(u*=0.3),u>d&&(d=u)),u=u=0,0<h.indexLabelAngle&&h.indexLabelAngle<Math.PI?(u=q.y2-(h.indexLabelTextBlock.y+h.indexLabelTextBlock.height/2+5),u*=-1):u=q.y1-
(h.indexLabelTextBlock.y-h.indexLabelTextBlock.height/2-5),0<u&&(!l&&h.indexLabelText&&(r=0<h.indexLabelAngle&&h.indexLabelAngle<Math.PI?-1:1,0===f(a,u*r)&&f(a,2*r)),Math.abs(h.indexLabelTextBlock.x-x.x)<D&&(u/=Math.abs(Math.sin(h.indexLabelAngle)),9<u&&(u*=0.3),u>d&&(d=u)));var G=function(a,b,c){for(var d=[],e=0;d.push(g[b]),b!==c;b=(b+1+m.length)%m.length);d.sort(function(a,b){return a.y-b.y});for(b=0;b<d.length;b++)if(c=d[b],e<0.7*a)e+=c.indexLabelTextBlock.height,c.indexLabelTextBlock.text="",
c.indexLabelText="",c.indexLabelTextBlock.measureText();else break};(function(){for(var a=-1,c=-1,d=0,f=!1,l=0;l<m.length;l++)if(f=!1,t=g[l],t.indexLabelText){var k=e(l);if(null!==k){var h=g[k];z=0;z=b(t,h);var q;if(q=0>z){q=t.indexLabelTextBlock.x;var s=t.indexLabelTextBlock.y-t.indexLabelTextBlock.height/2,p=t.indexLabelTextBlock.y+t.indexLabelTextBlock.height/2,r=h.indexLabelTextBlock.y-h.indexLabelTextBlock.height/2,u=h.indexLabelTextBlock.x+h.indexLabelTextBlock.width,C=h.indexLabelTextBlock.y+
h.indexLabelTextBlock.height/2;q=t.indexLabelTextBlock.x+t.indexLabelTextBlock.width<h.indexLabelTextBlock.x-n||q>u+n||s>C+n||p<r-n?!1:!0}q?(0>a&&(a=l),k!==a&&(c=k,d+=-z),0===l%Math.max(m.length/10,3)&&(f=!0)):f=!0;f&&(0<d&&0<=a&&0<=c)&&(G(d,a,c),c=a=-1,d=0)}}0<d&&G(d,a,c)})()}}function h(){p.plotArea.layoutManager.reset();p.title&&(p.title.dockInsidePlotArea||"center"===p.title.horizontalAlign&&"center"===p.title.verticalAlign)&&p.title.render();if(p.subtitles)for(var a=0;a<p.subtitles.length;a++){var b=
p.subtitles[a];(b.dockInsidePlotArea||"center"===b.horizontalAlign&&"center"===b.verticalAlign)&&b.render()}p.legend&&(p.legend.dockInsidePlotArea||"center"===p.legend.horizontalAlign&&"center"===p.legend.verticalAlign)&&(p.legend.setLayout(),p.legend.render())}var p=this;if(!(0>=a.dataSeriesIndexes.length)){var k=this.data[a.dataSeriesIndexes[0]],m=k.dataPoints,n=10,q=this.plotArea,g=k.dataPointEOs,s=2,w,v=1.3,u=20/180*Math.PI,y=6,x={x:(q.x2+q.x1)/2,y:(q.y2+q.y1)/2},z=0;a=!1;for(var A=0;A<m.length;A++)z+=
Math.abs(m[A].y),!a&&("undefined"!==typeof m[A].indexLabel&&null!==m[A].indexLabel&&0<m[A].indexLabel.toString().length)&&(a=!0),!a&&("undefined"!==typeof m[A].label&&null!==m[A].label&&0<m[A].label.toString().length)&&(a=!0);if(0!==z){a=a||"undefined"!==typeof k.indexLabel&&null!==k.indexLabel&&0<k.indexLabel.toString().length;var D="inside"!==k.indexLabelPlacement&&a?0.75*Math.min(q.width,q.height)/2:0.92*Math.min(q.width,q.height)/2;k.radius&&(D=Ta(k.radius,D));var B="undefined"!==typeof k.innerRadius&&
null!==k.innerRadius?Ta(k.innerRadius,D):0.7*D;k.radius=D;"doughnut"===k.type&&(k.innerRadius=B);var E=Math.min(B/D,(D-1)/D);this.pieDoughnutClickHandler=function(a){p.isAnimating||!r(a.dataSeries.explodeOnClick)&&!a.dataSeries.explodeOnClick||(a=a.dataPoint,a.exploded=a.exploded?!1:!0,1<this.dataPoints.length&&p._animator.animate(0,500,function(a){c(a);h();p.dispatchEvent("dataAnimationIterationEnd",{chart:p});p.dispatchEvent("dataAnimationEnd",{chart:p})}))};d();l();l();l();l();this.disableToolTip=
!0;this._animator.animate(0,this.animatedRender?this.animationDuration:0,function(a){var b=p.plotArea.ctx;b.clearRect(q.x1,q.y1,q.width,q.height);b.fillStyle=p.backgroundColor;b.fillRect(q.x1,q.y1,q.width,q.height);for(var b=g[0].startAngle+2*Math.PI*a,c=0;c<m.length;c++){var d=0===c?g[c].startAngle:e,e=d+(g[c].endAngle-g[c].startAngle),f=!1;e>b&&(e=b,f=!0);var l=m[c].color?m[c].color:k._colorSet[c%k._colorSet.length];e>d&&pa(p.plotArea.ctx,g[c].center,g[c].radius,l,k.type,d,e,k.fillOpacity,g[c].percentInnerRadius);
if(f)break}h();p.dispatchEvent("dataAnimationIterationEnd",{chart:p});1<=a&&p.dispatchEvent("dataAnimationEnd",{chart:p})},function(){p.disableToolTip=!1;p._animator.animate(0,p.animatedRender?500:0,function(a){c(a);h();p.dispatchEvent("dataAnimationIterationEnd",{chart:p})});p.dispatchEvent("dataAnimationEnd",{chart:p})})}}};var ra=function(a,d,c,b){"undefined"===typeof c&&(c=1);0>=Math.round(d.y4-d.y1)||(a.save(),a.globalAlpha=c,a.beginPath(),a.moveTo(Math.round(d.x1),Math.round(d.y1)),a.lineTo(Math.round(d.x2),
Math.round(d.y2)),a.lineTo(Math.round(d.x3),Math.round(d.y3)),a.lineTo(Math.round(d.x4),Math.round(d.y4)),"undefined"!==d.x5&&(a.lineTo(Math.round(d.x5),Math.round(d.y5)),a.lineTo(Math.round(d.x6),Math.round(d.y6))),a.closePath(),a.fillStyle=b?b:d.color,a.fill(),a.globalAplha=1,a.restore())};p.prototype.renderFunnel=function(a){function d(){for(var a=0,b=[],c=0;c<y.length;c++){if("undefined"===typeof y[c].y)return-1;y[c].y="number"===typeof y[c].y?y[c].y:0;a+=Math.abs(y[c].y)}if(0===a)return-1;for(c=
b[0]=0;c<y.length;c++)b.push(Math.abs(y[c].y)*E/a);return b}function c(){var a=T,b=V,c=O,d=W,e,f;e=$;f=N-Q;d=Math.abs((f-e)*(b-a+(d-c))/2);c=W-O;e=f-e;f=c*(f-N);f=Math.abs(f);f=d+f;for(var d=[],g=0,l=0;l<y.length;l++){if("undefined"===typeof y[l].y)return-1;y[l].y="number"===typeof y[l].y?y[l].y:0;g+=Math.abs(y[l].y)}if(0===g)return-1;for(var k=d[0]=0,m=0,h,n,b=b-a,k=!1,l=0;l<y.length;l++)a=Math.abs(y[l].y)*f/g,k?h=0==Number(c.toFixed(3))?0:a/c:(n=aa*aa*b*b-4*Math.abs(aa)*a,0>n?(n=c,k=(b+n)*(e-m)/
2,a-=k,h=e-m,m+=e-m,h+=0==n?0:a/n,m+=a/n,k=!0):(h=(Math.abs(aa)*b-Math.sqrt(n))/2,n=b-2*h/Math.abs(aa),m+=h,m>e&&(m-=h,n=c,k=(b+n)*(e-m)/2,a-=k,h=e-m,m+=e-m,h+=a/n,m+=a/n,k=!0),b=n)),d.push(h);return d}function b(){if(u&&y){for(var a,b,c,d,e,f,l,k,m,h,n,q,t,p,s,C=[],x=[],v={percent:null,total:null},z=null,D=0;D<y.length;D++)s=R[D],s="undefined"!==typeof s.x5?(s.y2+s.y4)/2:(s.y2+s.y3)/2,s=g(s).x2+1,C[D]=K-s-X;s=0.5*X;for(var D=0,B=y.length-1;D<y.length||0<=B;D++,B--){b=u.reversed?y[B]:y[D];a=b.color?
b.color:u.reversed?u._colorSet[(y.length-1-D)%u._colorSet.length]:u._colorSet[D%u._colorSet.length];c=b.indexLabelPlacement||u.indexLabelPlacement||"outside";p=b.indexLabelTextAlign||u.indexLabelTextAlign||"left";d=b.indexLabelBackgroundColor||u.indexLabelBackgroundColor||(w?"transparent":null);e=b.indexLabelFontColor||u.indexLabelFontColor||"#979797";f=r(b.indexLabelFontSize)?u.indexLabelFontSize:b.indexLabelFontSize;l=b.indexLabelFontStyle||u.indexLabelFontStyle||"normal";k=b.indexLabelFontFamily||
u.indexLabelFontFamily||"arial";m=b.indexLabelFontWeight||u.indexLabelFontWeight||"normal";a=b.indexLabelLineColor||u.options.indexLabelLineColor||a;h="number"===typeof b.indexLabelLineThickness?b.indexLabelLineThickness:"number"===typeof u.indexLabelLineThickness?u.indexLabelLineThickness:2;n=b.indexLabelLineDashType||u.indexLabelLineDashType||"solid";q="undefined"!==typeof b.indexLabelWrap?b.indexLabelWrap:"undefined"!==typeof u.indexLabelWrap?u.indexLabelWrap:!0;t=u.dataPointIds[D];A._eventManager.objectMap[t]=
{id:t,objectType:"dataPoint",dataPointIndex:D,dataSeriesIndex:0,funnelSection:R[u.reversed?y.length-1-D:D]};"inside"===u.indexLabelPlacement&&(C[D]=D!==ca?u.reversed?R[D].x2-R[D].x1:R[D].x3-R[D].x4:R[D].x3-R[D].x6,20>C[D]&&(C[D]=D!==ca?u.reversed?R[D].x3-R[D].x4:R[D].x2-R[D].x1:R[D].x2-R[D].x1,C[D]/=2));t=b.indexLabelMaxWidth?b.indexLabelMaxWidth:u.options.indexLabelMaxWidth?u.indexLabelMaxWidth:C[D];if(t>C[D]||0>t)t=C[D];x[D]="inside"===u.indexLabelPlacement?q?Math.max(R[D].height,f):1.5*f:!1;v=
A.getPercentAndTotal(u,b);if(u.indexLabelFormatter||b.indexLabelFormatter)z={chart:A.options,dataSeries:u,dataPoint:b,total:v.total,percent:v.percent};b=b.indexLabelFormatter?b.indexLabelFormatter(z):b.indexLabel?A.replaceKeywordsWithValue(b.indexLabel,b,u,D):u.indexLabelFormatter?u.indexLabelFormatter(z):u.indexLabel?A.replaceKeywordsWithValue(u.indexLabel,b,u,D):b.label?b.label:"";0>=h&&(h=0);1E3>t&&1E3-t<s&&(t+=1E3-t);P.roundRect||Da(P);c=new ja(P,{fontSize:f,fontFamily:k,fontColor:e,fontStyle:l,
fontWeight:m,horizontalAlign:c,textAlign:p,backgroundColor:d,maxWidth:t,maxHeight:!1===x[D]?q?4.28571429*f:1.5*f:x[D],text:b,padding:da});c.measureText();I.push({textBlock:c,id:u.reversed?B:D,isDirty:!1,lineColor:a,lineThickness:h,lineDashType:n,height:c.height<c.maxHeight?c.height:c.maxHeight,width:c.width<c.maxWidth?c.width:c.maxWidth})}}}function e(){var a,b,c,d,e,f=[];e=!1;c=0;for(var g,l=K-V-X/2,l=u.options.indexLabelMaxWidth?u.indexLabelMaxWidth>l?l:u.indexLabelMaxWidth:l,k=I.length-1;0<=k;k--){g=
y[I[k].id];c=I[k];d=c.textBlock;b=(a=q(k)<R.length?I[q(k)]:null)?a.textBlock:null;c=c.height;a&&d.y+c+da>b.y&&(e=!0);c=g.indexLabelMaxWidth||l;if(c>l||0>c)c=l;f.push(c)}if(e)for(k=I.length-1;0<=k;k--)a=R[k],I[k].textBlock.maxWidth=f[f.length-(k+1)],I[k].textBlock.measureText(),I[k].textBlock.x=K-l,c=I[k].textBlock.height<I[k].textBlock.maxHeight?I[k].textBlock.height:I[k].textBlock.maxHeight,e=I[k].textBlock.width<I[k].textBlock.maxWidth?I[k].textBlock.width:I[k].textBlock.maxWidth,I[k].height=c,
I[k].width=e,c="undefined"!==typeof a.x5?(a.y2+a.y4)/2:(a.y2+a.y3)/2,I[k].textBlock.y=c-I[k].height/2,u.reversed?(I[k].textBlock.y+I[k].height>U+z&&(I[k].textBlock.y=U+z-I[k].height),I[k].textBlock.y<ta-z&&(I[k].textBlock.y=ta-z)):(I[k].textBlock.y<U-z&&(I[k].textBlock.y=U-z),I[k].textBlock.y+I[k].height>ta+z&&(I[k].textBlock.y=ta+z-I[k].height))}function f(){var a,b,c,d;if("inside"!==u.indexLabelPlacement)for(var e=0;e<R.length;e++)0==I[e].textBlock.text.length?I[e].isDirty=!0:(a=R[e],c="undefined"!==
typeof a.x5?(a.y2+a.y4)/2:(a.y2+a.y3)/2,b=u.reversed?"undefined"!==typeof a.x5?c>Ca?g(c).x2+1:(a.x2+a.x3)/2+1:(a.x2+a.x3)/2+1:"undefined"!==typeof a.x5?c<Ca?g(c).x2+1:(a.x4+a.x3)/2+1:(a.x2+a.x3)/2+1,I[e].textBlock.x=b+X,I[e].textBlock.y=c-I[e].height/2,u.reversed?(I[e].textBlock.y+I[e].height>U+z&&(I[e].textBlock.y=U+z-I[e].height),I[e].textBlock.y<ta-z&&(I[e].textBlock.y=ta-z)):(I[e].textBlock.y<U-z&&(I[e].textBlock.y=U-z),I[e].textBlock.y+I[e].height>ta+z&&(I[e].textBlock.y=ta+z-I[e].height)));
else for(e=0;e<R.length;e++)0==I[e].textBlock.text.length?I[e].isDirty=!0:(a=R[e],b=a.height,c=I[e].height,d=I[e].width,b>=c?(b=e!=ca?(a.x4+a.x3)/2-d/2:(a.x5+a.x4)/2-d/2,c=e!=ca?(a.y1+a.y3)/2-c/2:(a.y1+a.y4)/2-c/2,I[e].textBlock.x=b,I[e].textBlock.y=c):I[e].isDirty=!0)}function l(){function a(b,c){var d;if(0>b||b>=I.length)return 0;var e,f=I[b].textBlock;if(0>c){c*=-1;e=n(b);d=h(e,b);if(d>=c)return f.y-=c,c;if(0==b)return 0<d&&(f.y-=d),d;d+=a(e,-(c-d));0<d&&(f.y-=d);return d}e=q(b);d=h(b,e);if(d>=
c)return f.y+=c,c;if(b==R.length-1)return 0<d&&(f.y+=d),d;d+=a(e,c-d);0<d&&(f.y+=d);return d}function b(){var a,d,e,f,g=0,k;f=(N-$+2*z)/m;k=m;for(var l,h=1;h<k;h++){e=h*f;for(var t=I.length-1;0<=t;t--)!I[t].isDirty&&(I[t].textBlock.y<e&&I[t].textBlock.y+I[t].height>e)&&(l=q(t),!(l>=I.length-1)&&I[t].textBlock.y+I[t].height+da>I[l].textBlock.y&&(I[t].textBlock.y=I[t].textBlock.y+I[t].height-e>e-I[t].textBlock.y?e+1:e-I[t].height-1))}for(l=R.length-1;0<l;l--)if(!I[l].isDirty){e=n(l);if(0>e&&(e=0,I[e].isDirty))break;
if(I[l].textBlock.y<I[e].textBlock.y+I[e].height){d=d||l;f=l;for(k=0;I[f].textBlock.y<I[e].textBlock.y+I[e].height+da;){a=a||I[f].textBlock.y+I[f].height;k+=I[f].height;k+=da;f=e;if(0>=f){f=0;k+=I[f].height;break}e=n(f);if(0>e){f=0;k+=I[f].height;break}}if(f!=l){g=I[f].textBlock.y;a-=g;a=k-a;g=c(a,d,f);break}}}return g}function c(a,b,d){var e=[],f=0,g=0;for(a=Math.abs(a);d<=b;d++)e.push(R[d]);e.sort(function(a,b){return a.height-b.height});for(d=0;d<e.length;d++)if(b=e[d],f<a)g++,f+=I[b.id].height+
da,I[b.id].textBlock.text="",I[b.id].indexLabelText="",I[b.id].isDirty=!0,I[b.id].textBlock.measureText();else break;return g}for(var d,e,f,g,k,l,m=1,s=0;s<2*m;s++){for(var p=I.length-1;0<=p&&!(0<=n(p)&&n(p),f=I[p],g=f.textBlock,l=(k=q(p)<R.length?I[q(p)]:null)?k.textBlock:null,d=+f.height.toFixed(6),e=+g.y.toFixed(6),!f.isDirty&&(k&&e+d+da>+l.y.toFixed(6))&&(d=g.y+d+da-l.y,e=a(p,-d),e<d&&(0<e&&(d-=e),e=a(q(p),d),e!=d)));p--);b()}}function h(a,b){return(b<R.length?I[b].textBlock.y:u.reversed?U+z:
ta+z)-(0>a?u.reversed?ta-z:U-z:I[a].textBlock.y+I[a].height+da)}function p(a,b,c){var d,e,g,l=[],h=z,n=[];-1!==b&&(0<=Z.indexOf(b)?(e=Z.indexOf(b),Z.splice(e,1)):(Z.push(b),Z=Z.sort(function(a,b){return a-b})));if(0===Z.length)l=ia;else{e=z*(1!=Z.length||0!=Z[0]&&Z[0]!=R.length-1?2:1)/k();for(var q=0;q<R.length;q++){if(1==Z.length&&0==Z[0]){if(0===q){l.push(ia[q]);d=h;continue}}else 0===q&&(d=-1*h);l.push(ia[q]+d);if(0<=Z.indexOf(q)||q<R.length&&0<=Z.indexOf(q+1))d+=e}}g=function(){for(var a=[],b=
0;b<R.length;b++)a.push(l[b]-R[b].y1);return a}();var t={startTime:(new Date).getTime(),duration:c||500,easingFunction:function(a,b,c,d){return M.easing.easeOutQuart(a,b,c,d)},changeSection:function(a){for(var b,c,d=0;d<R.length;d++)b=g[d],c=R[d],b*=a,"undefined"===typeof n[d]&&(n[d]=0),0>n&&(n*=-1),c.y1+=b-n[d],c.y2+=b-n[d],c.y3+=b-n[d],c.y4+=b-n[d],c.y5&&(c.y5+=b-n[d],c.y6+=b-n[d]),n[d]=b}};a._animator.animate(0,c,function(c){var d=a.plotArea.ctx||a.ctx;ha=!0;d.clearRect(x.x1,x.y1,x.x2-x.x1,x.y2-
x.y1);d.fillStyle=a.backgroundColor;d.fillRect(x.x1,x.y1,x.width,x.height);t.changeSection(c,b);var e={};e.dataSeries=u;e.dataPoint=u.reversed?u.dataPoints[y.length-1-b]:u.dataPoints[b];e.index=u.reversed?y.length-1-b:b;a.toolTip.highlightObjects([e]);for(e=0;e<R.length;e++)ra(d,R[e],u.fillOpacity);v(d);L&&("inside"!==u.indexLabelPlacement?m(d):f(),s(d));1<=c&&(ha=!1)},null,M.easing.easeOutQuart)}function k(){for(var a=0,b=0;b<R.length-1;b++)(0<=Z.indexOf(b)||0<=Z.indexOf(b+1))&&a++;return a}function m(a){for(var b,
c,d,e,f=0;f<R.length;f++)e=1===I[f].lineThickness%2?0.5:0,c=((R[f].y2+R[f].y4)/2<<0)+e,b=g(c).x2-1,d=I[f].textBlock.x,e=(I[f].textBlock.y+I[f].height/2<<0)+e,I[f].isDirty||0==I[f].lineThickness||(a.strokeStyle=I[f].lineColor,a.lineWidth=I[f].lineThickness,a.setLineDash&&a.setLineDash(J(I[f].lineDashType,I[f].lineThickness)),a.beginPath(),a.moveTo(b,c),a.lineTo(d,e),a.stroke())}function n(a){for(a-=1;-1<=a&&-1!=a&&I[a].isDirty;a--);return a}function q(a){for(a+=1;a<=R.length&&a!=R.length&&I[a].isDirty;a++);
return a}function g(a){for(var b,c=0;c<y.length;c++)if(R[c].y1<a&&R[c].y4>a){b=R[c];break}return b?(a=b.y6?a>b.y6?b.x3+(b.x4-b.x3)/(b.y4-b.y3)*(a-b.y3):b.x2+(b.x3-b.x2)/(b.y3-b.y2)*(a-b.y2):b.x2+(b.x3-b.x2)/(b.y3-b.y2)*(a-b.y2),{x1:a,x2:a}):-1}function s(a){for(var b=0;b<R.length;b++)I[b].isDirty||(a&&(I[b].textBlock.ctx=a),I[b].textBlock.render(!0))}function v(a){A.plotArea.layoutManager.reset();a.roundRect||Da(a);A.title&&(A.title.dockInsidePlotArea||"center"===A.title.horizontalAlign&&"center"===
A.title.verticalAlign)&&(A.title.ctx=a,A.title.render());if(A.subtitles)for(var b=0;b<A.subtitles.length;b++){var c=A.subtitles[b];if(c.dockInsidePlotArea||"center"===c.horizontalAlign&&"center"===c.verticalAlign)A.subtitles.ctx=a,c.render()}A.legend&&(A.legend.dockInsidePlotArea||"center"===A.legend.horizontalAlign&&"center"===A.legend.verticalAlign)&&(A.legend.ctx=a,A.legend.setLayout(),A.legend.render());va.fNg&&va.fNg(A)}var A=this;if(!(0>=a.dataSeriesIndexes.length)){for(var u=this.data[a.dataSeriesIndexes[0]],
y=u.dataPoints,x=this.plotArea,z=0.025*x.width,B=0.01*x.width,D=0,E=x.height-2*z,G=Math.min(x.width-2*B,2.8*x.height),L=!1,S=0;S<y.length;S++)if(!L&&("undefined"!==typeof y[S].indexLabel&&null!==y[S].indexLabel&&0<y[S].indexLabel.toString().length)&&(L=!0),!L&&("undefined"!==typeof y[S].label&&null!==y[S].label&&0<y[S].label.toString().length)&&(L=!0),!L&&"function"===typeof u.indexLabelFormatter||"function"===typeof y[S].indexLabelFormatter)L=!0;L=L||"undefined"!==typeof u.indexLabel&&null!==u.indexLabel&&
0<u.indexLabel.toString().length;"inside"!==u.indexLabelPlacement&&L||(B=(x.width-0.75*G)/2);var S=x.x1+B,K=x.x2-B,$=x.y1+z,N=x.y2-z,P=a.targetCanvasCtx||this.plotArea.ctx||this.ctx;if(0!=u.length&&(u.dataPoints&&u.visible)&&0!==y.length){var Q,F;a=75*G/100;var X=30*(K-a)/100;"funnel"===u.type?(Q=r(u.options.neckHeight)?0.35*E:u.neckHeight,F=r(u.options.neckWidth)?0.25*a:u.neckWidth,"string"===typeof Q&&Q.match(/%$/)?(Q=parseInt(Q),Q=Q*E/100):Q=parseInt(Q),"string"===typeof F&&F.match(/%$/)?(F=parseInt(F),
F=F*a/100):F=parseInt(F),Q>E?Q=E:0>=Q&&(Q=0),F>a?F=a-0.5:0>=F&&(F=0)):"pyramid"===u.type&&(F=Q=0,u.reversed=u.reversed?!1:!0);var B=S+a/2,T=S,V=S+a,U=u.reversed?N:$,O=B-F/2,W=B+F/2,Ca=u.reversed?$+Q:N-Q,ta=u.reversed?$:N;a=[];var B=[],R=[],G=[],Y=$,ca,aa=(Ca-U)/(O-T),fa=-aa,S="area"===(u.valueRepresents?u.valueRepresents:"height")?c():d();if(-1!==S){if(u.reversed)for(G.push(Y),F=S.length-1;0<F;F--)Y+=S[F],G.push(Y);else for(F=0;F<S.length;F++)Y+=S[F],G.push(Y);if(u.reversed)for(F=0;F<S.length;F++)G[F]<
Ca?(a.push(O),B.push(W),ca=F):(a.push((G[F]-U+aa*T)/aa),B.push((G[F]-U+fa*V)/fa));else for(F=0;F<S.length;F++)G[F]<Ca?(a.push((G[F]-U+aa*T)/aa),B.push((G[F]-U+fa*V)/fa),ca=F):(a.push(O),B.push(W));for(F=0;F<S.length-1;F++)Y=u.reversed?y[y.length-1-F].color?y[y.length-1-F].color:u._colorSet[(y.length-1-F)%u._colorSet.length]:y[F].color?y[F].color:u._colorSet[F%u._colorSet.length],F===ca?R.push({x1:a[F],y1:G[F],x2:B[F],y2:G[F],x3:W,y3:Ca,x4:B[F+1],y4:G[F+1],x5:a[F+1],y5:G[F+1],x6:O,y6:Ca,id:F,height:G[F+
1]-G[F],color:Y}):R.push({x1:a[F],y1:G[F],x2:B[F],y2:G[F],x3:B[F+1],y3:G[F+1],x4:a[F+1],y4:G[F+1],id:F,height:G[F+1]-G[F],color:Y});var da=2,I=[],ha=!1,Z=[],ia=[],S=!1;a=a=0;Ea(Z);for(F=0;F<y.length;F++)y[F].exploded&&(S=!0,u.reversed?Z.push(y.length-1-F):Z.push(F));P.clearRect(x.x1,x.y1,x.width,x.height);P.fillStyle=A.backgroundColor;P.fillRect(x.x1,x.y1,x.width,x.height);if(L&&u.visible&&(b(),f(),e(),"inside"!==u.indexLabelPlacement)){l();for(F=0;F<y.length;F++)I[F].isDirty||(a=I[F].textBlock.x+
I[F].width,a=(K-a)/2,0==F&&(D=a),D>a&&(D=a));for(F=0;F<R.length;F++)R[F].x1+=D,R[F].x2+=D,R[F].x3+=D,R[F].x4+=D,R[F].x5&&(R[F].x5+=D,R[F].x6+=D),I[F].textBlock.x+=D}for(F=0;F<R.length;F++)D=R[F],ra(P,D,u.fillOpacity),ia.push(D.y1);v(P);L&&u.visible&&("inside"===u.indexLabelPlacement||A.animationEnabled||m(P),A.animationEnabled||s());if(!L)for(F=0;F<y.length;F++)D=u.dataPointIds[F],a={id:D,objectType:"dataPoint",dataPointIndex:F,dataSeriesIndex:0,funnelSection:R[u.reversed?y.length-1-F:F]},A._eventManager.objectMap[D]=
a;!A.animationEnabled&&S?p(A,-1,0):A.animationEnabled&&!A.animatedRender&&p(A,-1,0);this.funnelPyramidClickHandler=function(a){var b=-1;if(!ha&&!A.isAnimating&&(r(a.dataSeries.explodeOnClick)||a.dataSeries.explodeOnClick)&&(b=u.reversed?y.length-1-a.dataPointIndex:a.dataPointIndex,0<=b)){a=b;if("funnel"===u.type||"pyramid"===u.type)u.reversed?y[y.length-1-a].exploded=y[y.length-1-a].exploded?!1:!0:y[a].exploded=y[a].exploded?!1:!0;p(A,b,500)}};return{source:P,dest:this.plotArea.ctx,animationCallback:function(a,
b){M.fadeInAnimation(a,b);1<=a&&(p(A,-1,500),v(A.plotArea.ctx||A.ctx))},easingFunction:M.easing.easeInQuad,animationBase:0}}}}};p.prototype.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(a){window.setTimeout(a,1E3/60)}}();p.prototype.cancelRequestAnimFrame=window.cancelAnimationFrame||window.webkitCancelRequestAnimationFrame||window.mozCancelRequestAnimationFrame||
window.oCancelRequestAnimationFrame||window.msCancelRequestAnimationFrame||clearTimeout;p.prototype.set=function(a,d,c){c="undefined"===typeof c?!0:c;"options"===a?(this.options=d,c&&this.render()):p.base.set.call(this,a,d,c)};p.prototype.exportChart=function(a){a="undefined"===typeof a?{}:a;var d=a.format?a.format:"png",c=a.fileName?a.fileName:this.exportFileName;if(a.toDataURL)return this.canvas.toDataURL("image/"+d);var b=this.canvas;if(b&&d&&c){c=c+"."+d;a="image/"+d;var b=b.toDataURL(a),e=!1,
f=document.createElement("a");f.download=c;f.href=b;if("undefined"!==typeof Blob&&new Blob){for(var l=b.replace(/^data:[a-z\/]*;base64,/,""),l=atob(l),h=new ArrayBuffer(l.length),h=new Uint8Array(h),p=0;p<l.length;p++)h[p]=l.charCodeAt(p);d=new Blob([h.buffer],{type:"image/"+d});try{window.navigator.msSaveBlob(d,c),e=!0}catch(k){f.dataset.downloadurl=[a,f.download,f.href].join(":"),f.href=window.URL.createObjectURL(d)}}if(!e)try{event=document.createEvent("MouseEvents"),event.initMouseEvent("click",
!0,!1,window,0,0,0,0,0,!1,!1,!1,!1,0,null),f.dispatchEvent?f.dispatchEvent(event):f.fireEvent&&f.fireEvent("onclick")}catch(m){d=window.open(),d.document.write("<img src='"+b+"'></img><div>Please right click on the image and save it to your device</div>"),d.document.close()}}};p.prototype.print=function(){var a=this.exportChart({toDataURL:!0}),d=document.createElement("iframe");d.setAttribute("class","canvasjs-chart-print-frame");V(d,{position:"absolute",width:"100%",border:"0px",margin:"0px 0px 0px 0px",
padding:"0px 0px 0px 0px"});d.style.height=this.height+"px";this._canvasJSContainer.appendChild(d);var c=this,b=d.contentWindow||d.contentDocument.document||d.contentDocument;b.document.open();b.document.write('<!DOCTYPE HTML>\n<html><body><img src="'+a+'"/><body/></html>');b.document.body&&b.document.body.style&&(b.document.body.style.margin="0px 0px 0px 0px",b.document.body.style.padding="0px 0px 0px 0px");b.document.close();setTimeout(function(){b.focus();b.print();setTimeout(function(){c._canvasJSContainer.removeChild(d)},
1E3)},500)};p.prototype.getPercentAndTotal=function(a,d){var c=null,b=null,e=c=null;if(0<=a.type.indexOf("stacked"))b=0,c=d.x.getTime?d.x.getTime():d.x,c in a.plotUnit.yTotals&&(b=a.plotUnit.yTotals[c],c=a.plotUnit.yAbsTotals[c],e=isNaN(d.y)?0:0===c?0:100*(d.y/c));else if("pie"===a.type||"doughnut"===a.type||"funnel"===a.type||"pyramid"===a.type){for(c=b=0;c<a.dataPoints.length;c++)isNaN(a.dataPoints[c].y)||(b+=a.dataPoints[c].y);e=isNaN(d.y)?0:100*(d.y/b)}return{percent:e,total:b}};p.prototype.replaceKeywordsWithValue=
function(a,d,c,b,e){var f=this;e="undefined"===typeof e?0:e;if((0<=c.type.indexOf("stacked")||"pie"===c.type||"doughnut"===c.type||"funnel"===c.type||"pyramid"===c.type)&&(0<=a.indexOf("#percent")||0<=a.indexOf("#total"))){var l="#percent",h="#total",p=this.getPercentAndTotal(c,d),h=isNaN(p.total)?h:p.total,l=isNaN(p.percent)?l:p.percent;do{p="";if(c.percentFormatString)p=c.percentFormatString;else{var p="#,##0.",k=Math.max(Math.ceil(Math.log(1/Math.abs(l))/Math.LN10),2);if(isNaN(k)||!isFinite(k))k=
2;for(var m=0;m<k;m++)p+="#";c.percentFormatString=p}a=a.replace("#percent",da(l,p,f._cultureInfo));a=a.replace("#total",da(h,c.yValueFormatString?c.yValueFormatString:"#,##0.########",f._cultureInfo))}while(0<=a.indexOf("#percent")||0<=a.indexOf("#total"))}return a.replace(/\{.*?\}|"[^"]*"|'[^']*'/g,function(a){if('"'===a[0]&&'"'===a[a.length-1]||"'"===a[0]&&"'"===a[a.length-1])return a.slice(1,a.length-1);a=Ha(a.slice(1,a.length-1));a=a.replace("#index",e);var k=null;try{var g=a.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
g&&0<g.length&&(k=Ha(g[2]),a=Ha(g[1]))}catch(l){}g=null;if("color"===a)return"waterfall"===c.type?d.color?d.color:0<d.y?c.risingColor:c.fallingColor:"error"===c.type?c.color?c.color:c._colorSet[k%c._colorSet.length]:d.color?d.color:c.color?c.color:c._colorSet[b%c._colorSet.length];if(d.hasOwnProperty(a))g=d;else if(c.hasOwnProperty(a))g=c;else return"";g=g[a];null!==k&&(g=g[k]);return"x"===a?(c.axisX&&"dateTime"===c.axisX.valueType||"dateTime"===c.xValueType||d.x&&d.x.getTime)&&!c.axisX.logarithmic?
Ba(g,d.xValueFormatString?d.xValueFormatString:c.xValueFormatString?c.xValueFormatString:c.xValueFormatString=f.axisX&&f.axisX.autoValueFormatString?f.axisX.autoValueFormatString:"DD MMM YY",f._cultureInfo):da(g,d.xValueFormatString?d.xValueFormatString:c.xValueFormatString?c.xValueFormatString:c.xValueFormatString="#,##0.########",f._cultureInfo):"y"===a?da(g,d.yValueFormatString?d.yValueFormatString:c.yValueFormatString?c.yValueFormatString:c.yValueFormatString="#,##0.########",f._cultureInfo):
"z"===a?da(g,d.zValueFormatString?d.zValueFormatString:c.zValueFormatString?c.zValueFormatString:c.zValueFormatString="#,##0.########",f._cultureInfo):g})};oa(K,G);K.prototype.setLayout=function(){var a=this.dockInsidePlotArea?this.chart.plotArea:this.chart,d=a.layoutManager.getFreeSpace(),c=null,b=0,e=0,f=0,l=0,h=this.markerMargin=this.chart.options.legend&&!r(this.chart.options.legend.markerMargin)?this.chart.options.legend.markerMargin:0.3*this.fontSize;this.height=0;var p=[],k=[];if("top"===this.verticalAlign||
"bottom"===this.verticalAlign)this.orientation="horizontal",c=this.verticalAlign,f=this.maxWidth=null!==this.maxWidth?this.maxWidth:d.width,l=this.maxHeight=null!==this.maxHeight?this.maxHeight:0.5*d.height;else if("center"===this.verticalAlign){this.orientation="vertical";if("left"===this.horizontalAlign||"center"===this.horizontalAlign||"right"===this.horizontalAlign)c=this.horizontalAlign;f=this.maxWidth=null!==this.maxWidth?this.maxWidth:0.5*d.width;l=this.maxHeight=null!==this.maxHeight?this.maxHeight:
d.height}this.errorMarkerColor=[];for(var m=0;m<this.dataSeries.length;m++){var n=this.dataSeries[m];if(n.dataPoints&&n.dataPoints.length)if("pie"!==n.type&&"doughnut"!==n.type&&"funnel"!==n.type&&"pyramid"!==n.type){var q=n.legendMarkerType=n.legendMarkerType?n.legendMarkerType:"line"!==n.type&&"stepLine"!==n.type&&"spline"!==n.type&&"scatter"!==n.type&&"bubble"!==n.type||!n.markerType?"error"===n.type&&n._linkedSeries?n._linkedSeries.legendMarkerType?n._linkedSeries.legendMarkerType:Q.getDefaultLegendMarker(n._linkedSeries.type):
Q.getDefaultLegendMarker(n.type):n.markerType,g=n.legendText?n.legendText:this.itemTextFormatter?this.itemTextFormatter({chart:this.chart,legend:this.options,dataSeries:n,dataPoint:null}):n.name,s=n.legendMarkerColor=n.legendMarkerColor?n.legendMarkerColor:n.markerColor?n.markerColor:"error"===n.type?r(n.whiskerColor)?n._colorSet[0]:n.whiskerColor:n._colorSet[0],w=n.markerSize||"line"!==n.type&&"stepLine"!==n.type&&"spline"!==n.type?0.75*this.lineHeight:0,v=n.legendMarkerBorderColor?n.legendMarkerBorderColor:
n.markerBorderColor,u=n.legendMarkerBorderThickness?n.legendMarkerBorderThickness:n.markerBorderThickness?Math.max(1,Math.round(0.2*w)):0;"error"===n.type&&this.errorMarkerColor.push(s);g=this.chart.replaceKeywordsWithValue(g,n.dataPoints[0],n,m);q={markerType:q,markerColor:s,text:g,textBlock:null,chartType:n.type,markerSize:w,lineColor:n._colorSet[0],dataSeriesIndex:n.index,dataPointIndex:null,markerBorderColor:v,markerBorderThickness:u};p.push(q)}else for(var y=0;y<n.dataPoints.length;y++){var x=
n.dataPoints[y],q=x.legendMarkerType?x.legendMarkerType:n.legendMarkerType?n.legendMarkerType:Q.getDefaultLegendMarker(n.type),g=x.legendText?x.legendText:n.legendText?n.legendText:this.itemTextFormatter?this.itemTextFormatter({chart:this.chart,legend:this.options,dataSeries:n,dataPoint:x}):x.name?x.name:"DataPoint: "+(y+1),s=x.legendMarkerColor?x.legendMarkerColor:n.legendMarkerColor?n.legendMarkerColor:x.color?x.color:n.color?n.color:n._colorSet[y%n._colorSet.length],w=0.75*this.lineHeight,v=x.legendMarkerBorderColor?
x.legendMarkerBorderColor:n.legendMarkerBorderColor?n.legendMarkerBorderColor:x.markerBorderColor?x.markerBorderColor:n.markerBorderColor,u=x.legendMarkerBorderThickness?x.legendMarkerBorderThickness:n.legendMarkerBorderThickness?n.legendMarkerBorderThickness:x.markerBorderThickness||n.markerBorderThickness?Math.max(1,Math.round(0.2*w)):0,g=this.chart.replaceKeywordsWithValue(g,x,n,y),q={markerType:q,markerColor:s,text:g,textBlock:null,chartType:n.type,markerSize:w,dataSeriesIndex:m,dataPointIndex:y,
markerBorderColor:v,markerBorderThickness:u};(x.showInLegend||n.showInLegend&&!1!==x.showInLegend)&&p.push(q)}}!0===this.reversed&&p.reverse();if(0<p.length){n=null;g=x=y=0;x=null!==this.itemWidth?null!==this.itemMaxWidth?Math.min(this.itemWidth,this.itemMaxWidth,f):this.itemMaxWidth=Math.min(this.itemWidth,f):null!==this.itemMaxWidth?Math.min(this.itemMaxWidth,f):this.itemMaxWidth=f;w=0===w?0.75*this.lineHeight:w;x=(this.itemMaxWidth?this.itemMaxWidth:x)-(w+h);for(m=0;m<p.length;m++){q=p[m];s=x;
if("line"===q.chartType||"spline"===q.chartType||"stepLine"===q.chartType)s-=2*0.1*this.lineHeight;if(!(0>=l||"undefined"===typeof l||0>=s||"undefined"===typeof s))if("horizontal"===this.orientation){q.textBlock=new ja(this.ctx,{x:0,y:0,maxWidth:s,maxHeight:this.itemWrap?l:this.lineHeight,angle:0,text:q.text,horizontalAlign:"left",fontSize:this.fontSize,fontFamily:this.fontFamily,fontWeight:this.fontWeight,fontColor:this.fontColor,fontStyle:this.fontStyle,textBaseline:"middle"});q.textBlock.measureText();
null!==this.itemWidth&&(q.textBlock.width=this.itemWidth-(w+h+("line"===q.chartType||"spline"===q.chartType||"stepLine"===q.chartType?2*0.1*this.lineHeight:0)));if(!n||n.width+Math.round(q.textBlock.width+w+h+(0===n.width?0:this.horizontalSpacing)+("line"===q.chartType||"spline"===q.chartType||"stepLine"===q.chartType?2*0.1*this.lineHeight:0))>f)n={items:[],width:0},k.push(n),this.height+=g,g=0;g=Math.max(g,q.textBlock.height?q.textBlock.height:this.lineHeight);q.textBlock.x=n.width;q.textBlock.y=
0;n.width+=Math.round(q.textBlock.width+w+h+(0===n.width?0:this.horizontalSpacing)+("line"===q.chartType||"spline"===q.chartType||"stepLine"===q.chartType?2*0.1*this.lineHeight:0));n.items.push(q);this.width=Math.max(n.width,this.width)}else q.textBlock=new ja(this.ctx,{x:0,y:0,maxWidth:x,maxHeight:!0===this.itemWrap?l:1.5*this.fontSize,angle:0,text:q.text,horizontalAlign:"left",fontSize:this.fontSize,fontFamily:this.fontFamily,fontWeight:this.fontWeight,fontColor:this.fontColor,fontStyle:this.fontStyle,
textBaseline:"middle"}),q.textBlock.measureText(),null!==this.itemWidth&&(q.textBlock.width=this.itemWidth-(w+h+("line"===q.chartType||"spline"===q.chartType||"stepLine"===q.chartType?2*0.1*this.lineHeight:0))),this.height<l-this.lineHeight?(n={items:[],width:0},k.push(n)):(n=k[y],y=(y+1)%k.length),n&&(this.height+=q.textBlock.height?q.textBlock.height:this.lineHeight,q.textBlock.x=n.width,q.textBlock.y=0,n.width+=Math.round(q.textBlock.width+w+h+(0===n.width?0:this.horizontalSpacing)+("line"===q.chartType||
"spline"===q.chartType||"stepLine"===q.chartType?2*0.1*this.lineHeight:0)),n.items.push(q),this.width=Math.max(n.width,this.width))}this.height=!1===this.itemWrap?k.length*this.lineHeight:this.height+g;this.height=Math.min(l,this.height);this.width=Math.min(f,this.width)}"top"===this.verticalAlign?(e="left"===this.horizontalAlign?d.x1:"right"===this.horizontalAlign?d.x2-this.width:d.x1+d.width/2-this.width/2,b=d.y1):"center"===this.verticalAlign?(e="left"===this.horizontalAlign?d.x1:"right"===this.horizontalAlign?
d.x2-this.width:d.x1+d.width/2-this.width/2,b=d.y1+d.height/2-this.height/2):"bottom"===this.verticalAlign&&(e="left"===this.horizontalAlign?d.x1:"right"===this.horizontalAlign?d.x2-this.width:d.x1+d.width/2-this.width/2,b=d.y2-this.height);this.items=p;for(m=0;m<this.items.length;m++)q=p[m],q.id=++this.chart._eventManager.lastObjectId,this.chart._eventManager.objectMap[q.id]={id:q.id,objectType:"legendItem",legendItemIndex:m,dataSeriesIndex:q.dataSeriesIndex,dataPointIndex:q.dataPointIndex};this.markerSize=
w;this.rows=k;0<p.length&&a.layoutManager.registerSpace(c,{width:this.width+2+2,height:this.height+5+5});this.bounds={x1:e,y1:b,x2:e+this.width,y2:b+this.height}};K.prototype.render=function(){var a=this.bounds.x1,d=this.bounds.y1,c=this.markerMargin,b=this.maxWidth,e=this.maxHeight,f=this.markerSize,l=this.rows;(0<this.borderThickness&&this.borderColor||this.backgroundColor)&&this.ctx.roundRect(a,d,this.width,this.height,this.cornerRadius,this.borderThickness,this.backgroundColor,this.borderColor);
for(var h=0,p=0;p<l.length;p++){for(var k=l[p],m=0,n=0;n<k.items.length;n++){var q=k.items[n],g=q.textBlock.x+a+(0===n?0.2*f:this.horizontalSpacing),s=d+h,r=g;this.chart.data[q.dataSeriesIndex].visible||(this.ctx.globalAlpha=0.5);this.ctx.save();this.ctx.beginPath();this.ctx.rect(a,d,b,Math.max(e-e%this.lineHeight,0));this.ctx.clip();if("line"===q.chartType||"stepLine"===q.chartType||"spline"===q.chartType)this.ctx.strokeStyle=q.lineColor,this.ctx.lineWidth=Math.ceil(this.lineHeight/8),this.ctx.beginPath(),
this.ctx.moveTo(g-0.1*this.lineHeight,s+this.lineHeight/2),this.ctx.lineTo(g+0.85*this.lineHeight,s+this.lineHeight/2),this.ctx.stroke(),r-=0.1*this.lineHeight;if("error"===q.chartType){this.ctx.strokeStyle=this.errorMarkerColor[0];this.ctx.lineWidth=f/8;this.ctx.beginPath();var w=g-0.08*this.lineHeight+0.1*this.lineHeight,u=s+0.15*this.lineHeight,y=0.7*this.lineHeight,x=y+0.02*this.lineHeight;this.ctx.moveTo(w,u);this.ctx.lineTo(w+y,u);this.ctx.stroke();this.ctx.beginPath();this.ctx.moveTo(w+y/2,
u);this.ctx.lineTo(w+y/2,u+x);this.ctx.stroke();this.ctx.beginPath();this.ctx.moveTo(w,u+x);this.ctx.lineTo(w+y,u+x);this.ctx.stroke();this.errorMarkerColor.shift()}W.drawMarker(g+f/2,s+this.lineHeight/2,this.ctx,q.markerType,"error"===q.chartType||"line"===q.chartType||"spline"===q.chartType?q.markerSize/2:q.markerSize,q.markerColor,q.markerBorderColor,q.markerBorderThickness);q.textBlock.x=g+c+f;if("line"===q.chartType||"stepLine"===q.chartType||"spline"===q.chartType)q.textBlock.x+=0.1*this.lineHeight;
q.textBlock.y=Math.round(s+this.lineHeight/2);q.textBlock.render(!0);this.ctx.restore();m=0<n?Math.max(m,q.textBlock.height?q.textBlock.height:this.lineHeight):q.textBlock.height?q.textBlock.height:this.lineHeight;this.chart.data[q.dataSeriesIndex].visible||(this.ctx.globalAlpha=1);g=X(q.id);this.ghostCtx.fillStyle=g;this.ghostCtx.beginPath();this.ghostCtx.fillRect(r,q.textBlock.y-this.lineHeight/2,q.textBlock.x+q.textBlock.width-r,q.textBlock.height?q.textBlock.height:this.lineHeight);q.x1=this.chart._eventManager.objectMap[q.id].x1=
r;q.y1=this.chart._eventManager.objectMap[q.id].y1=q.textBlock.y-this.lineHeight/2;q.x2=this.chart._eventManager.objectMap[q.id].x2=q.textBlock.x+q.textBlock.width;q.y2=this.chart._eventManager.objectMap[q.id].y2=q.textBlock.y+(q.textBlock.height?q.textBlock.height:this.lineHeight)-this.lineHeight/2}h+=m}};oa(Q,G);Q.prototype.getDefaultAxisPlacement=function(){var a=this.type;if("column"===a||"line"===a||"stepLine"===a||"spline"===a||"area"===a||"stepArea"===a||"splineArea"===a||"stackedColumn"===
a||"stackedLine"===a||"bubble"===a||"scatter"===a||"stackedArea"===a||"stackedColumn100"===a||"stackedLine100"===a||"stackedArea100"===a||"candlestick"===a||"ohlc"===a||"rangeColumn"===a||"rangeArea"===a||"rangeSplineArea"===a||"boxAndWhisker"===a||"waterfall"===a)return"normal";if("bar"===a||"stackedBar"===a||"stackedBar100"===a||"rangeBar"===a)return"xySwapped";if("pie"===a||"doughnut"===a||"funnel"===a||"pyramid"===a)return"none";"error"!==a&&window.console.log("Unknown Chart Type: "+a);return null};
Q.getDefaultLegendMarker=function(a){if("column"===a||"stackedColumn"===a||"stackedLine"===a||"bar"===a||"stackedBar"===a||"stackedBar100"===a||"bubble"===a||"scatter"===a||"stackedColumn100"===a||"stackedLine100"===a||"stepArea"===a||"candlestick"===a||"ohlc"===a||"rangeColumn"===a||"rangeBar"===a||"rangeArea"===a||"rangeSplineArea"===a||"boxAndWhisker"===a||"waterfall"===a)return"square";if("line"===a||"stepLine"===a||"spline"===a||"pie"===a||"doughnut"===a)return"circle";if("area"===a||"splineArea"===
a||"stackedArea"===a||"stackedArea100"===a||"funnel"===a||"pyramid"===a)return"triangle";if("error"===a)return"none";window.console.log("Unknown Chart Type: "+a);return null};Q.prototype.getDataPointAtX=function(a,d){if(!this.dataPoints||0===this.dataPoints.length)return null;var c={dataPoint:null,distance:Infinity,index:NaN},b=null,e=0,f=0,l=1,h=Infinity,p=0,k=0,m=0;"none"!==this.chart.plotInfo.axisPlacement&&(this.axisX.logarithmic?(m=Math.log(this.dataPoints[this.dataPoints.length-1].x/this.dataPoints[0].x),
m=1<m?Math.min(Math.max((this.dataPoints.length-1)/m*Math.log(a/this.dataPoints[0].x)>>0,0),this.dataPoints.length):0):(m=this.dataPoints[this.dataPoints.length-1].x-this.dataPoints[0].x,m=0<m?Math.min(Math.max((this.dataPoints.length-1)/m*(a-this.dataPoints[0].x)>>0,0),this.dataPoints.length):0));for(;;){f=0<l?m+e:m-e;if(0<=f&&f<this.dataPoints.length){var b=this.dataPoints[f],n=this.axisX.logarithmic?b.x>a?b.x/a:a/b.x:Math.abs(b.x-a);n<c.distance&&(c.dataPoint=b,c.distance=n,c.index=f);b=n;b<=h?
h=b:0<l?p++:k++;if(1E3<p&&1E3<k)break}else if(0>m-e&&m+e>=this.dataPoints.length)break;-1===l?(e++,l=1):l=-1}return d||(c.dataPoint.x.getTime?c.dataPoint.x.getTime():c.dataPoint.x)!==(a.getTime?a.getTime():a)?d&&null!==c.dataPoint?c:null:c};Q.prototype.getDataPointAtXY=function(a,d,c){if(!this.dataPoints||0===this.dataPoints.length||a<this.chart.plotArea.x1||a>this.chart.plotArea.x2||d<this.chart.plotArea.y1||d>this.chart.plotArea.y2)return null;c=c||!1;var b=[],e=0,f=0,l=1,h=!1,p=Infinity,k=0,m=
0,n=0;if("none"!==this.chart.plotInfo.axisPlacement)if(n=(this.chart.axisX[0]?this.chart.axisX[0]:this.chart.axisX2[0]).getXValueAt({x:a,y:d}),this.axisX.logarithmic)var q=Math.log(this.dataPoints[this.dataPoints.length-1].x/this.dataPoints[0].x),n=1<q?Math.min(Math.max((this.dataPoints.length-1)/q*Math.log(n/this.dataPoints[0].x)>>0,0),this.dataPoints.length):0;else q=this.dataPoints[this.dataPoints.length-1].x-this.dataPoints[0].x,n=0<q?Math.min(Math.max((this.dataPoints.length-1)/q*(n-this.dataPoints[0].x)>>
0,0),this.dataPoints.length):0;for(;;){f=0<l?n+e:n-e;if(0<=f&&f<this.dataPoints.length){var q=this.chart._eventManager.objectMap[this.dataPointIds[f]],g=this.dataPoints[f],s=null;if(q){switch(this.type){case "column":case "stackedColumn":case "stackedColumn100":case "bar":case "stackedBar":case "stackedBar100":case "rangeColumn":case "rangeBar":case "waterfall":case "error":a>=q.x1&&(a<=q.x2&&d>=q.y1&&d<=q.y2)&&(b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:Math.min(Math.abs(q.x1-
a),Math.abs(q.x2-a),Math.abs(q.y1-d),Math.abs(q.y2-d))}),h=!0);break;case "line":case "stepLine":case "spline":case "area":case "stepArea":case "stackedArea":case "stackedArea100":case "splineArea":case "scatter":var w=ma("markerSize",g,this)||4,v=c?20:w,s=Math.sqrt(Math.pow(q.x1-a,2)+Math.pow(q.y1-d,2));s<=v&&b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:s});q=Math.abs(q.x1-a);q<=p?p=q:0<l?k++:m++;s<=w/2&&(h=!0);break;case "rangeArea":case "rangeSplineArea":w=ma("markerSize",g,this)||
4;v=c?20:w;s=Math.min(Math.sqrt(Math.pow(q.x1-a,2)+Math.pow(q.y1-d,2)),Math.sqrt(Math.pow(q.x1-a,2)+Math.pow(q.y2-d,2)));s<=v&&b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:s});q=Math.abs(q.x1-a);q<=p?p=q:0<l?k++:m++;s<=w/2&&(h=!0);break;case "bubble":w=q.size;s=Math.sqrt(Math.pow(q.x1-a,2)+Math.pow(q.y1-d,2));s<=w/2&&(b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:s}),h=!0);break;case "pie":case "doughnut":w=q.center;v="doughnut"===this.type?q.percentInnerRadius*q.radius:
0;s=Math.sqrt(Math.pow(w.x-a,2)+Math.pow(w.y-d,2));s<q.radius&&s>v&&(s=Math.atan2(d-w.y,a-w.x),0>s&&(s+=2*Math.PI),s=Number(((180*(s/Math.PI)%360+360)%360).toFixed(12)),w=Number(((180*(q.startAngle/Math.PI)%360+360)%360).toFixed(12)),v=Number(((180*(q.endAngle/Math.PI)%360+360)%360).toFixed(12)),0===v&&1<q.endAngle&&(v=360),w>=v&&(0!==g.y&&!r(g.y))&&(v+=360,s<w&&(s+=360)),s>w&&s<v&&(b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:0}),h=!0));break;case "funnel":case "pyramid":s=q.funnelSection;
d>s.y1&&d<s.y4&&(s.y6?d>s.y6?(f=s.x6+(s.x5-s.x6)/(s.y5-s.y6)*(d-s.y6),s=s.x3+(s.x4-s.x3)/(s.y4-s.y3)*(d-s.y3)):(f=s.x1+(s.x6-s.x1)/(s.y6-s.y1)*(d-s.y1),s=s.x2+(s.x3-s.x2)/(s.y3-s.y2)*(d-s.y2)):(f=s.x1+(s.x4-s.x1)/(s.y4-s.y1)*(d-s.y1),s=s.x2+(s.x3-s.x2)/(s.y3-s.y2)*(d-s.y2)),a>f&&a<s&&(b.push({dataPoint:g,dataPointIndex:q.dataPointIndex,dataSeries:this,distance:0}),h=!0));break;case "boxAndWhisker":if(a>=q.x1-q.borderThickness/2&&a<=q.x2+q.borderThickness/2&&d>=q.y4-q.borderThickness/2&&d<=q.y1+q.borderThickness/
2||Math.abs(q.x2-a+q.x1-a)<q.borderThickness&&d>=q.y1&&d<=q.y4)b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:Math.min(Math.abs(q.x1-a),Math.abs(q.x2-a),Math.abs(q.y2-d),Math.abs(q.y3-d))}),h=!0;break;case "candlestick":if(a>=q.x1-q.borderThickness/2&&a<=q.x2+q.borderThickness/2&&d>=q.y2-q.borderThickness/2&&d<=q.y3+q.borderThickness/2||Math.abs(q.x2-a+q.x1-a)<q.borderThickness&&d>=q.y1&&d<=q.y4)b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:Math.min(Math.abs(q.x1-a),
Math.abs(q.x2-a),Math.abs(q.y2-d),Math.abs(q.y3-d))}),h=!0;break;case "ohlc":if(Math.abs(q.x2-a+q.x1-a)<q.borderThickness&&d>=q.y2&&d<=q.y3||a>=q.x1&&a<=(q.x2+q.x1)/2&&d>=q.y1-q.borderThickness/2&&d<=q.y1+q.borderThickness/2||a>=(q.x1+q.x2)/2&&a<=q.x2&&d>=q.y4-q.borderThickness/2&&d<=q.y4+q.borderThickness/2)b.push({dataPoint:g,dataPointIndex:f,dataSeries:this,distance:Math.min(Math.abs(q.x1-a),Math.abs(q.x2-a),Math.abs(q.y2-d),Math.abs(q.y3-d))}),h=!0}if(h||1E3<k&&1E3<m)break}}else if(0>n-e&&n+e>=
this.dataPoints.length)break;-1===l?(e++,l=1):l=-1}a=null;for(d=0;d<b.length;d++)a?b[d].distance<=a.distance&&(a=b[d]):a=b[d];return a};Q.prototype.getMarkerProperties=function(a,d,c,b){var e=this.dataPoints,f=e[a].markerColor?e[a].markerColor:this.markerColor?this.markerColor:e[a].color?e[a].color:this.color?this.color:this._colorSet[a%this._colorSet.length],l=e[a].markerBorderColor?e[a].markerBorderColor:this.markerBorderColor?this.markerBorderColor:null,h=r(e[a].markerBorderThickness)?this.markerBorderThickness?
this.markerBorderThickness:null:e[a].markerBorderThickness,p=e[a].markerType?e[a].markerType:this.markerType;a=r(e[a].markerSize)?this.markerSize:e[a].markerSize;return{x:d,y:c,ctx:b,type:p,size:a,color:f,borderColor:l,borderThickness:h}};oa(A,G);A.prototype.createExtraLabelsForLog=function(a){a=(a||0)+1;if(!(5<a)){var d=this.logLabelValues[0]||this.intervalStartPosition;if(Math.log(this.range)/Math.log(d/this.viewportMinimum)<this.noTicks-1){for(var c=A.getNiceNumber((d-this.viewportMinimum)/Math.min(Math.max(2,
this.noTicks-this.logLabelValues.length),3),!0),b=Math.ceil(this.viewportMinimum/c)*c;b<d;b+=c)b<this.viewportMinimum||this.logLabelValues.push(b);this.logLabelValues.sort(Ra);this.createExtraLabelsForLog(a)}}};A.prototype.createLabels=function(){var a,d,c=0,b=0,e,f=0,l=0,b=0,b=this.interval,h=0,p,k=0.6*this.chart.height,m;a=!1;var n=this.scaleBreaks?this.scaleBreaks._appliedBreaks:[],q=n.length?r(this.scaleBreaks.firstBreakIndex)?0:this.scaleBreaks.firstBreakIndex:0;if("axisX"!==this.type||"dateTime"!==
this.valueType||this.logarithmic){e=this.viewportMaximum;if(this.labels){a=Math.ceil(b);for(var b=Math.ceil(this.intervalStartPosition),g=!1,c=b;c<this.viewportMaximum;c+=a)if(this.labels[c])g=!0;else{g=!1;break}g&&(this.interval=a,this.intervalStartPosition=b)}if(this.logarithmic&&!this.equidistantInterval)for(this.logLabelValues||(this.logLabelValues=[],this.createExtraLabelsForLog()),b=0,g=q;b<this.logLabelValues.length;b++)if(c=this.logLabelValues[b],c<this.viewportMinimum)b++;else{for(;g<n.length&&
c>n[g].endValue;g++);a=g<n.length&&c>=n[g].startValue&&c<=n[g].endValue;m=c;a||(a=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.options,value:m,label:this.labels[m]?this.labels[m]:null}):"axisX"===this.type&&this.labels[m]?this.labels[m]:da(m,this.valueFormatString,this.chart._cultureInfo),a=new ja(this.ctx,{x:0,y:0,maxWidth:f,maxHeight:l,angle:this.labelAngle,text:this.prefix+a+this.suffix,backgroundColor:this.labelBackgroundColor,borderColor:this.labelBorderColor,cornerRadius:this.labelCornerRadius,
textAlign:this.labelTextAlign,fontSize:this.labelFontSize,fontFamily:this.labelFontFamily,fontWeight:this.labelFontWeight,fontColor:this.labelFontColor,fontStyle:this.labelFontStyle,textBaseline:"middle",borderThickness:0}),this._labels.push({position:m,textBlock:a,effectiveHeight:null}))}g=q;for(c=this.intervalStartPosition;c<=e;c=parseFloat(1E-12>this.interval?this.logarithmic&&this.equidistantInterval?c*Math.pow(this.logarithmBase,this.interval):c+this.interval:(this.logarithmic&&this.equidistantInterval?
c*Math.pow(this.logarithmBase,this.interval):c+this.interval).toFixed(12))){for(;g<n.length&&c>n[g].endValue;g++);a=g<n.length&&c>=n[g].startValue&&c<=n[g].endValue;m=c;a||(a=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.options,value:m,label:this.labels[m]?this.labels[m]:null}):"axisX"===this.type&&this.labels[m]?this.labels[m]:da(m,this.valueFormatString,this.chart._cultureInfo),a=new ja(this.ctx,{x:0,y:0,maxWidth:f,maxHeight:l,angle:this.labelAngle,text:this.prefix+a+this.suffix,
textAlign:this.labelTextAlign,backgroundColor:this.labelBackgroundColor,borderColor:this.labelBorderColor,borderThickness:this.labelBorderThickness,cornerRadius:this.labelCornerRadius,fontSize:this.labelFontSize,fontFamily:this.labelFontFamily,fontWeight:this.labelFontWeight,fontColor:this.labelFontColor,fontStyle:this.labelFontStyle,textBaseline:"middle"}),this._labels.push({position:m,textBlock:a,effectiveHeight:null}))}}else for(this.intervalStartPosition=this.getLabelStartPoint(new Date(this.viewportMinimum),
this.intervalType,this.interval),e=Xa(new Date(this.viewportMaximum),this.interval,this.intervalType),g=q,c=this.intervalStartPosition;c<e;Xa(c,b,this.intervalType)){for(a=c.getTime();g<n.length&&a>n[g].endValue;g++);m=a;a=g<n.length&&a>=n[g].startValue&&a<=n[g].endValue;a||(a=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.options,value:new Date(m),label:this.labels[m]?this.labels[m]:null}):"axisX"===this.type&&this.labels[m]?this.labels[m]:Ba(m,this.valueFormatString,this.chart._cultureInfo),
a=new ja(this.ctx,{x:0,y:0,maxWidth:f,backgroundColor:this.labelBackgroundColor,borderColor:this.labelBorderColor,borderThickness:this.labelBorderThickness,cornerRadius:this.labelCornerRadius,maxHeight:l,angle:this.labelAngle,text:this.prefix+a+this.suffix,textAlign:this.labelTextAlign,fontSize:this.labelFontSize,fontFamily:this.labelFontFamily,fontWeight:this.labelFontWeight,fontColor:this.labelFontColor,fontStyle:this.labelFontStyle,textBaseline:"middle"}),this._labels.push({position:m,textBlock:a,
effectiveHeight:null,breaksLabelType:void 0}))}if("bottom"===this._position||"top"===this._position)h=this.logarithmic&&!this.equidistantInterval&&2<=this._labels.length?this.lineCoordinates.width*Math.log(Math.min(this._labels[this._labels.length-1].position/this._labels[this._labels.length-2].position,this._labels[1].position/this._labels[0].position))/Math.log(this.range):this.lineCoordinates.width/(this.logarithmic&&this.equidistantInterval?Math.log(this.range)/Math.log(this.logarithmBase):Math.abs(this.range))*
T[this.intervalType+"Duration"]*this.interval,f="undefined"===typeof this.options.labelMaxWidth?0.5*this.chart.width>>0:this.options.labelMaxWidth,this.chart.panEnabled||(l="undefined"===typeof this.options.labelWrap||this.labelWrap?0.8*this.chart.height>>0:1.5*this.labelFontSize);else if("left"===this._position||"right"===this._position)h=this.logarithmic&&!this.equidistantInterval&&2<=this._labels.length?this.lineCoordinates.height*Math.log(Math.min(this._labels[this._labels.length-1].position/
this._labels[this._labels.length-2].position,this._labels[1].position/this._labels[0].position))/Math.log(this.range):this.lineCoordinates.height/(this.logarithmic&&this.equidistantInterval?Math.log(this.range)/Math.log(this.logarithmBase):Math.abs(this.range))*T[this.intervalType+"Duration"]*this.interval,this.chart.panEnabled||(f="undefined"===typeof this.options.labelMaxWidth?0.3*this.chart.width>>0:this.options.labelMaxWidth),l="undefined"===typeof this.options.labelWrap||this.labelWrap?0.3*this.chart.height>>
0:1.5*this.labelFontSize;for(b=0;b<this._labels.length;b++){a=this._labels[b].textBlock;a.maxWidth=f;a.maxHeight=l;var s=a.measureText();p=s.height}e=[];q=n=0;if(this.labelAutoFit||this.options.labelAutoFit)if(r(this.labelAngle)||(this.labelAngle=(this.labelAngle%360+360)%360,90<this.labelAngle&&270>this.labelAngle?this.labelAngle-=180:270<=this.labelAngle&&360>=this.labelAngle&&(this.labelAngle-=360)),"bottom"===this._position||"top"===this._position)if(f=0.9*h>>0,q=0,!this.chart.panEnabled&&1<=
this._labels.length){this.sessionVariables.labelFontSize=this.labelFontSize;this.sessionVariables.labelMaxWidth=f;this.sessionVariables.labelMaxHeight=l;this.sessionVariables.labelAngle=this.labelAngle;this.sessionVariables.labelWrap=this.labelWrap;for(c=0;c<this._labels.length;c++)if(!this._labels[c].breaksLabelType){a=this._labels[c].textBlock;for(var v,g=a.text.split(" "),b=0;b<g.length;b++)m=g[b],this.ctx.font=a.fontStyle+" "+a.fontWeight+" "+a.fontSize+"px "+a.fontFamily,m=this.ctx.measureText(m),
m.width>q&&(v=c,q=m.width)}c=0;for(c=this.intervalStartPosition<this.viewportMinimum?1:0;c<this._labels.length;c++)if(!this._labels[c].breaksLabelType){a=this._labels[c].textBlock;s=a.measureText();for(g=c+1;g<this._labels.length;g++)if(!this._labels[g].breaksLabelType){d=this._labels[g].textBlock;d=d.measureText();break}e.push(a.height);this.sessionVariables.labelMaxHeight=Math.max.apply(Math,e);Math.cos(Math.PI/180*Math.abs(this.labelAngle));Math.sin(Math.PI/180*Math.abs(this.labelAngle));b=f*Math.sin(Math.PI/
180*Math.abs(this.labelAngle))+(l-a.fontSize/2)*Math.cos(Math.PI/180*Math.abs(this.labelAngle));if(r(this.options.labelAngle)&&isNaN(this.options.labelAngle)&&0!==this.options.labelAngle)if(this.sessionVariables.labelMaxHeight=0===this.labelAngle?l:Math.min((b-f*Math.cos(Math.PI/180*Math.abs(this.labelAngle)))/Math.sin(Math.PI/180*Math.abs(this.labelAngle)),b),m=(k-(p+a.fontSize/2)*Math.cos(Math.PI/180*Math.abs(-25)))/Math.sin(Math.PI/180*Math.abs(-25)),!r(this.options.labelWrap))this.labelWrap?r(this.options.labelMaxWidth)?
(this.sessionVariables.labelMaxWidth=Math.min(Math.max(f,q),m),this.sessionVariables.labelWrap=this.labelWrap,d&&s.width+d.width>>0>2*f&&(this.sessionVariables.labelAngle=-25)):(this.sessionVariables.labelWrap=this.labelWrap,this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth,this.sessionVariables.labelAngle=this.sessionVariables.labelMaxWidth>f?-25:this.sessionVariables.labelAngle):r(this.options.labelMaxWidth)?(this.sessionVariables.labelWrap=this.labelWrap,this.sessionVariables.labelMaxHeight=
l,this.sessionVariables.labelMaxWidth=f,d&&s.width+d.width>>0>2*f&&(this.sessionVariables.labelAngle=-25,this.sessionVariables.labelMaxWidth=m)):(this.sessionVariables.labelAngle=this.sessionVariables.labelMaxWidth>f?-25:this.sessionVariables.labelAngle,this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth,this.sessionVariables.labelMaxHeight=l,this.sessionVariables.labelWrap=this.labelWrap);else{if(r(this.options.labelWrap))if(!r(this.options.labelMaxWidth))this.options.labelMaxWidth<f?
(this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth,this.sessionVariables.labelMaxHeight=b):(this.sessionVariables.labelAngle=-25,this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth,this.sessionVariables.labelMaxHeight=l);else if(!r(d))if(b=s.width+d.width>>0,g=this.labelFontSize,q<f)b-2*f>n&&(n=b-2*f,b>=2*f&&b<2.2*f?(this.sessionVariables.labelMaxWidth=f,r(this.options.labelFontSize)&&12<g&&(g=Math.floor(12/13*g),a.measureText()),this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?
g:this.options.labelFontSize,this.sessionVariables.labelAngle=this.labelAngle):b>=2.2*f&&b<2.8*f?(this.sessionVariables.labelAngle=-25,this.sessionVariables.labelMaxWidth=m,this.sessionVariables.labelFontSize=g):b>=2.8*f&&b<3.2*f?(this.sessionVariables.labelMaxWidth=Math.max(f,q),this.sessionVariables.labelWrap=!0,r(this.options.labelFontSize)&&12<this.labelFontSize&&(this.labelFontSize=Math.floor(12/13*this.labelFontSize),a.measureText()),this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?
g:this.options.labelFontSize,this.sessionVariables.labelAngle=this.labelAngle):b>=3.2*f&&b<3.6*f?(this.sessionVariables.labelAngle=-25,this.sessionVariables.labelWrap=!0,this.sessionVariables.labelMaxWidth=m,this.sessionVariables.labelFontSize=this.labelFontSize):b>3.6*f&&b<5*f?(r(this.options.labelFontSize)&&12<g&&(g=Math.floor(12/13*g),a.measureText()),this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?g:this.options.labelFontSize,this.sessionVariables.labelWrap=!0,this.sessionVariables.labelAngle=
-25,this.sessionVariables.labelMaxWidth=m):b>5*f&&(this.sessionVariables.labelWrap=!0,this.sessionVariables.labelMaxWidth=f,this.sessionVariables.labelFontSize=g,this.sessionVariables.labelMaxHeight=l,this.sessionVariables.labelAngle=this.labelAngle));else if(v===c&&(0===v&&q+this._labels[v+1].textBlock.measureText().width-2*f>n||v===this._labels.length-1&&q+this._labels[v-1].textBlock.measureText().width-2*f>n||0<v&&v<this._labels.length-1&&q+this._labels[v+1].textBlock.measureText().width-2*f>n&&
q+this._labels[v-1].textBlock.measureText().width-2*f>n))n=0===v?q+this._labels[v+1].textBlock.measureText().width-2*f:q+this._labels[v-1].textBlock.measureText().width-2*f,this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?g:this.options.labelFontSize,this.sessionVariables.labelWrap=!0,this.sessionVariables.labelAngle=-25,this.sessionVariables.labelMaxWidth=m;else if(0===n)for(this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?g:this.options.labelFontSize,this.sessionVariables.labelWrap=
!0,b=0;b<this._labels.length;b++)a=this._labels[b].textBlock,a.maxWidth=this.sessionVariables.labelMaxWidth=Math.min(Math.max(f,q),m),s=a.measureText(),b<this._labels.length-1&&(g=b+1,d=this._labels[g].textBlock,d.maxWidth=this.sessionVariables.labelMaxWidth=Math.min(Math.max(f,q),m),d=d.measureText(),s.width+d.width>>0>2*f&&(this.sessionVariables.labelAngle=-25))}else(this.sessionVariables.labelAngle=this.labelAngle,this.sessionVariables.labelMaxHeight=0===this.labelAngle?l:Math.min((b-f*Math.cos(Math.PI/
180*Math.abs(this.labelAngle)))/Math.sin(Math.PI/180*Math.abs(this.labelAngle)),b),m=0!=this.labelAngle?(k-(p+a.fontSize/2)*Math.cos(Math.PI/180*Math.abs(this.labelAngle)))/Math.sin(Math.PI/180*Math.abs(this.labelAngle)):f,this.sessionVariables.labelMaxHeight=this.labelWrap?(k-m*Math.sin(Math.PI/180*Math.abs(this.labelAngle)))/Math.cos(Math.PI/180*Math.abs(this.labelAngle)):1.5*this.labelFontSize,r(this.options.labelWrap))?r(this.options.labelWrap)&&(this.labelWrap&&!r(this.options.labelMaxWidth)?
(this.sessionVariables.labelWrap=this.labelWrap,this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth?this.options.labelMaxWidth:m,this.sessionVariables.labelMaxHeight=l):(this.sessionVariables.labelAngle=this.labelAngle,this.sessionVariables.labelMaxWidth=m,this.sessionVariables.labelMaxHeight=b<0.9*h?0.9*h:b,this.sessionVariables.labelWrap=this.labelWrap)):(this.options.labelWrap?(this.sessionVariables.labelWrap=this.labelWrap,this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth?
this.options.labelMaxWidth:m):(r(this.options.labelMaxWidth),this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth?this.options.labelMaxWidth:m,this.sessionVariables.labelWrap=this.labelWrap),this.sessionVariables.labelMaxHeight=l)}for(b=0;b<this._labels.length;b++)a=this._labels[b].textBlock,a.maxWidth=this.labelMaxWidth=this.sessionVariables.labelMaxWidth,a.fontSize=this.sessionVariables.labelFontSize,a.angle=this.labelAngle=this.sessionVariables.labelAngle,a.wrap=this.labelWrap=this.sessionVariables.labelWrap,
a.maxHeight=this.sessionVariables.labelMaxHeight,a.measureText()}else for(c=0;c<this._labels.length;c++)a=this._labels[c].textBlock,a.maxWidth=this.labelMaxWidth=r(this.options.labelMaxWidth)?r(this.sessionVariables.labelMaxWidth)?this.sessionVariables.labelMaxWidth=f:this.sessionVariables.labelMaxWidth:this.options.labelMaxWidth,a.fontSize=this.labelFontSize=r(this.options.labelFontSize)?r(this.sessionVariables.labelFontSize)?this.sessionVariables.labelFontSize=this.labelFontSize:this.sessionVariables.labelFontSize:
this.options.labelFontSize,a.angle=this.labelAngle=r(this.options.labelAngle)?r(this.sessionVariables.labelAngle)?this.sessionVariables.labelAngle=this.labelAngle:this.sessionVariables.labelAngle:this.labelAngle,a.wrap=this.labelWrap=r(this.options.labelWrap)?r(this.sessionVariables.labelWrap)?this.sessionVariables.labelWrap=this.labelWrap:this.sessionVariables.labelWrap:this.options.labelWrap,a.maxHeight=r(this.sessionVariables.labelMaxHeight)?this.sessionVariables.labelMaxHeight=l:this.sessionVariables.labelMaxHeight,
a.measureText();else if("left"===this._position||"right"===this._position)if(f=r(this.options.labelMaxWidth)?0.3*this.chart.width>>0:this.options.labelMaxWidth,l="undefined"===typeof this.options.labelWrap||this.labelWrap?0.3*this.chart.height>>0:1.5*this.labelFontSize,!this.chart.panEnabled&&1<=this._labels.length){this.sessionVariables.labelFontSize=this.labelFontSize;this.sessionVariables.labelMaxWidth=f;this.sessionVariables.labelMaxHeight=l;this.sessionVariables.labelAngle=r(this.sessionVariables.labelAngle)?
0:this.sessionVariables.labelAngle;this.sessionVariables.labelWrap=this.labelWrap;for(c=0;c<this._labels.length;c++)if(!this._labels[c].breaksLabelType){a=this._labels[c].textBlock;s=a.measureText();for(g=c+1;g<this._labels.length;g++)if(!this._labels[g].breaksLabelType){d=this._labels[g].textBlock;d=d.measureText();break}e.push(a.height);this.sessionVariables.labelMaxHeight=Math.max.apply(Math,e);b=f*Math.sin(Math.PI/180*Math.abs(this.labelAngle))+(l-a.fontSize/2)*Math.cos(Math.PI/180*Math.abs(this.labelAngle));
Math.cos(Math.PI/180*Math.abs(this.labelAngle));Math.sin(Math.PI/180*Math.abs(this.labelAngle));r(this.options.labelAngle)&&isNaN(this.options.labelAngle)&&0!==this.options.labelAngle?r(this.options.labelWrap)?r(this.options.labelWrap)&&(r(this.options.labelMaxWidth)?r(d)||(h=s.height+d.height>>0,h-2*l>q&&(q=h-2*l,h>=2*l&&h<2.4*l?(r(this.options.labelFontSize)&&12<this.labelFontSize&&(this.labelFontSize=Math.floor(12/13*this.labelFontSize),a.measureText()),this.sessionVariables.labelMaxHeight=l,this.sessionVariables.labelFontSize=
r(this.options.labelFontSize)?this.labelFontSize:this.options.labelFontSize):h>=2.4*l&&h<2.8*l?(this.sessionVariables.labelMaxHeight=b,this.sessionVariables.labelFontSize=this.labelFontSize,this.sessionVariables.labelWrap=!0):h>=2.8*l&&h<3.2*l?(this.sessionVariables.labelMaxHeight=l,this.sessionVariables.labelWrap=!0,r(this.options.labelFontSize)&&12<this.labelFontSize&&(this.labelFontSize=Math.floor(12/13*this.labelFontSize),a.measureText()),this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?
this.labelFontSize:this.options.labelFontSize,this.sessionVariables.labelAngle=r(this.sessionVariables.labelAngle)?0:this.sessionVariables.labelAngle):h>=3.2*l&&h<3.6*l?(this.sessionVariables.labelMaxHeight=b,this.sessionVariables.labelWrap=!0,this.sessionVariables.labelFontSize=this.labelFontSize):h>3.6*l&&h<10*l?(r(this.options.labelFontSize)&&12<this.labelFontSize&&(this.labelFontSize=Math.floor(12/13*this.labelFontSize),a.measureText()),this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?
this.labelFontSize:this.options.labelFontSize,this.sessionVariables.labelMaxWidth=f,this.sessionVariables.labelMaxHeight=l,this.sessionVariables.labelAngle=r(this.sessionVariables.labelAngle)?0:this.sessionVariables.labelAngle):h>10*l&&h<50*l&&(r(this.options.labelFontSize)&&12<this.labelFontSize&&(this.labelFontSize=Math.floor(12/13*this.labelFontSize),a.measureText()),this.sessionVariables.labelFontSize=r(this.options.labelFontSize)?this.labelFontSize:this.options.labelFontSize,this.sessionVariables.labelMaxHeight=
l,this.sessionVariables.labelMaxWidth=f,this.sessionVariables.labelAngle=r(this.sessionVariables.labelAngle)?0:this.sessionVariables.labelAngle))):(this.sessionVariables.labelMaxHeight=l,this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth?this.options.labelMaxWidth:this.sessionVariables.labelMaxWidth)):(this.sessionVariables.labelMaxWidth=this.labelWrap?this.options.labelMaxWidth?this.options.labelMaxWidth:this.sessionVariables.labelMaxWidth:this.labelMaxWidth?this.options.labelMaxWidth?
this.options.labelMaxWidth:this.sessionVariables.labelMaxWidth:f,this.sessionVariables.labelMaxHeight=l):(this.sessionVariables.labelAngle=this.labelAngle,this.sessionVariables.labelMaxWidth=0===this.labelAngle?f:Math.min((b-l*Math.sin(Math.PI/180*Math.abs(this.labelAngle)))/Math.cos(Math.PI/180*Math.abs(this.labelAngle)),l),r(this.options.labelWrap))?r(this.options.labelWrap)&&(this.labelWrap&&!r(this.options.labelMaxWidth)?(this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth?this.options.labelMaxWidth:
this.sessionVariables.labelMaxWidth,this.sessionVariables.labelWrap=this.labelWrap,this.sessionVariables.labelMaxHeight=b):(this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth?this.options.labelMaxWidth:f,this.sessionVariables.labelMaxHeight=0===this.labelAngle?l:b,r(this.options.labelMaxWidth)&&(this.sessionVariables.labelAngle=this.labelAngle))):this.options.labelWrap?(this.sessionVariables.labelMaxHeight=0===this.labelAngle?l:b,this.sessionVariables.labelWrap=this.labelWrap,this.sessionVariables.labelMaxWidth=
f):(this.sessionVariables.labelMaxHeight=l,r(this.options.labelMaxWidth),this.sessionVariables.labelMaxWidth=this.options.labelMaxWidth?this.options.labelMaxWidth:this.sessionVariables.labelMaxWidth,this.sessionVariables.labelWrap=this.labelWrap)}for(b=0;b<this._labels.length;b++)a=this._labels[b].textBlock,a.maxWidth=this.labelMaxWidth=this.sessionVariables.labelMaxWidth,a.fontSize=this.labelFontSize=this.sessionVariables.labelFontSize,a.angle=this.labelAngle=this.sessionVariables.labelAngle,a.wrap=
this.labelWrap=this.sessionVariables.labelWrap,a.maxHeight=this.sessionVariables.labelMaxHeight,a.measureText()}else for(c=0;c<this._labels.length;c++)a=this._labels[c].textBlock,a.maxWidth=this.labelMaxWidth=r(this.options.labelMaxWidth)?r(this.sessionVariables.labelMaxWidth)?this.sessionVariables.labelMaxWidth=f:this.sessionVariables.labelMaxWidth:this.options.labelMaxWidth,a.fontSize=this.labelFontSize=r(this.options.labelFontSize)?r(this.sessionVariables.labelFontSize)?this.sessionVariables.labelFontSize=
this.labelFontSize:this.sessionVariables.labelFontSize:this.options.labelFontSize,a.angle=this.labelAngle=r(this.options.labelAngle)?r(this.sessionVariables.labelAngle)?this.sessionVariables.labelAngle=this.labelAngle:this.sessionVariables.labelAngle:this.labelAngle,a.wrap=this.labelWrap=r(this.options.labelWrap)?r(this.sessionVariables.labelWrap)?this.sessionVariables.labelWrap=this.labelWrap:this.sessionVariables.labelWrap:this.options.labelWrap,a.maxHeight=r(this.sessionVariables.labelMaxHeight)?
this.sessionVariables.labelMaxHeight=l:this.sessionVariables.labelMaxHeight,a.measureText();for(c=0;c<this.stripLines.length;c++){var f=this.stripLines[c],A;if("outside"===f.labelPlacement){l=this.sessionVariables.labelMaxWidth;if("bottom"===this._position||"top"===this._position)r(f.options.labelWrap)&&!r(this.sessionVariables.stripLineLabelMaxHeight)?A=this.sessionVariables.stripLineLabelMaxHeight:this.sessionVariables.stripLineLabelMaxHeight=A=f.labelWrap?0.8*this.chart.height>>0:1.5*this.labelFontSize;
if("left"===this._position||"right"===this._position)r(f.options.labelWrap)&&!r(this.sessionVariables.stripLineLabelMaxHeight)?A=this.sessionVariables.stripLineLabelMaxHeight:this.sessionVariables.stripLineLabelMaxHeight=A=f.labelWrap?0.8*this.chart.width>>0:1.5*this.labelFontSize;r(f.labelBackgroundColor)&&(f.labelBackgroundColor="#EEEEEE")}else l="bottom"===this._position||"top"===this._position?0.9*this.chart.width>>0:0.9*this.chart.height>>0,A=r(f.options.labelWrap)||f.labelWrap?"bottom"===this._position||
"top"===this._position?0.8*this.chart.width>>0:0.8*this.chart.height>>0:1.5*this.labelFontSize,r(f.labelBackgroundColor)&&(r(f.startValue)&&0!==f.startValue?f.labelBackgroundColor=w?"transparent":null:f.labelBackgroundColor="#EEEEEE");a=new ja(this.ctx,{x:0,y:0,backgroundColor:f.labelBackgroundColor,borderColor:f.labelBorderColor,borderThickness:f.labelBorderThickness,cornerRadius:f.labelCornerRadius,maxWidth:f.options.labelMaxWidth?f.options.labelMaxWidth:l,maxHeight:A,angle:this.labelAngle,text:f.labelFormatter?
f.labelFormatter({chart:this.chart,axis:this,stripLine:f}):f.label,textAlign:this.labelTextAlign,fontSize:"outside"===f.labelPlacement?f.options.labelFontSize?f.labelFontSize:this.labelFontSize:f.labelFontSize,fontFamily:"outside"===f.labelPlacement?f.options.labelFontFamily?f.labelFontFamily:this.labelFontFamily:f.labelFontFamily,fontWeight:"outside"===f.labelPlacement?f.options.labelFontWeight?f.labelFontWeight:this.labelFontWeight:f.labelFontWeight,fontColor:f.labelFontColor||f.color,fontStyle:"outside"===
f.labelPlacement?f.options.labelFontStyle?f.labelFontStyle:this.fontWeight:f.labelFontStyle,textBaseline:"middle"});this._stripLineLabels.push({position:f.value,textBlock:a,effectiveHeight:null,stripLine:f})}};A.prototype.createLabelsAndCalculateWidth=function(){var a=0,d=0;this._labels=[];this._stripLineLabels=[];var c=this.chart.isNavigator?0:5;if("left"===this._position||"right"===this._position){this.createLabels();if("inside"!=this.labelPlacement||"inside"===this.labelPlacement&&0<this._index)for(d=
0;d<this._labels.length;d++){var b=this._labels[d].textBlock,e=b.measureText(),f=0,f=0===this.labelAngle?e.width:e.width*Math.cos(Math.PI/180*Math.abs(this.labelAngle))+(e.height-b.fontSize/2)*Math.sin(Math.PI/180*Math.abs(this.labelAngle));a<f&&(this.labelEffectiveWidth=a=f);this._labels[d].effectiveWidth=f}for(d=0;d<this._stripLineLabels.length;d++)"outside"===this._stripLineLabels[d].stripLine.labelPlacement&&(this._stripLineLabels[d].stripLine.value>=this.viewportMinimum&&this._stripLineLabels[d].stripLine.value<=
this.viewportMaximum)&&(b=this._stripLineLabels[d].textBlock,e=b.measureText(),f=0===this.labelAngle?e.width:e.width*Math.cos(Math.PI/180*Math.abs(this.labelAngle))+(e.height-b.fontSize/2)*Math.sin(Math.PI/180*Math.abs(this.labelAngle)),"inside"===this.tickPlacement&&(f+=this.tickLength),"inside"===this.labelPlacement&&(a+=0<this._index?f:0),a<f&&(a=f),this.stripLineLabelEffectiveWidth=this._stripLineLabels[d].effectiveWidth=f)}return(this.title?this._titleTextBlock.measureText().height+2:0)+a+("inside"===
this.tickPlacement?0<this._index?this.tickLength:0:this.tickLength)+c};A.prototype.createLabelsAndCalculateHeight=function(){var a=0;this._labels=[];this._stripLineLabels=[];var d,c=0,b=this.chart.isNavigator?0:5;if("bottom"===this._position||"top"===this._position){this.createLabels();if("inside"!=this.labelPlacement||"inside"===this.labelPlacement&&0<this._index)for(c=0;c<this._labels.length;c++){d=this._labels[c].textBlock;var e=d.measureText(),f=0,f=0===this.labelAngle?e.height:e.width*Math.sin(Math.PI/
180*Math.abs(this.labelAngle))+(e.height-d.fontSize/2)*Math.cos(Math.PI/180*Math.abs(this.labelAngle));a<f&&(this.labelEffectiveHeight=a=f);this._labels[c].effectiveHeight=f}for(c=0;c<this._stripLineLabels.length;c++)"outside"===this._stripLineLabels[c].stripLine.labelPlacement&&(this._stripLineLabels[c].stripLine.value>=this.viewportMinimum&&this._stripLineLabels[c].stripLine.value<=this.viewportMaximum)&&(d=this._stripLineLabels[c].textBlock,e=d.measureText(),f=0===this.labelAngle?e.height:e.width*
Math.sin(Math.PI/180*Math.abs(this.labelAngle))+(e.height-d.fontSize/2)*Math.cos(Math.PI/180*Math.abs(this.labelAngle)),"inside"===this.tickPlacement&&(f+=this.tickLength),"inside"===this.labelPlacement&&(a+=0<this._index?f:0),a<f&&(a=f),this.stripLineLabelEffectiveHeight=this._stripLineLabels[c].effectiveHeight=f)}return(this.title?this._titleTextBlock.measureText().height+2:0)+a+("inside"===this.tickPlacement?0<this._index?this.tickLength:0:this.tickLength)+b};A.setLayout=function(a,d,c,b,e,f){var l,
h,p,k,m=a[0]?a[0].chart:d[0].chart,n=m.isNavigator?0:10,q=m._axes;if(a&&0<a.length)for(var g=0;g<a.length;g++)a[g]&&a[g].calculateAxisParameters();if(d&&0<d.length)for(g=0;g<d.length;g++)d[g].calculateAxisParameters();if(c&&0<c.length)for(g=0;g<c.length;g++)c[g].calculateAxisParameters();if(b&&0<b.length)for(g=0;g<b.length;g++)b[g].calculateAxisParameters();for(g=0;g<q.length;g++)if(q[g]&&q[g].scaleBreaks&&q[g].scaleBreaks._appliedBreaks.length)for(var s=q[g].scaleBreaks._appliedBreaks,w=0;w<s.length&&
!(s[w].startValue>q[g].viewportMaximum);w++)s[w].endValue<q[g].viewportMinimum||(r(q[g].scaleBreaks.firstBreakIndex)&&(q[g].scaleBreaks.firstBreakIndex=w),s[w].startValue>=q[g].viewPortMinimum&&(q[g].scaleBreaks.lastBreakIndex=w));for(var v=w=0,u=0,y=0,x=0,z=0,A=0,D,B,E=h=0,G,J,K,s=G=J=K=!1,g=0;g<q.length;g++)q[g]&&q[g].title&&(q[g]._titleTextBlock=new ja(q[g].ctx,{text:q[g].title,horizontalAlign:"center",fontSize:q[g].titleFontSize,fontFamily:q[g].titleFontFamily,fontWeight:q[g].titleFontWeight,
fontColor:q[g].titleFontColor,fontStyle:q[g].titleFontStyle,borderColor:q[g].titleBorderColor,borderThickness:q[g].titleBorderThickness,backgroundColor:q[g].titleBackgroundColor,cornerRadius:q[g].titleCornerRadius,textBaseline:"top"}));for(g=0;g<q.length;g++)if(q[g].title)switch(q[g]._position){case "left":q[g]._titleTextBlock.maxWidth=q[g].titleMaxWidth||f.height;q[g]._titleTextBlock.maxHeight=q[g].titleWrap?0.8*f.width:1.5*q[g].titleFontSize;q[g]._titleTextBlock.angle=-90;break;case "right":q[g]._titleTextBlock.maxWidth=
q[g].titleMaxWidth||f.height;q[g]._titleTextBlock.maxHeight=q[g].titleWrap?0.8*f.width:1.5*q[g].titleFontSize;q[g]._titleTextBlock.angle=90;break;default:q[g]._titleTextBlock.maxWidth=q[g].titleMaxWidth||f.width,q[g]._titleTextBlock.maxHeight=q[g].titleWrap?0.8*f.height:1.5*q[g].titleFontSize,q[g]._titleTextBlock.angle=0}if("normal"===e){for(var y=[],x=[],z=[],A=[],M=[],Q=[],N=[],P=[];4>w;){var F=0,X=0,T=0,U=0,V=e=0,O=0,Z=0,W=0,Y=0,R=0,aa=0;if(c&&0<c.length)for(z=[],g=R=0;g<c.length;g++)z.push(Math.ceil(c[g]?
c[g].createLabelsAndCalculateWidth():0)),R+=z[g],O+=c[g]&&!m.isNavigator?c[g].margin:0;else z.push(Math.ceil(c[0]?c[0].createLabelsAndCalculateWidth():0));N.push(z);if(b&&0<b.length)for(A=[],g=aa=0;g<b.length;g++)A.push(Math.ceil(b[g]?b[g].createLabelsAndCalculateWidth():0)),aa+=A[g],Z+=b[g]?b[g].margin:0;else A.push(Math.ceil(b[0]?b[0].createLabelsAndCalculateWidth():0));P.push(A);l=Math.round(f.x1+R+O);p=Math.round(f.x2-aa-Z>m.width-n?m.width-n:f.x2-aa-Z);if(a&&0<a.length)for(y=[],g=W=0;g<a.length;g++)a[g]&&
(a[g].lineCoordinates={}),a[g].lineCoordinates.width=Math.abs(p-l),a[g].title&&(a[g]._titleTextBlock.maxWidth=0<a[g].titleMaxWidth&&a[g].titleMaxWidth<a[g].lineCoordinates.width?a[g].titleMaxWidth:a[g].lineCoordinates.width),y.push(Math.ceil(a[g]?a[g].createLabelsAndCalculateHeight():0)),W+=y[g],e+=a[g]&&!m.isNavigator?a[g].margin:0;else y.push(Math.ceil(a[0]?a[0].createLabelsAndCalculateHeight():0));M.push(y);if(d&&0<d.length)for(x=[],g=Y=0;g<d.length;g++)d[g]&&(d[g].lineCoordinates={}),d[g].lineCoordinates.width=
Math.abs(p-l),d[g].title&&(d[g]._titleTextBlock.maxWidth=0<d[g].titleMaxWidth&&d[g].titleMaxWidth<d[g].lineCoordinates.width?d[g].titleMaxWidth:d[g].lineCoordinates.width),x.push(Math.ceil(d[g]?d[g].createLabelsAndCalculateHeight():0)),Y+=x[g],V+=d[g]&&!m.isNavigator?d[g].margin:0;else x.push(Math.ceil(d[0]?d[0].createLabelsAndCalculateHeight():0));Q.push(x);if(a&&0<a.length)for(g=0;g<a.length;g++)a[g]&&(a[g].lineCoordinates.x1=l,p=Math.round(f.x2-aa-Z>m.width-n?m.width-n:f.x2-aa-Z),a[g]._labels&&
1<a[g]._labels.length&&(h=k=0,k=a[g]._labels[1],h="dateTime"===a[g].valueType?a[g]._labels[a[g]._labels.length-2]:a[g]._labels[a[g]._labels.length-1],v=k.textBlock.width*Math.cos(Math.PI/180*Math.abs(k.textBlock.angle))+(k.textBlock.height-h.textBlock.fontSize/2)*Math.sin(Math.PI/180*Math.abs(k.textBlock.angle)),u=h.textBlock.width*Math.cos(Math.PI/180*Math.abs(h.textBlock.angle))+(h.textBlock.height-h.textBlock.fontSize/2)*Math.sin(Math.PI/180*Math.abs(h.textBlock.angle))),!a[g]||(!a[g].labelAutoFit||
r(D)||r(B)||m.isNavigator||m.stockChart)||(h=0,0<a[g].labelAngle?B+u>p&&(h+=0<a[g].labelAngle?B+u-p-aa:0):0>a[g].labelAngle?D-v<l&&D-v<a[g].viewportMinimum&&(E=l-(O+a[g].tickLength+z+D-v+a[g].labelFontSize/2)):0===a[g].labelAngle&&(B+u>p&&(h=B+u/2-p-aa),D-v<l&&D-v<a[g].viewportMinimum&&(E=l-O-a[g].tickLength-z-D+v/2)),a[g].viewportMaximum===a[g].maximum&&a[g].viewportMinimum===a[g].minimum&&0<a[g].labelAngle&&0<h?p-=h:a[g].viewportMaximum===a[g].maximum&&a[g].viewportMinimum===a[g].minimum&&0>a[g].labelAngle&&
0<E?l+=E:a[g].viewportMaximum===a[g].maximum&&a[g].viewportMinimum===a[g].minimum&&0===a[g].labelAngle&&(0<E&&(l+=E),0<h&&(p-=h))),m.panEnabled?W=r(m.sessionVariables.axisX.height)?m.sessionVariables.axisX.height=W:m.sessionVariables.axisX.height:m.sessionVariables.axisX.height=W,h=Math.round(f.y2-W-e+F),k=Math.round(f.y2),a[g].lineCoordinates.x2=p,a[g].lineCoordinates.width=p-l,a[g].lineCoordinates.y1=h,a[g].lineCoordinates.y2=h+a[g].lineThickness/2,"inside"===a[g].labelPlacement&&0<g&&(a[g].lineCoordinates.y1=
a[g-1].lineCoordinates.y2+F+(a[g].labelEffectiveHeight||0),a[g].lineCoordinates.y2=a[g].lineCoordinates.y1+a[g].lineThickness/2),"inside"===a[g].tickPlacement&&0<g&&(a[g].lineCoordinates.y1+=a[g].tickLength,a[g].lineCoordinates.y2=a[g].lineCoordinates.y1+a[g].lineThickness/2),a[g].bounds={x1:l,y1:h,x2:p,y2:k-(W+e-y[g]-F),width:p-l},a[g].bounds.height=a[g].bounds.y2-a[g].bounds.y1),F+=y[g]+a[g].margin;if(d&&0<d.length)for(g=0;g<d.length;g++)d[g].lineCoordinates.x1=Math.round(f.x1+R+O),d[g].lineCoordinates.x2=
Math.round(f.x2-aa-Z>m.width-n?m.width-n:f.x2-aa-Z),d[g].lineCoordinates.width=Math.abs(p-l),d[g]._labels&&1<d[g]._labels.length&&(k=d[g]._labels[1],h="dateTime"===d[g].valueType?d[g]._labels[d[g]._labels.length-2]:d[g]._labels[d[g]._labels.length-1],v=k.textBlock.width*Math.cos(Math.PI/180*Math.abs(k.textBlock.angle))+(k.textBlock.height-h.textBlock.fontSize/2)*Math.sin(Math.PI/180*Math.abs(k.textBlock.angle)),u=h.textBlock.width*Math.cos(Math.PI/180*Math.abs(h.textBlock.angle))+(h.textBlock.height-
h.textBlock.fontSize/2)*Math.sin(Math.PI/180*Math.abs(h.textBlock.angle))),m.panEnabled?Y=r(m.sessionVariables.axisX2.height)?m.sessionVariables.axisX2.height=Y:m.sessionVariables.axisX2.height:m.sessionVariables.axisX2.height=Y,h=Math.round(f.y1),k=d[g].lineCoordinates.y1=h+Y+V-X,d[g].lineCoordinates.y2=h,"inside"===d[g].labelPlacement&&0<g&&(d[g].lineCoordinates.y1=d[g-1].lineCoordinates.y1-X-(d[g].labelEffectiveHeight||0)),"inside"===d[g].tickPlacement&&0<g&&(d[g].lineCoordinates.y1-=d[g].tickLength),
d[g].bounds={x1:l,y1:h+(Y+V-x[g]-X),x2:p,y2:k,width:p-l},d[g].bounds.height=d[g].bounds.y2-d[g].bounds.y1,X+=x[g]+d[g].margin;if(c&&0<c.length)for(g=0;g<c.length;g++)O=m.isNavigator?0:10,c[g]&&(l=Math.round(a[0]?a[0].lineCoordinates.x1:d[0].lineCoordinates.x1),O=c[g]._labels&&0<c[g]._labels.length?c[g]._labels[c[g]._labels.length-1].textBlock.height/2:n,h=Math.round(f.y1+Y+V<Math.max(O,n)?Math.max(O,n):f.y1+Y+V),p=Math.round(a[0]?a[0].lineCoordinates.x1:d[0].lineCoordinates.x1),O=0<a.length?0:c[g]._labels&&
0<c[g]._labels.length?c[g]._labels[0].textBlock.height/2:n,k=Math.round(f.y2-W-e-O),c[g].lineCoordinates={x1:l-T,y1:h,x2:p-T,y2:k,height:Math.abs(k-h)},"inside"===c[g].labelPlacement&&0<g&&(c[g].lineCoordinates.x1=c[g-1].lineCoordinates.x1-T-(c[g].labelEffectiveWidth||0),c[g].lineCoordinates.x2=c[g].lineCoordinates.x1+c[g].lineThickness/2),"inside"===c[g].tickPlacement&&0<g&&(c[g].lineCoordinates.x1-=c[g].tickLength,c[g].lineCoordinates.x2=c[g].lineCoordinates.x1+c[g].lineThickness/2),c[g].bounds=
{x1:l-(z[g]+T),y1:h,x2:p-T,y2:k,height:k-h},c[g].bounds.width=c[g].bounds.x2-c[g].bounds.x1,c[g].title&&(c[g]._titleTextBlock.maxWidth=0<c[g].titleMaxWidth&&c[g].titleMaxWidth<c[g].lineCoordinates.height?c[g].titleMaxWidth:c[g].lineCoordinates.height),T+=z[g]+c[g].margin);if(b&&0<b.length)for(g=0;g<b.length;g++)b[g]&&(l=Math.round(a[0]?a[0].lineCoordinates.x2:d[0].lineCoordinates.x2),p=Math.round(l),O=b[g]._labels&&0<b[g]._labels.length?b[g]._labels[b[g]._labels.length-1].textBlock.height/2:0,h=Math.round(f.y1+
Y+V<Math.max(O,n)?Math.max(O,n):f.y1+Y+V),O=0<a.length?0:b[g]._labels&&0<b[g]._labels.length?b[g]._labels[0].textBlock.height/2:0,k=Math.round(f.y2-(W+e+O)),b[g].lineCoordinates={x1:l+U,y1:h,x2:l+U,y2:k,height:Math.abs(k-h)},"inside"===b[g].labelPlacement&&0<g&&(b[g].lineCoordinates.x1=b[g-1].lineCoordinates.x2+U+(b[g].labelEffectiveWidth||0),b[g].lineCoordinates.x2=b[g].lineCoordinates.x1+b[g].lineThickness/2),"inside"===b[g].tickPlacement&&0<g&&(b[g].lineCoordinates.x1+=b[g].tickLength,b[g].lineCoordinates.x2=
b[g].lineCoordinates.x1+b[g].lineThickness/2),b[g].bounds={x1:l+U,y1:h,x2:p+(A[g]+U),y2:k,height:k-h},b[g].bounds.width=b[g].bounds.x2-b[g].bounds.x1,b[g].title&&(b[g]._titleTextBlock.maxWidth=0<b[g].titleMaxWidth&&b[g].titleMaxWidth<b[g].lineCoordinates.height?b[g].titleMaxWidth:b[g].lineCoordinates.height),U+=A[g]+b[g].margin);if(a&&0<a.length)for(g=0;g<a.length;g++)a[g]&&(a[g].calculateValueToPixelConversionParameters(),a[g].calculateBreaksSizeInValues(),a[g]._labels&&1<a[g]._labels.length&&(D=
(a[g].logarithmic?Math.log(a[g]._labels[1].position/a[g].viewportMinimum)/a[g].conversionParameters.lnLogarithmBase:a[g]._labels[1].position-a[g].viewportMinimum)*Math.abs(a[g].conversionParameters.pixelPerUnit)+a[g].lineCoordinates.x1,l=a[g]._labels[a[g]._labels.length-("dateTime"===a[g].valueType?2:1)].position,l=a[g].getApparentDifference(a[g].viewportMinimum,l),B=a[g].logarithmic?(1<l?Math.log(l)/a[g].conversionParameters.lnLogarithmBase*Math.abs(a[g].conversionParameters.pixelPerUnit):0)+a[g].lineCoordinates.x1:
(0<l?l*Math.abs(a[g].conversionParameters.pixelPerUnit):0)+a[g].lineCoordinates.x1));if(d&&0<d.length)for(g=0;g<d.length;g++)d[g].calculateValueToPixelConversionParameters(),d[g].calculateBreaksSizeInValues(),d[g]._labels&&1<d[g]._labels.length&&(D=(d[g].logarithmic?Math.log(d[g]._labels[1].position/d[g].viewportMinimum)/d[g].conversionParameters.lnLogarithmBase:d[g]._labels[1].position-d[g].viewportMinimum)*Math.abs(d[g].conversionParameters.pixelPerUnit)+d[g].lineCoordinates.x1,l=d[g]._labels[d[g]._labels.length-
("dateTime"===d[g].valueType?2:1)].position,l=d[g].getApparentDifference(d[g].viewportMinimum,l),B=d[g].logarithmic?(1<l?Math.log(l)/d[g].conversionParameters.lnLogarithmBase*Math.abs(d[g].conversionParameters.pixelPerUnit):0)+d[g].lineCoordinates.x1:(0<l?l*Math.abs(d[g].conversionParameters.pixelPerUnit):0)+d[g].lineCoordinates.x1);for(g=0;g<q.length;g++)"axisY"===q[g].type&&(q[g].calculateValueToPixelConversionParameters(),q[g].calculateBreaksSizeInValues());if(0<w){if(a&&0<a.length)for(g=0;g<a.length;g++)s=
M[w-1][g]===M[w][g]?!0:!1;else s=!0;if(d&&0<d.length)for(g=0;g<d.length;g++)G=Q[w-1][g]===Q[w][g]?!0:!1;else G=!0;if(c&&0<c.length)for(g=0;g<c.length;g++)J=N[w-1][g]===N[w][g]?!0:!1;else J=!0;if(b&&0<b.length)for(g=0;g<b.length;g++)K=P[w-1][g]===P[w][g]?!0:!1;else K=!0}if(s&&G&&J&&K)break;w++}if(a&&0<a.length)for(g=0;g<a.length;g++)a[g].calculateStripLinesThicknessInValues(),a[g].calculateBreaksInPixels();if(d&&0<d.length)for(g=0;g<d.length;g++)d[g].calculateStripLinesThicknessInValues(),d[g].calculateBreaksInPixels();
if(c&&0<c.length)for(g=0;g<c.length;g++)c[g].calculateStripLinesThicknessInValues(),c[g].calculateBreaksInPixels();if(b&&0<b.length)for(g=0;g<b.length;g++)b[g].calculateStripLinesThicknessInValues(),b[g].calculateBreaksInPixels()}else{n=[];D=[];E=[];v=[];B=[];u=[];M=[];for(Q=[];4>w;){W=U=T=Z=O=V=e=P=N=F=Y=0;if(a&&0<a.length)for(E=[],g=U=0;g<a.length;g++)E.push(Math.ceil(a[g]?a[g].createLabelsAndCalculateWidth():0)),U+=E[g],e+=a[g]&&!m.isNavigator?a[g].margin:0;else E.push(Math.ceil(a[0]?a[0].createLabelsAndCalculateWidth():
0));M.push(E);if(d&&0<d.length)for(v=[],g=W=0;g<d.length;g++)v.push(Math.ceil(d[g]?d[g].createLabelsAndCalculateWidth():0)),W+=v[g],V+=d[g]?d[g].margin:0;else v.push(Math.ceil(d[0]?d[0].createLabelsAndCalculateWidth():0));Q.push(v);if(c&&0<c.length)for(g=0;g<c.length;g++)c[g].lineCoordinates={},l=Math.round(f.x1+U+e),p=Math.round(f.x2-W-V>m.width-10?m.width-10:f.x2-W-V),c[g].labelAutoFit&&!r(y)&&(0<!a.length&&(l=0>c[g].labelAngle?Math.max(l,y):0===c[g].labelAngle?Math.max(l,y/2):l),0<!d.length&&(p=
0<c[g].labelAngle?p-x/2:0===c[g].labelAngle?p-x/2:p)),c[g].lineCoordinates.x1=l,c[g].lineCoordinates.x2=p,c[g].lineCoordinates.width=Math.abs(p-l),c[g].title&&(c[g]._titleTextBlock.maxWidth=0<c[g].titleMaxWidth&&c[g].titleMaxWidth<c[g].lineCoordinates.width?c[g].titleMaxWidth:c[g].lineCoordinates.width);if(b&&0<b.length)for(g=0;g<b.length;g++)b[g].lineCoordinates={},l=Math.round(f.x1+U+e),p=Math.round(f.x2-W-V>b[g].chart.width-10?b[g].chart.width-10:f.x2-W-V),b[g]&&b[g].labelAutoFit&&!r(z)&&(0<!a.length&&
(l=0<b[g].labelAngle?Math.max(l,z):0===b[g].labelAngle?Math.max(l,z/2):l),0<!d.length&&(p-=A/2)),b[g].lineCoordinates.x1=l,b[g].lineCoordinates.x2=p,b[g].lineCoordinates.width=Math.abs(p-l),b[g].title&&(b[g]._titleTextBlock.maxWidth=0<b[g].titleMaxWidth&&b[g].titleMaxWidth<b[g].lineCoordinates.width?b[g].titleMaxWidth:b[g].lineCoordinates.width);if(c&&0<c.length)for(n=[],g=T=0;g<c.length;g++)n.push(Math.ceil(c[g]?c[g].createLabelsAndCalculateHeight():0)),T+=n[g]+c[g].margin,O+=c[g].margin;else n.push(Math.ceil(c[0]?
c[0].createLabelsAndCalculateHeight():0));B.push(n);if(b&&0<b.length)for(D=[],g=0;g<b.length;g++)D.push(Math.ceil(b[g]?b[g].createLabelsAndCalculateHeight():0)),Z+=b[g].margin;else D.push(Math.ceil(b[0]?b[0].createLabelsAndCalculateHeight():0));u.push(D);if(c&&0<c.length)for(g=0;g<c.length;g++)0<c[g]._labels.length&&(k=c[g]._labels[0],h=c[g]._labels[c[g]._labels.length-1],y=k.textBlock.width*Math.cos(Math.PI/180*Math.abs(k.textBlock.angle))+(k.textBlock.height-h.textBlock.fontSize/2)*Math.sin(Math.PI/
180*Math.abs(k.textBlock.angle)),x=h.textBlock.width*Math.cos(Math.PI/180*Math.abs(h.textBlock.angle))+(h.textBlock.height-h.textBlock.fontSize/2)*Math.sin(Math.PI/180*Math.abs(h.textBlock.angle)));if(b&&0<b.length)for(g=0;g<b.length;g++)b[g]&&0<b[g]._labels.length&&(k=b[g]._labels[0],h=b[g]._labels[b[g]._labels.length-1],z=k.textBlock.width*Math.cos(Math.PI/180*Math.abs(k.textBlock.angle))+(k.textBlock.height-h.textBlock.fontSize/2)*Math.sin(Math.PI/180*Math.abs(k.textBlock.angle)),A=h.textBlock.width*
Math.cos(Math.PI/180*Math.abs(h.textBlock.angle))+(h.textBlock.height-h.textBlock.fontSize/2)*Math.sin(Math.PI/180*Math.abs(h.textBlock.angle)));if(m.panEnabled)for(g=0;g<c.length;g++)n[g]=r(m.sessionVariables.axisY[g].height)?m.sessionVariables.axisY[g].height=n[g]:m.sessionVariables.axisY[g].height;else for(g=0;g<c.length;g++)m.sessionVariables.axisY[g].height=n[g];if(c&&0<c.length)for(g=c.length-1;0<=g;g--)h=Math.round(f.y2),k=Math.round(f.y2>c[g].chart.height?c[g].chart.height:f.y2),c[g].lineCoordinates.y1=
h-(n[g]+c[g].margin+Y),c[g].lineCoordinates.y2=h-(n[g]+c[g].margin+Y),"inside"===c[g].labelPlacement&&0<g&&(c[g].lineCoordinates.y1=c[g].lineCoordinates.y1+n[g]-(c[g]._titleTextBlock?c[g]._titleTextBlock.height:0)-c[g].tickLength-(c[g].stripLineLabelEffectiveHeight||0)-5,c[g].lineCoordinates.y2=c[g].lineCoordinates.y1+c[g].lineThickness/2),"inside"===c[g].tickPlacement&&0<g&&(c[g].lineCoordinates.y1+=c[g].tickLength,c[g].lineCoordinates.y2=c[g].lineCoordinates.y1+c[g].lineThickness/2),c[g].bounds=
{x1:l,y1:h-(n[g]+Y+c[g].margin),x2:p,y2:k-(Y+c[g].margin),width:p-l,height:n[g]},c[g].title&&(c[g]._titleTextBlock.maxWidth=0<c[g].titleMaxWidth&&c[g].titleMaxWidth<c[g].lineCoordinates.width?c[g].titleMaxWidth:c[g].lineCoordinates.width),Y+=n[g]+c[g].margin;if(b&&0<b.length)for(g=b.length-1;0<=g;g--)b[g]&&(h=Math.round(f.y1),k=Math.round(f.y1+(D[g]+b[g].margin+F)),b[g].lineCoordinates.y1=k,b[g].lineCoordinates.y2=k,"inside"===b[g].labelPlacement&&0<g&&(b[g].lineCoordinates.y1=k-D[g]+(b[g]._titleTextBlock?
b[g]._titleTextBlock.height:0)+b[g].tickLength+(b[g].stripLineLabelEffectiveHeight||0),b[g].lineCoordinates.y2=b[g].lineCoordinates.y1-b[g].lineThickness/2),"inside"===b[g].tickPlacement&&0<g&&(b[g].lineCoordinates.y1-=b[g].tickLength,b[g].lineCoordinates.y2=b[g].lineCoordinates.y1-b[g].lineThickness/2),b[g].bounds={x1:l,y1:h+(b[g].margin+F),x2:p,y2:k,width:p-l},b[g].bounds.height=b[g].bounds.y2-b[g].bounds.y1,b[g].title&&(b[g]._titleTextBlock.maxWidth=0<b[g].titleMaxWidth&&b[g].titleMaxWidth<b[g].lineCoordinates.width?
b[g].titleMaxWidth:b[g].lineCoordinates.width),F+=D[g]+b[g].margin);if(a&&0<a.length)for(g=0;g<a.length;g++){O=a[g]._labels&&0<a[g]._labels.length?a[g]._labels[0].textBlock.fontSize/2:0;l=Math.round(f.x1+e);h=b&&0<b.length?Math.round(b[0]?b[0].lineCoordinates.y2:f.y1<Math.max(O,10)?Math.max(O,10):f.y1):f.y1<Math.max(O,10)?Math.max(O,10):f.y1;p=Math.round(f.x1+U+e);k=c&&0<c.length?Math.round(c[0]?c[0].lineCoordinates.y1:f.y2-T>m.height-Math.max(O,10)?m.height-Math.max(O,10):f.y2-T):f.y2>m.height-Math.max(O,
10)?m.height-Math.max(O,10):f.y2;if(c&&0<c.length)for(O=0;O<c.length;O++)c[O]&&c[O].labelAutoFit&&(p=c[O].lineCoordinates.x1,l=0>c[O].labelAngle||0===c[O].labelAngle?p-U:l);if(b&&0<b.length)for(O=0;O<b.length;O++)b[O]&&b[O].labelAutoFit&&(p=b[O].lineCoordinates.x1,l=p-U);a[g].lineCoordinates={x1:p-N,y1:h,x2:p-N,y2:k,height:Math.abs(k-h)};"inside"===a[g].labelPlacement&&0<g&&(a[g].lineCoordinates.x1=a[g].lineCoordinates.x1-(E[g]-(a[g]._titleTextBlock?a[g]._titleTextBlock.height:0))+a[g].tickLength+
(a[g].stripLineLabelEffectiveWidth||0),a[g].lineCoordinates.x2=a[g].lineCoordinates.x1+a[g].lineThickness/2);"inside"===a[g].tickPlacement&&0<g&&(a[g].lineCoordinates.x1-=a[g].tickLength,a[g].lineCoordinates.x2=a[g].lineCoordinates.x1+a[g].lineThickness/2);a[g].bounds={x1:p-(E[g]+N),y1:h,x2:p-N,y2:k,height:k-h};a[g].bounds.width=a[g].bounds.x2-a[g].bounds.x1;a[g].title&&(a[g]._titleTextBlock.maxWidth=0<a[g].titleMaxWidth&&a[g].titleMaxWidth<a[g].lineCoordinates.height?a[g].titleMaxWidth:a[g].lineCoordinates.height);
a[g].calculateValueToPixelConversionParameters();a[g].calculateBreaksSizeInValues();N+=E[g]+a[g].margin}if(d&&0<d.length)for(g=0;g<d.length;g++){O=d[g]._labels&&0<d[g]._labels.length?d[g]._labels[0].textBlock.fontSize/2:0;l=Math.round(f.x1-e);h=b&&0<b.length?Math.round(b[0]?b[0].lineCoordinates.y2:f.y1<Math.max(O,10)?Math.max(O,10):f.y1):f.y1<Math.max(O,10)?Math.max(O,10):f.y1;p=Math.round(f.x2-W-V);k=c&&0<c.length?Math.round(c[0]?c[0].lineCoordinates.y1:f.y2-T>m.height-Math.max(O,10)?m.height-Math.max(O,
10):f.y2-T):f.y2>m.height-Math.max(O,10)?m.height-Math.max(O,10):f.y2;if(c&&0<c.length)for(O=0;O<c.length;O++)c[O]&&c[O].labelAutoFit&&(p=0>c[O].labelAngle?Math.max(p,y):0===c[O].labelAngle?Math.max(p,y/2):p,l=0>c[O].labelAngle||0===c[O].labelAngle?p-W:l);if(b&&0<b.length)for(O=0;O<b.length;O++)b[O]&&b[O].labelAutoFit&&(p=b[O].lineCoordinates.x2,l=p-W);d[g].lineCoordinates={x1:p+P,y1:h,x2:p+P,y2:k,height:Math.abs(k-h)};"inside"===d[g].labelPlacement&&0<g&&(d[g].lineCoordinates.x1=d[g].lineCoordinates.x1+
(v[g]-(d[g]._titleTextBlock?d[g]._titleTextBlock.height:0)-2)-d[g].tickLength-(d[g].stripLineLabelEffectiveWidth||0),d[g].lineCoordinates.x2=d[g].lineCoordinates.x1+d[g].lineThickness/2);"inside"===d[g].tickPlacement&&0<g&&(d[g].lineCoordinates.x1+=d[g].tickLength,d[g].lineCoordinates.x2=d[g].lineCoordinates.x1+d[g].lineThickness/2);d[g].bounds={x1:d[g].lineCoordinates.x1,y1:h,x2:p+v[g]+P,y2:k,width:p-l,height:k-h};d[g].bounds.width=d[g].bounds.x2-d[g].bounds.x1;d[g].title&&(d[g]._titleTextBlock.maxWidth=
0<d[g].titleMaxWidth&&d[g].titleMaxWidth<d[g].lineCoordinates.height?d[g].titleMaxWidth:d[g].lineCoordinates.height);d[g].calculateValueToPixelConversionParameters();d[g].calculateBreaksSizeInValues();P+=v[g]+d[g].margin}for(g=0;g<q.length;g++)"axisY"===q[g].type&&(q[g].calculateValueToPixelConversionParameters(),q[g].calculateBreaksSizeInValues());if(0<w){if(a&&0<a.length)for(g=0;g<a.length;g++)s=M[w-1][g]===M[w][g]?!0:!1;else s=!0;if(d&&0<d.length)for(g=0;g<d.length;g++)G=Q[w-1][g]===Q[w][g]?!0:
!1;else G=!0;if(c&&0<c.length)for(g=0;g<c.length;g++)J=B[w-1][g]===B[w][g]?!0:!1;else J=!0;if(b&&0<b.length)for(g=0;g<b.length;g++)K=u[w-1][g]===u[w][g]?!0:!1;else K=!0}if(s&&G&&J&&K)break;w++}if(c&&0<c.length)for(g=0;g<c.length;g++)c[g].calculateStripLinesThicknessInValues(),c[g].calculateBreaksInPixels();if(b&&0<b.length)for(g=0;g<b.length;g++)b[g].calculateStripLinesThicknessInValues(),b[g].calculateBreaksInPixels();if(a&&0<a.length)for(g=0;g<a.length;g++)a[g].calculateStripLinesThicknessInValues(),
a[g].calculateBreaksInPixels();if(d&&0<d.length)for(g=0;g<d.length;g++)d[g].calculateStripLinesThicknessInValues(),d[g].calculateBreaksInPixels()}};A.render=function(a,d,c,b,e){var f=a[0]?a[0].chart:d[0].chart;e=f.ctx;f.alignVerticalAxes&&f.alignVerticalAxes();e.save();e.beginPath();a&&a.length&&e.rect(5,a[0].bounds.y1,a[0].chart.width-10,a[a.length-1].bounds.y2);d&&d.length&&e.rect(5,d[d.length-1].bounds.y1,d[0].chart.width-10,d[0].bounds.y2);e.clip();if(a&&0<a.length)for(var l=0;l<a.length;l++)a[l].renderLabelsTicksAndTitle();
if(d&&0<d.length)for(l=0;l<d.length;l++)d[l].renderLabelsTicksAndTitle();e.restore();if(c&&0<c.length)for(l=0;l<c.length;l++)c[l].renderLabelsTicksAndTitle();if(b&&0<b.length)for(l=0;l<b.length;l++)b[l].renderLabelsTicksAndTitle();f.preparePlotArea();f=f.plotArea;e.save();e.beginPath();e.rect(f.x1,f.y1,Math.abs(f.x2-f.x1),Math.abs(f.y2-f.y1));e.clip();if(a&&0<a.length)for(l=0;l<a.length;l++)a[l].renderStripLinesOfThicknessType("value");if(d&&0<d.length)for(l=0;l<d.length;l++)d[l].renderStripLinesOfThicknessType("value");
if(c&&0<c.length)for(l=0;l<c.length;l++)c[l].renderStripLinesOfThicknessType("value");if(b&&0<b.length)for(l=0;l<b.length;l++)b[l].renderStripLinesOfThicknessType("value");if(a&&0<a.length)for(l=0;l<a.length;l++)a[l].renderInterlacedColors();if(d&&0<d.length)for(l=0;l<d.length;l++)d[l].renderInterlacedColors();if(c&&0<c.length)for(l=0;l<c.length;l++)c[l].renderInterlacedColors();if(b&&0<b.length)for(l=0;l<b.length;l++)b[l].renderInterlacedColors();e.restore();if(a&&0<a.length)for(l=0;l<a.length;l++)a[l].renderGrid(),
w&&(a[l].createMask(),a[l].renderBreaksBackground());if(d&&0<d.length)for(l=0;l<d.length;l++)d[l].renderGrid(),w&&(d[l].createMask(),d[l].renderBreaksBackground());if(c&&0<c.length)for(l=0;l<c.length;l++)c[l].renderGrid(),w&&(c[l].createMask(),c[l].renderBreaksBackground());if(b&&0<b.length)for(l=0;l<b.length;l++)b[l].renderGrid(),w&&(b[l].createMask(),b[l].renderBreaksBackground());if(a&&0<a.length)for(l=0;l<a.length;l++)a[l].renderAxisLine();if(d&&0<d.length)for(l=0;l<d.length;l++)d[l].renderAxisLine();
if(c&&0<c.length)for(l=0;l<c.length;l++)c[l].renderAxisLine();if(b&&0<b.length)for(l=0;l<b.length;l++)b[l].renderAxisLine();if(a&&0<a.length)for(l=0;l<a.length;l++)a[l].renderStripLinesOfThicknessType("pixel");if(d&&0<d.length)for(l=0;l<d.length;l++)d[l].renderStripLinesOfThicknessType("pixel");if(c&&0<c.length)for(l=0;l<c.length;l++)c[l].renderStripLinesOfThicknessType("pixel");if(b&&0<b.length)for(l=0;l<b.length;l++)b[l].renderStripLinesOfThicknessType("pixel")};A.prototype.calculateStripLinesThicknessInValues=
function(){for(var a=0;a<this.stripLines.length;a++)if(null!==this.stripLines[a].startValue&&null!==this.stripLines[a].endValue){var d=Math.min(this.stripLines[a].startValue,this.stripLines[a].endValue),c=Math.max(this.stripLines[a].startValue,this.stripLines[a].endValue),b=this.getApparentDifference(d,c);this.stripLines[a].value=this.convertPixelToValue(Math.abs(this.convertValueToPixel(d)+this.convertValueToPixel(c))/2);this.stripLines[a].thickness=b;this.stripLines[a]._thicknessType="value"}};
A.prototype.calculateBreaksSizeInValues=function(){for(var a="left"===this._position||"right"===this._position?this.lineCoordinates.height||this.chart.height:this.lineCoordinates.width||this.chart.width,d=this.scaleBreaks?this.scaleBreaks._appliedBreaks:[],c=this.conversionParameters.pixelPerUnit||a/(this.logarithmic?this.conversionParameters.maximum/this.conversionParameters.minimum:this.conversionParameters.maximum-this.conversionParameters.minimum),b=this.scaleBreaks&&!r(this.scaleBreaks.options.spacing),
e,f=0;f<d.length;f++)e=b||!r(d[f].options.spacing),d[f].spacing=Ta(d[f].spacing,a,8,e?0.1*a:8,e?0:3)<<0,d[f].size=0>d[f].spacing?0:Math.abs(d[f].spacing/c),this.logarithmic&&(d[f].size=Math.pow(this.logarithmBase,d[f].size))};A.prototype.calculateBreaksInPixels=function(){if(!(this.scaleBreaks&&0>=this.scaleBreaks._appliedBreaks.length)){var a=this.scaleBreaks?this.scaleBreaks._appliedBreaks:[];a.length&&(this.scaleBreaks.firstBreakIndex=this.scaleBreaks.lastBreakIndex=null);for(var d=0;d<a.length&&
!(a[d].startValue>this.conversionParameters.maximum);d++)a[d].endValue<this.conversionParameters.minimum||(r(this.scaleBreaks.firstBreakIndex)&&(this.scaleBreaks.firstBreakIndex=d),a[d].startValue>=this.conversionParameters.minimum&&(a[d].startPixel=this.convertValueToPixel(a[d].startValue),this.scaleBreaks.lastBreakIndex=d),a[d].endValue<=this.conversionParameters.maximum&&(a[d].endPixel=this.convertValueToPixel(a[d].endValue)))}};A.prototype.renderLabelsTicksAndTitle=function(){var a=this,d=!1,
c=0,b=0,e=1,f=0;0!==this.labelAngle&&360!==this.labelAngle&&(e=1.2);if("undefined"===typeof this.options.interval){if("bottom"===this._position||"top"===this._position)if(this.logarithmic&&!this.equidistantInterval&&this.labelAutoFit){for(var c=[],e=0!==this.labelAngle&&360!==this.labelAngle?1:1.2,l,h=this.viewportMaximum,p=this.lineCoordinates.width/Math.log(this.range),k=this._labels.length-1;0<=k;k--){n=this._labels[k];if(n.position<this.viewportMinimum)break;n.position>this.viewportMaximum||!(k===
this._labels.length-1||l<Math.log(h/n.position)*p/e)||(c.push(n),h=n.position,l=n.textBlock.width*Math.abs(Math.cos(Math.PI/180*this.labelAngle))+n.textBlock.height*Math.abs(Math.sin(Math.PI/180*this.labelAngle)))}this._labels=c}else{for(k=0;k<this._labels.length;k++)n=this._labels[k],n.position<this.viewportMinimum||(l=n.textBlock.width*Math.abs(Math.cos(Math.PI/180*this.labelAngle))+n.textBlock.height*Math.abs(Math.sin(Math.PI/180*this.labelAngle)),c+=l);c>this.lineCoordinates.width*e&&this.labelAutoFit&&
(d=!0)}if("left"===this._position||"right"===this._position)if(this.logarithmic&&!this.equidistantInterval&&this.labelAutoFit){for(var c=[],m,h=this.viewportMaximum,p=this.lineCoordinates.height/Math.log(this.range),k=this._labels.length-1;0<=k;k--){n=this._labels[k];if(n.position<this.viewportMinimum)break;n.position>this.viewportMaximum||!(k===this._labels.length-1||m<Math.log(h/n.position)*p)||(c.push(n),h=n.position,m=n.textBlock.height*Math.abs(Math.cos(Math.PI/180*this.labelAngle))+n.textBlock.width*
Math.abs(Math.sin(Math.PI/180*this.labelAngle)))}this._labels=c}else{for(k=0;k<this._labels.length;k++)n=this._labels[k],n.position<this.viewportMinimum||(m=n.textBlock.height*Math.abs(Math.cos(Math.PI/180*this.labelAngle))+n.textBlock.width*Math.abs(Math.sin(Math.PI/180*this.labelAngle)),b+=m);b>this.lineCoordinates.height*e&&this.labelAutoFit&&(d=!0)}}this.logarithmic&&(!this.equidistantInterval&&this.labelAutoFit)&&this._labels.sort(function(a,b){return a.position-b.position});var k=0,n,q;if("bottom"===
this._position){for(k=0;k<this._labels.length;k++)n=this._labels[k],n.position<this.viewportMinimum||n.position>this.viewportMaximum||(q=this.getPixelCoordinatesOnAxis(n.position),this.tickThickness&&"inside"!=this.tickPlacement&&(this.ctx.lineWidth=this.tickThickness,this.ctx.strokeStyle=this.tickColor,b=1===this.ctx.lineWidth%2?(q.x<<0)+0.5:q.x<<0,this.ctx.beginPath(),this.ctx.moveTo(b,q.y<<0),this.ctx.lineTo(b,q.y+this.tickLength<<0),this.ctx.stroke()),d&&0!==f++%2&&this.labelAutoFit||(0===n.textBlock.angle?
(q.x-=n.textBlock.width/2,q.y="inside"===this.labelPlacement?q.y-(("inside"===this.tickPlacement?this.tickLength:0)+n.textBlock.height-n.textBlock.fontSize/2):q.y+("inside"===this.tickPlacement?0:this.tickLength)+n.textBlock.fontSize/2+5):(q.x="inside"===this.labelPlacement?0>this.labelAngle?q.x:q.x-n.textBlock.width*Math.cos(Math.PI/180*this.labelAngle):q.x-(0>this.labelAngle?n.textBlock.width*Math.cos(Math.PI/180*this.labelAngle):0),q.y="inside"===this.labelPlacement?0>this.labelAngle?q.y-("inside"===
this.tickPlacement?this.tickLength:0)-5:q.y-("inside"===this.tickPlacement?this.tickLength:0)-Math.abs(n.textBlock.width*Math.sin(Math.PI/180*this.labelAngle)+5):q.y+("inside"===this.tickPlacement?0:this.tickLength)+Math.abs(0>this.labelAngle?n.textBlock.width*Math.sin(Math.PI/180*this.labelAngle)-5:5)),n.textBlock.x=q.x,n.textBlock.y=q.y));"inside"===this.tickPlacement&&this.chart.addEventListener("dataAnimationIterationEnd",function(){for(k=0;k<a._labels.length;k++)if(n=a._labels[k],!(n.position<
a.viewportMinimum||n.position>a.viewportMaximum)&&(q=a.getPixelCoordinatesOnAxis(n.position),a.tickThickness)){a.ctx.lineWidth=a.tickThickness;a.ctx.strokeStyle=a.tickColor;var b=1===a.ctx.lineWidth%2?(q.x<<0)+0.5:q.x<<0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(b,q.y<<0);a.ctx.lineTo(b,q.y-a.tickLength<<0);a.ctx.stroke();a.ctx.restore()}},this);this.title&&(this._titleTextBlock.measureText(),this._titleTextBlock.x=this.lineCoordinates.x1+this.lineCoordinates.width/2-this._titleTextBlock.width/
2,this._titleTextBlock.y=this.bounds.y2-this._titleTextBlock.height-3,this.titleMaxWidth=this._titleTextBlock.maxWidth,this._titleTextBlock.render(!0))}else if("top"===this._position){for(k=0;k<this._labels.length;k++)n=this._labels[k],n.position<this.viewportMinimum||n.position>this.viewportMaximum||(q=this.getPixelCoordinatesOnAxis(n.position),this.tickThickness&&"inside"!=this.tickPlacement&&(this.ctx.lineWidth=this.tickThickness,this.ctx.strokeStyle=this.tickColor,b=1===this.ctx.lineWidth%2?(q.x<<
0)+0.5:q.x<<0,this.ctx.beginPath(),this.ctx.moveTo(b,q.y<<0),this.ctx.lineTo(b,q.y-this.tickLength<<0),this.ctx.stroke()),d&&0!==f++%2&&this.labelAutoFit||(0===n.textBlock.angle?(q.x-=n.textBlock.width/2,q.y="inside"===this.labelPlacement?q.y+this.labelFontSize/2+("inside"===this.tickPlacement?this.tickLength:0)+5:q.y-(("inside"===this.tickPlacement?0:this.tickLength)+n.textBlock.height-n.textBlock.fontSize/2)):(q.x="inside"===this.labelPlacement?0<this.labelAngle?q.x:q.x-n.textBlock.width*Math.cos(Math.PI/
180*this.labelAngle):q.x+(n.textBlock.height-this.labelFontSize)*Math.sin(Math.PI/180*this.labelAngle)-(0<this.labelAngle?n.textBlock.width*Math.cos(Math.PI/180*this.labelAngle):0),q.y="inside"===this.labelPlacement?0<this.labelAngle?q.y+("inside"===this.tickPlacement?this.tickLength:0)+5:q.y-n.textBlock.width*Math.sin(Math.PI/180*this.labelAngle)+("inside"===this.tickPlacement?this.tickLength:0)+5:q.y-(("inside"===this.tickPlacement?0:this.tickLength)+((n.textBlock.height-n.textBlock.fontSize/2)*
Math.cos(Math.PI/180*this.labelAngle)+(0<this.labelAngle?n.textBlock.width*Math.sin(Math.PI/180*this.labelAngle):0)))),n.textBlock.x=q.x,n.textBlock.y=q.y));"inside"===this.tickPlacement&&this.chart.addEventListener("dataAnimationIterationEnd",function(){for(k=0;k<a._labels.length;k++)if(n=a._labels[k],!(n.position<a.viewportMinimum||n.position>a.viewportMaximum)&&(q=a.getPixelCoordinatesOnAxis(n.position),a.tickThickness)){a.ctx.lineWidth=a.tickThickness;a.ctx.strokeStyle=a.tickColor;var b=1===a.ctx.lineWidth%
2?(q.x<<0)+0.5:q.x<<0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(b,q.y<<0);a.ctx.lineTo(b,q.y+a.tickLength<<0);a.ctx.stroke();a.ctx.restore()}},this);this.title&&(this._titleTextBlock.measureText(),this._titleTextBlock.x=this.lineCoordinates.x1+this.lineCoordinates.width/2-this._titleTextBlock.width/2,this._titleTextBlock.y=this.bounds.y1+1,this.titleMaxWidth=this._titleTextBlock.maxWidth,this._titleTextBlock.render(!0))}else if("left"===this._position){for(k=0;k<this._labels.length;k++)n=this._labels[k],
n.position<this.viewportMinimum||n.position>this.viewportMaximum||(q=this.getPixelCoordinatesOnAxis(n.position),this.tickThickness&&"inside"!=this.tickPlacement&&(this.ctx.lineWidth=this.tickThickness,this.ctx.strokeStyle=this.tickColor,b=1===this.ctx.lineWidth%2?(q.y<<0)+0.5:q.y<<0,this.ctx.beginPath(),this.ctx.moveTo(q.x<<0,b),this.ctx.lineTo(q.x-this.tickLength<<0,b),this.ctx.stroke()),d&&0!==f++%2&&this.labelAutoFit||(0===this.labelAngle?(n.textBlock.y=q.y,n.textBlock.x="inside"===this.labelPlacement?
q.x+("inside"===this.tickPlacement?this.tickLength:0)+5:q.x-n.textBlock.width*Math.cos(Math.PI/180*this.labelAngle)-("inside"===this.tickPlacement?0:this.tickLength)-5):(n.textBlock.y="inside"===this.labelPlacement?q.y:q.y-n.textBlock.width*Math.sin(Math.PI/180*this.labelAngle),n.textBlock.x="inside"===this.labelPlacement?q.x+("inside"===this.tickPlacement?this.tickLength:0)+5:0<this.labelAngle?q.x-n.textBlock.width*Math.cos(Math.PI/180*this.labelAngle)-("inside"===this.tickPlacement?0:this.tickLength)-
5:q.x-n.textBlock.width*Math.cos(Math.PI/180*this.labelAngle)+(n.textBlock.height-n.textBlock.fontSize/2-5)*Math.sin(Math.PI/180*this.labelAngle)-("inside"===this.tickPlacement?0:this.tickLength))));"inside"===this.tickPlacement&&this.chart.addEventListener("dataAnimationIterationEnd",function(){for(k=0;k<a._labels.length;k++)if(n=a._labels[k],!(n.position<a.viewportMinimum||n.position>a.viewportMaximum)&&(q=a.getPixelCoordinatesOnAxis(n.position),a.tickThickness)){a.ctx.lineWidth=a.tickThickness;
a.ctx.strokeStyle=a.tickColor;var b=1===a.ctx.lineWidth%2?(q.y<<0)+0.5:q.y<<0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(q.x<<0,b);a.ctx.lineTo(q.x+a.tickLength<<0,b);a.ctx.stroke();a.ctx.restore()}},this);this.title&&(this._titleTextBlock.measureText(),this._titleTextBlock.x=this.bounds.x1+1,this._titleTextBlock.y=this.lineCoordinates.height/2+this._titleTextBlock.width/2+this.lineCoordinates.y1,this.titleMaxWidth=this._titleTextBlock.maxWidth,this._titleTextBlock.render(!0))}else if("right"===
this._position){for(k=0;k<this._labels.length;k++)n=this._labels[k],n.position<this.viewportMinimum||n.position>this.viewportMaximum||(q=this.getPixelCoordinatesOnAxis(n.position),this.tickThickness&&"inside"!=this.tickPlacement&&(this.ctx.lineWidth=this.tickThickness,this.ctx.strokeStyle=this.tickColor,b=1===this.ctx.lineWidth%2?(q.y<<0)+0.5:q.y<<0,this.ctx.beginPath(),this.ctx.moveTo(q.x<<0,b),this.ctx.lineTo(q.x+this.tickLength<<0,b),this.ctx.stroke()),d&&0!==f++%2&&this.labelAutoFit||(0===this.labelAngle?
(n.textBlock.y=q.y,n.textBlock.x="inside"===this.labelPlacement?q.x-n.textBlock.width-("inside"===this.tickPlacement?this.tickLength:0)-5:q.x+("inside"===this.tickPlacement?0:this.tickLength)+5):(n.textBlock.y="inside"===this.labelPlacement?q.y-n.textBlock.width*Math.sin(Math.PI/180*this.labelAngle):0>this.labelAngle?q.y:q.y-(n.textBlock.height-n.textBlock.fontSize/2-5)*Math.cos(Math.PI/180*this.labelAngle),n.textBlock.x="inside"===this.labelPlacement?q.x-n.textBlock.width*Math.cos(Math.PI/180*this.labelAngle)-
("inside"===this.tickPlacement?this.tickLength:0)-5:0<this.labelAngle?q.x+(n.textBlock.height-n.textBlock.fontSize/2-5)*Math.sin(Math.PI/180*this.labelAngle)+("inside"===this.tickPlacement?0:this.tickLength):q.x+("inside"===this.tickPlacement?0:this.tickLength)+5)));"inside"===this.tickPlacement&&this.chart.addEventListener("dataAnimationIterationEnd",function(){for(k=0;k<a._labels.length;k++)if(n=a._labels[k],!(n.position<a.viewportMinimum||n.position>a.viewportMaximum)&&(q=a.getPixelCoordinatesOnAxis(n.position),
a.tickThickness)){a.ctx.lineWidth=a.tickThickness;a.ctx.strokeStyle=a.tickColor;var b=1===a.ctx.lineWidth%2?(q.y<<0)+0.5:q.y<<0;a.ctx.save();a.ctx.beginPath();a.ctx.moveTo(q.x<<0,b);a.ctx.lineTo(q.x-a.tickLength<<0,b);a.ctx.stroke();a.ctx.restore()}},this);this.title&&(this._titleTextBlock.measureText(),this._titleTextBlock.x=this.bounds.x2-1,this._titleTextBlock.y=this.lineCoordinates.height/2-this._titleTextBlock.width/2+this.lineCoordinates.y1,this.titleMaxWidth=this._titleTextBlock.maxWidth,this._titleTextBlock.render(!0))}f=
0;if("inside"===this.labelPlacement)this.chart.addEventListener("dataAnimationIterationEnd",function(){for(k=0;k<a._labels.length;k++)n=a._labels[k],n.position<a.viewportMinimum||(n.position>a.viewportMaximum||d&&0!==f++%2&&a.labelAutoFit)||(a.ctx.save(),a.ctx.beginPath(),n.textBlock.render(!0),a.ctx.restore())},this);else for(k=0;k<this._labels.length;k++)n=this._labels[k],n.position<this.viewportMinimum||(n.position>this.viewportMaximum||d&&0!==f++%2&&this.labelAutoFit)||n.textBlock.render(!0)};
A.prototype.renderInterlacedColors=function(){var a=this.chart.plotArea.ctx,d,c,b=this.chart.plotArea,e=0;d=!0;if(("bottom"===this._position||"top"===this._position)&&this.interlacedColor)for(a.fillStyle=this.interlacedColor,e=0;e<this._labels.length;e++)d?(d=this.getPixelCoordinatesOnAxis(this._labels[e].position),c=e+1>this._labels.length-1?this.getPixelCoordinatesOnAxis(this.viewportMaximum):this.getPixelCoordinatesOnAxis(this._labels[e+1].position),a.fillRect(Math.min(c.x,d.x),b.y1,Math.abs(c.x-
d.x),Math.abs(b.y1-b.y2)),d=!1):d=!0;else if(("left"===this._position||"right"===this._position)&&this.interlacedColor)for(a.fillStyle=this.interlacedColor,e=0;e<this._labels.length;e++)d?(c=this.getPixelCoordinatesOnAxis(this._labels[e].position),d=e+1>this._labels.length-1?this.getPixelCoordinatesOnAxis(this.viewportMaximum):this.getPixelCoordinatesOnAxis(this._labels[e+1].position),a.fillRect(b.x1,Math.min(c.y,d.y),Math.abs(b.x1-b.x2),Math.abs(d.y-c.y)),d=!1):d=!0;a.beginPath()};A.prototype.renderStripLinesOfThicknessType=
function(a){if(this.stripLines&&0<this.stripLines.length&&a){var d=this,c,b,e=0,f=0,l=!1;b=!1;for(var h=[],p=[],k=!1,e=0;e<this.stripLines.length;e++){var m=this.stripLines[e];m._thicknessType===a&&("pixel"===a&&(m.value<this.viewportMinimum||m.value>this.viewportMaximum||r(m.value)||isNaN(this.range))||"value"===a&&(m.startValue<=this.viewportMinimum&&m.endValue<=this.viewportMinimum||m.startValue>=this.viewportMaximum&&m.endValue>=this.viewportMaximum||r(m.startValue)||r(m.endValue)||isNaN(this.range))||
h.push(m))}for(e=0;e<this._stripLineLabels.length;e++)if(m=this.stripLines[e],c=this._stripLineLabels[e],!(c.position<this.viewportMinimum||c.position>this.viewportMaximum||isNaN(this.range)))if(b=this.getPixelCoordinatesOnAxis(c.position),"outside"===c.stripLine.labelPlacement){m&&(this.ctx.strokeStyle=m.color,this.ctx.lineWidth="pixel"===m._thicknessType?m.thickness:this.tickThickness);if("bottom"===this._position){var n=1===this.ctx.lineWidth%2?(b.x<<0)+0.5:b.x<<0;this.ctx.beginPath();this.ctx.moveTo(n,
b.y<<0);this.ctx.lineTo(n,b.y+this.tickLength<<0);this.ctx.stroke();0===this.labelAngle?(b.x-=c.textBlock.width/2,b.y+=this.tickLength+c.textBlock.fontSize/2+5):(b.x-=0>this.labelAngle?c.textBlock.width*Math.cos(Math.PI/180*this.labelAngle):0,b.y+=this.tickLength+Math.abs(0>this.labelAngle?c.textBlock.width*Math.sin(Math.PI/180*this.labelAngle)-5:5))}else"top"===this._position?(n=1===this.ctx.lineWidth%2?(b.x<<0)+0.5:b.x<<0,this.ctx.beginPath(),this.ctx.moveTo(n,b.y<<0),this.ctx.lineTo(n,b.y-this.tickLength<<
0),this.ctx.stroke(),0===this.labelAngle?(b.x-=c.textBlock.width/2,b.y-=this.tickLength+c.textBlock.height-c.textBlock.fontSize/2):(b.x+=(c.textBlock.height-this.tickLength-this.labelFontSize/2)*Math.sin(Math.PI/180*this.labelAngle)-(0<this.labelAngle?c.textBlock.width*Math.cos(Math.PI/180*this.labelAngle):0),b.y-=this.tickLength+(c.textBlock.height*Math.cos(Math.PI/180*this.labelAngle)+(0<this.labelAngle?c.textBlock.width*Math.sin(Math.PI/180*this.labelAngle):0)))):"left"===this._position?(n=1===
this.ctx.lineWidth%2?(b.y<<0)+0.5:b.y<<0,this.ctx.beginPath(),this.ctx.moveTo(b.x<<0,n),this.ctx.lineTo(b.x-this.tickLength<<0,n),this.ctx.stroke(),0===this.labelAngle?b.x=b.x-c.textBlock.width*Math.cos(Math.PI/180*this.labelAngle)-this.tickLength-5:(b.y-=c.textBlock.width*Math.sin(Math.PI/180*this.labelAngle),b.x=0<this.labelAngle?b.x-c.textBlock.width*Math.cos(Math.PI/180*this.labelAngle)-this.tickLength-5:b.x-c.textBlock.width*Math.cos(Math.PI/180*this.labelAngle)+(c.textBlock.height-c.textBlock.fontSize/
2-5)*Math.sin(Math.PI/180*this.labelAngle)-this.tickLength)):"right"===this._position&&(n=1===this.ctx.lineWidth%2?(b.y<<0)+0.5:b.y<<0,this.ctx.beginPath(),this.ctx.moveTo(b.x<<0,n),this.ctx.lineTo(b.x+this.tickLength<<0,n),this.ctx.stroke(),0===this.labelAngle?b.x=b.x+this.tickLength+5:(b.y=0>this.labelAngle?b.y:b.y-(c.textBlock.height-c.textBlock.fontSize/2-5)*Math.cos(Math.PI/180*this.labelAngle),b.x=0<this.labelAngle?b.x+(c.textBlock.height-c.textBlock.fontSize/2-5)*Math.sin(Math.PI/180*this.labelAngle)+
this.tickLength:b.x+this.tickLength+5));c.textBlock.x=b.x;c.textBlock.y=b.y;p.push(c)}else m._thicknessType===a&&(c.textBlock.angle=-90,"bottom"===this._position?(c.textBlock.maxWidth=this.options.stripLines[e].labelMaxWidth?this.options.stripLines[e].labelMaxWidth:this.chart.plotArea.height-3,c.textBlock.measureText(),b.x-c.textBlock.height-m.thickness/2>this.chart.plotArea.x1?r(m.startValue)?b.x-=c.textBlock.height-c.textBlock.fontSize/2+m.thickness/2:b.x-=c.textBlock.height/2-c.textBlock.fontSize/
2:(c.textBlock.angle=90,r(m.startValue)?b.x+=c.textBlock.height-c.textBlock.fontSize/2+m.thickness/2:b.x+=c.textBlock.height/2-c.textBlock.fontSize/2),b.y=-90===c.textBlock.angle?"near"===c.stripLine.labelAlign?this.chart.plotArea.y2-3:"center"===c.stripLine.labelAlign?(this.chart.plotArea.y2+this.chart.plotArea.y1+c.textBlock.width)/2:this.chart.plotArea.y1+c.textBlock.width+3:"near"===c.stripLine.labelAlign?this.chart.plotArea.y2-c.textBlock.width-3:"center"===c.stripLine.labelAlign?(this.chart.plotArea.y2+
this.chart.plotArea.y1-c.textBlock.width)/2:this.chart.plotArea.y1+3):"top"===this._position?(c.textBlock.maxWidth=this.options.stripLines[e].labelMaxWidth?this.options.stripLines[e].labelMaxWidth:this.chart.plotArea.height-3,c.textBlock.measureText(),b.x-c.textBlock.height-m.thickness/2>this.chart.plotArea.x1?r(m.startValue)?b.x-=c.textBlock.height-c.textBlock.fontSize/2+m.thickness/2:b.x-=c.textBlock.height/2-c.textBlock.fontSize/2:(c.textBlock.angle=90,r(m.startValue)?b.x+=c.textBlock.height-c.textBlock.fontSize/
2+m.thickness/2:b.x+=c.textBlock.height/2-c.textBlock.fontSize/2),b.y=-90===c.textBlock.angle?"near"===c.stripLine.labelAlign?this.chart.plotArea.y1+c.textBlock.width+3:"center"===c.stripLine.labelAlign?(this.chart.plotArea.y2+this.chart.plotArea.y1+c.textBlock.width)/2:this.chart.plotArea.y2-3:"near"===c.stripLine.labelAlign?this.chart.plotArea.y1+3:"center"===c.stripLine.labelAlign?(this.chart.plotArea.y2+this.chart.plotArea.y1-c.textBlock.width)/2:this.chart.plotArea.y2-c.textBlock.width-3):"left"===
this._position?(c.textBlock.maxWidth=this.options.stripLines[e].labelMaxWidth?this.options.stripLines[e].labelMaxWidth:this.chart.plotArea.width-3,c.textBlock.angle=0,c.textBlock.measureText(),b.y-c.textBlock.height-m.thickness/2>this.chart.plotArea.y1?r(m.startValue)?b.y-=c.textBlock.height-c.textBlock.fontSize/2+m.thickness/2:b.y-=c.textBlock.height/2-c.textBlock.fontSize/2:r(m.startValue)?b.y+=c.textBlock.height-c.textBlock.fontSize/2+m.thickness/2:b.y+=c.textBlock.height/2-c.textBlock.fontSize+
3,b.x="near"===c.stripLine.labelAlign?this.chart.plotArea.x1+3:"center"===c.stripLine.labelAlign?(this.chart.plotArea.x2+this.chart.plotArea.x1)/2-c.textBlock.width/2:this.chart.plotArea.x2-c.textBlock.width-3):"right"===this._position&&(c.textBlock.maxWidth=this.options.stripLines[e].labelMaxWidth?this.options.stripLines[e].labelMaxWidth:this.chart.plotArea.width-3,c.textBlock.angle=0,c.textBlock.measureText(),b.y-c.textBlock.height-m.thickness/2>this.chart.plotArea.y1?r(m.startValue)?b.y-=c.textBlock.height-
c.textBlock.fontSize/2+m.thickness/2:b.y-=c.textBlock.height/2-c.textBlock.fontSize/2:r(m.startValue)?b.y+=c.textBlock.height-c.textBlock.fontSize/2+m.thickness/2:b.y-=c.textBlock.height/2-c.textBlock.fontSize/2+3,b.x="near"===c.stripLine.labelAlign?this.chart.plotArea.x2-c.textBlock.width-3:"center"===c.stripLine.labelAlign?(this.chart.plotArea.x2+this.chart.plotArea.x1)/2-c.textBlock.width/2:this.chart.plotArea.x1+3),c.textBlock.x=b.x,c.textBlock.y=b.y,p.push(c));if(!k){b=!1;this.ctx.save();this.ctx.beginPath();
this.ctx.rect(this.chart.plotArea.x1,this.chart.plotArea.y1,this.chart.plotArea.width,this.chart.plotArea.height);this.ctx.clip();for(e=0;e<h.length;e++)m=h[e],m.showOnTop?l||(l=!0,this.chart.addEventListener("dataAnimationIterationEnd",function(){this.ctx.save();this.ctx.beginPath();this.ctx.rect(this.chart.plotArea.x1,this.chart.plotArea.y1,this.chart.plotArea.width,this.chart.plotArea.height);this.ctx.clip();for(f=0;f<h.length;f++)m=h[f],m.showOnTop&&m.render();this.ctx.restore()},m)):m.render();
for(e=0;e<p.length;e++)c=p[e],c.stripLine.showOnTop?b||(b=!0,this.chart.addEventListener("dataAnimationIterationEnd",function(){for(f=0;f<p.length;f++)c=p[f],"inside"===c.stripLine.labelPlacement&&c.stripLine.showOnTop&&(d.ctx.save(),d.ctx.beginPath(),d.ctx.rect(d.chart.plotArea.x1,d.chart.plotArea.y1,d.chart.plotArea.width,d.chart.plotArea.height),d.ctx.clip(),c.textBlock.render(!0),d.ctx.restore())},c.textBlock)):"inside"===c.stripLine.labelPlacement&&c.textBlock.render(!0);this.ctx.restore();k=
!0}if(k)for(b=!1,e=0;e<p.length;e++)c=p[e],"outside"===c.stripLine.labelPlacement&&c.textBlock.render(!0)}};A.prototype.renderBreaksBackground=function(){this.chart._breaksCanvas&&(this.scaleBreaks&&0<this.scaleBreaks._appliedBreaks.length&&this.maskCanvas)&&(this.chart._breaksCanvasCtx.save(),this.chart._breaksCanvasCtx.beginPath(),this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1,this.chart.plotArea.y1,this.chart.plotArea.width,this.chart.plotArea.height),this.chart._breaksCanvasCtx.clip(),
this.chart._breaksCanvasCtx.drawImage(this.maskCanvas,0,0,this.chart.width,this.chart.height),this.chart._breaksCanvasCtx.restore())};A.prototype.createMask=function(){if(this.scaleBreaks&&0<this.scaleBreaks._appliedBreaks.length){var a=this.scaleBreaks._appliedBreaks;w?(this.maskCanvas=ua(this.chart.width,this.chart.height),this.maskCtx=this.maskCanvas.getContext("2d")):(this.maskCanvas=this.chart.plotArea.canvas,this.maskCtx=this.chart.plotArea.ctx);this.maskCtx.save();this.maskCtx.beginPath();
this.maskCtx.rect(this.chart.plotArea.x1,this.chart.plotArea.y1,this.chart.plotArea.width,this.chart.plotArea.height);this.maskCtx.clip();for(var d=0;d<a.length;d++)a[d].endValue<this.viewportMinimum||(a[d].startValue>this.viewportMaximum||isNaN(this.range))||a[d].render(this.maskCtx);this.maskCtx.restore()}};A.prototype.renderCrosshair=function(a,d){isFinite(this.minimum)&&isFinite(this.maximum)&&this.crosshair.render(a,d)};A.prototype.showCrosshair=function(a){r(a)||(a<this.viewportMinimum||a>this.viewportMaximum)||
("top"===this._position||"bottom"===this._position?this.crosshair.render(this.convertValueToPixel(a),null,a):this.crosshair.render(null,this.convertValueToPixel(a),a))};A.prototype.renderGrid=function(){if(this.gridThickness&&0<this.gridThickness){var a=this.chart.ctx;a.save();var d,c=this.chart.plotArea;a.lineWidth=this.gridThickness;a.strokeStyle=this.gridColor;a.setLineDash&&a.setLineDash(J(this.gridDashType,this.gridThickness));if("bottom"===this._position||"top"===this._position)for(b=0;b<this._labels.length;b++)this._labels[b].position<
this.viewportMinimum||(this._labels[b].position>this.viewportMaximum||this._labels[b].breaksLabelType)||(a.beginPath(),d=this.getPixelCoordinatesOnAxis(this._labels[b].position),d=1===a.lineWidth%2?(d.x<<0)+0.5:d.x<<0,a.moveTo(d,c.y1<<0),a.lineTo(d,c.y2<<0),a.stroke());else if("left"===this._position||"right"===this._position)for(var b=0;b<this._labels.length;b++)this._labels[b].position<this.viewportMinimum||(this._labels[b].position>this.viewportMaximum||this._labels[b].breaksLabelType)||(a.beginPath(),
d=this.getPixelCoordinatesOnAxis(this._labels[b].position),d=1===a.lineWidth%2?(d.y<<0)+0.5:d.y<<0,a.moveTo(c.x1<<0,d),a.lineTo(c.x2<<0,d),a.stroke());a.restore()}};A.prototype.renderAxisLine=function(){var a=this.chart.ctx,d=w?this.chart._preRenderCtx:a,c=Math.ceil(this.tickThickness/(this.reversed?-2:2)),b=Math.ceil(this.tickThickness/(this.reversed?2:-2)),e,f;d.save();if("bottom"===this._position||"top"===this._position){if(this.lineThickness){this.reversed?(e=this.lineCoordinates.x2,f=this.lineCoordinates.x1):
(e=this.lineCoordinates.x1,f=this.lineCoordinates.x2);d.lineWidth=this.lineThickness;d.strokeStyle=this.lineColor?this.lineColor:"black";d.setLineDash&&d.setLineDash(J(this.lineDashType,this.lineThickness));var l=1===this.lineThickness%2?(this.lineCoordinates.y1<<0)+0.5:this.lineCoordinates.y1<<0;d.beginPath();if(this.scaleBreaks&&!r(this.scaleBreaks.firstBreakIndex))if(r(this.scaleBreaks.lastBreakIndex))e=this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel+b;else for(var h=
this.scaleBreaks.firstBreakIndex;h<=this.scaleBreaks.lastBreakIndex;h++)d.moveTo(e,l),d.lineTo(this.scaleBreaks._appliedBreaks[h].startPixel+c,l),e=this.scaleBreaks._appliedBreaks[h].endPixel+b;e&&(d.moveTo(e,l),d.lineTo(f,l));d.stroke()}}else if(("left"===this._position||"right"===this._position)&&this.lineThickness){this.reversed?(e=this.lineCoordinates.y1,f=this.lineCoordinates.y2):(e=this.lineCoordinates.y2,f=this.lineCoordinates.y1);d.lineWidth=this.lineThickness;d.strokeStyle=this.lineColor;
d.setLineDash&&d.setLineDash(J(this.lineDashType,this.lineThickness));l=1===this.lineThickness%2?(this.lineCoordinates.x1<<0)+0.5:this.lineCoordinates.x1<<0;d.beginPath();if(this.scaleBreaks&&!r(this.scaleBreaks.firstBreakIndex))if(r(this.scaleBreaks.lastBreakIndex))e=this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel+c;else for(h=this.scaleBreaks.firstBreakIndex;h<=this.scaleBreaks.lastBreakIndex;h++)d.moveTo(l,e),d.lineTo(l,this.scaleBreaks._appliedBreaks[h].startPixel+b),
e=this.scaleBreaks._appliedBreaks[h].endPixel+c;e&&(d.moveTo(l,e),d.lineTo(l,f));d.stroke()}w&&(a.drawImage(this.chart._preRenderCanvas,0,0,this.chart.width,this.chart.height),this.chart._breaksCanvasCtx&&this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas,0,0,this.chart.width,this.chart.height),d.clearRect(0,0,this.chart.width,this.chart.height));d.restore()};A.prototype.getPixelCoordinatesOnAxis=function(a){var d={};if("bottom"===this._position||"top"===this._position)d.x=this.convertValueToPixel(a),
d.y=this.lineCoordinates.y1;if("left"===this._position||"right"===this._position)d.y=this.convertValueToPixel(a),d.x=this.lineCoordinates.x2;return d};A.prototype.convertPixelToValue=function(a){if("undefined"===typeof a)return null;var d=0,c=0,b,d=!0,e=this.scaleBreaks?this.scaleBreaks._appliedBreaks:[],c="number"===typeof a?a:"left"===this._position||"right"===this._position?a.y:a.x;if(this.logarithmic){a=b=Math.pow(this.logarithmBase,(c-this.conversionParameters.reference)/this.conversionParameters.pixelPerUnit);
if(c<=this.conversionParameters.reference===("left"===this._position||"right"===this._position)!==this.reversed)for(c=0;c<e.length;c++){if(!(e[c].endValue<this.conversionParameters.minimum))if(d)if(e[c].startValue<this.conversionParameters.minimum){if(1<e[c].size&&this.conversionParameters.minimum*Math.pow(e[c].endValue/e[c].startValue,Math.log(b)/Math.log(e[c].size))<e[c].endValue){a=Math.pow(e[c].endValue/e[c].startValue,Math.log(b)/Math.log(e[c].size));break}else a*=e[c].endValue/this.conversionParameters.minimum/
Math.pow(e[c].size,Math.log(e[c].endValue/this.conversionParameters.minimum)/Math.log(e[c].endValue/e[c].startValue)),b/=Math.pow(e[c].size,Math.log(e[c].endValue/this.conversionParameters.minimum)/Math.log(e[c].endValue/e[c].startValue));d=!1}else if(b>e[c].startValue/this.conversionParameters.minimum){b/=e[c].startValue/this.conversionParameters.minimum;if(b<e[c].size){a*=Math.pow(e[c].endValue/e[c].startValue,1===e[c].size?1:Math.log(b)/Math.log(e[c].size))/b;break}else a*=e[c].endValue/e[c].startValue/
e[c].size;b/=e[c].size;d=!1}else break;else if(b>e[c].startValue/e[c-1].endValue){b/=e[c].startValue/e[c-1].endValue;if(b<e[c].size){a*=Math.pow(e[c].endValue/e[c].startValue,1===e[c].size?1:Math.log(b)/Math.log(e[c].size))/b;break}else a*=e[c].endValue/e[c].startValue/e[c].size;b/=e[c].size}else break}else for(c=e.length-1;0<=c;c--)if(!(e[c].startValue>this.conversionParameters.minimum))if(d)if(e[c].endValue>this.conversionParameters.minimum){if(1<e[c].size&&this.conversionParameters.minimum*Math.pow(e[c].endValue/
e[c].startValue,Math.log(b)/Math.log(e[c].size))>e[c].startValue){a=Math.pow(e[c].endValue/e[c].startValue,Math.log(b)/Math.log(e[c].size));break}else a*=e[c].startValue/this.conversionParameters.minimum*Math.pow(e[c].size,Math.log(e[c].startValue/this.conversionParameters.minimum)/Math.log(e[c].endValue/e[c].startValue))*b,b*=Math.pow(e[c].size,Math.log(this.conversionParameters.minimum/e[c].startValue)/Math.log(e[c].endValue/e[c].startValue));d=!1}else if(b<e[c].endValue/this.conversionParameters.minimum){b/=
e[c].endValue/this.conversionParameters.minimum;if(b>1/e[c].size){a*=Math.pow(e[c].endValue/e[c].startValue,1>=e[c].size?1:Math.log(b)/Math.log(e[c].size))*b;break}else a/=e[c].endValue/e[c].startValue/e[c].size;b*=e[c].size;d=!1}else break;else if(b<e[c].endValue/e[c+1].startValue){b/=e[c].endValue/e[c+1].startValue;if(b>1/e[c].size){a*=Math.pow(e[c].endValue/e[c].startValue,1>=e[c].size?1:Math.log(b)/Math.log(e[c].size))*b;break}else a/=e[c].endValue/e[c].startValue/e[c].size;b*=e[c].size}else break;
d=a*this.viewportMinimum}else{a=b=(c-this.conversionParameters.reference)/this.conversionParameters.pixelPerUnit;if(c<=this.conversionParameters.reference===("left"===this._position||"right"===this._position)!==this.reversed)for(c=0;c<e.length;c++){if(!(e[c].endValue<this.conversionParameters.minimum))if(d)if(e[c].startValue<this.conversionParameters.minimum){if(e[c].size&&this.conversionParameters.minimum+b*(e[c].endValue-e[c].startValue)/e[c].size<e[c].endValue){a=0>=e[c].size?0:b*(e[c].endValue-
e[c].startValue)/e[c].size;break}else a+=e[c].endValue-this.conversionParameters.minimum-e[c].size*(e[c].endValue-this.conversionParameters.minimum)/(e[c].endValue-e[c].startValue),b-=e[c].size*(e[c].endValue-this.conversionParameters.minimum)/(e[c].endValue-e[c].startValue);d=!1}else if(b>e[c].startValue-this.conversionParameters.minimum){b-=e[c].startValue-this.conversionParameters.minimum;if(b<e[c].size){a+=(e[c].endValue-e[c].startValue)*(0===e[c].size?1:b/e[c].size)-b;break}else a+=e[c].endValue-
e[c].startValue-e[c].size;b-=e[c].size;d=!1}else break;else if(b>e[c].startValue-e[c-1].endValue){b-=e[c].startValue-e[c-1].endValue;if(b<e[c].size){a+=(e[c].endValue-e[c].startValue)*(0===e[c].size?1:b/e[c].size)-b;break}else a+=e[c].endValue-e[c].startValue-e[c].size;b-=e[c].size}else break}else for(c=e.length-1;0<=c;c--)if(!(e[c].startValue>this.conversionParameters.minimum))if(d)if(e[c].endValue>this.conversionParameters.minimum)if(e[c].size&&this.conversionParameters.minimum+b*(e[c].endValue-
e[c].startValue)/e[c].size>e[c].startValue){a=0>=e[c].size?0:b*(e[c].endValue-e[c].startValue)/e[c].size;break}else a+=e[c].startValue-this.conversionParameters.minimum+e[c].size*(this.conversionParameters.minimum-e[c].startValue)/(e[c].endValue-e[c].startValue),b+=e[c].size*(this.conversionParameters.minimum-e[c].startValue)/(e[c].endValue-e[c].startValue),d=!1;else if(b<e[c].endValue-this.conversionParameters.minimum){b-=e[c].endValue-this.conversionParameters.minimum;if(b>-1*e[c].size){a+=(e[c].endValue-
e[c].startValue)*(0===e[c].size?1:b/e[c].size)+b;break}else a-=e[c].endValue-e[c].startValue-e[c].size;b+=e[c].size;d=!1}else break;else if(b<e[c].endValue-e[c+1].startValue){b-=e[c].endValue-e[c+1].startValue;if(b>-1*e[c].size){a+=(e[c].endValue-e[c].startValue)*(0===e[c].size?1:b/e[c].size)+b;break}else a-=e[c].endValue-e[c].startValue-e[c].size;b+=e[c].size}else break;d=this.conversionParameters.minimum+a}return d};A.prototype.convertValueToPixel=function(a){a=this.getApparentDifference(this.conversionParameters.minimum,
a,a);return this.logarithmic?this.conversionParameters.reference+this.conversionParameters.pixelPerUnit*Math.log(a/this.conversionParameters.minimum)/this.conversionParameters.lnLogarithmBase+0.5<<0:"axisX"===this.type?this.conversionParameters.reference+this.conversionParameters.pixelPerUnit*(a-this.conversionParameters.minimum)+0.5<<0:this.conversionParameters.reference+this.conversionParameters.pixelPerUnit*(a-this.conversionParameters.minimum)+0.5};A.prototype.getApparentDifference=function(a,
d,c,b){var e=this.scaleBreaks?this.scaleBreaks._appliedBreaks:[];if(this.logarithmic){c=r(c)?d/a:c;for(var f=0;f<e.length&&!(d<e[f].startValue);f++)a>e[f].endValue||(a<=e[f].startValue&&d>=e[f].endValue?c=c/e[f].endValue*e[f].startValue*e[f].size:a>=e[f].startValue&&d>=e[f].endValue?c=c/e[f].endValue*a*Math.pow(e[f].size,Math.log(e[f].endValue/a)/Math.log(e[f].endValue/e[f].startValue)):a<=e[f].startValue&&d<=e[f].endValue?c=c/d*e[f].startValue*Math.pow(e[f].size,Math.log(d/e[f].startValue)/Math.log(e[f].endValue/
e[f].startValue)):!b&&(a>e[f].startValue&&d<e[f].endValue)&&(c=a*Math.pow(e[f].size,Math.log(d/a)/Math.log(e[f].endValue/e[f].startValue))))}else for(c=r(c)?Math.abs(d-a):c,f=0;f<e.length&&!(d<e[f].startValue);f++)a>e[f].endValue||(a<=e[f].startValue&&d>=e[f].endValue?c=c-e[f].endValue+e[f].startValue+e[f].size:a>e[f].startValue&&d>=e[f].endValue?c=c-e[f].endValue+a+e[f].size*(e[f].endValue-a)/(e[f].endValue-e[f].startValue):a<=e[f].startValue&&d<e[f].endValue?c=c-d+e[f].startValue+e[f].size*(d-e[f].startValue)/
(e[f].endValue-e[f].startValue):!b&&(a>e[f].startValue&&d<e[f].endValue)&&(c=a+e[f].size*(d-a)/(e[f].endValue-e[f].startValue)));return c};A.prototype.setViewPortRange=function(a,d){this.sessionVariables.newViewportMinimum=this.viewportMinimum=Math.min(a,d);this.sessionVariables.newViewportMaximum=this.viewportMaximum=Math.max(a,d)};A.prototype.getXValueAt=function(a){if(!a)return null;var d=null;"left"===this._position?d=this.convertPixelToValue(a.y):"bottom"===this._position&&(d=this.convertPixelToValue(a.x));
return d};A.prototype.calculateValueToPixelConversionParameters=function(a){a=this.scaleBreaks?this.scaleBreaks._appliedBreaks:[];var d={pixelPerUnit:null,minimum:null,reference:null},c=this.lineCoordinates.width,b=this.lineCoordinates.height,c="bottom"===this._position||"top"===this._position?c:b,b=Math.abs(this.range);if(this.logarithmic)for(var e=0;e<a.length&&!(this.viewportMaximum<a[e].startValue);e++)this.viewportMinimum>a[e].endValue||(this.viewportMinimum>=a[e].startValue&&this.viewportMaximum<=
a[e].endValue?c=0:this.viewportMinimum<=a[e].startValue&&this.viewportMaximum>=a[e].endValue?(b=b/a[e].endValue*a[e].startValue,c=0<a[e].spacing.toString().indexOf("%")?c*(1-parseFloat(a[e].spacing)/100):c-Math.min(a[e].spacing,0.1*c)):this.viewportMinimum>a[e].startValue&&this.viewportMaximum>=a[e].endValue?(b=b/a[e].endValue*this.viewportMinimum,c=0<a[e].spacing.toString().indexOf("%")?c*(1-parseFloat(a[e].spacing)/100*Math.log(a[e].endValue/this.viewportMinimum)/Math.log(a[e].endValue/a[e].startValue)):
c-Math.min(a[e].spacing,0.1*c)*Math.log(a[e].endValue/this.viewportMinimum)/Math.log(a[e].endValue/a[e].startValue)):this.viewportMinimum<=a[e].startValue&&this.viewportMaximum<a[e].endValue&&(b=b/this.viewportMaximum*a[e].startValue,c=0<a[e].spacing.toString().indexOf("%")?c*(1-parseFloat(a[e].spacing)/100*Math.log(this.viewportMaximum/a[e].startValue)/Math.log(a[e].endValue/a[e].startValue)):c-Math.min(a[e].spacing,0.1*c)*Math.log(this.viewportMaximum/a[e].startValue)/Math.log(a[e].endValue/a[e].startValue)));
else for(e=0;e<a.length&&!(this.viewportMaximum<a[e].startValue);e++)this.viewportMinimum>a[e].endValue||(this.viewportMinimum>=a[e].startValue&&this.viewportMaximum<=a[e].endValue?c=0:this.viewportMinimum<=a[e].startValue&&this.viewportMaximum>=a[e].endValue?(b=b-a[e].endValue+a[e].startValue,c=0<a[e].spacing.toString().indexOf("%")?c*(1-parseFloat(a[e].spacing)/100):c-Math.min(a[e].spacing,0.1*c)):this.viewportMinimum>a[e].startValue&&this.viewportMaximum>=a[e].endValue?(b=b-a[e].endValue+this.viewportMinimum,
c=0<a[e].spacing.toString().indexOf("%")?c*(1-parseFloat(a[e].spacing)/100*(a[e].endValue-this.viewportMinimum)/(a[e].endValue-a[e].startValue)):c-Math.min(a[e].spacing,0.1*c)*(a[e].endValue-this.viewportMinimum)/(a[e].endValue-a[e].startValue)):this.viewportMinimum<=a[e].startValue&&this.viewportMaximum<a[e].endValue&&(b=b-this.viewportMaximum+a[e].startValue,c=0<a[e].spacing.toString().indexOf("%")?c*(1-parseFloat(a[e].spacing)/100*(this.viewportMaximum-a[e].startValue)/(a[e].endValue-a[e].startValue)):
c-Math.min(a[e].spacing,0.1*c)*(this.viewportMaximum-a[e].startValue)/(a[e].endValue-a[e].startValue)));d.minimum=this.viewportMinimum;d.maximum=this.viewportMaximum;d.range=b;if("bottom"===this._position||"top"===this._position)this.logarithmic?(d.lnLogarithmBase=Math.log(this.logarithmBase),d.pixelPerUnit=(this.reversed?-1:1)*c*d.lnLogarithmBase/Math.log(Math.abs(b))):d.pixelPerUnit=(this.reversed?-1:1)*c/Math.abs(b),d.reference=this.reversed?this.lineCoordinates.x2:this.lineCoordinates.x1;if("left"===
this._position||"right"===this._position)this.logarithmic?(d.lnLogarithmBase=Math.log(this.logarithmBase),d.pixelPerUnit=(this.reversed?1:-1)*c*d.lnLogarithmBase/Math.log(Math.abs(b))):d.pixelPerUnit=(this.reversed?1:-1)*c/Math.abs(b),d.reference=this.reversed?this.lineCoordinates.y1:this.lineCoordinates.y2;this.conversionParameters=d};A.prototype.calculateAxisParameters=function(){if(this.logarithmic)this.calculateLogarithmicAxisParameters();else{var a=this.chart.layoutManager.getFreeSpace(),d=!1,
c=!1;"bottom"===this._position||"top"===this._position?(this.maxWidth=a.width,this.maxHeight=a.height):(this.maxWidth=a.height,this.maxHeight=a.width);var a="axisX"===this.type?"xySwapped"===this.chart.plotInfo.axisPlacement?62:70:"xySwapped"===this.chart.plotInfo.axisPlacement?50:40,b=4;"axisX"===this.type&&(b=600>this.maxWidth?8:6);var a=Math.max(b,Math.floor(this.maxWidth/a)),e,f,l,b=0;!r(this.options.viewportMinimum)&&(!r(this.options.viewportMaximum)&&this.options.viewportMinimum>=this.options.viewportMaximum)&&
(this.viewportMinimum=this.viewportMaximum=null);if(r(this.options.viewportMinimum)&&!r(this.sessionVariables.newViewportMinimum)&&!isNaN(this.sessionVariables.newViewportMinimum))this.viewportMinimum=this.sessionVariables.newViewportMinimum;else if(null===this.viewportMinimum||isNaN(this.viewportMinimum))this.viewportMinimum=this.minimum;if(r(this.options.viewportMaximum)&&!r(this.sessionVariables.newViewportMaximum)&&!isNaN(this.sessionVariables.newViewportMaximum))this.viewportMaximum=this.sessionVariables.newViewportMaximum;
else if(null===this.viewportMaximum||isNaN(this.viewportMaximum))this.viewportMaximum=this.maximum;if(this.scaleBreaks)for(b=0;b<this.scaleBreaks._appliedBreaks.length;b++)if((!r(this.sessionVariables.newViewportMinimum)&&this.sessionVariables.newViewportMinimum>=this.scaleBreaks._appliedBreaks[b].startValue||!r(this.options.minimum)&&this.options.minimum>=this.scaleBreaks._appliedBreaks[b].startValue||!r(this.options.viewportMinimum)&&this.viewportMinimum>=this.scaleBreaks._appliedBreaks[b].startValue)&&
(!r(this.sessionVariables.newViewportMaximum)&&this.sessionVariables.newViewportMaximum<=this.scaleBreaks._appliedBreaks[b].endValue||!r(this.options.maximum)&&this.options.maximum<=this.scaleBreaks._appliedBreaks[b].endValue||!r(this.options.viewportMaximum)&&this.viewportMaximum<=this.scaleBreaks._appliedBreaks[b].endValue)){this.scaleBreaks._appliedBreaks.splice(b,1);break}if("axisX"===this.type){if(this.dataSeries&&0<this.dataSeries.length)for(e=0;e<this.dataSeries.length;e++)"dateTime"===this.dataSeries[e].xValueType&&
(c=!0);e=null!==this.viewportMinimum?this.viewportMinimum:this.dataInfo.viewPortMin;f=null!==this.viewportMaximum?this.viewportMaximum:this.dataInfo.viewPortMax;0===f-e&&(b="undefined"===typeof this.options.interval?0.4:this.options.interval,f+=b,e-=b);Infinity!==this.dataInfo.minDiff?l=this.dataInfo.minDiff:1<f-e?l=0.5*Math.abs(f-e):(l=1,c&&(d=!0))}else"axisY"===this.type&&(e=null!==this.viewportMinimum?this.viewportMinimum:this.dataInfo.viewPortMin,f=null!==this.viewportMaximum?this.viewportMaximum:
this.dataInfo.viewPortMax,isFinite(e)||isFinite(f)?isFinite(e)?isFinite(f)||(f=e):e=f:(f="undefined"===typeof this.options.interval?-Infinity:this.options.interval,e="undefined"!==typeof this.options.interval||isFinite(this.dataInfo.minDiff)?0:Infinity),0===e&&0===f?(f+=9,e=0):0===f-e?(b=Math.min(Math.abs(0.01*Math.abs(f)),5),f+=b,e-=b):e>f?(b=Math.min(0.01*Math.abs(this.getApparentDifference(f,e,null,!0)),5),0<=f?e=f-b:f=isFinite(e)?e+b:0):(b=Math.min(0.01*Math.abs(this.getApparentDifference(e,f,
null,!0)),0.05),0!==f&&(f+=b),0!==e&&(e-=b)),l=Infinity!==this.dataInfo.minDiff?this.dataInfo.minDiff:1<f-e?0.5*Math.abs(f-e):1,this.includeZero&&(null===this.viewportMinimum||isNaN(this.viewportMinimum))&&0<e&&(e=0),this.includeZero&&(null===this.viewportMaximum||isNaN(this.viewportMaximum))&&0>f&&(f=0));b=this.getApparentDifference(isNaN(this.viewportMinimum)||null===this.viewportMinimum?e:this.viewportMinimum,isNaN(this.viewportMaximum)||null===this.viewportMaximum?f:this.viewportMaximum,null,
!0);if("axisX"===this.type&&c){this.valueType="dateTime";this.intervalType||(b/1<=a?(this.interval=1,this.intervalType="millisecond"):b/2<=a?(this.interval=2,this.intervalType="millisecond"):b/5<=a?(this.interval=5,this.intervalType="millisecond"):b/10<=a?(this.interval=10,this.intervalType="millisecond"):b/20<=a?(this.interval=20,this.intervalType="millisecond"):b/50<=a?(this.interval=50,this.intervalType="millisecond"):b/100<=a?(this.interval=100,this.intervalType="millisecond"):b/200<=a?(this.interval=
200,this.intervalType="millisecond"):b/250<=a?(this.interval=250,this.intervalType="millisecond"):b/300<=a?(this.interval=300,this.intervalType="millisecond"):b/400<=a?(this.interval=400,this.intervalType="millisecond"):b/500<=a?(this.interval=500,this.intervalType="millisecond"):b/(1*T.secondDuration)<=a?(this.interval=1,this.intervalType="second"):b/(2*T.secondDuration)<=a?(this.interval=2,this.intervalType="second"):b/(5*T.secondDuration)<=a?(this.interval=5,this.intervalType="second"):b/(10*T.secondDuration)<=
a?(this.interval=10,this.intervalType="second"):b/(15*T.secondDuration)<=a?(this.interval=15,this.intervalType="second"):b/(20*T.secondDuration)<=a?(this.interval=20,this.intervalType="second"):b/(30*T.secondDuration)<=a?(this.interval=30,this.intervalType="second"):b/(1*T.minuteDuration)<=a?(this.interval=1,this.intervalType="minute"):b/(2*T.minuteDuration)<=a?(this.interval=2,this.intervalType="minute"):b/(5*T.minuteDuration)<=a?(this.interval=5,this.intervalType="minute"):b/(10*T.minuteDuration)<=
a?(this.interval=10,this.intervalType="minute"):b/(15*T.minuteDuration)<=a?(this.interval=15,this.intervalType="minute"):b/(20*T.minuteDuration)<=a?(this.interval=20,this.intervalType="minute"):b/(30*T.minuteDuration)<=a?(this.interval=30,this.intervalType="minute"):b/(1*T.hourDuration)<=a?(this.interval=1,this.intervalType="hour"):b/(2*T.hourDuration)<=a?(this.interval=2,this.intervalType="hour"):b/(3*T.hourDuration)<=a?(this.interval=3,this.intervalType="hour"):b/(6*T.hourDuration)<=a?(this.interval=
6,this.intervalType="hour"):b/(1*T.dayDuration)<=a?(this.interval=1,this.intervalType="day"):b/(2*T.dayDuration)<=a?(this.interval=2,this.intervalType="day"):b/(4*T.dayDuration)<=a?(this.interval=4,this.intervalType="day"):b/(1*T.weekDuration)<=a?(this.interval=1,this.intervalType="week"):b/(2*T.weekDuration)<=a?(this.interval=2,this.intervalType="week"):b/(3*T.weekDuration)<=a?(this.interval=3,this.intervalType="week"):b/(1*T.monthDuration)<=a?(this.interval=1,this.intervalType="month"):b/(2*T.monthDuration)<=
a?(this.interval=2,this.intervalType="month"):b/(3*T.monthDuration)<=a?(this.interval=3,this.intervalType="month"):b/(6*T.monthDuration)<=a?(this.interval=6,this.intervalType="month"):(this.interval=b/(1*T.yearDuration)<=a?1:b/(2*T.yearDuration)<=a?2:b/(4*T.yearDuration)<=a?4:Math.floor(A.getNiceNumber(b/(a-1),!0)/T.yearDuration),this.intervalType="year"));if(null===this.viewportMinimum||isNaN(this.viewportMinimum))this.viewportMinimum=e-l/2;if(null===this.viewportMaximum||isNaN(this.viewportMaximum))this.viewportMaximum=
f+l/2;d?this.autoValueFormatString="MMM DD YYYY HH:mm":"year"===this.intervalType?this.autoValueFormatString="YYYY":"month"===this.intervalType?this.autoValueFormatString="MMM YYYY":"week"===this.intervalType?this.autoValueFormatString="MMM DD YYYY":"day"===this.intervalType?this.autoValueFormatString="MMM DD YYYY":"hour"===this.intervalType?this.autoValueFormatString="hh:mm TT":"minute"===this.intervalType?this.autoValueFormatString="hh:mm TT":"second"===this.intervalType?this.autoValueFormatString=
"hh:mm:ss TT":"millisecond"===this.intervalType&&(this.autoValueFormatString="fff'ms'");this.valueFormatString||(this.valueFormatString=this.autoValueFormatString)}else{this.intervalType="number";b=A.getNiceNumber(b,!1);this.interval=this.options&&0<this.options.interval?this.options.interval:A.getNiceNumber(b/(a-1),!0);if(null===this.viewportMinimum||isNaN(this.viewportMinimum))this.viewportMinimum="axisX"===this.type?e-l/2:Math.floor(e/this.interval)*this.interval;if(null===this.viewportMaximum||
isNaN(this.viewportMaximum))this.viewportMaximum="axisX"===this.type?f+l/2:Math.ceil(f/this.interval)*this.interval;0===this.viewportMaximum&&0===this.viewportMinimum&&(0===this.options.viewportMinimum?this.viewportMaximum+=10:0===this.options.viewportMaximum&&(this.viewportMinimum-=10),this.options&&"undefined"===typeof this.options.interval&&(this.interval=A.getNiceNumber((this.viewportMaximum-this.viewportMinimum)/(a-1),!0)))}if(null===this.minimum||null===this.maximum)if("axisX"===this.type?(e=
null!==this.minimum?this.minimum:this.dataInfo.min,f=null!==this.maximum?this.maximum:this.dataInfo.max,0===f-e&&(b="undefined"===typeof this.options.interval?0.4:this.options.interval,f+=b,e-=b),l=Infinity!==this.dataInfo.minDiff?this.dataInfo.minDiff:1<f-e?0.5*Math.abs(f-e):1):"axisY"===this.type&&(e=null!==this.minimum?this.minimum:this.dataInfo.min,f=null!==this.maximum?this.maximum:this.dataInfo.max,isFinite(e)||isFinite(f)?0===e&&0===f?(f+=9,e=0):0===f-e?(b=Math.min(Math.abs(0.01*Math.abs(f)),
5),f+=b,e-=b):e>f?(b=Math.min(0.01*Math.abs(this.getApparentDifference(f,e,null,!0)),5),0<=f?e=f-b:f=isFinite(e)?e+b:0):(b=Math.min(0.01*Math.abs(this.getApparentDifference(e,f,null,!0)),0.05),0!==f&&(f+=b),0!==e&&(e-=b)):(f="undefined"===typeof this.options.interval?-Infinity:this.options.interval,e="undefined"!==typeof this.options.interval||isFinite(this.dataInfo.minDiff)?0:Infinity),l=Infinity!==this.dataInfo.minDiff?this.dataInfo.minDiff:1<f-e?0.5*Math.abs(f-e):1,this.includeZero&&(null===this.minimum||
isNaN(this.minimum))&&0<e&&(e=0),this.includeZero&&(null===this.maximum||isNaN(this.maximum))&&0>f&&(f=0)),Math.abs(this.getApparentDifference(e,f,null,!0)),"axisX"===this.type&&c){this.valueType="dateTime";if(null===this.minimum||isNaN(this.minimum))this.minimum=e-l/2,this.minimum=Math.min(this.minimum,null===this.sessionVariables.viewportMinimum||isNaN(this.sessionVariables.viewportMinimum)?Infinity:this.sessionVariables.viewportMinimum);if(null===this.maximum||isNaN(this.maximum))this.maximum=
f+l/2,this.maximum=Math.max(this.maximum,null===this.sessionVariables.viewportMaximum||isNaN(this.sessionVariables.viewportMaximum)?-Infinity:this.sessionVariables.viewportMaximum)}else this.intervalType=this.valueType="number",null===this.minimum&&(this.minimum="axisX"===this.type?e-l/2:Math.floor(e/this.interval)*this.interval,this.minimum=Math.min(this.minimum,null===this.sessionVariables.viewportMinimum||isNaN(this.sessionVariables.viewportMinimum)?Infinity:this.sessionVariables.viewportMinimum)),
null===this.maximum&&(this.maximum="axisX"===this.type?f+l/2:Math.ceil(f/this.interval)*this.interval,this.maximum=Math.max(this.maximum,null===this.sessionVariables.viewportMaximum||isNaN(this.sessionVariables.viewportMaximum)?-Infinity:this.sessionVariables.viewportMaximum)),0===this.maximum&&0===this.minimum&&(0===this.options.minimum?this.maximum+=10:0===this.options.maximum&&(this.minimum-=10));r(this.sessionVariables.newViewportMinimum)&&(this.viewportMinimum=Math.max(this.viewportMinimum,this.minimum));
r(this.sessionVariables.newViewportMaximum)&&(this.viewportMaximum=Math.min(this.viewportMaximum,this.maximum));this.range=this.viewportMaximum-this.viewportMinimum;this.intervalStartPosition="axisX"===this.type&&c?this.getLabelStartPoint(new Date(this.viewportMinimum),this.intervalType,this.interval):Math.floor((this.viewportMinimum+0.2*this.interval)/this.interval)*this.interval;this.valueFormatString||(this.valueFormatString=A.generateValueFormatString(this.range,2))}};A.prototype.calculateLogarithmicAxisParameters=
function(){var a=this.chart.layoutManager.getFreeSpace(),d=Math.log(this.logarithmBase),c;"bottom"===this._position||"top"===this._position?(this.maxWidth=a.width,this.maxHeight=a.height):(this.maxWidth=a.height,this.maxHeight=a.width);var a="axisX"===this.type?500>this.maxWidth?7:Math.max(7,Math.floor(this.maxWidth/100)):Math.max(Math.floor(this.maxWidth/50),3),b,e,f,l;l=1;if(null===this.viewportMinimum||isNaN(this.viewportMinimum))this.viewportMinimum=this.minimum;if(null===this.viewportMaximum||
isNaN(this.viewportMaximum))this.viewportMaximum=this.maximum;if(this.scaleBreaks)for(l=0;l<this.scaleBreaks._appliedBreaks.length;l++)if((!r(this.sessionVariables.newViewportMinimum)&&this.sessionVariables.newViewportMinimum>=this.scaleBreaks._appliedBreaks[l].startValue||!r(this.options.minimum)&&this.options.minimum>=this.scaleBreaks._appliedBreaks[l].startValue||!r(this.options.viewportMinimum)&&this.viewportMinimum>=this.scaleBreaks._appliedBreaks[l].startValue)&&(!r(this.sessionVariables.newViewportMaximum)&&
this.sessionVariables.newViewportMaximum<=this.scaleBreaks._appliedBreaks[l].endValue||!r(this.options.maximum)&&this.options.maximum<=this.scaleBreaks._appliedBreaks[l].endValue||!r(this.options.viewportMaximum)&&this.viewportMaximum<=this.scaleBreaks._appliedBreaks[l].endValue)){this.scaleBreaks._appliedBreaks.splice(l,1);break}"axisX"===this.type?(b=null!==this.viewportMinimum?this.viewportMinimum:this.dataInfo.viewPortMin,e=null!==this.viewportMaximum?this.viewportMaximum:this.dataInfo.viewPortMax,
1===e/b&&(l=Math.pow(this.logarithmBase,"undefined"===typeof this.options.interval?0.4:this.options.interval),e*=l,b/=l),f=Infinity!==this.dataInfo.minDiff?this.dataInfo.minDiff:e/b>this.logarithmBase?e/b*Math.pow(this.logarithmBase,0.5):this.logarithmBase):"axisY"===this.type&&(b=null!==this.viewportMinimum?this.viewportMinimum:this.dataInfo.viewPortMin,e=null!==this.viewportMaximum?this.viewportMaximum:this.dataInfo.viewPortMax,0>=b&&!isFinite(e)?(e="undefined"===typeof this.options.interval?0:
this.options.interval,b=1):0>=b?b=e:isFinite(e)||(e=b),1===b&&1===e?(e*=this.logarithmBase-1/this.logarithmBase,b=1):1===e/b?(l=Math.min(e*Math.pow(this.logarithmBase,0.01),Math.pow(this.logarithmBase,5)),e*=l,b/=l):b>e?(l=Math.min(b/e*Math.pow(this.logarithmBase,0.01),Math.pow(this.logarithmBase,5)),1<=e?b=e/l:e=b*l):(l=Math.min(e/b*Math.pow(this.logarithmBase,0.01),Math.pow(this.logarithmBase,0.04)),1!==e&&(e*=l),1!==b&&(b/=l)),f=Infinity!==this.dataInfo.minDiff?this.dataInfo.minDiff:e/b>this.logarithmBase?
e/b*Math.pow(this.logarithmBase,0.5):this.logarithmBase,this.includeZero&&(null===this.viewportMinimum||isNaN(this.viewportMinimum))&&1<b&&(b=1),this.includeZero&&(null===this.viewportMaximum||isNaN(this.viewportMaximum))&&1>e&&(e=1));l=(isNaN(this.viewportMaximum)||null===this.viewportMaximum?e:this.viewportMaximum)/(isNaN(this.viewportMinimum)||null===this.viewportMinimum?b:this.viewportMinimum);var h=(isNaN(this.viewportMaximum)||null===this.viewportMaximum?e:this.viewportMaximum)-(isNaN(this.viewportMinimum)||
null===this.viewportMinimum?b:this.viewportMinimum);this.intervalType="number";l=Math.pow(this.logarithmBase,A.getNiceNumber(Math.abs(Math.log(l)/d),!1));this.options&&0<this.options.interval?this.interval=this.options.interval:(this.interval=A.getNiceExponent(Math.log(l)/d/(a-1),!0),c=A.getNiceNumber(h/(a-1),!0));if(null===this.viewportMinimum||isNaN(this.viewportMinimum))this.viewportMinimum="axisX"===this.type?b/Math.sqrt(f):Math.pow(this.logarithmBase,this.interval*Math.floor(Math.log(b)/d/this.interval));
if(null===this.viewportMaximum||isNaN(this.viewportMaximum))this.viewportMaximum="axisX"===this.type?e*Math.sqrt(f):Math.pow(this.logarithmBase,this.interval*Math.ceil(Math.log(e)/d/this.interval));1===this.viewportMaximum&&1===this.viewportMinimum&&(1===this.options.viewportMinimum?this.viewportMaximum*=this.logarithmBase-1/this.logarithmBase:1===this.options.viewportMaximum&&(this.viewportMinimum/=this.logarithmBase-1/this.logarithmBase),this.options&&"undefined"===typeof this.options.interval&&
(this.interval=A.getNiceExponent(Math.ceil(Math.log(l)/d)/(a-1)),c=A.getNiceNumber((this.viewportMaximum-this.viewportMinimum)/(a-1),!0)));if(null===this.minimum||null===this.maximum)"axisX"===this.type?(b=null!==this.minimum?this.minimum:this.dataInfo.min,e=null!==this.maximum?this.maximum:this.dataInfo.max,1===e/b&&(l=Math.pow(this.logarithmBase,"undefined"===typeof this.options.interval?0.4:this.options.interval),e*=l,b/=l),f=Infinity!==this.dataInfo.minDiff?this.dataInfo.minDiff:e/b>this.logarithmBase?
e/b*Math.pow(this.logarithmBase,0.5):this.logarithmBase):"axisY"===this.type&&(b=null!==this.minimum?this.minimum:this.dataInfo.min,e=null!==this.maximum?this.maximum:this.dataInfo.max,isFinite(b)||isFinite(e)?1===b&&1===e?(e*=this.logarithmBase,b/=this.logarithmBase):1===e/b?(l=Math.pow(this.logarithmBase,this.interval),e*=l,b/=l):b>e?(l=Math.min(0.01*(b/e),5),1<=e?b=e/l:e=b*l):(l=Math.min(e/b*Math.pow(this.logarithmBase,0.01),Math.pow(this.logarithmBase,0.04)),1!==e&&(e*=l),1!==b&&(b/=l)):(e="undefined"===
typeof this.options.interval?0:this.options.interval,b=1),f=Infinity!==this.dataInfo.minDiff?this.dataInfo.minDiff:e/b>this.logarithmBase?e/b*Math.pow(this.logarithmBase,0.5):this.logarithmBase,this.includeZero&&(null===this.minimum||isNaN(this.minimum))&&1<b&&(b=1),this.includeZero&&(null===this.maximum||isNaN(this.maximum))&&1>e&&(e=1)),this.intervalType="number",null===this.minimum&&(this.minimum="axisX"===this.type?b/Math.sqrt(f):Math.pow(this.logarithmBase,this.interval*Math.floor(Math.log(b)/
d/this.interval)),r(null===this.sessionVariables.viewportMinimum||isNaN(this.sessionVariables.viewportMinimum)?"undefined"===typeof this.sessionVariables.newViewportMinimum?Infinity:this.sessionVariables.newViewportMinimum:this.sessionVariables.viewportMinimum)||(this.minimum=Math.min(this.minimum,null===this.sessionVariables.viewportMinimum||isNaN(this.sessionVariables.viewportMinimum)?"undefined"===typeof this.sessionVariables.newViewportMinimum?Infinity:this.sessionVariables.newViewportMinimum:
this.sessionVariables.viewportMinimum))),null===this.maximum&&(this.maximum="axisX"===this.type?e*Math.sqrt(f):Math.pow(this.logarithmBase,this.interval*Math.ceil(Math.log(e)/d/this.interval)),r(null===this.sessionVariables.viewportMaximum||isNaN(this.sessionVariables.viewportMaximum)?"undefined"===typeof this.sessionVariables.newViewportMaximum?0:this.sessionVariables.newViewportMaximum:this.sessionVariables.viewportMaximum)||(this.maximum=Math.max(this.maximum,null===this.sessionVariables.viewportMaximum||
isNaN(this.sessionVariables.viewportMaximum)?"undefined"===typeof this.sessionVariables.newViewportMaximum?0:this.sessionVariables.newViewportMaximum:this.sessionVariables.viewportMaximum))),1===this.maximum&&1===this.minimum&&(1===this.options.minimum?this.maximum*=this.logarithmBase-1/this.logarithmBase:1===this.options.maximum&&(this.minimum/=this.logarithmBase-1/this.logarithmBase));this.viewportMinimum=Math.max(this.viewportMinimum,this.minimum);this.viewportMaximum=Math.min(this.viewportMaximum,
this.maximum);this.viewportMinimum>this.viewportMaximum&&(!this.options.viewportMinimum&&!this.options.minimum||this.options.viewportMaximum||this.options.maximum?this.options.viewportMinimum||this.options.minimum||!this.options.viewportMaximum&&!this.options.maximum||(this.viewportMinimum=this.minimum=(this.options.viewportMaximum||this.options.maximum)/Math.pow(this.logarithmBase,2*Math.ceil(this.interval))):this.viewportMaximum=this.maximum=this.options.viewportMinimum||this.options.minimum);b=
Math.pow(this.logarithmBase,Math.floor(Math.log(this.viewportMinimum)/(d*this.interval)+0.2)*this.interval);this.range=this.viewportMaximum/this.viewportMinimum;this.noTicks=a;if(!this.options.interval&&this.range<Math.pow(this.logarithmBase,8>this.viewportMaximum||3>a?2:3)){for(d=Math.floor(this.viewportMinimum/c+0.5)*c;d<this.viewportMinimum;)d+=c;this.equidistantInterval=!1;this.intervalStartPosition=d;this.interval=c}else this.options.interval||(c=Math.ceil(this.interval),this.range>this.interval&&
(this.interval=c,b=Math.pow(this.logarithmBase,Math.floor(Math.log(this.viewportMinimum)/(d*this.interval)+0.2)*this.interval))),this.equidistantInterval=!0,this.intervalStartPosition=b;if(!this.valueFormatString&&(this.valueFormatString="#,##0.##",1>this.viewportMinimum)){d=Math.floor(Math.abs(Math.log(this.viewportMinimum)/Math.LN10))+2;if(isNaN(d)||!isFinite(d))d=2;if(2<d)for(l=0;l<d-2;l++)this.valueFormatString+="#"}};A.generateValueFormatString=function(a,d){var c="#,##0.",b=d;1>a&&(b+=Math.floor(Math.abs(Math.log(a)/
Math.LN10)),isNaN(b)||!isFinite(b))&&(b=d);for(var e=0;e<b;e++)c+="#";return c};A.getNiceExponent=function(a,d){var c=Math.floor(Math.log(a)/Math.LN10),b=a/Math.pow(10,c),b=0>c?1>=b?1:5>=b?5:10:Math.max(Math.floor(b),1);return-20>c?Number(b*Math.pow(10,c)):Number((b*Math.pow(10,c)).toFixed(20))};A.getNiceNumber=function(a,d){var c=Math.floor(Math.log(a)/Math.LN10),b=a/Math.pow(10,c),b=d?1.5>b?1:3>b?2:7>b?5:10:1>=b?1:2>=b?2:5>=b?5:10;return-20>c?Number(b*Math.pow(10,c)):Number((b*Math.pow(10,c)).toFixed(20))};
A.prototype.getLabelStartPoint=function(){var a=T[this.intervalType+"Duration"]*this.interval,a=new Date(Math.floor(this.viewportMinimum/a)*a);if("millisecond"!==this.intervalType)if("second"===this.intervalType)0<a.getMilliseconds()&&(a.setSeconds(a.getSeconds()+1),a.setMilliseconds(0));else if("minute"===this.intervalType){if(0<a.getSeconds()||0<a.getMilliseconds())a.setMinutes(a.getMinutes()+1),a.setSeconds(0),a.setMilliseconds(0)}else if("hour"===this.intervalType){if(0<a.getMinutes()||0<a.getSeconds()||
0<a.getMilliseconds())a.setHours(a.getHours()+1),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)}else if("day"===this.intervalType){if(0<a.getHours()||0<a.getMinutes()||0<a.getSeconds()||0<a.getMilliseconds())a.setDate(a.getDate()+1),a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)}else if("week"===this.intervalType){if(0<a.getDay()||0<a.getHours()||0<a.getMinutes()||0<a.getSeconds()||0<a.getMilliseconds())a.setDate(a.getDate()+(7-a.getDay())),a.setHours(0),a.setMinutes(0),
a.setSeconds(0),a.setMilliseconds(0)}else if("month"===this.intervalType){if(1<a.getDate()||0<a.getHours()||0<a.getMinutes()||0<a.getSeconds()||0<a.getMilliseconds())a.setMonth(a.getMonth()+1),a.setDate(1),a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)}else"year"===this.intervalType&&(0<a.getMonth()||1<a.getDate()||0<a.getHours()||0<a.getMinutes()||0<a.getSeconds()||0<a.getMilliseconds())&&(a.setFullYear(a.getFullYear()+1),a.setMonth(0),a.setDate(1),a.setHours(0),a.setMinutes(0),
a.setSeconds(0),a.setMilliseconds(0));return a};oa(fa,G);oa(aa,G);aa.prototype.createUserOptions=function(a){if("undefined"!==typeof a||this.options._isPlaceholder){var d=0;this.parent.options._isPlaceholder&&this.parent.createUserOptions();this.options._isPlaceholder||(Ea(this.parent[this.optionsName]),d=this.parent.options[this.optionsName].indexOf(this.options));this.options="undefined"===typeof a?{}:a;this.parent.options[this.optionsName][d]=this.options}};aa.prototype.render=function(a){if(0!==
this.spacing||0!==this.options.lineThickness&&("undefined"!==typeof this.options.lineThickness||0!==this.parent.lineThickness)){var d=this.ctx,c=this.ctx.globalAlpha;this.ctx=a||this.ctx;this.ctx.save();this.ctx.beginPath();this.ctx.rect(this.chart.plotArea.x1,this.chart.plotArea.y1,this.chart.plotArea.width,this.chart.plotArea.height);this.ctx.clip();var b=this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue),e=this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);this.ctx.strokeStyle=
this.lineColor;this.ctx.fillStyle=this.color;this.ctx.beginPath();this.ctx.globalAlpha=1;X(this.id);var f,h,p,r,k,m;a=Math.max(this.spacing,3);var n=Math.max(0,this.lineThickness);this.ctx.lineWidth=n;this.ctx.setLineDash&&this.ctx.setLineDash(J(this.lineDashType,n));if("bottom"===this.scaleBreaks.parent._position||"top"===this.scaleBreaks.parent._position)if(b=1===n%2?(b.x<<0)+0.5:b.x<<0,h=1===n%2?(e.x<<0)+0.5:e.x<<0,"top"===this.scaleBreaks.parent._position?(e=this.chart.plotArea.y1,p=this.chart.plotArea.y2+
n/2+0.5<<0):(e=this.chart.plotArea.y2,p=this.chart.plotArea.y1-n/2+0.5<<0,a*=-1),this.bounds={x1:b-n/2,y1:e,x2:h+n/2,y2:p},this.ctx.moveTo(b,e),"straight"===this.type||"top"===this.scaleBreaks.parent._position&&0>=a||"bottom"===this.scaleBreaks.parent._position&&0<=a)this.ctx.lineTo(b,p),this.ctx.lineTo(h,p),this.ctx.lineTo(h,e);else if("wavy"===this.type){r=b;k=e;f=0.5;m=(p-k)/a/3;for(var q=0;q<m;q++)this.ctx.bezierCurveTo(r+f*a,k+a,r+f*a,k+2*a,r,k+3*a),k+=3*a,f*=-1;this.ctx.bezierCurveTo(r+f*a,
k+a,r+f*a,k+2*a,r,k+3*a);r=h;f*=-1;this.ctx.lineTo(r,k);for(q=0;q<m;q++)this.ctx.bezierCurveTo(r+f*a,k-a,r+f*a,k-2*a,r,k-3*a),k-=3*a,f*=-1}else{if("zigzag"===this.type){f=-1;k=e+a;r=b+a;m=(p-k)/a/2;for(q=0;q<m;q++)this.ctx.lineTo(r,k),r+=2*f*a,k+=2*a,f*=-1;this.ctx.lineTo(r,k);r+=h-b;for(q=0;q<m+1;q++)this.ctx.lineTo(r,k),r+=2*f*a,k-=2*a,f*=-1;this.ctx.lineTo(r+f*a,k+a)}}else if("left"===this.scaleBreaks.parent._position||"right"===this.scaleBreaks.parent._position)if(e=1===n%2?(e.y<<0)+0.5:e.y<<
0,p=1===n%2?(b.y<<0)+0.5:b.y<<0,"left"===this.scaleBreaks.parent._position?(b=this.chart.plotArea.x1,h=this.chart.plotArea.x2+n/2+0.5<<0):(b=this.chart.plotArea.x2,h=this.chart.plotArea.x1-n/2+0.5<<0,a*=-1),this.bounds={x1:b,y1:e-n/2,x2:h,y2:p+n/2},this.ctx.moveTo(b,e),"straight"===this.type||"left"===this.scaleBreaks.parent._position&&0>=a||"right"===this.scaleBreaks.parent._position&&0<=a)this.ctx.lineTo(h,e),this.ctx.lineTo(h,p),this.ctx.lineTo(b,p);else if("wavy"===this.type){r=b;k=e;f=0.5;m=
(h-r)/a/3;for(q=0;q<m;q++)this.ctx.bezierCurveTo(r+a,k+f*a,r+2*a,k+f*a,r+3*a,k),r+=3*a,f*=-1;this.ctx.bezierCurveTo(r+a,k+f*a,r+2*a,k+f*a,r+3*a,k);k=p;f*=-1;this.ctx.lineTo(r,k);for(q=0;q<m;q++)this.ctx.bezierCurveTo(r-a,k+f*a,r-2*a,k+f*a,r-3*a,k),r-=3*a,f*=-1}else if("zigzag"===this.type){f=1;k=e-a;r=b+a;m=(h-r)/a/2;for(q=0;q<m;q++)this.ctx.lineTo(r,k),k+=2*f*a,r+=2*a,f*=-1;this.ctx.lineTo(r,k);k+=p-e;for(q=0;q<m+1;q++)this.ctx.lineTo(r,k),k+=2*f*a,r-=2*a,f*=-1;this.ctx.lineTo(r+a,k+f*a)}0<n&&this.ctx.stroke();
this.ctx.closePath();this.ctx.globalAlpha=this.fillOpacity;this.ctx.globalCompositeOperation="destination-over";this.ctx.fill();this.ctx.restore();this.ctx.globalAlpha=c;this.ctx=d}};oa(N,G);N.prototype.createUserOptions=function(a){if("undefined"!==typeof a||this.options._isPlaceholder){var d=0;this.parent.options._isPlaceholder&&this.parent.createUserOptions();this.options._isPlaceholder||(Ea(this.parent.stripLines),d=this.parent.options.stripLines.indexOf(this.options));this.options="undefined"===
typeof a?{}:a;this.parent.options.stripLines[d]=this.options}};N.prototype.render=function(){this.ctx.save();var a=this.parent.getPixelCoordinatesOnAxis(this.value),d=Math.abs("pixel"===this._thicknessType?this.thickness:Math.abs(this.parent.convertValueToPixel(this.endValue)-this.parent.convertValueToPixel(this.startValue)));if(0<d){var c=null===this.opacity?1:this.opacity;this.ctx.strokeStyle=this.color;this.ctx.beginPath();var b=this.ctx.globalAlpha;this.ctx.globalAlpha=c;X(this.id);var e,f,h,
p;this.ctx.lineWidth=d;this.ctx.setLineDash&&this.ctx.setLineDash(J(this.lineDashType,d));if("bottom"===this.parent._position||"top"===this.parent._position)e=f=1===this.ctx.lineWidth%2?(a.x<<0)+0.5:a.x<<0,h=this.chart.plotArea.y1,p=this.chart.plotArea.y2,this.bounds={x1:e-d/2,y1:h,x2:f+d/2,y2:p};else if("left"===this.parent._position||"right"===this.parent._position)h=p=1===this.ctx.lineWidth%2?(a.y<<0)+0.5:a.y<<0,e=this.chart.plotArea.x1,f=this.chart.plotArea.x2,this.bounds={x1:e,y1:h-d/2,x2:f,
y2:p+d/2};this.ctx.moveTo(e,h);this.ctx.lineTo(f,p);this.ctx.stroke();this.ctx.globalAlpha=b}this.ctx.restore()};oa(ca,G);ca.prototype.showAt=function(a){if(!this.enabled)return!1;var d=this.chart,c=!1;d.resetOverlayedCanvas();d.clearedOverlayedCanvas=this.parent.type;this.chart.renderCrosshairs(this.parent);if("xySwapped"===d.plotInfo.axisPlacement)if("bottom"===this.parent._position)for(var b=0;b<d.axisY.length;b++)this.parent===d.axisY[b]&&(d.axisY[b]._crosshairValue=a>=d.axisY[b].viewportMinimum&&
a<=d.axisY[b].viewportMaximum?a:null);else if("top"===this.parent._position)for(b=0;b<d.axisY2.length;b++)this.parent===d.axisY2[b]&&(d.axisY2[b]._crosshairValue=a>=d.axisY2[b].viewportMinimum&&a<=d.axisY2[b].viewportMaximum?a:null);else if("left"===this.parent._position)for(b=0;b<d.axisX.length;b++)this.parent===d.axisX[b]&&(d.axisX[b]._crosshairValue=a>=d.axisX[b].viewportMinimum&&a<=d.axisX[b].viewportMaximum?a:null);else{if("right"===this.parent._position)for(b=0;b<d.axisX2.length;b++)this.parent===
d.axisX2[b]&&(d.axisX2[b]._crosshairValue=a>=d.axisX2[b].viewportMinimum&&a<=d.axisX2[b].viewportMaximum?a:null)}else if("bottom"===this.parent._position)for(b=0;b<d.axisX.length;b++)this.parent===d.axisX[b]&&(d.axisX[b]._crosshairValue=a>=d.axisX[b].viewportMinimum&&a<=d.axisX[b].viewportMaximum?a:null);else if("top"===this.parent._position)for(b=0;b<d.axisX2.length;b++)this.parent===d.axisX2[b]&&(d.axisX2[b]._crosshairValue=a>=d.axisX2[b].viewportMinimum&&a<=d.axisX2[b].viewportMaximum?a:null);
else if("left"===this.parent._position)for(b=0;b<d.axisY.length;b++)this.parent===d.axisY[b]&&(d.axisY[b]._crosshairValue=a>=d.axisY[b].viewportMinimum&&a<=d.axisY[b].viewportMaximum?a:null);else if("right"===this.parent._position)for(b=0;b<d.axisY2.length;b++)this.parent===d.axisY2[b]&&(d.axisY2[b]._crosshairValue=a>=d.axisY2[b].viewportMinimum&&a<=d.axisY2[b].viewportMaximum?a:null);for(b=0;b<d.axisX.length;b++)a=d.axisX[b]._crosshairValue,d.axisX[b].crosshair&&(d.axisX[b].crosshair.enabled&&!r(a)&&
a>=d.axisX[b].viewportMinimum&&a<=d.axisX[b].viewportMaximum)&&(d.axisX[b].showCrosshair(a),d.axisX[b].crosshair._updatedValue=a,this===d.axisX[b].crosshair&&(c=!0));for(b=0;b<d.axisX2.length;b++)a=d.axisX2[b]._crosshairValue,d.axisX2[b].crosshair&&(d.axisX2[b].crosshair.enabled&&!r(a)&&a>=d.axisX2[b].viewportMinimum&&a<=d.axisX2[b].viewportMaximum)&&(d.axisX2[b].showCrosshair(a),d.axisX2[b].crosshair._updatedValue=a,this===d.axisX2[b].crosshair&&(c=!0));for(b=0;b<d.axisY.length;b++)a=d.axisY[b]._crosshairValue,
d.axisY[b].crosshair&&(d.axisY[b].crosshair.enabled&&!r(a)&&a>=d.axisY[b].viewportMinimum&&a<=d.axisY[b].viewportMaximum)&&(d.axisY[b].showCrosshair(a),d.axisY[b].crosshair._updatedValue=a,this===d.axisY[b].crosshair&&(c=!0));for(b=0;b<d.axisY2.length;b++)a=d.axisY2[b]._crosshairValue,d.axisY2[b].crosshair&&(d.axisY2[b].crosshair.enabled&&!r(a)&&a>=d.axisY2[b].viewportMinimum&&a<=d.axisY2[b].viewportMaximum)&&(d.axisY2[b].showCrosshair(a),d.axisY2[b].crosshair._updatedValue=a,this===d.axisY2[b].crosshair&&
(c=!0));this.chart.toolTip&&this.chart.toolTip._entries&&this.chart.toolTip.highlightObjects(this.chart.toolTip._entries);return c};ca.prototype.hide=function(){this.chart.resetOverlayedCanvas();this.chart.renderCrosshairs(this.parent);this._hidden=!0};ca.prototype.render=function(a,d,c){var b,e,f,h,p=null,w=null,k=null,m="";if(!this.valueFormatString)if("dateTime"===this.parent.valueType)this.valueFormatString=this.parent.valueFormatString;else{var n=0,n="xySwapped"===this.chart.plotInfo.axisPlacement?
50<this.parent.range?0:500<this.chart.width&&25>this.parent.range?2:Math.floor(Math.abs(Math.log(this.parent.range)/Math.LN10))+(5>this.parent.range?2:10>this.parent.range?1:0):50<this.parent.range?0:Math.floor(Math.abs(Math.log(this.parent.range)/Math.LN10))+(5>this.parent.range?2:10>this.parent.range?1:0);this.valueFormatString=A.generateValueFormatString(this.parent.range,n)}var k=null===this.opacity?1:this.opacity,n=Math.abs("pixel"===this._thicknessType?this.thickness:this.parent.conversionParameters.pixelPerUnit*
this.thickness),q=this.chart.overlaidCanvasCtx,g=q.globalAlpha;q.globalAlpha=k;q.beginPath();q.strokeStyle=this.color;q.lineWidth=n;q.save();this.labelFontSize=Math.abs(r(this.options.labelFontSize)?this.parent.labelFontSize:this.labelFontSize);this.labelMaxWidth=r(this.options.labelMaxWidth)?0.3*this.chart.width:this.labelMaxWidth;this.labelMaxHeight=r(this.options.labelWrap)||this.labelWrap?0.3*this.chart.height:2*this.labelFontSize;0<n&&q.setLineDash&&q.setLineDash(J(this.lineDashType,n));k=new ja(q,
{x:0,y:0,padding:{top:2,right:3,bottom:2,left:4},backgroundColor:this.labelBackgroundColor,borderColor:this.labelBorderColor,borderThickness:this.labelBorderThickness,cornerRadius:this.labelCornerRadius,maxWidth:this.labelMaxWidth,maxHeight:this.labelMaxHeight,angle:this.labelAngle,text:m,horizontalAlign:"left",fontSize:this.labelFontSize,fontFamily:this.labelFontFamily,fontWeight:this.labelFontWeight,fontColor:this.labelFontColor,fontStyle:this.labelFontStyle,textBaseline:"middle"});if(this.snapToDataPoint){var s=
0,m=[];if("xySwapped"===this.chart.plotInfo.axisPlacement){var v=null;if("bottom"===this.parent._position||"top"===this.parent._position)s=this.parent.dataSeries[0].axisX.convertPixelToValue({y:d});else if("left"===this.parent._position||"right"===this.parent._position)s=this.parent.convertPixelToValue({y:d});for(var B=0;B<this.parent.dataSeries.length;B++)(v=this.parent.dataSeries[B].getDataPointAtX(s,!0))&&0<=v.index&&(v.dataSeries=this.parent.dataSeries[B],null!==v.dataPoint.y&&v.dataSeries.visible&&
m.push(v));v=null;if(0===m.length)return;m.sort(function(a,b){return a.distance-b.distance});v=Math.abs(a-this.parent.convertValueToPixel(m[0].dataPoint.y));B=0;if("rangeBar"===m[0].dataSeries.type||"error"===m[0].dataSeries.type)for(var v=Math.abs(a-this.parent.convertValueToPixel(m[B].dataPoint.y[0])),u=0,s=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(var y=0;y<m[s].dataPoint.y.length;y++)u=Math.abs(a-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else u=
Math.abs(a-this.parent.convertValueToPixel(m[s].dataPoint.y)),u<v&&(v=u,B=s);else if("stackedBar"===m[0].dataSeries.type)for(var v=Math.abs(a-this.parent.convertValueToPixel(m[0].dataPoint.y)),x=u=0,s=B=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(y=0;y<m[s].dataPoint.y.length;y++)u=Math.abs(a-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else x+=m[s].dataPoint.y,u=Math.abs(a-this.parent.convertValueToPixel(x)),u<v&&(v=u,B=s);else if("stackedBar100"===m[0].dataSeries.type)for(var v=
Math.abs(a-this.parent.convertValueToPixel(m[0].dataPoint.y)),z=x=u=0,s=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(y=0;y<m[s].dataPoint.y.length;y++)u=Math.abs(a-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else x+=m[s].dataPoint.y,z=m[s].dataPoint.x.getTime?m[s].dataPoint.x.getTime():m[s].dataPoint.x,z=100*(x/m[s].dataSeries.plotUnit.dataPointYSums[z]),u=Math.abs(a-this.parent.convertValueToPixel(z)),u<v&&(v=u,B=s);else for(v=Math.abs(a-this.parent.convertValueToPixel(m[0].dataPoint.y)),
s=B=u=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(y=0;y<m[s].dataPoint.y.length;y++)u=Math.abs(a-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else u=Math.abs(a-this.parent.convertValueToPixel(m[s].dataPoint.y)),u<v&&(v=u,B=s);y=m[B];if("bottom"===this.parent._position||"top"===this.parent._position){b=0;if("rangeBar"===this.parent.dataSeries[B].type||"error"===this.parent.dataSeries[B].type){v=Math.abs(a-this.parent.convertValueToPixel(y.dataPoint.y[0]));
for(s=u=0;s<y.dataPoint.y.length;s++)u=Math.abs(a-this.parent.convertValueToPixel(y.dataPoint.y[s])),u<v&&(v=u,b=s);p=1===q.lineWidth%2?(this.parent.convertValueToPixel(y.dataPoint.y[b])<<0)+0.5:this.parent.convertValueToPixel(y.dataPoint.y[b])<<0;this.value=y.dataPoint.y[b];k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.y[b]}):r(this.options.label)?da(r(c)?y.dataPoint.y[b]:c,this.valueFormatString,this.chart._cultureInfo):
this.label}else if("stackedBar"===this.parent.dataSeries[B].type){v=Math.abs(a-this.parent.convertValueToPixel(m[0].dataPoint.y));x=u=0;for(s=B;0<=s;s--)x+=m[s].dataPoint.y,u=Math.abs(a-this.parent.convertValueToPixel(x)),u<v&&(v=u,b=s);p=1===q.lineWidth%2?(this.parent.convertValueToPixel(x)<<0)+0.5:this.parent.convertValueToPixel(x)<<0;this.value=x;k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.y}):r(this.options.label)?
da(r(c)?y.dataPoint.y:c,this.valueFormatString,this.chart._cultureInfo):this.label}else if("stackedBar100"===this.parent.dataSeries[B].type){v=Math.abs(a-this.parent.convertValueToPixel(m[0].dataPoint.y));z=x=u=0;for(s=B;0<=s;s--)x+=m[s].dataPoint.y,z=m[s].dataPoint.x.getTime?m[s].dataPoint.x.getTime():m[s].dataPoint.x,z=100*(x/m[s].dataSeries.plotUnit.dataPointYSums[z]),u=Math.abs(a-this.parent.convertValueToPixel(z)),u<v&&(v=u,b=s);p=1===q.lineWidth%2?(this.parent.convertValueToPixel(z)<<0)+0.5:
this.parent.convertValueToPixel(z)<<0;this.value=z;k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:z}):r(this.options.label)?da(r(c)?z:c,this.valueFormatString,this.chart._cultureInfo):this.label}else p=1===q.lineWidth%2?(this.parent.convertValueToPixel(y.dataPoint.y)<<0)+0.5:this.parent.convertValueToPixel(y.dataPoint.y)<<0,this.value=y.dataPoint.y,k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,
crosshair:this.options,value:y.dataPoint.y}):r(this.options.label)?da(r(c)?y.dataPoint.y:c,this.valueFormatString,this.chart._cultureInfo):this.label;b=e=p;f=this.chart.plotArea.y1;h=this.chart.plotArea.y2;this.bounds={x1:b-n/2,y1:f,x2:e+n/2,y2:h};k.x=b-k.measureText().width/2;k.x+k.width>this.chart.bounds.x2?k.x=this.chart.bounds.x2-k.width:k.x<this.chart.bounds.x1&&(k.x=this.chart.bounds.x1);k.y=this.parent.lineCoordinates.y2+("top"===this.parent._position?-k.height+this.parent.tickLength:k.fontSize/
2)+2;k.y+k.height>this.chart.bounds.y2?k.y=this.chart.bounds.y2-k.height:k.y<this.chart.bounds.y1&&(k.y=this.chart.bounds.y1)}else if("left"===this.parent._position||"right"===this.parent._position){f=h=w=1===q.lineWidth%2?(this.parent.convertValueToPixel(y.dataPoint.x)<<0)+0.5:this.parent.convertValueToPixel(y.dataPoint.x)<<0;b=this.chart.plotArea.x1;e=this.chart.plotArea.x2;this.bounds={x1:b,y1:f-n/2,x2:e,y2:h+n/2};z=!1;if(this.parent.labels)for(m=Math.ceil(this.parent.interval),s=0;s<this.parent.viewportMaximum;s+=
m)if(this.parent.labels[s])z=!0;else{z=!1;break}if(z){if("axisX"===this.parent.type)for(s=this.parent.convertPixelToValue({y:d}),v=null,B=0;B<this.parent.dataSeries.length;B++)(v=this.parent.dataSeries[B].getDataPointAtX(s,!0))&&0<=v.index&&(k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.x}):r(this.options.label)?v.dataPoint.label:this.label)}else k.text="dateTime"!==this.parent.valueType||this.parent.logarithmic?
this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.x}):r(this.options.label)?da(y.dataPoint.x,this.valueFormatString,this.chart._cultureInfo):this.label:this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.x}):r(this.options.label)?Ba(y.dataPoint.x,this.valueFormatString,this.chart._cultureInfo):this.label;this.value=y.dataPoint.x;k.y=h+k.fontSize/2-k.measureText().height/
2+2;k.y-k.fontSize/2<this.chart.bounds.y1?k.y=this.chart.bounds.y1+k.fontSize/2+2:k.y+k.measureText().height-k.fontSize/2>this.chart.bounds.y2&&(k.y=this.chart.bounds.y2-k.measureText().height+k.fontSize/2);"left"===this.parent._position?k.x=this.parent.lineCoordinates.x2-k.measureText().width:"right"===this.parent._position&&(k.x=this.parent.lineCoordinates.x2)}}else if("bottom"===this.parent._position||"top"===this.parent._position){s=this.parent.convertPixelToValue({x:a});for(B=0;B<this.parent.dataSeries.length;B++)(v=
this.parent.dataSeries[B].getDataPointAtX(s,!0))&&0<=v.index&&(v.dataSeries=this.parent.dataSeries[B],null!==v.dataPoint.y&&v.dataSeries.visible&&m.push(v));if(0===m.length)return;m.sort(function(a,b){return a.distance-b.distance});y=m[0];b=e=p=1===q.lineWidth%2?(this.parent.convertValueToPixel(y.dataPoint.x)<<0)+0.5:this.parent.convertValueToPixel(y.dataPoint.x)<<0;f=this.chart.plotArea.y1;h=this.chart.plotArea.y2;this.bounds={x1:b-n/2,y1:f,x2:e+n/2,y2:h};z=!1;if(this.parent.labels)for(m=Math.ceil(this.parent.interval),
s=0;s<this.parent.viewportMaximum;s+=m)if(this.parent.labels[s])z=!0;else{z=!1;break}if(z){if("axisX"===this.parent.type)for(s=this.parent.convertPixelToValue({x:a}),v=null,B=0;B<this.parent.dataSeries.length;B++)(v=this.parent.dataSeries[B].getDataPointAtX(s,!0))&&0<=v.index&&(k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.x}):r(this.options.label)?v.dataPoint.label:this.label)}else k.text="dateTime"!==this.parent.valueType||
this.parent.logarithmic?this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.x}):r(this.options.label)?da(y.dataPoint.x,this.valueFormatString,this.chart._cultureInfo):this.label:this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.x}):r(this.options.label)?Ba(y.dataPoint.x,this.valueFormatString,this.chart._cultureInfo):this.label;this.value=y.dataPoint.x;
k.x=b-k.measureText().width/2;k.x+k.width>this.chart.bounds.x2&&(k.x=this.chart.bounds.x2-k.width);k.x<this.chart.bounds.x1&&(k.x=this.chart.bounds.x1);"bottom"===this.parent._position?k.y=this.parent.lineCoordinates.y2+k.fontSize/2+2:"top"===this.parent._position&&(k.y=this.parent.lineCoordinates.y1-k.height+k.fontSize/2+2)}else if("left"===this.parent._position||"right"===this.parent._position){!r(this.parent.dataSeries)&&0<this.parent.dataSeries.length&&(s=this.parent.dataSeries[0].axisX.convertPixelToValue({x:a}));
for(B=0;B<this.parent.dataSeries.length;B++)(v=this.parent.dataSeries[B].getDataPointAtX(s,!0))&&0<=v.index&&(v.dataSeries=this.parent.dataSeries[B],null!==v.dataPoint.y&&v.dataSeries.visible&&m.push(v));if(0===m.length)return;m.sort(function(a,b){return a.distance-b.distance});B=0;if("rangeColumn"===m[0].dataSeries.type||"rangeArea"===m[0].dataSeries.type||"error"===m[0].dataSeries.type||"rangeSplineArea"===m[0].dataSeries.type||"candlestick"===m[0].dataSeries.type||"ohlc"===m[0].dataSeries.type||
"boxAndWhisker"===m[0].dataSeries.type)for(v=Math.abs(d-this.parent.convertValueToPixel(m[0].dataPoint.y[0])),s=u=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(y=0;y<m[s].dataPoint.y.length;y++)u=Math.abs(d-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else u=Math.abs(d-this.parent.convertValueToPixel(m[s].dataPoint.y)),u<v&&(v=u,B=s);else if("stackedColumn"===m[0].dataSeries.type||"stackedArea"===m[0].dataSeries.type)for(v=Math.abs(d-this.parent.convertValueToPixel(m[0].dataPoint.y)),
s=x=u=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(y=0;y<m[s].dataPoint.y.length;y++)u=Math.abs(d-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else x+=m[s].dataPoint.y,u=Math.abs(d-this.parent.convertValueToPixel(x)),u<v&&(v=u,B=s);else if("stackedColumn100"===m[0].dataSeries.type||"stackedArea100"===m[0].dataSeries.type)for(v=Math.abs(d-this.parent.convertValueToPixel(m[0].dataPoint.y)),s=z=x=u=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(y=
0;y<m[s].dataPoint.y.length;y++)u=Math.abs(d-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else x+=m[s].dataPoint.y,z=m[s].dataPoint.x.getTime?m[s].dataPoint.x.getTime():m[s].dataPoint.x,z=100*(x/m[s].dataSeries.plotUnit.dataPointYSums[z]),u=Math.abs(d-this.parent.convertValueToPixel(z)),u<v&&(v=u,B=s);else for(v=Math.abs(d-this.parent.convertValueToPixel(m[0].dataPoint.y)),s=u=0;s<m.length;s++)if(m[s].dataPoint.y&&m[s].dataPoint.y.length)for(y=0;y<m[s].dataPoint.y.length;y++)u=
Math.abs(d-this.parent.convertValueToPixel(m[s].dataPoint.y[y])),u<v&&(v=u,B=s);else u=Math.abs(d-this.parent.convertValueToPixel(m[s].dataPoint.y)),u<v&&(v=u,B=s);y=m[B];b=0;if("rangeColumn"===this.parent.dataSeries[B].type||"rangeArea"===this.parent.dataSeries[B].type||"error"===this.parent.dataSeries[B].type||"rangeSplineArea"===this.parent.dataSeries[B].type||"candlestick"===this.parent.dataSeries[B].type||"ohlc"===this.parent.dataSeries[B].type||"boxAndWhisker"===this.parent.dataSeries[B].type){v=
Math.abs(d-this.parent.convertValueToPixel(y.dataPoint.y[0]));for(s=u=0;s<y.dataPoint.y.length;s++)u=Math.abs(d-this.parent.convertValueToPixel(y.dataPoint.y[s])),u<v&&(v=u,b=s);w=1===q.lineWidth%2?(this.parent.convertValueToPixel(y.dataPoint.y[b])<<0)+0.5:this.parent.convertValueToPixel(y.dataPoint.y[b])<<0;k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataPoint.y[b]}):r(this.options.label)?da(r(c)?y.dataPoint.y[b]:c,this.valueFormatString,
this.chart._cultureInfo):this.label;this.value=y.dataPoint.y[b]}else if("stackedColumn"===this.parent.dataSeries[B].type||"stackedArea"===this.parent.dataSeries[B].type){v=Math.abs(d-this.parent.convertValueToPixel(m[0].dataPoint.y));x=u=0;for(s=B;0<=s;s--)x+=m[s].dataPoint.y,u=Math.abs(d-this.parent.convertValueToPixel(x)),u<v&&(v=u,b=s);w=1===q.lineWidth%2?(this.parent.convertValueToPixel(x)<<0)+0.5:this.parent.convertValueToPixel(x)<<0;k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,
axis:this.parent.options,crosshair:this.options,value:y.dataPoint.y}):r(this.options.label)?da(r(c)?y.dataPoint.y:c,this.valueFormatString,this.chart._cultureInfo):this.label;this.value=x}else if("stackedColumn100"===this.parent.dataSeries[B].type||"stackedArea100"===this.parent.dataSeries[B].type){v=Math.abs(d-this.parent.convertValueToPixel(m[0].dataPoint.y));x=u=0;for(s=B;0<=s;s--)x+=m[s].dataPoint.y,z=m[s].dataPoint.x.getTime?m[s].dataPoint.x.getTime():m[s].dataPoint.x,z=100*(x/m[s].dataSeries.plotUnit.dataPointYSums[z]),
u=Math.abs(d-this.parent.convertValueToPixel(z)),u<v&&(v=u,b=s);w=1===q.lineWidth%2?(this.parent.convertValueToPixel(z)<<0)+0.5:this.parent.convertValueToPixel(z)<<0;k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:z}):r(this.options.label)?da(r(c)?z:c,this.valueFormatString,this.chart._cultureInfo):this.label;this.value=z}else"waterfall"===this.parent.dataSeries[B].type?(w=1===q.lineWidth%2?(this.parent.convertValueToPixel(y.dataSeries.dataPointEOs[y.index].cumulativeSum)<<
0)+0.5:this.parent.convertValueToPixel(y.dataSeries.dataPointEOs[y.index].cumulativeSum)<<0,k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:y.dataSeries.dataPointEOs[y.index].cumulativeSum}):r(this.options.label)?da(r(c)?y.dataSeries.dataPointEOs[y.index].cumulativeSum:c,this.valueFormatString,this.chart._cultureInfo):this.label,this.value=y.dataSeries.dataPointEOs[y.index].cumulativeSum):(w=1===q.lineWidth%2?(r(a)?d:this.parent.convertValueToPixel(y.dataPoint.y)<<
0)+0.5:r(a)?d:this.parent.convertValueToPixel(y.dataPoint.y)<<0,k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:r(c)?y.dataPoint.y:c}):r(this.options.label)?da(r(c)?y.dataPoint.y:c,this.valueFormatString,this.chart._cultureInfo):this.label,this.value=y.dataPoint.y);f=h=w;b=this.chart.plotArea.x1;e=this.chart.plotArea.x2;this.bounds={x1:b,y1:f-n/2,x2:e,y2:h+n/2};k.y=h+k.fontSize/2-k.measureText().height/2+2;k.y-k.fontSize/2<this.chart.bounds.y1?
k.y=this.chart.bounds.y1+k.fontSize/2+2:k.y+k.measureText().height-k.fontSize/2>this.chart.bounds.y2&&(k.y=this.chart.bounds.y2-k.measureText().height+k.fontSize/2);"left"===this.parent._position?k.x=this.parent.lineCoordinates.x2-k.measureText().width:"right"===this.parent._position&&(k.x=this.parent.lineCoordinates.x2)}m=null;if("bottom"===this.parent._position||"top"===this.parent._position)"top"===this.parent._position&&k.y-k.fontSize/2<this.chart.bounds.y1&&(k.y=this.chart.bounds.y1+k.fontSize/
2),"bottom"===this.parent._position&&this.parent.lineCoordinates.y2-k.fontSize/2+k.measureText().height>this.chart.bounds.y2&&(k.y=this.chart.bounds.y2-k.height+k.fontSize/2+2),b>=this.parent.convertValueToPixel(this.parent.reversed?this.parent.viewportMaximum:this.parent.viewportMinimum)&&e<=this.parent.convertValueToPixel(this.parent.reversed?this.parent.viewportMinimum:this.parent.viewportMaximum)&&(0<n&&(q.moveTo(b,f),q.lineTo(e,h),q.stroke(),this._hidden=!1),q.restore());if("left"===this.parent._position||
"right"===this.parent._position)"left"===this.parent._position&&k.x<this.chart.bounds.x1&&(k.x=this.chart.bounds.x1),"right"===this.parent._position&&k.x+k.measureText().width>this.chart.bounds.x2&&(k.x=this.chart.bounds.x2-k.measureText().width),h>=this.parent.convertValueToPixel(this.parent.reversed?this.parent.viewportMinimum:this.parent.viewportMaximum)&&f<=this.parent.convertValueToPixel(this.parent.reversed?this.parent.viewportMaximum:this.parent.viewportMinimum)&&(0<n&&(q.moveTo(b,f),q.lineTo(e,
h),q.stroke(),this._hidden=!1),q.restore())}else{if("bottom"===this.parent._position||"top"===this.parent._position)b=e=p=1===q.lineWidth%2?(a<<0)+0.5:a<<0,f=this.chart.plotArea.y1,h=this.chart.plotArea.y2,this.bounds={x1:b-n/2,y1:f,x2:e+n/2,y2:h};else if("left"===this.parent._position||"right"===this.parent._position)f=h=w=1===q.lineWidth%2?(d<<0)+0.5:d<<0,b=this.chart.plotArea.x1,e=this.chart.plotArea.x2,this.bounds={x1:b,y1:f-n/2,x2:e,y2:h+n/2};if("xySwapped"===this.chart.plotInfo.axisPlacement)if("left"===
this.parent._position||"right"===this.parent._position){z=!1;if(this.parent.labels)for(m=Math.ceil(this.parent.interval),s=0;s<this.parent.viewportMaximum;s+=m)if(this.parent.labels[s])z=!0;else{z=!1;break}if(z){if("axisX"===this.parent.type)for(s=this.parent.convertPixelToValue({y:d}),v=null,B=0;B<this.parent.dataSeries.length;B++)(v=this.parent.dataSeries[B].getDataPointAtX(s,!0))&&0<=v.index&&(k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,
value:r(c)?this.parent.convertPixelToValue(a):c}):r(this.options.label)?v.dataPoint.label:this.label)}else k.text="dateTime"!==this.parent.valueType||this.parent.logarithmic?this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:r(c)?this.parent.convertPixelToValue(d):c}):r(this.options.label)?da(r(c)?this.parent.convertPixelToValue(d):c,this.valueFormatString,this.chart._cultureInfo):this.label:this.labelFormatter?this.labelFormatter({chart:this.chart,
axis:this.parent.options,crosshair:this.options,value:r(c)?this.parent.convertPixelToValue(d):c}):r(this.options.label)?Ba(r(c)?this.parent.convertPixelToValue(d):c,this.valueFormatString,this.chart._cultureInfo):this.label;k.y=d+k.fontSize/2-k.measureText().height/2+2;k.y-k.fontSize/2<this.chart.bounds.y1?k.y=this.chart.bounds.y1+k.fontSize/2+2:k.y+k.measureText().height-k.fontSize/2>this.chart.bounds.y2&&(k.y=this.chart.bounds.y2-k.measureText().height+k.fontSize/2);"left"===this.parent._position?
k.x=this.parent.lineCoordinates.x1-k.measureText().width:"right"===this.parent._position&&(k.x=this.parent.lineCoordinates.x2)}else{if("bottom"===this.parent._position||"top"===this.parent._position)k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:r(c)?this.parent.convertPixelToValue(a):c}):r(this.options.label)?da(r(c)?this.parent.convertPixelToValue(a):c,this.valueFormatString,this.chart._cultureInfo):this.label,k.x=b-k.measureText().width/
2,k.x+k.width>this.chart.bounds.x2&&(k.x=this.chart.bounds.x2-k.width),k.x<this.chart.bounds.x1&&(k.x=this.chart.bounds.x1),"bottom"===this.parent._position?k.y=this.parent.lineCoordinates.y2+k.fontSize/2+2:"top"===this.parent._position&&(k.y=this.parent.lineCoordinates.y1-k.height+k.fontSize/2+2)}else if("bottom"===this.parent._position||"top"===this.parent._position){z=!1;m="";if(this.parent.labels)for(m=Math.ceil(this.parent.interval),s=0;s<this.parent.viewportMaximum;s+=m)if(this.parent.labels[s])z=
!0;else{z=!1;break}if(z){if("axisX"===this.parent.type)for(s=this.parent.convertPixelToValue({x:a}),v=null,B=0;B<this.parent.dataSeries.length;B++)(v=this.parent.dataSeries[B].getDataPointAtX(s,!0))&&0<=v.index&&(k.text=this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:r(c)?this.parent.convertPixelToValue(a):c}):r(this.options.label)?r(c)?v.dataPoint.label:c:this.label)}else k.text="dateTime"!==this.parent.valueType||this.parent.logarithmic?
this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:r(c)?0<this.parent.dataSeries.length?this.parent.convertPixelToValue(a):"":c}):r(this.options.label)?da(r(c)?this.parent.convertPixelToValue(a):c,this.valueFormatString,this.chart._cultureInfo):this.label:this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:r(c)?this.parent.convertPixelToValue(a):c}):r(this.options.label)?Ba(r(c)?
this.parent.convertPixelToValue(a):c,this.valueFormatString,this.chart._cultureInfo):this.label;k.x=b-k.measureText().width/2;k.x+k.width>this.chart.bounds.x2&&(k.x=this.chart.bounds.x2-k.width);k.x<this.chart.bounds.x1&&(k.x=this.chart.bounds.x1);"bottom"===this.parent._position?k.y=this.parent.lineCoordinates.y2+k.fontSize/2+2:"top"===this.parent._position&&(k.y=this.parent.lineCoordinates.y1-k.height+k.fontSize/2+2)}else if("left"===this.parent._position||"right"===this.parent._position)k.text=
this.labelFormatter?this.labelFormatter({chart:this.chart,axis:this.parent.options,crosshair:this.options,value:r(c)?this.parent.convertPixelToValue(d):c}):r(this.options.label)?da(r(c)?this.parent.convertPixelToValue(d):c,this.valueFormatString,this.chart._cultureInfo):this.label,k.y=d+k.fontSize/2-k.measureText().height/2+2,k.y-k.fontSize/2<this.chart.bounds.y1?k.y=this.chart.bounds.y1+k.fontSize/2+2:k.y+k.measureText().height-k.fontSize/2>this.chart.bounds.y2&&(k.y=this.chart.bounds.y2-k.measureText().height+
k.fontSize/2),"left"===this.parent._position?k.x=this.parent.lineCoordinates.x2-k.measureText().width:"right"===this.parent._position&&(k.x=this.parent.lineCoordinates.x2);"left"===this.parent._position&&k.x<this.chart.bounds.x1?k.x=this.chart.bounds.x1:"right"===this.parent._position&&k.x+k.measureText().width>this.chart.bounds.x2?k.x=this.chart.bounds.x2-k.measureText().width:"top"===this.parent._position&&k.y-k.fontSize/2<this.chart.bounds.y1?k.y=this.chart.bounds.y1+k.fontSize/2:"bottom"===this.parent._position&&
this.parent.lineCoordinates.y2-k.fontSize/2+k.measureText().height>this.chart.bounds.y2&&(k.y=this.chart.bounds.y2-k.height+k.fontSize/2+2);0<n&&(q.moveTo(b,f),q.lineTo(e,h),q.stroke(),this._hidden=!1);q.restore();this.value="bottom"===this.parent._position||"top"===this.parent._position?this.parent.convertPixelToValue(a):this.parent.convertPixelToValue(d)}if("bottom"===this.parent._position||"top"===this.parent._position)this._updatedValue=this.parent.convertPixelToValue(p);if("left"===this.parent._position||
"right"===this.parent._position)this._updatedValue=this.parent.convertPixelToValue(w);this._textBlock=k;this._label=c;r(c)||this.renderLabel();q.globalAlpha=g};ca.prototype.renderLabel=function(){r(this._textBlock)||(r(this._textBlock.text)||!("number"===typeof this._textBlock.text.valueOf()||0<this._textBlock.text.length)||this._hidden)||this._textBlock.render(!0);r(this._label)&&this.dispatchEvent("updated",{chart:this.chart,crosshair:this.options,axis:this.parent,value:this.value},this.parent)};
oa(U,G);U.prototype._initialize=function(){this.updateOption("updated");this.updateOption("hidden");if(this.enabled){this.container=document.createElement("div");this.container.setAttribute("class","canvasjs-chart-tooltip");this.container.style.position="absolute";this.container.style.height="auto";this.container.style.boxShadow="1px 1px 2px 2px rgba(0,0,0,0.1)";this.container.style.zIndex="1000";this.container.style.pointerEvents="none";this.container.style.display="none";var a=document.createElement("div");
a.style.width="auto";a.style.height="auto";a.style.minWidth="50px";a.style.lineHeight="normal";a.style.margin="0px 0px 0px 0px";a.style.padding="5px";a.style.fontFamily="Calibri, Arial, Georgia, serif";a.style.fontWeight="normal";a.style.fontStyle=w?"italic":"normal";a.style.fontSize="14px";a.style.color="#000000";a.style.textShadow="1px 1px 1px rgba(0, 0, 0, 0.1)";a.style.textAlign="left";a.style.border="2px solid gray";a.style.background=w?"rgba(255,255,255,.9)":"rgb(255,255,255)";a.style.textIndent=
"0px";a.style.whiteSpace="nowrap";a.style.borderRadius="5px";a.style.MozUserSelect="none";a.style.WebkitUserSelect="none";a.style.msUserSelect="none";a.style.userSelect="none";w||(a.style.filter="alpha(opacity = 90)",a.style.filter="progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666')");a.innerText="Sample Tooltip";this.container.appendChild(a);this.contentDiv=this.container.firstChild;this.container.style.borderRadius=this.contentDiv.style.borderRadius;this.chart._canvasJSContainer.appendChild(this.container)}};
U.prototype.mouseMoveHandler=function(a,d){this._lastUpdated&&4>(new Date).getTime()-this._lastUpdated||(this._lastUpdated=(new Date).getTime(),this.chart.resetOverlayedCanvas(),this._updateToolTip(a,d),!this._updatedEventParameters||(isNaN(this._prevX)||isNaN(this._prevY))||this.dispatchEvent("updated",this._updatedEventParameters,this))};U.prototype._updateToolTip=function(a,d,c){c="undefined"===typeof c?!0:c;this.container||this._initialize();this.enabled||this.hide();if(!this.chart.disableToolTip){if("undefined"===
typeof a||"undefined"===typeof d){if(isNaN(this._prevX)||isNaN(this._prevY))return;a=this._prevX;d=this._prevY}else this._prevX=a,this._prevY=d;var b=null,e=null,f=[],h=0;if(this.shared&&this.enabled&&"none"!==this.chart.plotInfo.axisPlacement){var p=[];if(this.chart.axisX)for(var v=0;v<this.chart.axisX.length;v++){for(var h="xySwapped"===this.chart.plotInfo.axisPlacement?this.chart.axisX[v].convertPixelToValue({y:d}):this.chart.axisX[v].convertPixelToValue({x:a}),k=null,b=0;b<this.chart.axisX[v].dataSeries.length;b++)(k=
this.chart.axisX[v].dataSeries[b].getDataPointAtX(h,c))&&0<=k.index&&(k.dataSeries=this.chart.axisX[v].dataSeries[b],null!==k.dataPoint.y&&k.dataSeries.visible&&p.push(k));k=null}if(this.chart.axisX2)for(v=0;v<this.chart.axisX2.length;v++){h="xySwapped"===this.chart.plotInfo.axisPlacement?this.chart.axisX2[v].convertPixelToValue({y:d}):this.chart.axisX2[v].convertPixelToValue({x:a});k=null;for(b=0;b<this.chart.axisX2[v].dataSeries.length;b++)(k=this.chart.axisX2[v].dataSeries[b].getDataPointAtX(h,
c))&&0<=k.index&&(k.dataSeries=this.chart.axisX2[v].dataSeries[b],null!==k.dataPoint.y&&k.dataSeries.visible&&p.push(k));k=null}if(0===p.length)return;p.sort(function(a,b){return a.distance-b.distance});c=p[0];for(b=0;b<p.length;b++)p[b].dataPoint.x.valueOf()===c.dataPoint.x.valueOf()&&f.push(p[b]);p=null}else{if(b=this.chart.getDataPointAtXY(a,d,c))this.currentDataPointIndex=b.dataPointIndex,this.currentSeriesIndex=b.dataSeries.index;else if(w)if(b=$a(a,d,this.chart._eventManager.ghostCtx),0<b&&
"undefined"!==typeof this.chart._eventManager.objectMap[b]){b=this.chart._eventManager.objectMap[b];if("legendItem"===b.objectType)return;this.currentSeriesIndex=b.dataSeriesIndex;this.currentDataPointIndex=0<=b.dataPointIndex?b.dataPointIndex:-1}else this.currentDataPointIndex=-1;else this.currentDataPointIndex=-1;if(0<=this.currentSeriesIndex){e=this.chart.data[this.currentSeriesIndex];k={};if(0<=this.currentDataPointIndex)b=e.dataPoints[this.currentDataPointIndex],k.dataSeries=e,k.dataPoint=b,
k.index=this.currentDataPointIndex,k.distance=Math.abs(b.x-h),"waterfall"===e.type&&(k.cumulativeSumYStartValue=e.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue,k.cumulativeSum=e.dataPointEOs[this.currentDataPointIndex].cumulativeSum);else{if(!this.enabled||"line"!==e.type&&"stepLine"!==e.type&&"spline"!==e.type&&"area"!==e.type&&"stepArea"!==e.type&&"splineArea"!==e.type&&"stackedArea"!==e.type&&"stackedArea100"!==e.type&&"rangeArea"!==e.type&&"rangeSplineArea"!==e.type&&"candlestick"!==
e.type&&"ohlc"!==e.type&&"boxAndWhisker"!==e.type)return;h=e.axisX.convertPixelToValue({x:a});k=e.getDataPointAtX(h,c);r(k)||(k.dataSeries=e,this.currentDataPointIndex=k.index,b=k.dataPoint)}if(!r(k)&&!r(k.dataPoint)&&!r(k.dataPoint.y))if(k.dataSeries.axisY)if(0<k.dataPoint.y.length){for(b=c=0;b<k.dataPoint.y.length;b++)k.dataPoint.y[b]<k.dataSeries.axisY.viewportMinimum?c--:k.dataPoint.y[b]>k.dataSeries.axisY.viewportMaximum&&c++;c<k.dataPoint.y.length&&c>-k.dataPoint.y.length&&f.push(k)}else"column"===
e.type||"bar"===e.type?0>k.dataPoint.y?0>k.dataSeries.axisY.viewportMinimum&&k.dataSeries.axisY.viewportMaximum>=k.dataPoint.y&&f.push(k):k.dataSeries.axisY.viewportMinimum<=k.dataPoint.y&&0<=k.dataSeries.axisY.viewportMaximum&&f.push(k):"bubble"===e.type?(c=this.chart._eventManager.objectMap[e.dataPointIds[k.index]].size/2,k.dataPoint.y>=k.dataSeries.axisY.viewportMinimum-c&&k.dataPoint.y<=k.dataSeries.axisY.viewportMaximum+c&&f.push(k)):"waterfall"===e.type?(c=0,k.cumulativeSumYStartValue<k.dataSeries.axisY.viewportMinimum?
c--:k.cumulativeSumYStartValue>k.dataSeries.axisY.viewportMaximum&&c++,k.cumulativeSum<k.dataSeries.axisY.viewportMinimum?c--:k.cumulativeSum>k.dataSeries.axisY.viewportMaximum&&c++,2>c&&-2<c&&f.push(k)):(0<=k.dataSeries.type.indexOf("100")||"stackedColumn"===e.type||"stackedBar"===e.type||k.dataPoint.y>=k.dataSeries.axisY.viewportMinimum&&k.dataPoint.y<=k.dataSeries.axisY.viewportMaximum)&&f.push(k);else f.push(k)}}if(0<f.length){if(this.highlightObjects(f),this.enabled){c="";c=this.getToolTipInnerHTML({entries:f});
if(null!==c){this.contentDiv.innerHTML=c;if(this.isToolTipDefinedInData&&r(this.options.content)&&r(this.options.contentFormatter))for(h=this.contentDiv.getElementsByTagName("span"),b=0;b<h.length;b++)h[b]&&(h[b].style.color=h[b].getAttribute("data-color"));h=!1;"none"===this.container.style.display&&(h=!0,this.container.style.display="block");try{this.contentDiv.style.background=this.backgroundColor?this.backgroundColor:w?"rgba(255,255,255,.9)":"rgb(255,255,255)",this.borderColor="waterfall"===f[0].dataSeries.type?
this.contentDiv.style.borderRightColor=this.contentDiv.style.borderLeftColor=this.contentDiv.style.borderColor=this.options.borderColor?this.options.borderColor:f[0].dataPoint.color?f[0].dataPoint.color:0<f[0].dataPoint.y?f[0].dataSeries.risingColor:f[0].dataSeries.fallingColor:"error"===f[0].dataSeries.type?this.contentDiv.style.borderRightColor=this.contentDiv.style.borderLeftColor=this.contentDiv.style.borderColor=this.options.borderColor?this.options.borderColor:f[0].dataSeries.color?f[0].dataSeries.color:
f[0].dataSeries._colorSet[e.index%f[0].dataSeries._colorSet.length]:this.contentDiv.style.borderRightColor=this.contentDiv.style.borderLeftColor=this.contentDiv.style.borderColor=this.options.borderColor?this.options.borderColor:f[0].dataPoint.color?f[0].dataPoint.color:f[0].dataSeries.color?f[0].dataSeries.color:f[0].dataSeries._colorSet[f[0].index%f[0].dataSeries._colorSet.length],this.contentDiv.style.borderWidth=this.borderThickness||0===this.borderThickness?this.borderThickness+"px":"2px",this.contentDiv.style.borderRadius=
this.cornerRadius||0===this.cornerRadius?this.cornerRadius+"px":"5px",this.container.style.borderRadius=this.contentDiv.style.borderRadius,this.contentDiv.style.fontSize=this.fontSize||0===this.fontSize?this.fontSize+"px":"14px",this.contentDiv.style.color=this.fontColor?this.fontColor:"#000000",this.contentDiv.style.fontFamily=this.fontFamily?this.fontFamily:"Calibri, Arial, Georgia, serif;",this.contentDiv.style.fontWeight=this.fontWeight?this.fontWeight:"normal",this.contentDiv.style.fontStyle=
this.fontStyle?this.fontStyle:w?"italic":"normal"}catch(m){}"pie"===f[0].dataSeries.type||"doughnut"===f[0].dataSeries.type||"funnel"===f[0].dataSeries.type||"pyramid"===f[0].dataSeries.type||"bar"===f[0].dataSeries.type||"rangeBar"===f[0].dataSeries.type||"stackedBar"===f[0].dataSeries.type||"stackedBar100"===f[0].dataSeries.type?a=a-10-this.container.clientWidth:(a=f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x)-this.container.clientWidth<<0,a-=10);0>a&&(a+=this.container.clientWidth+
20);a+this.container.clientWidth>Math.max(this.chart.container.clientWidth,this.chart.width)&&(a=Math.max(0,Math.max(this.chart.container.clientWidth,this.chart.width)-this.container.clientWidth));d=1!==f.length||this.shared||"line"!==f[0].dataSeries.type&&"stepLine"!==f[0].dataSeries.type&&"spline"!==f[0].dataSeries.type&&"area"!==f[0].dataSeries.type&&"stepArea"!==f[0].dataSeries.type&&"splineArea"!==f[0].dataSeries.type?"bar"===f[0].dataSeries.type||"rangeBar"===f[0].dataSeries.type||"stackedBar"===
f[0].dataSeries.type||"stackedBar100"===f[0].dataSeries.type?f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x):d:f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y);d=-d+10;0<d+this.container.clientHeight+5&&(d-=d+this.container.clientHeight+5-0);this.fixMozTransitionDelay(a,d);!this.animationEnabled||h?this.disableAnimation():(this.enableAnimation(),this.container.style.MozTransition=this.mozContainerTransition);this.positionLeft=a;this.positionBottom=d;this.container.style.left=
a+"px";this.container.style.bottom=d+"px"}else this.hide(!1),this.enabled&&this.dispatchEvent("hidden",{chart:this.chart,toolTip:this},this);d=[];for(b=0;b<f.length;b++)d.push({xValue:f[b].dataPoint.x,dataPoint:f[b].dataPoint,dataSeries:f[b].dataSeries,dataPointIndex:f[b].index,dataSeriesIndex:f[b].dataSeries._index});this._updatedEventParameters={chart:this.chart,toolTip:this.options,content:c,entries:d};this._entries=f}}else this.hide(),this.enabled&&this.dispatchEvent("hidden",{chart:this.chart,
toolTip:this},this)}};U.prototype.highlightObjects=function(a){var d=this.chart.overlaidCanvasCtx;if(r(this.chart.clearedOverlayedCanvas)||"toolTip"===this.chart.clearedOverlayedCanvas)this.chart.resetOverlayedCanvas(),d.clearRect(0,0,this.chart.width,this.chart.height),this.chart.clearedOverlayedCanvas="toolTip";d.save();var c=this.chart.plotArea,b=0;d.beginPath();d.rect(c.x1,c.y1,c.x2-c.x1,c.y2-c.y1);d.clip();for(c=0;c<a.length;c++){var e=a[c];if((e=this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]])&&
e.objectType&&"dataPoint"===e.objectType){var b=this.chart.data[e.dataSeriesIndex],f=b.dataPoints[e.dataPointIndex],h=e.dataPointIndex;!1===f.highlightEnabled||!0!==b.highlightEnabled&&!0!==f.highlightEnabled||("line"===b.type||"stepLine"===b.type||"spline"===b.type||"scatter"===b.type||"area"===b.type||"stepArea"===b.type||"splineArea"===b.type||"stackedArea"===b.type||"stackedArea100"===b.type||"rangeArea"===b.type||"rangeSplineArea"===b.type?(f=b.getMarkerProperties(h,e.x1,e.y1,this.chart.overlaidCanvasCtx),
f.size=Math.max(1.5*f.size<<0,10),f.borderColor=f.borderColor||"#FFFFFF",f.borderThickness=f.borderThickness||Math.ceil(0.1*f.size),W.drawMarkers([f]),"undefined"!==typeof e.y2&&(f=b.getMarkerProperties(h,e.x1,e.y2,this.chart.overlaidCanvasCtx),f.size=Math.max(1.5*f.size<<0,10),f.borderColor=f.borderColor||"#FFFFFF",f.borderThickness=f.borderThickness||Math.ceil(0.1*f.size),W.drawMarkers([f]))):"bubble"===b.type?(f=b.getMarkerProperties(h,e.x1,e.y1,this.chart.overlaidCanvasCtx),f.size=e.size,f.color=
"white",f.borderColor="white",d.globalAlpha=0.3,W.drawMarkers([f]),d.globalAlpha=1):"column"===b.type||"stackedColumn"===b.type||"stackedColumn100"===b.type||"bar"===b.type||"rangeBar"===b.type||"stackedBar"===b.type||"stackedBar100"===b.type||"rangeColumn"===b.type||"waterfall"===b.type?Y(d,e.x1,e.y1,e.x2,e.y2,"white",0,null,!1,!1,!1,!1,0.3):"pie"===b.type||"doughnut"===b.type?pa(d,e.center,e.radius,"white",b.type,e.startAngle,e.endAngle,0.3,e.percentInnerRadius):"funnel"===b.type||"pyramid"===b.type?
ra(d,e.funnelSection,0.3,"white"):"candlestick"===b.type?(d.globalAlpha=1,d.strokeStyle=e.color,d.lineWidth=2*e.borderThickness,b=0===d.lineWidth%2?0:0.5,d.beginPath(),d.moveTo(e.x3-b,Math.min(e.y2,e.y3)),d.lineTo(e.x3-b,Math.min(e.y1,e.y4)),d.stroke(),d.beginPath(),d.moveTo(e.x3-b,Math.max(e.y1,e.y4)),d.lineTo(e.x3-b,Math.max(e.y2,e.y3)),d.stroke(),Y(d,e.x1,Math.min(e.y1,e.y4),e.x2,Math.max(e.y1,e.y4),"transparent",2*e.borderThickness,e.color,!1,!1,!1,!1),d.globalAlpha=1):"ohlc"===b.type?(d.globalAlpha=
1,d.strokeStyle=e.color,d.lineWidth=2*e.borderThickness,b=0===d.lineWidth%2?0:0.5,d.beginPath(),d.moveTo(e.x3-b,e.y2),d.lineTo(e.x3-b,e.y3),d.stroke(),d.beginPath(),d.moveTo(e.x3,e.y1),d.lineTo(e.x1,e.y1),d.stroke(),d.beginPath(),d.moveTo(e.x3,e.y4),d.lineTo(e.x2,e.y4),d.stroke(),d.globalAlpha=1):"boxAndWhisker"===b.type?(d.save(),d.globalAlpha=1,d.strokeStyle=e.stemColor,d.lineWidth=2*e.stemThickness,0<e.stemThickness&&(d.beginPath(),d.moveTo(e.x3,e.y2+e.borderThickness/2),d.lineTo(e.x3,e.y1+e.whiskerThickness/
2),d.stroke(),d.beginPath(),d.moveTo(e.x3,e.y4-e.whiskerThickness/2),d.lineTo(e.x3,e.y3-e.borderThickness/2),d.stroke()),d.beginPath(),Y(d,e.x1-e.borderThickness/2,Math.max(e.y2+e.borderThickness/2,e.y3+e.borderThickness/2),e.x2+e.borderThickness/2,Math.min(e.y2-e.borderThickness/2,e.y3-e.borderThickness/2),"transparent",e.borderThickness,e.color,!1,!1,!1,!1),d.globalAlpha=1,d.strokeStyle=e.whiskerColor,d.lineWidth=2*e.whiskerThickness,0<e.whiskerThickness&&(d.beginPath(),d.moveTo(Math.floor(e.x3-
e.whiskerLength/2),e.y4),d.lineTo(Math.ceil(e.x3+e.whiskerLength/2),e.y4),d.stroke(),d.beginPath(),d.moveTo(Math.floor(e.x3-e.whiskerLength/2),e.y1),d.lineTo(Math.ceil(e.x3+e.whiskerLength/2),e.y1),d.stroke()),d.globalAlpha=1,d.strokeStyle=e.lineColor,d.lineWidth=2*e.lineThickness,0<e.lineThickness&&(d.beginPath(),d.moveTo(e.x1,e.y5),d.lineTo(e.x2,e.y5),d.stroke()),d.restore(),d.globalAlpha=1):"error"===b.type&&B(d,e.x1,e.y1,e.x2,e.y2,"white",e.whiskerProperties,e.stemProperties,e.isXYSwapped,0.3))}}d.restore();
d.globalAlpha=1;d.beginPath()};U.prototype.getToolTipInnerHTML=function(a){a=a.entries;var d=null,c=null,b=null,e=0,f="";this.isToolTipDefinedInData=!0;for(var h=0;h<a.length;h++)if(a[h].dataSeries.toolTipContent||a[h].dataPoint.toolTipContent){this.isToolTipDefinedInData=!1;break}if(this.isToolTipDefinedInData&&(this.content&&"function"===typeof this.content||this.contentFormatter))a={chart:this.chart,toolTip:this.options,entries:a},d=this.contentFormatter?this.contentFormatter(a):this.content(a);
else if(this.shared&&"none"!==this.chart.plotInfo.axisPlacement){for(var p=null,r="",h=0;h<a.length;h++){c=a[h].dataSeries;b=a[h].dataPoint;e=a[h].index;f="";if(0===h&&this.isToolTipDefinedInData&&!this.content){this.chart.axisX&&0<this.chart.axisX.length?r+="undefined"!==typeof this.chart.axisX[0].labels[b.x]?this.chart.axisX[0].labels[b.x]:"{x}":this.chart.axisX2&&0<this.chart.axisX2.length&&(r+="undefined"!==typeof this.chart.axisX2[0].labels[b.x]?this.chart.axisX2[0].labels[b.x]:"{x}");r+="</br>";
if(!c.visible)continue;r=this.chart.replaceKeywordsWithValue(r,b,c,e)}null===b.toolTipContent||"undefined"===typeof b.toolTipContent&&null===c.options.toolTipContent||("line"===c.type||"stepLine"===c.type||"spline"===c.type||"area"===c.type||"stepArea"===c.type||"splineArea"===c.type||"column"===c.type||"bar"===c.type||"scatter"===c.type||"stackedColumn"===c.type||"stackedColumn100"===c.type||"stackedBar"===c.type||"stackedBar100"===c.type||"stackedArea"===c.type||"stackedArea100"===c.type||"waterfall"===
c.type?(this.chart.axisX&&1<this.chart.axisX.length&&(f+=p!=c.axisXIndex?c.axisX.title?c.axisX.title+"<br/>":"X:{axisXIndex}<br/>":""),f+=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>{name}:</span>&nbsp;&nbsp;{y}",p=c.axisXIndex):"bubble"===c.type?(this.chart.axisX&&1<this.chart.axisX.length&&(f+=p!=c.axisXIndex?c.axisX.title?c.axisX.title+"<br/>":
"X:{axisXIndex}<br/>":""),f+=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}"):"rangeColumn"===c.type||"rangeBar"===c.type||"rangeArea"===c.type||"rangeSplineArea"===c.type||"error"===c.type?(this.chart.axisX&&1<this.chart.axisX.length&&(f+=p!=c.axisXIndex?c.axisX.title?c.axisX.title+"<br/>":"X:{axisXIndex}<br/>":
""),f+=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}"):"candlestick"===c.type||"ohlc"===c.type?(this.chart.axisX&&1<this.chart.axisX.length&&(f+=p!=c.axisXIndex?c.axisX.title?c.axisX.title+"<br/>":"X:{axisXIndex}<br/>":""),f+=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&
"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}"):"boxAndWhisker"===c.type&&(this.chart.axisX&&1<this.chart.axisX.length&&(f+=p!=c.axisXIndex?c.axisX.title?c.axisX.title+"<br/>":"X:{axisXIndex}<br/>":""),f+=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==
typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>{name}:</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"),null===d&&(d=""),c.visible&&(!0===this.reversed?(d=this.chart.replaceKeywordsWithValue(f,
b,c,e)+d,h<a.length-1&&(d="</br>"+d)):(d+=this.chart.replaceKeywordsWithValue(f,b,c,e),h<a.length-1&&(d+="</br>"))))}null!==d&&(d=r+d)}else{c=a[0].dataSeries;b=a[0].dataPoint;e=a[0].index;if(null===b.toolTipContent||"undefined"===typeof b.toolTipContent&&null===c.options.toolTipContent)return null;"line"===c.type||"stepLine"===c.type||"spline"===c.type||"area"===c.type||"stepArea"===c.type||"splineArea"===c.type||"column"===c.type||"bar"===c.type||"scatter"===c.type||"stackedColumn"===c.type||"stackedColumn100"===
c.type||"stackedBar"===c.type||"stackedBar100"===c.type||"stackedArea"===c.type||"stackedArea100"===c.type||"waterfall"===c.type?f=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>"+(b.label?"{label}":"{x}")+":</span>&nbsp;&nbsp;{y}":"bubble"===c.type?f=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?
this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>"+(b.label?"{label}":"{x}")+":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}":"pie"===c.type||"doughnut"===c.type||"funnel"===c.type||"pyramid"===c.type?f=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>"+(b.name?"{name}:</span>&nbsp;&nbsp;":b.label?"{label}:</span>&nbsp;&nbsp;":
"</span>")+"{y}":"rangeColumn"===c.type||"rangeBar"===c.type||"rangeArea"===c.type||"rangeSplineArea"===c.type||"error"===c.type?f=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>"+(b.label?"{label}":"{x}")+" :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}":"candlestick"===c.type||"ohlc"===c.type?f=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:
this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?"":"'{color}'")+"\"'>"+(b.label?"{label}":"{x}")+"</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}":"boxAndWhisker"===c.type&&(f=b.toolTipContent?b.toolTipContent:c.toolTipContent?c.toolTipContent:this.content&&"function"!==typeof this.content?this.content:"<span data-color='\""+(this.options.fontColor?
"":"'{color}'")+"\"'>"+(b.label?"{label}":"{x}")+"</span><br/>Minimum: &nbsp;{y[0]}<br/>Q1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}");null===d&&(d="");d+=this.chart.replaceKeywordsWithValue(f,b,c,e)}return d};U.prototype.enableAnimation=function(){if(!this.container.style.WebkitTransition){var a=
this.getContainerTransition(this.containerTransitionDuration);this.container.style.WebkitTransition=a;this.container.style.MsTransition=a;this.container.style.transition=a;this.container.style.MozTransition=this.mozContainerTransition}};U.prototype.disableAnimation=function(){this.container.style.WebkitTransition&&(this.container.style.WebkitTransition="",this.container.style.MozTransition="",this.container.style.MsTransition="",this.container.style.transition="")};U.prototype.hide=function(a){this.container&&
(this.container.style.display="none",this.currentSeriesIndex=-1,this._prevY=this._prevX=NaN,("undefined"===typeof a||a)&&this.chart.resetOverlayedCanvas())};U.prototype.show=function(a,d,c){this._updateToolTip(a,d,"undefined"===typeof c?!1:c)};U.prototype.showAtIndex=function(a,d){};U.prototype.showAtX=function(a,d){if(!this.enabled)return!1;this.chart.clearedOverlayedCanvas=null;var c,b,e,f=[];e=!1;d=!r(d)&&0<=d&&d<this.chart.data.length?d:0;if(this.shared)for(var h=0;h<this.chart.data.length;h++)c=
this.chart.data[h],(b=c.getDataPointAtX(a,!1))&&(b.dataPoint&&!r(b.dataPoint.y)&&c.visible)&&(b.dataSeries=c,f.push(b));else c=this.chart.data[d],(b=c.getDataPointAtX(a,!1))&&(b.dataPoint&&!r(b.dataPoint.y)&&c.visible)&&(b.dataSeries=c,f.push(b));if(0<f.length){for(h=0;h<f.length;h++)if(b=f[h],(this.shared||0<=b.dataSeries.type.indexOf("100"))&&b.dataPoint.x>=b.dataSeries.axisX.viewportMinimum&&b.dataPoint.x<=b.dataSeries.axisX.viewportMaximum){e=!1;break}else if(b.dataPoint.x<b.dataSeries.axisX.viewportMinimum||
b.dataPoint.x>b.dataSeries.axisX.viewportMaximum||b.dataPoint.y<b.dataSeries.axisY.viewportMinimum||b.dataPoint.y>b.dataSeries.axisY.viewportMaximum)e=!0;else{e=!1;break}if(e)return this.hide(),!1;this.highlightObjects(f);this._entries=f;h="";h=this.getToolTipInnerHTML({entries:f});if(null!==h){this.contentDiv.innerHTML=h;if(this.isToolTipDefinedInData&&r(this.options.content)&&r(this.options.contentFormatter))for(b=this.contentDiv.getElementsByTagName("span"),h=0;h<b.length;h++)b[h]&&(b[h].style.color=
b[h].getAttribute("data-color"));h=!1;"none"===this.container.style.display&&(h=!0,this.container.style.display="block");try{this.contentDiv.style.background=this.backgroundColor?this.backgroundColor:w?"rgba(255,255,255,.9)":"rgb(255,255,255)",this.borderColor="waterfall"===f[0].dataSeries.type?this.contentDiv.style.borderRightColor=this.contentDiv.style.borderLeftColor=this.contentDiv.style.borderColor=this.options.borderColor?this.options.borderColor:f[0].dataPoint.color?f[0].dataPoint.color:0<
f[0].dataPoint.y?f[0].dataSeries.risingColor:f[0].dataSeries.fallingColor:"error"===f[0].dataSeries.type?this.contentDiv.style.borderRightColor=this.contentDiv.style.borderLeftColor=this.contentDiv.style.borderColor=this.options.borderColor?this.options.borderColor:f[0].dataSeries.color?f[0].dataSeries.color:f[0].dataSeries._colorSet[c.index%f[0].dataSeries._colorSet.length]:this.contentDiv.style.borderRightColor=this.contentDiv.style.borderLeftColor=this.contentDiv.style.borderColor=this.options.borderColor?
this.options.borderColor:f[0].dataPoint.color?f[0].dataPoint.color:f[0].dataSeries.color?f[0].dataSeries.color:f[0].dataSeries._colorSet[f[0].index%f[0].dataSeries._colorSet.length],this.contentDiv.style.borderWidth=this.borderThickness||0===this.borderThickness?this.borderThickness+"px":"2px",this.contentDiv.style.borderRadius=this.cornerRadius||0===this.cornerRadius?this.cornerRadius+"px":"5px",this.container.style.borderRadius=this.contentDiv.style.borderRadius,this.contentDiv.style.fontSize=this.fontSize||
0===this.fontSize?this.fontSize+"px":"14px",this.contentDiv.style.color=this.fontColor?this.fontColor:"#000000",this.contentDiv.style.fontFamily=this.fontFamily?this.fontFamily:"Calibri, Arial, Georgia, serif;",this.contentDiv.style.fontWeight=this.fontWeight?this.fontWeight:"normal",this.contentDiv.style.fontStyle=this.fontStyle?this.fontStyle:w?"italic":"normal"}catch(p){}"pie"===f[0].dataSeries.type||"doughnut"===f[0].dataSeries.type||"funnel"===f[0].dataSeries.type||"pyramid"===f[0].dataSeries.type?
c=mouseX-10-this.container.clientWidth:(c="bar"===f[0].dataSeries.type||"rangeBar"===f[0].dataSeries.type||"stackedBar"===f[0].dataSeries.type||"stackedBar100"===f[0].dataSeries.type?f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y)-this.container.clientWidth<<0:f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x)-this.container.clientWidth<<0,c-=10);0>c&&(c+=this.container.clientWidth+20);c+this.container.clientWidth>Math.max(this.chart.container.clientWidth,this.chart.width)&&(c=
Math.max(0,Math.max(this.chart.container.clientWidth,this.chart.width)-this.container.clientWidth));f=1!==f.length||this.shared||"line"!==f[0].dataSeries.type&&"stepLine"!==f[0].dataSeries.type&&"spline"!==f[0].dataSeries.type&&"area"!==f[0].dataSeries.type&&"stepArea"!==f[0].dataSeries.type&&"splineArea"!==f[0].dataSeries.type?"bar"===f[0].dataSeries.type||"rangeBar"===f[0].dataSeries.type||"stackedBar"===f[0].dataSeries.type||"stackedBar100"===f[0].dataSeries.type?f[0].dataSeries.axisX.convertValueToPixel(f[0].dataPoint.x):
f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y):f[0].dataSeries.axisY.convertValueToPixel(f[0].dataPoint.y);f=-f+10;0<f+this.container.clientHeight+5&&(f-=f+this.container.clientHeight+5-0);this.fixMozTransitionDelay(c,f);!this.animationEnabled||h?this.disableAnimation():(this.enableAnimation(),this.container.style.MozTransition=this.mozContainerTransition);this.container.style.left=c+"px";this.container.style.bottom=f+"px"}else return this.hide(!1),!1}else return this.hide(),!1;return!0};
U.prototype.fixMozTransitionDelay=function(a,d){if(20<this.chart._eventManager.lastObjectId)this.mozContainerTransition=this.getContainerTransition(0);else{var c=parseFloat(this.container.style.left),c=isNaN(c)?0:c,b=parseFloat(this.container.style.bottom),b=isNaN(b)?0:b;10<Math.sqrt(Math.pow(c-a,2)+Math.pow(b-d,2))?this.mozContainerTransition=this.getContainerTransition(0.1):this.mozContainerTransition=this.getContainerTransition(0)}};U.prototype.getContainerTransition=function(a){return"left "+
a+"s ease-out 0s, bottom "+a+"s ease-out 0s"};Z.prototype.reset=function(){this.lastObjectId=0;this.objectMap=[];this.rectangularRegionEventSubscriptions=[];this.previousDataPointEventObject=null;this.eventObjects=[];w&&(this.ghostCtx.clearRect(0,0,this.chart.width,this.chart.height),this.ghostCtx.beginPath())};Z.prototype.getNewObjectTrackingId=function(){return++this.lastObjectId};Z.prototype.mouseEventHandler=function(a){if("mousemove"===a.type||"click"===a.type){var d=[],c=Pa(a),b=null;if((b=
this.chart.getObjectAtXY(c.x,c.y,!1))&&"undefined"!==typeof this.objectMap[b])if(b=this.objectMap[b],"dataPoint"===b.objectType){var e=this.chart.data[b.dataSeriesIndex],f=e.dataPoints[b.dataPointIndex],h=b.dataPointIndex;b.eventParameter={x:c.x,y:c.y,dataPoint:f,dataSeries:e.options,dataPointIndex:h,dataSeriesIndex:e.index,chart:this.chart};b.eventContext={context:f,userContext:f,mouseover:"mouseover",mousemove:"mousemove",mouseout:"mouseout",click:"click"};d.push(b);b=this.objectMap[e.id];b.eventParameter=
{x:c.x,y:c.y,dataPoint:f,dataSeries:e.options,dataPointIndex:h,dataSeriesIndex:e.index,chart:this.chart};b.eventContext={context:e,userContext:e.options,mouseover:"mouseover",mousemove:"mousemove",mouseout:"mouseout",click:"click"};d.push(this.objectMap[e.id])}else"legendItem"===b.objectType&&(e=this.chart.data[b.dataSeriesIndex],f=null!==b.dataPointIndex?e.dataPoints[b.dataPointIndex]:null,b.eventParameter={x:c.x,y:c.y,dataSeries:e.options,dataPoint:f,dataPointIndex:b.dataPointIndex,dataSeriesIndex:b.dataSeriesIndex,
chart:this.chart},b.eventContext={context:this.chart.legend,userContext:this.chart.legend.options,mouseover:"itemmouseover",mousemove:"itemmousemove",mouseout:"itemmouseout",click:"itemclick"},d.push(b));e=[];for(c=0;c<this.mouseoveredObjectMaps.length;c++){f=!0;for(b=0;b<d.length;b++)if(d[b].id===this.mouseoveredObjectMaps[c].id){f=!1;break}f?this.fireEvent(this.mouseoveredObjectMaps[c],"mouseout",a):e.push(this.mouseoveredObjectMaps[c])}this.mouseoveredObjectMaps=e;for(c=0;c<d.length;c++){e=!1;
for(b=0;b<this.mouseoveredObjectMaps.length;b++)if(d[c].id===this.mouseoveredObjectMaps[b].id){e=!0;break}e||(this.fireEvent(d[c],"mouseover",a),this.mouseoveredObjectMaps.push(d[c]));"click"===a.type?this.fireEvent(d[c],"click",a):"mousemove"===a.type&&this.fireEvent(d[c],"mousemove",a)}}};Z.prototype.fireEvent=function(a,d,c){if(a&&d){var b=a.eventParameter,e=a.eventContext,f=a.eventContext.userContext;f&&(e&&f[e[d]])&&f[e[d]].call(f,b);"mouseout"!==d?f.cursor&&f.cursor!==c.target.style.cursor&&
(c.target.style.cursor=f.cursor):(c.target.style.cursor=this.chart._defaultCursor,delete a.eventParameter,delete a.eventContext);"click"===d&&("dataPoint"===a.objectType&&this.chart.pieDoughnutClickHandler)&&this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex],b);"click"===d&&("dataPoint"===a.objectType&&this.chart.funnelPyramidClickHandler)&&this.chart.funnelPyramidClickHandler.call(this.chart.data[a.dataSeriesIndex],b)}};ia.prototype.animate=function(a,d,c,b,e){var f=this;
this.chart.isAnimating=!0;e=e||M.easing.linear;c&&this.animations.push({startTime:(new Date).getTime()+(a?a:0),duration:d,animationCallback:c,onComplete:b});for(a=[];0<this.animations.length;)if(d=this.animations.shift(),c=(new Date).getTime(),b=0,d.startTime<=c&&(b=e(Math.min(c-d.startTime,d.duration),0,1,d.duration),b=Math.min(b,1),isNaN(b)||!isFinite(b))&&(b=1),1>b&&a.push(d),d.animationCallback(b),1<=b&&d.onComplete)d.onComplete();this.animations=a;0<this.animations.length?this.animationRequestId=
this.chart.requestAnimFrame.call(window,function(){f.animate.call(f)}):this.chart.isAnimating=!1};ia.prototype.cancelAllAnimations=function(){this.animations=[];this.animationRequestId&&this.chart.cancelRequestAnimFrame.call(window,this.animationRequestId);this.animationRequestId=null;this.chart.isAnimating=!1};var M={yScaleAnimation:function(a,d){if(0!==a){var c=d.dest,b=d.source.canvas,e=d.animationBase;c.drawImage(b,0,0,b.width,b.height,0,e-e*a,c.canvas.width/la,a*c.canvas.height/la)}},xScaleAnimation:function(a,
d){if(0!==a){var c=d.dest,b=d.source.canvas,e=d.animationBase;c.drawImage(b,0,0,b.width,b.height,e-e*a,0,a*c.canvas.width/la,c.canvas.height/la)}},xClipAnimation:function(a,d){if(0!==a){var c=d.dest,b=d.source.canvas;c.save();0<a&&c.drawImage(b,0,0,b.width*a,b.height,0,0,b.width*a/la,b.height/la);c.restore()}},fadeInAnimation:function(a,d){if(0!==a){var c=d.dest,b=d.source.canvas;c.save();c.globalAlpha=a;c.drawImage(b,0,0,b.width,b.height,0,0,c.canvas.width/la,c.canvas.height/la);c.restore()}},easing:{linear:function(a,
d,c,b){return c*a/b+d},easeOutQuad:function(a,d,c,b){return-c*(a/=b)*(a-2)+d},easeOutQuart:function(a,d,c,b){return-c*((a=a/b-1)*a*a*a-1)+d},easeInQuad:function(a,d,c,b){return c*(a/=b)*a+d},easeInQuart:function(a,d,c,b){return c*(a/=b)*a*a*a+d}}},W={drawMarker:function(a,d,c,b,e,f,h,p){if(c){var r=1;c.fillStyle=f?f:"#000000";c.strokeStyle=h?h:"#000000";c.lineWidth=p?p:0;c.setLineDash&&c.setLineDash(J("solid",p));"circle"===b?(c.moveTo(a,d),c.beginPath(),c.arc(a,d,e/2,0,2*Math.PI,!1),f&&c.fill(),
p&&(h?c.stroke():(r=c.globalAlpha,c.globalAlpha=0.15,c.strokeStyle="black",c.stroke(),c.globalAlpha=r))):"square"===b?(c.beginPath(),c.rect(a-e/2,d-e/2,e,e),f&&c.fill(),p&&(h?c.stroke():(r=c.globalAlpha,c.globalAlpha=0.15,c.strokeStyle="black",c.stroke(),c.globalAlpha=r))):"triangle"===b?(c.beginPath(),c.moveTo(a-e/2,d+e/2),c.lineTo(a+e/2,d+e/2),c.lineTo(a,d-e/2),c.closePath(),f&&c.fill(),p&&(h?c.stroke():(r=c.globalAlpha,c.globalAlpha=0.15,c.strokeStyle="black",c.stroke(),c.globalAlpha=r)),c.beginPath()):
"cross"===b&&(c.strokeStyle=f,c.lineWidth=e/4,c.beginPath(),c.moveTo(a-e/2,d-e/2),c.lineTo(a+e/2,d+e/2),c.stroke(),c.moveTo(a+e/2,d-e/2),c.lineTo(a-e/2,d+e/2),c.stroke())}},drawMarkers:function(a){for(var d=0;d<a.length;d++){var c=a[d];W.drawMarker(c.x,c.y,c.ctx,c.type,c.size,c.color,c.borderColor,c.borderThickness)}}};return p}();B.version="v3.7.33 GA";window.CanvasJS&&(B&&!window.CanvasJS.Chart)&&(window.CanvasJS.Chart=B)})();

/*
  excanvas is used to support IE678 which do not implement HTML5 Canvas Element. You can safely remove the following excanvas code if you don't need to support older browsers.

  Copyright 2006 Google Inc. https://code.google.com/p/explorercanvas/
  Licensed under the Apache License, Version 2.0
*/
document.createElement("canvas").getContext||function(){function V(){return this.context_||(this.context_=new C(this))}function W(a,b,c){var g=M.call(arguments,2);return function(){return a.apply(b,g.concat(M.call(arguments)))}}function N(a){return String(a).replace(/&/g,"&amp;").replace(/"/g,"&quot;")}function O(a){a.namespaces.g_vml_||a.namespaces.add("g_vml_","urn:schemas-microsoft-com:vml","#default#VML");a.namespaces.g_o_||a.namespaces.add("g_o_","urn:schemas-microsoft-com:office:office","#default#VML");
a.styleSheets.ex_canvas_||(a=a.createStyleSheet(),a.owningElement.id="ex_canvas_",a.cssText="canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}")}function X(a){var b=a.srcElement;switch(a.propertyName){case "width":b.getContext().clearRect();b.style.width=b.attributes.width.nodeValue+"px";b.firstChild.style.width=b.clientWidth+"px";break;case "height":b.getContext().clearRect(),b.style.height=b.attributes.height.nodeValue+"px",b.firstChild.style.height=b.clientHeight+
"px"}}function Y(a){a=a.srcElement;a.firstChild&&(a.firstChild.style.width=a.clientWidth+"px",a.firstChild.style.height=a.clientHeight+"px")}function D(){return[[1,0,0],[0,1,0],[0,0,1]]}function t(a,b){for(var c=D(),g=0;3>g;g++)for(var e=0;3>e;e++){for(var f=0,d=0;3>d;d++)f+=a[g][d]*b[d][e];c[g][e]=f}return c}function P(a,b){b.fillStyle=a.fillStyle;b.lineCap=a.lineCap;b.lineJoin=a.lineJoin;b.lineWidth=a.lineWidth;b.miterLimit=a.miterLimit;b.shadowBlur=a.shadowBlur;b.shadowColor=a.shadowColor;b.shadowOffsetX=
a.shadowOffsetX;b.shadowOffsetY=a.shadowOffsetY;b.strokeStyle=a.strokeStyle;b.globalAlpha=a.globalAlpha;b.font=a.font;b.textAlign=a.textAlign;b.textBaseline=a.textBaseline;b.arcScaleX_=a.arcScaleX_;b.arcScaleY_=a.arcScaleY_;b.lineScale_=a.lineScale_}function Q(a){var b=a.indexOf("(",3),c=a.indexOf(")",b+1),b=a.substring(b+1,c).split(",");if(4!=b.length||"a"!=a.charAt(3))b[3]=1;return b}function E(a,b,c){return Math.min(c,Math.max(b,a))}function F(a,b,c){0>c&&c++;1<c&&c--;return 1>6*c?a+6*(b-a)*c:
1>2*c?b:2>3*c?a+6*(b-a)*(2/3-c):a}function G(a){if(a in H)return H[a];var b,c=1;a=String(a);if("#"==a.charAt(0))b=a;else if(/^rgb/.test(a)){c=Q(a);b="#";for(var g,e=0;3>e;e++)g=-1!=c[e].indexOf("%")?Math.floor(255*(parseFloat(c[e])/100)):+c[e],b+=v[E(g,0,255)];c=+c[3]}else if(/^hsl/.test(a)){e=c=Q(a);b=parseFloat(e[0])/360%360;0>b&&b++;g=E(parseFloat(e[1])/100,0,1);e=E(parseFloat(e[2])/100,0,1);if(0==g)g=e=b=e;else{var f=0.5>e?e*(1+g):e+g-e*g,d=2*e-f;g=F(d,f,b+1/3);e=F(d,f,b);b=F(d,f,b-1/3)}b="#"+
v[Math.floor(255*g)]+v[Math.floor(255*e)]+v[Math.floor(255*b)];c=c[3]}else b=Z[a]||a;return H[a]={color:b,alpha:c}}function C(a){this.m_=D();this.mStack_=[];this.aStack_=[];this.currentPath_=[];this.fillStyle=this.strokeStyle="#000";this.lineWidth=1;this.lineJoin="miter";this.lineCap="butt";this.miterLimit=1*q;this.globalAlpha=1;this.font="10px sans-serif";this.textAlign="left";this.textBaseline="alphabetic";this.canvas=a;var b="width:"+a.clientWidth+"px;height:"+a.clientHeight+"px;overflow:hidden;position:absolute",
c=a.ownerDocument.createElement("div");c.style.cssText=b;a.appendChild(c);b=c.cloneNode(!1);b.style.backgroundColor="red";b.style.filter="alpha(opacity=0)";a.appendChild(b);this.element_=c;this.lineScale_=this.arcScaleY_=this.arcScaleX_=1}function R(a,b,c,g){a.currentPath_.push({type:"bezierCurveTo",cp1x:b.x,cp1y:b.y,cp2x:c.x,cp2y:c.y,x:g.x,y:g.y});a.currentX_=g.x;a.currentY_=g.y}function S(a,b){var c=G(a.strokeStyle),g=c.color,c=c.alpha*a.globalAlpha,e=a.lineScale_*a.lineWidth;1>e&&(c*=e);b.push("<g_vml_:stroke",
' opacity="',c,'"',' joinstyle="',a.lineJoin,'"',' miterlimit="',a.miterLimit,'"',' endcap="',$[a.lineCap]||"square",'"',' weight="',e,'px"',' color="',g,'" />')}function T(a,b,c,g){var e=a.fillStyle,f=a.arcScaleX_,d=a.arcScaleY_,k=g.x-c.x,n=g.y-c.y;if(e instanceof w){var h=0,l=g=0,u=0,m=1;if("gradient"==e.type_){h=e.x1_/f;c=e.y1_/d;var p=s(a,e.x0_/f,e.y0_/d),h=s(a,h,c),h=180*Math.atan2(h.x-p.x,h.y-p.y)/Math.PI;0>h&&(h+=360);1E-6>h&&(h=0)}else p=s(a,e.x0_,e.y0_),g=(p.x-c.x)/k,l=(p.y-c.y)/n,k/=f*q,
n/=d*q,m=x.max(k,n),u=2*e.r0_/m,m=2*e.r1_/m-u;f=e.colors_;f.sort(function(a,b){return a.offset-b.offset});d=f.length;p=f[0].color;c=f[d-1].color;k=f[0].alpha*a.globalAlpha;a=f[d-1].alpha*a.globalAlpha;for(var n=[],r=0;r<d;r++){var t=f[r];n.push(t.offset*m+u+" "+t.color)}b.push('<g_vml_:fill type="',e.type_,'"',' method="none" focus="100%"',' color="',p,'"',' color2="',c,'"',' colors="',n.join(","),'"',' opacity="',a,'"',' g_o_:opacity2="',k,'"',' angle="',h,'"',' focusposition="',g,",",l,'" />')}else e instanceof
I?k&&n&&b.push("<g_vml_:fill",' position="',-c.x/k*f*f,",",-c.y/n*d*d,'"',' type="tile"',' src="',e.src_,'" />'):(e=G(a.fillStyle),b.push('<g_vml_:fill color="',e.color,'" opacity="',e.alpha*a.globalAlpha,'" />'))}function s(a,b,c){a=a.m_;return{x:q*(b*a[0][0]+c*a[1][0]+a[2][0])-r,y:q*(b*a[0][1]+c*a[1][1]+a[2][1])-r}}function z(a,b,c){isFinite(b[0][0])&&(isFinite(b[0][1])&&isFinite(b[1][0])&&isFinite(b[1][1])&&isFinite(b[2][0])&&isFinite(b[2][1]))&&(a.m_=b,c&&(a.lineScale_=aa(ba(b[0][0]*b[1][1]-b[0][1]*
b[1][0]))))}function w(a){this.type_=a;this.r1_=this.y1_=this.x1_=this.r0_=this.y0_=this.x0_=0;this.colors_=[]}function I(a,b){if(!a||1!=a.nodeType||"IMG"!=a.tagName)throw new A("TYPE_MISMATCH_ERR");if("complete"!=a.readyState)throw new A("INVALID_STATE_ERR");switch(b){case "repeat":case null:case "":this.repetition_="repeat";break;case "repeat-x":case "repeat-y":case "no-repeat":this.repetition_=b;break;default:throw new A("SYNTAX_ERR");}this.src_=a.src;this.width_=a.width;this.height_=a.height}
function A(a){this.code=this[a];this.message=a+": DOM Exception "+this.code}var x=Math,k=x.round,J=x.sin,K=x.cos,ba=x.abs,aa=x.sqrt,q=10,r=q/2;navigator.userAgent.match(/MSIE ([\d.]+)?/);var M=Array.prototype.slice;O(document);var U={init:function(a){a=a||document;a.createElement("canvas");a.attachEvent("onreadystatechange",W(this.init_,this,a))},init_:function(a){a=a.getElementsByTagName("canvas");for(var b=0;b<a.length;b++)this.initElement(a[b])},initElement:function(a){if(!a.getContext){a.getContext=
V;O(a.ownerDocument);a.innerHTML="";a.attachEvent("onpropertychange",X);a.attachEvent("onresize",Y);var b=a.attributes;b.width&&b.width.specified?a.style.width=b.width.nodeValue+"px":a.width=a.clientWidth;b.height&&b.height.specified?a.style.height=b.height.nodeValue+"px":a.height=a.clientHeight}return a}};U.init();for(var v=[],d=0;16>d;d++)for(var B=0;16>B;B++)v[16*d+B]=d.toString(16)+B.toString(16);var Z={aliceblue:"#F0F8FF",antiquewhite:"#FAEBD7",aquamarine:"#7FFFD4",azure:"#F0FFFF",beige:"#F5F5DC",
bisque:"#FFE4C4",black:"#000000",blanchedalmond:"#FFEBCD",blueviolet:"#8A2BE2",brown:"#A52A2A",burlywood:"#DEB887",cadetblue:"#5F9EA0",chartreuse:"#7FFF00",chocolate:"#D2691E",coral:"#FF7F50",cornflowerblue:"#6495ED",cornsilk:"#FFF8DC",crimson:"#DC143C",cyan:"#00FFFF",darkblue:"#00008B",darkcyan:"#008B8B",darkgoldenrod:"#B8860B",darkgray:"#A9A9A9",darkgreen:"#006400",darkgrey:"#A9A9A9",darkkhaki:"#BDB76B",darkmagenta:"#8B008B",darkolivegreen:"#556B2F",darkorange:"#FF8C00",darkorchid:"#9932CC",darkred:"#8B0000",
darksalmon:"#E9967A",darkseagreen:"#8FBC8F",darkslateblue:"#483D8B",darkslategray:"#2F4F4F",darkslategrey:"#2F4F4F",darkturquoise:"#00CED1",darkviolet:"#9400D3",deeppink:"#FF1493",deepskyblue:"#00BFFF",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1E90FF",firebrick:"#B22222",floralwhite:"#FFFAF0",forestgreen:"#228B22",gainsboro:"#DCDCDC",ghostwhite:"#F8F8FF",gold:"#FFD700",goldenrod:"#DAA520",grey:"#808080",greenyellow:"#ADFF2F",honeydew:"#F0FFF0",hotpink:"#FF69B4",indianred:"#CD5C5C",indigo:"#4B0082",
ivory:"#FFFFF0",khaki:"#F0E68C",lavender:"#E6E6FA",lavenderblush:"#FFF0F5",lawngreen:"#7CFC00",lemonchiffon:"#FFFACD",lightblue:"#ADD8E6",lightcoral:"#F08080",lightcyan:"#E0FFFF",lightgoldenrodyellow:"#FAFAD2",lightgreen:"#90EE90",lightgrey:"#D3D3D3",lightpink:"#FFB6C1",lightsalmon:"#FFA07A",lightseagreen:"#20B2AA",lightskyblue:"#87CEFA",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#B0C4DE",lightyellow:"#FFFFE0",limegreen:"#32CD32",linen:"#FAF0E6",magenta:"#FF00FF",mediumaquamarine:"#66CDAA",
mediumblue:"#0000CD",mediumorchid:"#BA55D3",mediumpurple:"#9370DB",mediumseagreen:"#3CB371",mediumslateblue:"#7B68EE",mediumspringgreen:"#00FA9A",mediumturquoise:"#48D1CC",mediumvioletred:"#C71585",midnightblue:"#191970",mintcream:"#F5FFFA",mistyrose:"#FFE4E1",moccasin:"#FFE4B5",navajowhite:"#FFDEAD",oldlace:"#FDF5E6",olivedrab:"#6B8E23",orange:"#FFA500",orangered:"#FF4500",orchid:"#DA70D6",palegoldenrod:"#EEE8AA",palegreen:"#98FB98",paleturquoise:"#AFEEEE",palevioletred:"#DB7093",papayawhip:"#FFEFD5",
peachpuff:"#FFDAB9",peru:"#CD853F",pink:"#FFC0CB",plum:"#DDA0DD",powderblue:"#B0E0E6",rosybrown:"#BC8F8F",royalblue:"#4169E1",saddlebrown:"#8B4513",salmon:"#FA8072",sandybrown:"#F4A460",seagreen:"#2E8B57",seashell:"#FFF5EE",sienna:"#A0522D",skyblue:"#87CEEB",slateblue:"#6A5ACD",slategray:"#708090",slategrey:"#708090",snow:"#FFFAFA",springgreen:"#00FF7F",steelblue:"#4682B4",tan:"#D2B48C",thistle:"#D8BFD8",tomato:"#FF6347",turquoise:"#40E0D0",violet:"#EE82EE",wheat:"#F5DEB3",whitesmoke:"#F5F5F5",yellowgreen:"#9ACD32"},
H={},L={},$={butt:"flat",round:"round"},d=C.prototype;d.clearRect=function(){this.textMeasureEl_&&(this.textMeasureEl_.removeNode(!0),this.textMeasureEl_=null);this.element_.innerHTML=""};d.beginPath=function(){this.currentPath_=[]};d.moveTo=function(a,b){var c=s(this,a,b);this.currentPath_.push({type:"moveTo",x:c.x,y:c.y});this.currentX_=c.x;this.currentY_=c.y};d.lineTo=function(a,b){var c=s(this,a,b);this.currentPath_.push({type:"lineTo",x:c.x,y:c.y});this.currentX_=c.x;this.currentY_=c.y};d.bezierCurveTo=
function(a,b,c,g,e,f){e=s(this,e,f);a=s(this,a,b);c=s(this,c,g);R(this,a,c,e)};d.quadraticCurveTo=function(a,b,c,g){a=s(this,a,b);c=s(this,c,g);g={x:this.currentX_+2/3*(a.x-this.currentX_),y:this.currentY_+2/3*(a.y-this.currentY_)};R(this,g,{x:g.x+(c.x-this.currentX_)/3,y:g.y+(c.y-this.currentY_)/3},c)};d.arc=function(a,b,c,g,e,f){c*=q;var d=f?"at":"wa",k=a+K(g)*c-r,n=b+J(g)*c-r;g=a+K(e)*c-r;e=b+J(e)*c-r;k!=g||f||(k+=0.125);a=s(this,a,b);k=s(this,k,n);g=s(this,g,e);this.currentPath_.push({type:d,
x:a.x,y:a.y,radius:c,xStart:k.x,yStart:k.y,xEnd:g.x,yEnd:g.y})};d.rect=function(a,b,c,g){this.moveTo(a,b);this.lineTo(a+c,b);this.lineTo(a+c,b+g);this.lineTo(a,b+g);this.closePath()};d.strokeRect=function(a,b,c,g){var e=this.currentPath_;this.beginPath();this.moveTo(a,b);this.lineTo(a+c,b);this.lineTo(a+c,b+g);this.lineTo(a,b+g);this.closePath();this.stroke();this.currentPath_=e};d.fillRect=function(a,b,c,g){var e=this.currentPath_;this.beginPath();this.moveTo(a,b);this.lineTo(a+c,b);this.lineTo(a+
c,b+g);this.lineTo(a,b+g);this.closePath();this.fill();this.currentPath_=e};d.createLinearGradient=function(a,b,c,g){var e=new w("gradient");e.x0_=a;e.y0_=b;e.x1_=c;e.y1_=g;return e};d.createRadialGradient=function(a,b,c,g,e,f){var d=new w("gradientradial");d.x0_=a;d.y0_=b;d.r0_=c;d.x1_=g;d.y1_=e;d.r1_=f;return d};d.drawImage=function(a,b){var c,g,e,d,r,y,n,h;e=a.runtimeStyle.width;d=a.runtimeStyle.height;a.runtimeStyle.width="auto";a.runtimeStyle.height="auto";var l=a.width,u=a.height;a.runtimeStyle.width=
e;a.runtimeStyle.height=d;if(3==arguments.length)c=arguments[1],g=arguments[2],r=y=0,n=e=l,h=d=u;else if(5==arguments.length)c=arguments[1],g=arguments[2],e=arguments[3],d=arguments[4],r=y=0,n=l,h=u;else if(9==arguments.length)r=arguments[1],y=arguments[2],n=arguments[3],h=arguments[4],c=arguments[5],g=arguments[6],e=arguments[7],d=arguments[8];else throw Error("Invalid number of arguments");var m=s(this,c,g),p=[];p.push(" <g_vml_:group",' coordsize="',10*q,",",10*q,'"',' coordorigin="0,0"',' style="width:',
10,"px;height:",10,"px;position:absolute;");if(1!=this.m_[0][0]||this.m_[0][1]||1!=this.m_[1][1]||this.m_[1][0]){var t=[];t.push("M11=",this.m_[0][0],",","M12=",this.m_[1][0],",","M21=",this.m_[0][1],",","M22=",this.m_[1][1],",","Dx=",k(m.x/q),",","Dy=",k(m.y/q),"");var v=s(this,c+e,g),w=s(this,c,g+d);c=s(this,c+e,g+d);m.x=x.max(m.x,v.x,w.x,c.x);m.y=x.max(m.y,v.y,w.y,c.y);p.push("padding:0 ",k(m.x/q),"px ",k(m.y/q),"px 0;filter:progid:DXImageTransform.Microsoft.Matrix(",t.join(""),", sizingmethod='clip');")}else p.push("top:",
k(m.y/q),"px;left:",k(m.x/q),"px;");p.push(' ">','<g_vml_:image src="',a.src,'"',' style="width:',q*e,"px;"," height:",q*d,'px"',' cropleft="',r/l,'"',' croptop="',y/u,'"',' cropright="',(l-r-n)/l,'"',' cropbottom="',(u-y-h)/u,'"'," />","</g_vml_:group>");this.element_.insertAdjacentHTML("BeforeEnd",p.join(""))};d.stroke=function(a){var b=[];b.push("<g_vml_:shape",' filled="',!!a,'"',' style="position:absolute;width:',10,"px;height:",10,'px;"',' coordorigin="0,0"',' coordsize="',10*q,",",10*q,'"',
' stroked="',!a,'"',' path="');for(var c={x:null,y:null},d={x:null,y:null},e=0;e<this.currentPath_.length;e++){var f=this.currentPath_[e];switch(f.type){case "moveTo":b.push(" m ",k(f.x),",",k(f.y));break;case "lineTo":b.push(" l ",k(f.x),",",k(f.y));break;case "close":b.push(" x ");f=null;break;case "bezierCurveTo":b.push(" c ",k(f.cp1x),",",k(f.cp1y),",",k(f.cp2x),",",k(f.cp2y),",",k(f.x),",",k(f.y));break;case "at":case "wa":b.push(" ",f.type," ",k(f.x-this.arcScaleX_*f.radius),",",k(f.y-this.arcScaleY_*
f.radius)," ",k(f.x+this.arcScaleX_*f.radius),",",k(f.y+this.arcScaleY_*f.radius)," ",k(f.xStart),",",k(f.yStart)," ",k(f.xEnd),",",k(f.yEnd))}if(f){if(null==c.x||f.x<c.x)c.x=f.x;if(null==d.x||f.x>d.x)d.x=f.x;if(null==c.y||f.y<c.y)c.y=f.y;if(null==d.y||f.y>d.y)d.y=f.y}}b.push(' ">');a?T(this,b,c,d):S(this,b);b.push("</g_vml_:shape>");this.element_.insertAdjacentHTML("beforeEnd",b.join(""))};d.fill=function(){this.stroke(!0)};d.closePath=function(){this.currentPath_.push({type:"close"})};d.save=function(){var a=
{};P(this,a);this.aStack_.push(a);this.mStack_.push(this.m_);this.m_=t(D(),this.m_)};d.restore=function(){this.aStack_.length&&(P(this.aStack_.pop(),this),this.m_=this.mStack_.pop())};d.translate=function(a,b){z(this,t([[1,0,0],[0,1,0],[a,b,1]],this.m_),!1)};d.rotate=function(a){var b=K(a);a=J(a);z(this,t([[b,a,0],[-a,b,0],[0,0,1]],this.m_),!1)};d.scale=function(a,b){this.arcScaleX_*=a;this.arcScaleY_*=b;z(this,t([[a,0,0],[0,b,0],[0,0,1]],this.m_),!0)};d.transform=function(a,b,c,d,e,f){z(this,t([[a,
b,0],[c,d,0],[e,f,1]],this.m_),!0)};d.setTransform=function(a,b,c,d,e,f){z(this,[[a,b,0],[c,d,0],[e,f,1]],!0)};d.drawText_=function(a,b,c,d,e){var f=this.m_;d=0;var r=1E3,t=0,n=[],h;h=this.font;if(L[h])h=L[h];else{var l=document.createElement("div").style;try{l.font=h}catch(u){}h=L[h]={style:l.fontStyle||"normal",variant:l.fontVariant||"normal",weight:l.fontWeight||"normal",size:l.fontSize||10,family:l.fontFamily||"sans-serif"}}var l=h,m=this.element_;h={};for(var p in l)h[p]=l[p];p=parseFloat(m.currentStyle.fontSize);
m=parseFloat(l.size);"number"==typeof l.size?h.size=l.size:-1!=l.size.indexOf("px")?h.size=m:-1!=l.size.indexOf("em")?h.size=p*m:-1!=l.size.indexOf("%")?h.size=p/100*m:-1!=l.size.indexOf("pt")?h.size=m/0.75:h.size=p;h.size*=0.981;p=h.style+" "+h.variant+" "+h.weight+" "+h.size+"px "+h.family;m=this.element_.currentStyle;l=this.textAlign.toLowerCase();switch(l){case "left":case "center":case "right":break;case "end":l="ltr"==m.direction?"right":"left";break;case "start":l="rtl"==m.direction?"right":
"left";break;default:l="left"}switch(this.textBaseline){case "hanging":case "top":t=h.size/1.75;break;case "middle":break;default:case null:case "alphabetic":case "ideographic":case "bottom":t=-h.size/2.25}switch(l){case "right":d=1E3;r=0.05;break;case "center":d=r=500}b=s(this,b+0,c+t);n.push('<g_vml_:line from="',-d,' 0" to="',r,' 0.05" ',' coordsize="100 100" coordorigin="0 0"',' filled="',!e,'" stroked="',!!e,'" style="position:absolute;width:1px;height:1px;">');e?S(this,n):T(this,n,{x:-d,y:0},
{x:r,y:h.size});e=f[0][0].toFixed(3)+","+f[1][0].toFixed(3)+","+f[0][1].toFixed(3)+","+f[1][1].toFixed(3)+",0,0";b=k(b.x/q)+","+k(b.y/q);n.push('<g_vml_:skew on="t" matrix="',e,'" ',' offset="',b,'" origin="',d,' 0" />','<g_vml_:path textpathok="true" />','<g_vml_:textpath on="true" string="',N(a),'" style="v-text-align:',l,";font:",N(p),'" /></g_vml_:line>');this.element_.insertAdjacentHTML("beforeEnd",n.join(""))};d.fillText=function(a,b,c,d){this.drawText_(a,b,c,d,!1)};d.strokeText=function(a,
b,c,d){this.drawText_(a,b,c,d,!0)};d.measureText=function(a){this.textMeasureEl_||(this.element_.insertAdjacentHTML("beforeEnd",'<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'),this.textMeasureEl_=this.element_.lastChild);var b=this.element_.ownerDocument;this.textMeasureEl_.innerHTML="";this.textMeasureEl_.style.font=this.font;this.textMeasureEl_.appendChild(b.createTextNode(a));return{width:this.textMeasureEl_.offsetWidth}};d.clip=function(){};
d.arcTo=function(){};d.createPattern=function(a,b){return new I(a,b)};w.prototype.addColorStop=function(a,b){b=G(b);this.colors_.push({offset:a,color:b.color,alpha:b.alpha})};d=A.prototype=Error();d.INDEX_SIZE_ERR=1;d.DOMSTRING_SIZE_ERR=2;d.HIERARCHY_REQUEST_ERR=3;d.WRONG_DOCUMENT_ERR=4;d.INVALID_CHARACTER_ERR=5;d.NO_DATA_ALLOWED_ERR=6;d.NO_MODIFICATION_ALLOWED_ERR=7;d.NOT_FOUND_ERR=8;d.NOT_SUPPORTED_ERR=9;d.INUSE_ATTRIBUTE_ERR=10;d.INVALID_STATE_ERR=11;d.SYNTAX_ERR=12;d.INVALID_MODIFICATION_ERR=
13;d.NAMESPACE_ERR=14;d.INVALID_ACCESS_ERR=15;d.VALIDATION_ERR=16;d.TYPE_MISMATCH_ERR=17;G_vmlCanvasManager=U;CanvasRenderingContext2D=C;CanvasGradient=w;CanvasPattern=I;DOMException=A}();
/*tslint:enable*/
/*eslint-enable*/
/*jshint ignore:end*/

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ }),

/***/ "./src/algorithms/GeneticAlgorithm.ts":
/*!********************************************!*\
  !*** ./src/algorithms/GeneticAlgorithm.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calculate_and_sort_fitness: () => (/* binding */ calculate_and_sort_fitness),
/* harmony export */   calculate_fitness_by_coord: () => (/* binding */ calculate_fitness_by_coord),
/* harmony export */   calculate_fitness_by_food: () => (/* binding */ calculate_fitness_by_food),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   merge_sort: () => (/* binding */ merge_sort),
/* harmony export */   select_and_crossover: () => (/* binding */ select_and_crossover)
/* harmony export */ });
/* harmony import */ var _models_Gene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/Gene */ "./src/models/Gene.ts");
/* harmony import */ var _models_Organism__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/Organism */ "./src/models/Organism.ts");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.ts");



/**
 * Merges two sorted arrays of organisms into a single sorted array.
 * @param left - the left array of organisms.
 * @param right - the right array of organisms.
 * @returns - A single sorted array of organisms.
 */
function merge(left, right) {
    const result = [];
    let left_index = 0;
    let right_index = 0;
    // Iterate through both arrays and merge them while maintaining sorting.
    while (left_index < left.length && right_index < right.length) {
        if (left[left_index].fitness < right[right_index].fitness) {
            result.push(left[left_index]);
            left_index++;
        }
        else {
            result.push(right[right_index]);
            right_index++;
        }
    }
    // Concatenate remaining elements from both arrays into the result.
    return result.concat(left.slice(left_index)).concat(right.slice(right_index));
}
/**
 * Performs merge sort on an array of organisms.
 * @param arr - The array of organisms to be sorted.
 * @returns - A sorted array of organisms.
 */
function merge_sort(arr) {
    if (arr.length <= 1)
        return arr;
    // Calculate the middle index of the array.
    const middle = Math.floor(arr.length / 2);
    // Recursively divide the array into two halves and perform merge sort on each half.
    const left = merge_sort(arr.slice(0, middle));
    const right = merge_sort(arr.slice(middle));
    // Merge the sorted halves using the 'merge' function and return the result.
    return merge(left, right);
}
/**
 * Sorts an array of organisms based on their fitness and calculates their fitness values.
 * @param population - The array of organisms to be sorted.
 * @param goal - The goal of the simulation.
 * @param params - Parameters containing goal coordinates and maximum distances to goal for fitness calculation.
 * @returns - A sorted array of organisms.
 */
function calculate_and_sort_fitness(population, goal, params) {
    // Calculate fitness values for organisms based on the specified goal.
    if (goal === "food") {
        for (const organism of population) {
            organism.fitness = calculate_fitness_by_food(organism);
        }
    }
    else if (goal === "coord") {
        for (const organism of population) {
            organism.fitness = calculate_fitness_by_coord(organism, params);
        }
    }
    // Sort the population based on fitness using merge sort algorithm and return the sorted population.
    return merge_sort(population);
}
/**
 * Calculates the fitness value of an organism based on its energy level.
 * @param organism - The organism for which fitness is being calculated.
 * @returns - The calculated fitness value based on the organism's energy level.
 */
function calculate_fitness_by_food(organism) {
    return 1 - organism.energy / organism.config.MAX_ENERGY;
}
/**
 * Calculates the fitness value of an organism based on its proximity to specified coordinates.
 * @param organism - The organism for which fitness is being calculated.
 * @param params - Parameters containing goal coordinates and maximum distances to goal for fitness calculation.
 * @returns - The calculated fitness value based on the organism's proximity to the goal coordinates.
 */
function calculate_fitness_by_coord(organism, params) {
    const results = [];
    // Calculate distances between the organism's coordinate and each goal coordinate
    for (const coordinate of params.goal_coordinates) {
        results.push((0,_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.euclidean_distance)(organism.coordinate, coordinate));
    }
    // Find the minimum distance index to determine the maximum distance to normalize fitness
    const min_index = results.indexOf(Math.min(...results));
    const distance = results[min_index];
    const max_distance = params.max_distances_to_goal[min_index];
    // Normalize fitness score by dividing the distance by the maximum distance
    return distance / max_distance;
}
/**
 * Selects organisms for crossover and creates a new generation based on the provided population and configuration.
 * @param population - The array of organisms from which selection for crossover is performed.
 * @param config - The configuration object defining parameters for selection and crossover.
 * @returns - A new generation of organisms created through crossover and reproduction.
 */
function select_and_crossover(population, config) {
    const new_generation = [];
    const elitism_size = Math.floor((config.ELITISM_PERCENT * population.length) / 100);
    // Perform elitism by selecting the top organisms from the current population
    new_generation.push(...population.slice(0, elitism_size));
    // Generate new coordinates for the selected organisms
    for (const organism of new_generation) {
        const random_coord = organism.grid.fetch_empty_cell();
        organism.coordinate = random_coord;
    }
    const mating_size = Math.floor(((100 - config.ELITISM_PERCENT) * population.length) / 100);
    // Perform crossover by randomly selecting parents and creating offspring
    for (let i = 0; i < mating_size; i++) {
        const parent1 = population[Math.floor(Math.random() * ((config.TOP_PERCENT_TO_REPRODUCE / 100) * population.length))];
        const parent2 = population[Math.floor(Math.random() * ((config.TOP_PERCENT_TO_REPRODUCE / 100) * population.length))];
        const child = mate(parent1, parent2);
        new_generation.push(child);
    }
    return new_generation;
}
/**
 * Mates with another organism to produce a child organism.
 * @param parent - The first parent organism.
 * @param partner - The second parent organism.
 * @param id - The ID of the child organism.
 * @returns - A new child organism resulting from the mating process of the parent organisms.
 */
function mate(parent, partner) {
    // Create an array to store the child organism's genome
    const child_genome = new Array(parent.genome.data.length);
    // Loop through each gene in the parent organisms' genomes
    for (let i = 0; i < parent.genome.data.length; i++) {
        // Retrieve genes from the parent organisms
        const organism_gene = parent.genome.data[i];
        const partner_gene = partner.genome.data[i];
        // Generate a random probability value
        const random_probability = Math.random();
        // Calculate the selection probability for choosing genes from parents
        const selection_probability = (100 - parent.config.MUTATION_PERCENT) / 2 / 100;
        // Decide which gene to select based on the random probability
        if (random_probability < selection_probability) {
            // Select the gene from the first parent
            child_genome[i] = organism_gene;
        }
        else if (random_probability < selection_probability * 2) {
            // Select the gene from the second parent
            child_genome[i] = partner_gene;
        }
        else {
            // If no gene is selected, create a new gene
            child_genome[i] = new _models_Gene__WEBPACK_IMPORTED_MODULE_0__["default"](parent.config.NUMBER_OF_HIDDEN_NEURONS);
        }
    }
    // Get a random empty cell coordinate on the grid
    const random_coord = parent.grid.fetch_empty_cell();
    // Create and return a new organism with the generated genome and a random empty cell coordinate
    return new _models_Organism__WEBPACK_IMPORTED_MODULE_1__["default"](random_coord, child_genome, parent.grid, parent.config);
}


/***/ }),

/***/ "./src/algorithms/NeuralNetDiagram.ts":
/*!********************************************!*\
  !*** ./src/algorithms/NeuralNetDiagram.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   draw_neural_net_brain: () => (/* binding */ draw_neural_net_brain)
/* harmony export */ });
/* harmony import */ var _components_DOMElements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/DOMElements */ "./src/components/DOMElements.ts");
/* harmony import */ var _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/InputNeurons */ "./src/constants/InputNeurons.ts");
/* harmony import */ var _constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/OutputNeurons */ "./src/constants/OutputNeurons.ts");
/* harmony import */ var _models_Neurons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../models/Neurons */ "./src/models/Neurons.ts");




const node_radius = 20;
const node_spacing = 10;
const svg = _components_DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.neural_network_svg;
/**
 * Creates an SVG element with specific attributes.
 * @param element_type - The type of SVG element to be created.
 * @param attributes - The attributes of the SVG element.
 * @returns - The created SVG element.
 */
function create_element_ns(element_type, attributes) {
    // Create an SVG element with the specified element type.
    const element = document.createElementNS("http://www.w3.org/2000/svg", element_type);
    // Iterate through the key value pairs in the attributes object and set each attribute to the element.
    for (const [key, value] of Object.entries(attributes)) {
        element.setAttribute(key, value);
    }
    // Return the element.
    return element;
}
/**
 * Creates an SVG text element with specific attributes.
 * @param x - x-coordinate of the text element.
 * @param y - y-coordinate of the text element.
 * @param text - Text content of the text element.
 * @param fill - Fill colour of the text element.
 * @returns - The created SVG text element.
 */
function create_text(x, y, text, fill) {
    // Create an object with the attributes for the text element.
    const attributes = {
        x: x.toString(),
        y: y.toString(),
        "text-anchor": "middle",
        dy: ".3em",
        fill: fill,
    };
    // Create the text element and set its text content.
    const text_element = create_element_ns("text", attributes);
    text_element.textContent = text;
    // Return the text element.
    return text_element;
}
/**
 * Connects two nodes with a line.
 * @param source - The source node.
 * @param sink - The sink node.
 * @param weight - The weight of the connection.
 * @param is_positive - Whether the connection is positive or negative.
 */
function connect_nodes(source, sink, weight, is_positive) {
    // Define attributes for the line connecting the source and sink nodes.
    const attributes = {
        // X-coordinate of the source node.
        x1: source[0].toString(),
        // Y-coordinate of the source node.
        y1: source[1].toString(),
        // X-coordinate of the sink node.
        x2: sink[0].toString(),
        // Y-coordinate of the sink node.
        y2: sink[1].toString(),
        // Colour of the line based on weight.
        stroke: is_positive ? "green" : "red",
        // Width of the line based on weight.
        "stroke-width": weight.toString(),
    };
    // Create a line SVG element with the defined attributes.
    const line = create_element_ns("line", attributes);
    // Append the line to the SVG canvas.
    svg.appendChild(line);
    // Define properties for the circles representing the source and sink nodes.
    const circle_radius = 3;
    // Fill colour of the circles.
    const circle_fill = is_positive ? "green" : "red";
    // Create circle SVG elements representing the source and sink nodes.
    const source_node = create_circle(source[0], source[1], circle_radius, circle_fill);
    const sink_node = create_circle(sink[0], sink[1], circle_radius, circle_fill);
    // Append the source and sink node to the SVG.
    svg.appendChild(source_node);
    svg.appendChild(sink_node);
}
/**
 * Creates an SVG circle element with specific attributes.
 * @param x - x-coordinate of the centre of the circle.
 * @param y - y-coordinate of the centre of the circle.
 * @param r - Radius of the circle.
 * @param fill - Fill colour of the circle.
 * @param stroke - Whether the circle has a stroke.
 * @returns - The created SVG circle element.
 */
function create_circle(x, y, r, fill, stroke = false) {
    // Define attributes for the circle element.
    const attributes = {
        // X-coordinate of the centre of the circle.
        cx: x.toString(),
        // Y-coordinate of the centre of the circle.
        cy: y.toString(),
        // Radius of the circle.
        r: r.toString(),
        // Fill colour of the circle.
        fill: fill,
    };
    if (stroke) {
        (attributes["stroke"] = "black"), (attributes["stroke-width"] = "5px");
    }
    // Create a circle SVG element with the defined attributes.
    const circle = create_element_ns("circle", attributes);
    // Return the created circle element.
    return circle;
}
/**
 * Finds the y-coordinate of the previous node.
 * @param object - The object containing the nodes of the current type.
 * @param previous - The previous y-coordinate.
 * @returns - The y-coordinate of the previous node.
 */
function find_previous_node_y_coord(object, previous) {
    // If the object is empty, there is no previous node, so return the node spacing plus the node radius as the initial y-coordinate.
    if (Object.keys(object).length == 0) {
        previous = node_spacing + node_radius;
    }
    else {
        // Otherwise, find the previous y-coordinate by adding the node spacing and the node radius to the previous y-coordinate.
        previous = previous + (node_spacing + 2 * node_radius);
    }
    return previous;
}
/**
 * Creates a node for the neural network diagram.
 * @param node_type - The type of node.
 * @param node_id - The ID of the node.
 * @param input_neurons - The input neurons.
 * @param hidden_neurons - The hidden neurons.
 * @param output_neurons - The output neurons.
 * @param last_input_neuron_coord - The last y-coordinate of the input neuron.
 * @param last_hidden_neuron_coord - The last y-coordinate of the hidden neuron.
 * @param last_output_neuron_coord - The last y-coordinate of the output neuron.
 * @returns - The updated input, hidden, and output neurons and their last coordinates.
 */
function create_node(node_type, node_id, input_neurons, hidden_neurons, output_neurons, last_input_neuron_coord, last_hidden_neuron_coord, last_output_neuron_coord) {
    // Create a new SVG group element.
    const group = create_element_ns("g", {});
    // Define x coord positions for different types of nodes.
    const input = 50;
    const hidden = 200;
    const output = 350;
    // Initialise variables for previous y-coordinate, x-coordinate, and node text.
    let previous_y_coord;
    let x_coord;
    let node_text;
    // Determine the y-coordinate and update neuron positions based on node type.
    if (node_type == "INPUT") {
        // Find the previous y-coordinate for the input neuron.
        previous_y_coord = find_previous_node_y_coord(input_neurons, last_input_neuron_coord);
        input_neurons[node_id] = [input, previous_y_coord];
        last_input_neuron_coord = previous_y_coord;
    }
    else if (node_type == "OUTPUT") {
        // Find the previous y-coordinate for the output neuron.
        previous_y_coord = find_previous_node_y_coord(output_neurons, last_output_neuron_coord);
        output_neurons[node_id] = [output, previous_y_coord];
        last_output_neuron_coord = previous_y_coord;
    }
    else if (node_type == "HIDDEN") {
        // Find the previous y-coordinate for the hidden neuron.
        previous_y_coord = find_previous_node_y_coord(hidden_neurons, last_hidden_neuron_coord);
        hidden_neurons[node_id] = [hidden, previous_y_coord];
        last_hidden_neuron_coord = previous_y_coord;
    }
    // Determine x-coordinate and node text based on the node type.
    if (node_type == "INPUT") {
        x_coord = input;
        node_text = _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_1__.InputNeuronSymbols[node_id];
    }
    else if (node_type == "OUTPUT") {
        x_coord = output;
        node_text = _constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_2__.OutputNeuronSymbols[node_id];
    }
    else if (node_type == "HIDDEN") {
        x_coord = hidden;
        node_text = node_id.toString();
    }
    // Create circle and text elements for the node.
    const circle = create_circle(x_coord, previous_y_coord, node_radius, "white", true);
    const text_element = create_text(x_coord, previous_y_coord, node_text, "black");
    // Append the circle and text elements to the group element.
    group.appendChild(circle);
    group.appendChild(text_element);
    // Append the group element to the SVG.
    svg.appendChild(group);
    return [input_neurons, hidden_neurons, output_neurons, last_input_neuron_coord, last_hidden_neuron_coord, last_output_neuron_coord];
}
/**
 * Draws the neural network diagram based on the given connections.
 * @param connections - The connections between nodes in the neural network.
 */
function draw_neural_net_brain(connections) {
    // Lists to store the input, hidden, and output neurons.
    let input_neurons = [];
    let hidden_neurons = [];
    let output_neurons = [];
    // Variables to store the last y coordinates of the input, hidden, and output neurons.
    let last_input_neuron_coord = 0;
    let last_hidden_neuron_coord = 0;
    let last_output_neuron_coord = 0;
    // Variable to store the updated coordinates of the input, hidden, and output neurons plus their last coordinates.
    let updated_coordinates;
    // Set the initial height of the SVG.
    let height = 400;
    svg.innerHTML = `<svg width='400px' height='${height}px' id='neural-network-svg'></svg>`;
    svg.style.height = height.toString(); // Iterate through each connection to draw lines between connected nodes.
    // Iterate through each connection to draw lines between connected nodes.
    for (const connection of connections) {
        let source;
        let sink;
        // Determine the source node based on its type.
        if (connection.source_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.INPUT || connection.source_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.HIDDEN) {
            if (connection.source_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.INPUT && input_neurons[connection.source_id]) {
                source = input_neurons[connection.source_id];
            }
            else if (connection.source_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.HIDDEN && hidden_neurons[connection.source_id]) {
                source = hidden_neurons[connection.source_id];
            }
            else {
                // If the source node does not exist, create it.
                updated_coordinates = create_node(connection.source_type == 0 ? "HIDDEN" : "INPUT", connection.source_id, input_neurons, hidden_neurons, output_neurons, last_input_neuron_coord, last_hidden_neuron_coord, last_output_neuron_coord);
                if (connection.source_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.INPUT) {
                    source = input_neurons[connection.source_id];
                }
                else if (connection.source_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.HIDDEN) {
                    source = hidden_neurons[connection.source_id];
                }
            }
        }
        // Update the input, hidden, and output neurons and their last coordinates.
        input_neurons = updated_coordinates[0];
        hidden_neurons = updated_coordinates[1];
        output_neurons = updated_coordinates[2];
        last_input_neuron_coord = updated_coordinates[3];
        last_hidden_neuron_coord = updated_coordinates[4];
        last_output_neuron_coord = updated_coordinates[5];
        // Determine the sink node based on its type.
        if (connection.sink_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.OUTPUT || connection.sink_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.HIDDEN) {
            if (connection.sink_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.OUTPUT && output_neurons[connection.sink_id]) {
                sink = output_neurons[connection.sink_id];
            }
            else if (connection.sink_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.HIDDEN && hidden_neurons[connection.sink_id]) {
                sink = hidden_neurons[connection.sink_id];
            }
            else {
                // If the sink node does not exist, create it.
                updated_coordinates = create_node(connection.sink_type == 0 ? "HIDDEN" : "OUTPUT", connection.sink_id, input_neurons, hidden_neurons, output_neurons, last_input_neuron_coord, last_hidden_neuron_coord, last_output_neuron_coord);
                if (connection.sink_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.OUTPUT) {
                    sink = output_neurons[connection.sink_id];
                }
                else if (connection.sink_type == _models_Neurons__WEBPACK_IMPORTED_MODULE_3__.Neurons.HIDDEN) {
                    sink = hidden_neurons[connection.sink_id];
                }
            }
        }
        // Update the input, hidden, and output neurons and their last coordinates.
        input_neurons = updated_coordinates[0];
        hidden_neurons = updated_coordinates[1];
        output_neurons = updated_coordinates[2];
        last_input_neuron_coord = updated_coordinates[3];
        last_hidden_neuron_coord = updated_coordinates[4];
        last_output_neuron_coord = updated_coordinates[5];
        // Define constants for line thickness calculation based on the weight of the connection.
        const max_thickness = 2.5;
        const min_thickness = 0.5;
        // The thickness is calculated by calculating the ratio of the weight to the maximum/minimum possible weight and multiplying it by the maximum/minimum thickness.
        const thickness = Math.max(connection.weight >= 0 ? (connection.weight / 0x7fff) * max_thickness : (Math.abs(connection.weight) / 0x8000) * max_thickness, min_thickness);
        // Draw connections between nodes based on their coordinates and connection weight.
        connect_nodes(source, sink, thickness, connection.weight >= 0);
    }
    // Obtain the number of input, hidden, and output neurons.
    const input_neurons_size = Object.keys(input_neurons).length;
    const output_neurons_size = Object.keys(output_neurons).length;
    const hidden_neurons_size = Object.keys(hidden_neurons).length;
    // Determine the height of the SVG based on the number of input, hidden, and output neurons.
    // The maximum of the three is used to determine the height of the SVG.
    if (Math.max(input_neurons_size, output_neurons_size, hidden_neurons_size) == input_neurons_size) {
        height = last_input_neuron_coord;
    }
    else if (Math.max(input_neurons_size, output_neurons_size, hidden_neurons_size) == output_neurons_size) {
        height = last_output_neuron_coord;
    }
    else if (Math.max(input_neurons_size, output_neurons_size, hidden_neurons_size) == hidden_neurons_size) {
        height = last_hidden_neuron_coord;
    }
    // Set the height of the SVG.
    svg.style.height = (height + node_radius + node_spacing).toString();
}


/***/ }),

/***/ "./src/components/Buttons.ts":
/*!***********************************!*\
  !*** ./src/components/Buttons.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   register_download_neuralnet_button: () => (/* binding */ register_download_neuralnet_button),
/* harmony export */   register_fps_slider: () => (/* binding */ register_fps_slider),
/* harmony export */   register_rendering_enabled_button: () => (/* binding */ register_rendering_enabled_button),
/* harmony export */   register_show_controls: () => (/* binding */ register_show_controls),
/* harmony export */   register_sim_restart_button: () => (/* binding */ register_sim_restart_button),
/* harmony export */   register_sim_start_stop_button: () => (/* binding */ register_sim_start_stop_button),
/* harmony export */   register_switch_chart: () => (/* binding */ register_switch_chart)
/* harmony export */ });
/* harmony import */ var _DOMElements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DOMElements */ "./src/components/DOMElements.ts");

/**
 * Registers an event listener for the download neural network button.
 */
function register_download_neuralnet_button() {
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.export_neuralnet.addEventListener("click", () => {
        // Get the SVG element from the Document Object Model (DOM)
        const svg = document.querySelector("svg");
        if (svg) {
            // Serialize the SVG element to a string
            const as_text = new XMLSerializer().serializeToString(svg);
            // Create a Blob object from the serialized SVG string
            const blob = new Blob([as_text], { type: "image/svg+xml" });
            // Create a URL object from the Blob object
            const url = URL.createObjectURL(blob);
            // Create a link element and set its attributes
            const link = document.createElement("a");
            link.href = url;
            link.download = "neural_network.svg";
            // Click the link element to download the SVG file
            link.click();
        }
    });
}
/**
 * Registers an event listener for the rendering enabled button.
 * @param simulation - The simulation object.
 */
function register_rendering_enabled_button(simulation) {
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.rendering_enabled.addEventListener("click", () => {
        // When the button is clicked, the rendering enabled property is toggled.
        simulation.rendering_enabled = !simulation.rendering_enabled;
        // Update the button text to reflect the current rendering state.
        _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.rendering_enabled.innerHTML = "Rendering " + (simulation.rendering_enabled ? "ON" : "OFF");
        // If the simulation is running, restart the engine to apply the changes.
        if (simulation.is_running) {
            simulation.stop_engine();
            simulation.start_engine();
        }
    });
}
/**
 * Registers an event listener for the restart button.
 */
function register_sim_restart_button() {
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.sim_restart.addEventListener("click", () => {
        // Creates a confirmation dialog box asking the user whether they want to restart the simulation.
        const restart_confirmed = confirm("Are you sure you would like to restart?");
        // If the user confirms, reload the page.
        if (restart_confirmed) {
            window.location.reload();
        }
    });
}
/**
 * Registers an event listener for the start/stop button.
 * @param simulation - The simulation object.
 */
function register_sim_start_stop_button(simulation) {
    // When the button is clicked, the simulation is either started or stopped.
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.sim_start_stop.addEventListener("click", () => {
        // If the simulation is running, stop the engine and update the button text.
        if (simulation.is_running) {
            simulation.stop_engine();
            _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.sim_start_stop.innerHTML = "START";
        }
        else {
            // If the simulation is not running, start the engine and update the button text.
            const engine_started = simulation.start_engine();
            if (engine_started) {
                _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.sim_start_stop.innerHTML = "STOP";
            }
        }
    });
}
/** Registers an event listener for the show controls button. */
function register_show_controls() {
    let control_window_shown = false;
    // When the button is clicked, the control window is either shown or hidden.
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.button.addEventListener("click", () => {
        // Toggle the control window's visibility.
        control_window_shown = !control_window_shown;
        // If the control window is shown, display the sidebar, else hide it.
        if (control_window_shown) {
            _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.sidebar.style.display = "block";
        }
        else {
            _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.sidebar.style.display = "none";
        }
    });
}
/**
 * Registers an event listener for the FPS slider.
 * @param simulation - The simulation object.
 * @param config - The simulation configuration.
 */
function register_fps_slider(simulation, config) {
    // Set the slider's min, max, and initial value.
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.max = config.TARGET_UPDATE_MAX_FPS.toString();
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.value = config.TARGET_UPDATE_FPS.toString();
    // When the slider's value is changed, the target update FPS is updated.
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.addEventListener("input", () => {
        if (_DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.value === _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.max) {
            // If the slider is at its maximum value, set the target update FPS to the maximum safe integer (highest possible FPS).
            _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.slider_label.innerHTML = "MAX";
            config.TARGET_UPDATE_FPS = Number.MAX_SAFE_INTEGER;
        }
        else if (_DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.value == _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.min) {
            // If the slider is at its minimum value, set the target update FPS to 1.
            _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.slider_label.innerHTML = "1";
            config.TARGET_UPDATE_FPS = 1;
        }
        else {
            // Otherwise, set the target update FPS to the slider's value.
            _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.slider_label.innerHTML = _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.value;
            config.TARGET_UPDATE_FPS = parseInt(_DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.target_update_fps_slider.value, 10);
        }
        // If the simulation is running, restart the engine to apply the changes.
        if (simulation.is_running) {
            simulation.restart_engine();
        }
    });
}
/**
 * Registers an event listener for the chart switcher.
 * @param simulation - The simulation object.
 */
function register_switch_chart(simulation) {
    _DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.switch_chart.addEventListener("change", () => {
        const index = parseInt(_DOMElements__WEBPACK_IMPORTED_MODULE_0__.DOMElements.switch_chart.value);
        simulation.environment.chart.switch_chart(index);
    });
}


/***/ }),

/***/ "./src/components/DOMElements.ts":
/*!***************************************!*\
  !*** ./src/components/DOMElements.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DOMElements: () => (/* binding */ DOMElements)
/* harmony export */ });
// DOM elements are stored in a single object to avoid polluting the global namespace.
const DOMElements = {
    button: document.getElementById("open_sidebar"),
    export_neuralnet: document.getElementById("export_neuralnet"),
    rendering_enabled: document.getElementById("render_on_off"),
    sidebar: document.getElementById("sidebar"),
    sim_restart: document.getElementById("sim_restart"),
    sim_start_stop: document.getElementById("sim_start_stop"),
    slider_label: document.getElementById("target_update_fps"),
    target_update_fps_slider: document.getElementById("target_update_fps_slider"),
    export_population: document.getElementById("export_all_organisms"),
    export_config: document.getElementById("export_config"),
    export_simulation: document.getElementById("export_simulation"),
    export_environment: document.getElementById("export_environment"),
    import_config: document.getElementById("import_config"),
    import_organisms: document.getElementById("import_organisms"),
    import_simulation: document.getElementById("import_simulation"),
    import_environment: document.getElementById("import_environment"),
    neural_network_svg: document.getElementById("neural_network_svg"),
    settings: document.getElementById("settings"),
    mode: document.getElementById("mode"),
    organism_selected: document.getElementById("organism_selected"),
    organism_selected_table: document.getElementById("export_neuralnet"),
    target_update_fps: document.getElementById("target_update_fps"),
    target_render_fps: document.getElementById("target_render_fps"),
    current_update_fps: document.getElementById("current_update_fps"),
    current_render_fps: document.getElementById("current_render_fps"),
    tick_count: document.getElementById("tick_count"),
    generation: document.getElementById("generation"),
    best_fitness: document.getElementById("best_fitness"),
    overall_fitness: document.getElementById("overall_fitness"),
    organisms_alive: document.getElementById("organisms_alive"),
    switch_chart: document.getElementById("switch_chart"),
    number_of_species: document.getElementById("number_of_species"),
};


/***/ }),

/***/ "./src/components/ImportExport.ts":
/*!****************************************!*\
  !*** ./src/components/ImportExport.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   export_environment: () => (/* binding */ export_environment),
/* harmony export */   export_population: () => (/* binding */ export_population),
/* harmony export */   export_population_button: () => (/* binding */ export_population_button),
/* harmony export */   register_export_config_button: () => (/* binding */ register_export_config_button),
/* harmony export */   register_export_environment_button: () => (/* binding */ register_export_environment_button),
/* harmony export */   register_export_simulation_button: () => (/* binding */ register_export_simulation_button),
/* harmony export */   register_import_config_button: () => (/* binding */ register_import_config_button),
/* harmony export */   register_import_environment_button: () => (/* binding */ register_import_environment_button),
/* harmony export */   register_import_organisms_button: () => (/* binding */ register_import_organisms_button),
/* harmony export */   register_import_simulation_button: () => (/* binding */ register_import_simulation_button)
/* harmony export */ });
/* harmony import */ var _environment_Grid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../environment/Grid */ "./src/environment/Grid.ts");
/* harmony import */ var _utils_export_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/export_object */ "./src/utils/export_object.ts");
/* harmony import */ var _utils_read_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/read_file */ "./src/utils/read_file.ts");
/* harmony import */ var _DOMElements__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DOMElements */ "./src/components/DOMElements.ts");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Settings */ "./src/components/Settings.ts");





/**
 * Exports all organisms in the simulation.
 * @param population - The population to be exported.
 * @param with_coordinates - Whether or not to export the coordinates of the organisms.
 * @returns An object containing the exported population.
 */
function export_population(population, with_coordinates) {
    // Create an array to store the exported population.
    const population_export = [];
    // Iterate over all organisms in the population.
    for (const organism of population) {
        // If the user wants to export the coordinates, export the genome and the coordinates.
        if (with_coordinates) {
            // Create an object to store the organism's genome and coordinates.
            const organism_export = {};
            organism_export["genome"] = organism.genome.data;
            organism_export["coordinates"] = organism.coordinate;
            population_export.push(organism_export);
        }
        else {
            // Otherwise, only export the genome.
            population_export.push(organism.genome.data);
        }
    }
    // Return the exported population.
    return population_export;
}
/**
 * Exports the environment.
 * @param grid - The grid to export.
 * @returns - An array containing the obstacles in the grid.
 */
function export_environment(grid) {
    // Create an array to store the obstacles.
    const obstacles = [];
    // Iterate over all cells in the grid.
    for (let i = 0; i < grid.grid_size; i++) {
        for (let j = 0; j < grid.grid_size; j++) {
            // Get the state of the cell.
            const state = grid.get_cell_at({ x: i, y: j }).state;
            // If the cell is a wall or radioactive, push the cell to the obstacles array.
            if (state == _environment_Grid__WEBPACK_IMPORTED_MODULE_0__.CellStates.WALL || state == _environment_Grid__WEBPACK_IMPORTED_MODULE_0__.CellStates.RADIOACTIVE) {
                obstacles.push([i, j, state]);
            }
        }
    }
    return obstacles;
}
/**
 * Registers an event listener for the export population button.
 * @param simulation - The simulation object.
 */
function export_population_button(simulation) {
    // Register an event listener for the export population button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.export_population.addEventListener("click", () => {
        // Get the population from the simulation.
        const organisms = simulation.environment.population;
        // If the population exists, export it.
        if (organisms) {
            const population = export_population(organisms, false);
            // Export the population
            (0,_utils_export_object__WEBPACK_IMPORTED_MODULE_1__["default"])({ file_type: "organism_export", population }, "population");
        }
        else {
            // Otherwise, alert the user that there are no organisms to export.
            alert("No organisms available to export.");
        }
    });
}
/**
 * Registers an event listener for the export config button.
 * @param config - The simulation configuration.
 */
function register_export_config_button(config) {
    // Register an event listener for the export config button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.export_config.addEventListener("click", () => {
        // Export the simulation config.
        (0,_utils_export_object__WEBPACK_IMPORTED_MODULE_1__["default"])({ file_type: "config_export", config: config }, "config");
    });
}
/**
 * Registers an event listener for the export simulation button.
 * @param simulation - The simulation object.
 * @param config - The simulation configuration.
 */
function register_export_simulation_button(simulation, config) {
    // Register an event listener for the export simulation button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.export_simulation.addEventListener("click", () => {
        // Create an object to store the export.
        const simulation_export = {};
        // Assign the simulation config to the export object.
        simulation_export["simulation_config"] = config;
        // Get the population from the simulation.
        const population = simulation.environment.population;
        // If the population exists, export it.
        if (population) {
            const exported_population = export_population(population, true);
            simulation_export.population = exported_population;
        }
        // Exports the environment.
        const obstacles = export_environment(simulation.environment.grid);
        // Push the generation, ticks and file type to the export object.
        simulation_export["generation"] = simulation.environment.generation;
        simulation_export["ticks"] = simulation.environment.ticks;
        simulation_export["file_type"] = "simulation_export";
        simulation_export["obstacles"] = obstacles;
        // Export the simulation.
        (0,_utils_export_object__WEBPACK_IMPORTED_MODULE_1__["default"])(simulation_export, "simulation");
    });
}
/**
 * Registers an event listener for the export environment button.
 * @param simulation - The simulation object.
 */
function register_export_environment_button(simulation) {
    // Register an event listener for the export environment button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.export_environment.addEventListener("click", () => {
        // Exports the environment.
        const obstacles = export_environment(simulation.environment.grid);
        // Export the obstacles.
        (0,_utils_export_object__WEBPACK_IMPORTED_MODULE_1__["default"])({ file_type: "obstacles", obstacles: obstacles }, "obstacles");
    });
}
/**
 * Registers an event listener for the import config button.
 * @param simulation - The simulation object.
 */
function register_import_config_button(simulation) {
    // Register an event listener for the import config button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_config.addEventListener("change", (event) => {
        // Read and parse the json file, then update the simulation config.
        (0,_utils_read_file__WEBPACK_IMPORTED_MODULE_2__.read_file)(event).then((data) => {
            // If the file is valid, update the simulation config.
            if (data.config && data.file_type == "config_export") {
                simulation.config = data.config;
                simulation.environment.config = data.config;
                (0,_Settings__WEBPACK_IMPORTED_MODULE_4__.render_settings)(simulation, simulation.config);
                alert("Successfully imported config.");
            }
            else {
                // Otherwise, alert the user that the file is invalid.
                alert("Failed to read config from file.");
            }
            // Reset the file input element.
            _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_config.value = "";
        });
    });
}
/**
 * Registers an event listener for the import organisms button.
 * @param simulation - The simulation object.
 */
function register_import_organisms_button(simulation) {
    // Register an event listener for the import organisms button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_organisms.addEventListener("change", (event) => {
        // Read and parse the json file, then add the organisms to the simulation.
        (0,_utils_read_file__WEBPACK_IMPORTED_MODULE_2__.read_file)(event).then((data) => {
            // If the file is valid, add the organisms to the simulation.
            if (data && data.file_type == "organism_export") {
                // Iterate over all organisms in the file.
                for (const genome of data.population) {
                    // Add the organism to the simulation using its genome.
                    const added_organism = simulation.environment.add_organism(genome);
                    // If the organism was not added, alert the user.
                    if (!added_organism) {
                        alert("Failed to import all organisms.");
                        return;
                    }
                }
                // Alert the user that the organisms were successfully imported.
                alert("Successfully imported organisms.");
            }
            else {
                // Otherwise, alert the user that the file is invalid.
                alert("Invalid file.");
            }
            // Reset the file input element.
            _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_organisms.value = "";
        });
    });
}
/**
 * Registers an event listener for the import simulation button.
 * @param simulation - The simulation object.
 */
function register_import_simulation_button(simulation) {
    // Register an event listener for the import simulation button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_simulation.addEventListener("change", (event) => {
        // Read and parse the JSON file.
        (0,_utils_read_file__WEBPACK_IMPORTED_MODULE_2__.read_file)(event).then((data) => {
            // If the file is valid, import the simulation.
            if (data && data.file_type == "simulation_export") {
                // If simulation config exists, update the simulation config and render settings.
                if (data.simulation_config) {
                    simulation.config = data.simulation_config;
                    (0,_Settings__WEBPACK_IMPORTED_MODULE_4__.render_settings)(simulation, simulation.config);
                }
                else {
                    // Alert if simulation config is missing.
                    alert("Failed to read simulation config from file.");
                }
                // If obstacles data exists, add obstacles to the simulation.
                if (data.obstacles) {
                    for (const obstacle of data.obstacles) {
                        simulation.environment.grid.set_cell_state({ x: obstacle[0], y: obstacle[1] }, obstacle[2]);
                    }
                }
                else {
                    // Alert if obstacles data is missing.
                    alert("Failed to read obstacles from file.");
                }
                // If population data exists, add organisms to the simulation.
                if (data.population) {
                    for (const organism of data.population) {
                        const result = simulation.environment.add_organism(organism.genome, organism.coordinates);
                        if (!result) {
                            alert("Failed to import all organisms.");
                            return;
                        }
                    }
                }
                else {
                    // Alert if population data is missing.
                    alert("Failed to read population from file.");
                }
                // Update generation count if available.
                if (data.generation) {
                    simulation.environment.generation = data.generation;
                }
                else {
                    // Alert if generation count is missing.
                    alert("Failed to read generation from file.");
                }
                // Update ticks count if available.
                if (data.ticks) {
                    simulation.environment.ticks = data.ticks;
                }
                else {
                    // Alert if ticks count is missing.
                    alert("Failed to read ticks from file.");
                }
                // Alert on successful import of the simulation.
                alert("Successfully imported simulation.");
            }
            else {
                // Alert if the file is invalid.
                alert("Invalid file.");
            }
            // Reset the file input element.
            _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_simulation.value = "";
        });
    });
}
/**
 * Registers an event listener for the import environment button.
 * @param simulation - The simulation object.
 */
function register_import_environment_button(simulation) {
    // Event listener for import environment button.
    _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_environment.addEventListener("change", (event) => {
        // Read and parse the JSON file.
        (0,_utils_read_file__WEBPACK_IMPORTED_MODULE_2__.read_file)(event).then((data) => {
            // Check if obstacles data exists and the file type is obstacles.
            if (data.obstacles && data.file_type == "obstacles") {
                // Iterate over all obstacles in the file.
                for (const obstacle of data.obstacles) {
                    // Set the cell state of the obstacle.
                    simulation.environment.grid.set_cell_state({ x: obstacle[0], y: obstacle[1] }, obstacle[2]);
                }
                // Alert on successful import of environment.
                alert("Successfully imported environment.");
            }
            else {
                // Alert if obstacles data is missing or file type is incorrect.
                alert("Failed to read obstacles from file.");
            }
            // Reset the file input element.
            _DOMElements__WEBPACK_IMPORTED_MODULE_3__.DOMElements.import_environment.value = "";
        });
    });
}


/***/ }),

/***/ "./src/components/Settings.ts":
/*!************************************!*\
  !*** ./src/components/Settings.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render_fps_element: () => (/* binding */ render_fps_element),
/* harmony export */   render_settings: () => (/* binding */ render_settings)
/* harmony export */ });
/* harmony import */ var _controllers_renderer_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../controllers/renderer.controller */ "./src/controllers/renderer.controller.ts");
/* harmony import */ var _environment_Grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../environment/Grid */ "./src/environment/Grid.ts");
/* harmony import */ var _DOMElements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DOMElements */ "./src/components/DOMElements.ts");



/** These are the only parameters that can only be changed whilst the simulation is running. */
const live_params = ["MUTATION_PERCENT", "ELITISM_PERCENT", "TICKS_PER_GENERATION"];
/**
 * Checks if the parameter is a live parameter and alerts the user if it is.
 * @param started - Whether the simulation has started.
 * @param key - The key in the config object that was changed.
 * @returns - Whether the parameter is a live parameter.
 */
function check_if_live_param(started, key) {
    if (started && !live_params.includes(key)) {
        alert(`The ${key} parameter cannot be changed when the simulation has already started.`);
        return false;
    }
    else {
        return true;
    }
}
/**
 * Checks for changes in the config object and applies them to the simulation.
 * @param simulation - The simulation object.
 * @param config - The config object.
 * @param key - The key in the config object that was changed.
 */
function check_config_changes(simulation, config, key) {
    // Check if the key in the config object is "GRID_SIZE"
    if (key === "GRID_SIZE") {
        // Calculate the new pixel size based on the grid size.
        simulation.environment.pixel_size = (config[key] * 15) / config[key];
        // Set canvas width and height based on the grid size multiplied by 15,
        simulation.environment.canvas.width = simulation.environment.canvas.height = config[key] * 15;
        // Apply scaling to the canvas using the zoom level.
        simulation.environment.canvas.style.transform = `scale(${simulation.environment.zoom_level})`;
        // Create a new Renderer instance with updated canvas, context, and pixel size.
        simulation.environment.renderer = new _controllers_renderer_controller__WEBPACK_IMPORTED_MODULE_0__["default"](simulation.environment.canvas, simulation.environment.ctx, simulation.environment.pixel_size);
        // Create a new Grid instance with the updated grid size and renderer
        simulation.environment.grid = new _environment_Grid__WEBPACK_IMPORTED_MODULE_1__.Grid(config[key], simulation.environment.renderer);
        // Ensure renderer's pixel size matches the updated environment's pixel size
        simulation.environment.renderer.pixel_size = simulation.environment.pixel_size;
        // Clear the canvas using the updated renderer.
        simulation.environment.renderer.clear_canvas();
    }
}
/**
 * Renders the FPS element on the HTML page.
 * @param element - The HTML element to render the FPS element in.
 * @param fps - The FPS value to display.
 */
function render_fps_element(element, fps) {
    // Set the inner HTML of the specified HTML element to display the rounded FPS value as a string
    element.innerHTML = Math.round(fps).toString();
}
/**
 * Renders the settings element on the HTML page.
 * @param simulation - The simulation object.
 * @param config - The config object.
 */
function render_settings(simulation, config) {
    // Function to handle changes in the input
    function handle_change(e) {
        const target = e.target;
        const key = target.id;
        const value = target.value;
        // Check if the key is a live parameter before updating simulation config.
        if (check_if_live_param(simulation.has_started, key)) {
            // Update the config object based on the input type
            if (typeof config[key] === "number") {
                config[key] = parseInt(value);
            }
            else if (typeof config[key] === "boolean") {
                config[key] = target.checked;
            }
            // Trigger function to check and apply config changes
            check_config_changes(simulation, config, key);
        }
        else {
            // Reset the input value to the config value
            target.value = config[key].toString();
        }
    }
    // Retrieve all keys from the config object
    const keys = Object.keys(config);
    // Clear the innerHTML of the settings element
    _DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.settings.innerHTML = "";
    // Iterate through each key in the config object
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = config[key];
        // Create a new table row.
        const row = document.createElement("tr");
        // Create a new table cell for the key
        const key_cell = document.createElement("td");
        // Display the key with underscores replaced by spaces
        key_cell.textContent = key.replaceAll("_", " ");
        // Append the key cell to the row
        row.appendChild(key_cell);
        // Append the row to the settings div
        _DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.settings.appendChild(row);
        // Create a new table cell for the input
        const input_cell = document.createElement("td");
        const input = document.createElement("input");
        // Set the input type based on the value type (number or checkbox)
        input.setAttribute("type", typeof value === "number" ? "number" : "checkbox");
        input.setAttribute("id", key); // Set input ID to the key
        // Set the input value or checked attribute based on the value
        if (typeof value == "boolean" && value) {
            input.setAttribute("checked", "true");
        }
        else {
            input.setAttribute("value", value.toString());
        }
        // Add event listener to handle input changes
        input.addEventListener("change", handle_change);
        // Append the input cell to the row
        row.appendChild(input_cell);
        input_cell.appendChild(input);
        // Append the row to the settings div
        _DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.settings.appendChild(row);
        // Check for config changes
        check_config_changes(simulation, config, key);
    }
}


/***/ }),

/***/ "./src/config/simulation.config.ts":
/*!*****************************************!*\
  !*** ./src/config/simulation.config.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultSimulationConfig: () => (/* binding */ DefaultSimulationConfig)
/* harmony export */ });
/* harmony import */ var _constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../constants/OutputNeurons */ "./src/constants/OutputNeurons.ts");
/* harmony import */ var _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/InputNeurons */ "./src/constants/InputNeurons.ts");
// Importing constants for output and input neurons


/** Default simulation settings. */
const DefaultSimulationConfig = {
    // Grid size for the simulation
    GRID_SIZE: 128,
    // Maximum frames per second (FPS) for updating the simulation
    TARGET_UPDATE_MAX_FPS: 300,
    // Target frames per second (FPS) for updating the simulation
    TARGET_UPDATE_FPS: 300,
    // Target frames per second (FPS) for rendering the simulation
    TARGET_RENDER_FPS: 60,
    // Number of organisms in the population
    POPULATION: 1500,
    // Number of simulation steps before moving to next generation.
    TICKS_PER_GENERATION: 300,
    // Percentage of top performers considered for elitism
    ELITISM_PERCENT: 10,
    // Percentage of top performers for reproduction
    TOP_PERCENT_TO_REPRODUCE: 3,
    // Percentage of mutation rate
    MUTATION_PERCENT: 0,
    // Flag for enabling sexual reproduction
    SEXUAL_REPRODUCTION: true,
    // Total number of neurons in the simulation.
    NUMBER_OF_HIDDEN_NEURONS: 15, // 127
    // Maximum energy each organism can have.
    MAX_ENERGY: 1,
    // Total number of genes for organisms
    NUMBER_OF_GENES: 50,
    // Flags indicating whether goal is food or coordinated.
    GOAL_FOOD: false,
    GOAL_COORD: true,
    // Determine the number of available input and output neurons based on imported constants.
    NUMBER_OF_INPUTS: Object.keys(_constants_InputNeurons__WEBPACK_IMPORTED_MODULE_1__.InputNeurons).length,
    NUMBER_OF_OUTPUTS: Object.keys(_constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_0__.OutputNeurons).length,
};



/***/ }),

/***/ "./src/config/theme.config.ts":
/*!************************************!*\
  !*** ./src/config/theme.config.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Theme palette for simulation, cells are coloured with hex values. */
const ThemeConfig = {
    EMPTY: "#282a36",
    WALL: "#44475a",
    FOOD: "#44475a",
    RADIOACTIVE: "#ff5555",
    HIGHLIGHTED: "#f1fa8c",
    SELECTED: "#ffffff",
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ThemeConfig);


/***/ }),

/***/ "./src/constants/Directions.ts":
/*!*************************************!*\
  !*** ./src/constants/Directions.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Angles: () => (/* binding */ Angles),
/* harmony export */   "default": () => (/* binding */ Directions)
/* harmony export */ });
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.ts");

/**
 * This class is a collection of static vectors representing different directions. It also
 * contains methods to calculate the forward, backward, left and right directions based on
 * the given angle.
 */
class Directions {
    // No movement vector
    static IDLE = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0);
    // Vector pointing north
    static NORTH = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 1);
    // Vector pointing east
    static EAST = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(1, 0);
    // Vector pointing south
    static SOUTH = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, -1);
    // Vector pointing west
    static WEST = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(-1, 0);
    // Vector pointing northeast
    static NORTH_EAST = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(1, 1);
    // Vector pointing northwest
    static NORTH_WEST = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(-1, 1);
    // Vector pointing southeast
    static SOUTH_EAST = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(-1, 1);
    // Vector pointing southwest
    static SOUTH_WEST = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(-1, -1);
    /**
     * Calculates the forward direction based on the given angle.
     * @param angle - The angle to calculate the forward direction from .
     * @returns The forward direction based on the given angle.
     */
    static forward(angle) {
        // Rotate North vector by the given angle
        return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.rotate_point)(this.NORTH, (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0), angle);
    }
    /**
     * Calculates the backward direction based on the given angle.
     * @param angle - The angle to calculate the backward direction from.
     * @returns The backward direction based on the given angle.
     */
    static backward(angle) {
        // Rotate South vector by the given angle
        return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.rotate_point)(this.SOUTH, (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0), angle);
    }
    /**
     * Calculates the left direction based on the given angle.
     * @param angle - The angle to calculate the left direction from.
     * @returns The left direction based on the given angle.
     */
    static left(angle) {
        // Rotate Left vector by 90 degrees from North
        return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.rotate_point)(this.NORTH, (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0), angle - Math.PI / 2);
    }
    /**
     * Calculates the right direction based on the given angle.
     * @param angle - The angle to calculate the right direction from.
     * @returns The right direction based on the given angle.
     */
    static right(angle) {
        // Rotate Right vector by 90 degrees from North
        return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.rotate_point)(this.NORTH, (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0), angle + Math.PI / 2);
    }
}
/** Constant angles for each cardinal direction. */
const Angles = {
    // Angle for facing North
    NORTH: 0,
    // Angle for facing East
    EAST: 90,
    // Angle for facing South
    SOUTH: 180,
    // Angle for facing West
    WEST: 270,
};


/***/ }),

/***/ "./src/constants/InputNeurons.ts":
/*!***************************************!*\
  !*** ./src/constants/InputNeurons.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InputNeuronSymbols: () => (/* binding */ InputNeuronSymbols),
/* harmony export */   InputNeurons: () => (/* binding */ InputNeurons)
/* harmony export */ });
/** Constant object defining all the available input neurons. */
const InputNeurons = {
    // Input neuron for X-coordinate
    X_COORDINATE: 1,
    // Input neuron for Y-coordinate
    Y_COORDINATE: 2,
    // Input neuron for boundary - North
    BOUNDARY_NORTH: 3,
    // Input neuron for boundary - East
    BOUNDARY_EAST: 4,
    // Input neuron for boundary - South
    BOUNDARY_SOUTH: 5,
    // Input neuron for boundary - West
    BOUNDARY_WEST: 6,
    // Input neuron for looking direction - North
    LOOK_NORTH: 7,
    // Input neuron for looking direction - East
    LOOK_EAST: 8,
    // Input neuron for looking direction - South
    LOOK_SOUTH: 9,
    // Input neuron for looking direction - West
    LOOK_WEST: 10,
};
/** Array of strings representing abbreviated symbols for Input Neurons. */
const InputNeuronSymbols = ["XC", "YC", "BN", "BE", "BS", "BW", "LN", "LE", "LS", "LW"];


/***/ }),

/***/ "./src/constants/OutputNeurons.ts":
/*!****************************************!*\
  !*** ./src/constants/OutputNeurons.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OutputNeuronSymbols: () => (/* binding */ OutputNeuronSymbols),
/* harmony export */   OutputNeurons: () => (/* binding */ OutputNeurons)
/* harmony export */ });
/** Constant object defining all the available output neurons. */
const OutputNeurons = {
    // Represents the output neuron for moving along the X-axis
    MOVE_X: 0,
    // Represents the output neuron for moving along the Y-axis
    MOVE_Y: 1,
    // Represents the output neuron for moving towards the North direction
    MOVE_NORTH: 2,
    // Represents the output neuron for moving towards the East direction
    MOVE_EAST: 3,
    // Represents the output neuron for moving towards the South direction
    MOVE_SOUTH: 4,
    // Represents the output neuron for moving towards the West direction
    MOVE_WEST: 5,
};
/** Array of strings containing abbreviations for each output neuron. */
const OutputNeuronSymbols = ["MX", "MY", "MN", "ME", "MS", "MW"];


/***/ }),

/***/ "./src/controllers/canvas.controller.ts":
/*!**********************************************!*\
  !*** ./src/controllers/canvas.controller.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Canvas)
/* harmony export */ });
/* harmony import */ var _algorithms_NeuralNetDiagram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/NeuralNetDiagram */ "./src/algorithms/NeuralNetDiagram.ts");
/* harmony import */ var _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/DOMElements */ "./src/components/DOMElements.ts");
/* harmony import */ var _environment_Grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../environment/Grid */ "./src/environment/Grid.ts");
/* harmony import */ var _utils_get_max_distance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/get_max_distance */ "./src/utils/get_max_distance.ts");
/* harmony import */ var _utils_get_style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/get_style */ "./src/utils/get_style.ts");
/* harmony import */ var _mouse_controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mouse.controller */ "./src/controllers/mouse.controller.ts");
/* harmony import */ var _renderer_controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderer.controller */ "./src/controllers/renderer.controller.ts");







/** Class to handle canvas-related events. */
class Canvas {
    canvas;
    ctx;
    grid_size;
    pixel_size;
    zoom_level;
    zoom_speed;
    min_zoom;
    pan_amount;
    mouse;
    renderer;
    grid;
    config;
    goal_coordinates;
    max_distances_to_goal;
    constructor(canvas_id, config) {
        this.config = config;
        // Get the canvas element and its 2D rendering context
        this.canvas = document.getElementById(canvas_id);
        this.ctx = this.canvas.getContext("2d");
        // Set the canvas dimensions based on the grid size
        this.canvas.width = this.canvas.height = this.config.GRID_SIZE * 15;
        this.grid_size = this.config.GRID_SIZE;
        this.pixel_size = (this.config.GRID_SIZE * 15) / this.grid_size;
        this.zoom_level = 0.4;
        this.zoom_speed = 0.01;
        this.min_zoom = 0.1;
        this.pan_amount = 50;
        this.mouse = new _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.Mouse(this.pixel_size, this.grid_size);
        this.renderer = new _renderer_controller__WEBPACK_IMPORTED_MODULE_6__["default"](this.canvas, this.ctx, this.pixel_size);
        this.grid = new _environment_Grid__WEBPACK_IMPORTED_MODULE_2__.Grid(this.grid_size, this.renderer);
        this.goal_coordinates = [];
        this.max_distances_to_goal = [];
        // Set the initial zoom level and transform the canvas accordingly
        this.canvas.style.transform = `scale(${this.zoom_level})`;
        // Register mouse and keyboard events
        this.register_mouse_events();
        this.register_keyboard_events();
        this.renderer.clear_canvas();
    }
    /** Registers mouse events on the canvas. */
    register_mouse_events() {
        // Register mouse events on the canvas.
        this.canvas.addEventListener("mousemove", (e) => this.mouse_move(e));
        this.canvas.addEventListener("mouseup", (e) => this.mouse_up(e));
        this.canvas.addEventListener("mousedown", (e) => this.mouse_down(e));
        this.canvas.addEventListener("mouseenter", (e) => this.mouse_enter(e));
        this.canvas.addEventListener("mouseleave", () => this.mouse_leave());
        this.canvas.addEventListener("wheel", (e) => this.wheel(e));
    }
    /** Registers keyboard events on the window. */
    register_keyboard_events() {
        // Register keyboard events on the window
        window.addEventListener("keydown", (e) => {
            this.handle_key_down(e);
        });
    }
    /**
     * Handles mouse move event.
     * @param event - The mouse move event.
     */
    mouse_move(event) {
        // Handle mouse move event
        this.mouse.mouse_move(event);
        this.handle_mouse_move();
        this.check_mouse_events();
    }
    /**
     * Handles mouse up event.
     * @param event - The mouse up event.
     */
    mouse_up(event) {
        // Handle mouse up event
        this.mouse.mouse_up(event);
    }
    /**
     * Handles mouse down event.
     * @param event - The mouse down event.
     */
    mouse_down(event) {
        this.mouse.mouse_down(event);
        this.check_mouse_events();
    }
    /**
     * Handles mouse enter event.
     * @param event - The mouse enter event.
     */
    mouse_enter(event) {
        // Handle mouse enter event
        this.mouse.mouse_enter(event);
        this.handle_mouse_move();
    }
    /**
     * Handles mouse leave event.
     * @param event - The mouse leave event.
     */
    mouse_leave() {
        this.mouse.mouse_leave();
        this.handle_mouse_leave();
    }
    /**
     * Handles mouse wheel event.
     * @param event - The mouse wheel event.
     */
    wheel(event) {
        // Handle mouse wheel event
        this.handle_mouse_wheel(event);
    }
    /** Checks and performs mouse-related actions based on the current mode */
    check_mouse_events() {
        // Check if the left mouse button is clicked
        if (this.mouse.left_click) {
            // Get the cell at the current mouse position
            const cell = this.grid.get_cell_at(this.mouse.grid_coord);
            // If the current mode is goal, check if the cell is selected, and add or remove it from the goal coordinates.
            if (this.mouse.mode == _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.GOAL) {
                if (cell.is_selected) {
                    // Remove selected goal coordinate and its max distance
                    this.goal_coordinates.splice(this.goal_coordinates.indexOf(cell.coordinate), 1);
                    this.max_distances_to_goal.splice(this.goal_coordinates.indexOf(cell.coordinate), 1);
                    this.grid.set_cell_selected(cell.coordinate, false);
                }
                else {
                    // Add selected goal coordinate and its max distance
                    this.goal_coordinates.push(cell.coordinate);
                    this.max_distances_to_goal.push((0,_utils_get_max_distance__WEBPACK_IMPORTED_MODULE_3__.max_distance_to_point)(this.config.GRID_SIZE, cell.coordinate.x, cell.coordinate.y));
                    this.grid.set_cell_selected(cell.coordinate, true);
                }
            }
            else if (this.mouse.mode == _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.IDLE) {
                // If the current mode is idle, check if the cell is an organism, and create its neural network diagram.
                if (cell.state == _environment_Grid__WEBPACK_IMPORTED_MODULE_2__.CellStates.ORGANISM && cell.owner?.brain.connections) {
                    // Display selected organism's neural network diagram
                    _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.organism_selected.innerHTML = "Organism selected";
                    _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.organism_selected_table.style.display = "block";
                    (0,_algorithms_NeuralNetDiagram__WEBPACK_IMPORTED_MODULE_0__.draw_neural_net_brain)(cell.owner.brain.connections);
                }
                else {
                    // Clear organism selected message and hide neural network diagram download button.
                    _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.organism_selected.innerHTML = "";
                    _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.organism_selected_table.style.display = "none";
                }
            }
            else if (this.mouse.mode == _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.PAN) {
                // If the current mode is pan, move the canvas based on the mouse movement.
                const canvas_top = parseInt((0,_utils_get_style__WEBPACK_IMPORTED_MODULE_4__["default"])("canvas", "top"));
                const canvas_left = parseInt((0,_utils_get_style__WEBPACK_IMPORTED_MODULE_4__["default"])("canvas", "left"));
                // Add the difference between the current mouse position and the clicked mouse position to the canvas position.
                this.canvas.style.top = canvas_top + (this.mouse.canvas_coord.y - this.mouse.clicked_coord.y) * this.zoom_level + "px";
                this.canvas.style.left = canvas_left + (this.mouse.canvas_coord.x - this.mouse.clicked_coord.x) * this.zoom_level + "px";
            }
            else if (this.mouse.mode == _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.WALL) {
                // If the current mode is wall and there is no owner in the selected cell, set the cell state to wall.
                if (!cell.owner) {
                    this.grid.set_cell_state(this.mouse.grid_coord, _environment_Grid__WEBPACK_IMPORTED_MODULE_2__.CellStates.WALL);
                }
            }
            else if (this.mouse.mode == _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.RADIOACTIVE) {
                // If the current mode is radioactive and there is no owner in the selected cell, set the cell state to radioactive.
                if (!cell.owner) {
                    this.grid.set_cell_state(this.mouse.grid_coord, _environment_Grid__WEBPACK_IMPORTED_MODULE_2__.CellStates.RADIOACTIVE);
                }
            }
            else if (this.mouse.mode == _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.REMOVE) {
                // If the current mode is remove and there is no owner in the selected cell, clear the cell state.
                if (!cell.owner) {
                    this.grid.clear_cell_state(this.mouse.grid_coord);
                }
            }
        }
    }
    /**
     * Handles keyboard key down events.
     * @param event - The keyboard event.
     */
    handle_key_down(event) {
        // Obtain canvas top and left style values
        const canvas_top = parseInt((0,_utils_get_style__WEBPACK_IMPORTED_MODULE_4__["default"])("canvas", "top"));
        const canvas_left = parseInt((0,_utils_get_style__WEBPACK_IMPORTED_MODULE_4__["default"])("canvas", "left"));
        // If the WASD keys are pressed, pan the canvas by adding or subtracting the pan amount from the canvas top or left style values.
        if (event.code == "KeyD")
            this.canvas.style.left = canvas_left - this.pan_amount + "px";
        else if (event.code == "KeyA")
            this.canvas.style.left = canvas_left + this.pan_amount + "px";
        else if (event.code == "KeyS")
            this.canvas.style.top = canvas_top - this.pan_amount + "px";
        else if (event.code == "KeyW")
            this.canvas.style.top = canvas_top + this.pan_amount + "px";
        // If the 1-6 keys are pressed, change the current mode.
        else if (event.code == "Digit1")
            this.mouse.mode = _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.IDLE;
        else if (event.code == "Digit2")
            this.mouse.mode = _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.PAN;
        else if (event.code == "Digit3")
            this.mouse.mode = _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.GOAL;
        else if (event.code == "Digit4")
            this.mouse.mode = _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.WALL;
        else if (event.code == "Digit5")
            this.mouse.mode = _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.RADIOACTIVE;
        else if (event.code == "Digit6")
            this.mouse.mode = _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModes.REMOVE;
        // Display the current mode on the DOM
        _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.mode.innerHTML = _mouse_controller__WEBPACK_IMPORTED_MODULE_5__.MouseModeSymbols[this.mouse.mode];
    }
    // Handles mouse wheel event for zooming and panning
    handle_mouse_wheel(event) {
        // Determine the direction of mouse wheel scroll
        const sign = -Math.sign(event.deltaY);
        // Calculate the scale by taking the maximum between the minimum zoom level and the current zoom level plus the sign of the mouse wheel scroll multiplied by the zoom speed.
        const scale = Math.max(this.min_zoom, this.zoom_level + sign * this.zoom_speed);
        // Obtain the current top and left style values for the canvas
        const canvas_top = parseInt((0,_utils_get_style__WEBPACK_IMPORTED_MODULE_4__["default"])("canvas", "top"));
        const canvas_left = parseInt((0,_utils_get_style__WEBPACK_IMPORTED_MODULE_4__["default"])("canvas", "left"));
        // Calculate the displacement in X and Y from zooming
        const dx = (this.canvas.width / 2 - this.mouse.canvas_coord.x) * (scale - this.zoom_level);
        const dy = (this.canvas.height / 2 - this.mouse.canvas_coord.y) * (scale - this.zoom_level);
        // Update the top and left styles for canvas based on the zoom level and mouse position
        this.canvas.style.top = canvas_top + dy + "px";
        this.canvas.style.left = canvas_left + dx + "px";
        // Update the zoom level and apply the CSS scale transformation to the canvas
        this.zoom_level = scale;
        this.canvas.style.transform = `scale(${this.zoom_level})`;
    }
    // Handles the action to highlight cells upon mouse move.
    handle_mouse_move() {
        // Clear the highlight from the previously highlighted cell
        this.grid.set_cell_highlighted(this.mouse.prev_grid_coord, false);
        // Set the current cell under the mouse pointer as highlighted
        this.grid.set_cell_highlighted(this.mouse.grid_coord, true);
    }
    // Handle mouse leave canvas.
    handle_mouse_leave() {
        // Handle mouse leave event
        // const cell = this.grid.get_cell_at(this.mouse.grid_coord);
        // if (cell.is_highlighted) {
        //   this.grid.set_cell_highlighted(this.mouse.grid_coord, false);
        // }
    }
}


/***/ }),

/***/ "./src/controllers/chart.controller.ts":
/*!*********************************************!*\
  !*** ./src/controllers/chart.controller.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ChartController)
/* harmony export */ });
/* harmony import */ var _canvasjs_charts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @canvasjs/charts */ "./node_modules/@canvasjs/charts/canvasjs.min.js");
/* harmony import */ var _canvasjs_charts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_canvasjs_charts__WEBPACK_IMPORTED_MODULE_0__);

/** This class is used to create a chart controller that can be used to switch between charts. */
class ChartController {
    chart;
    configs;
    chart_id;
    constructor(chart_id) {
        this.configs = [];
        this.chart_id = chart_id;
    }
    /**
     * Switches the chart to the specified index.
     * @param index - The index of the chart to switch to.
     */
    switch_chart(index) {
        this.chart = new (_canvasjs_charts__WEBPACK_IMPORTED_MODULE_0___default().Chart)(this.chart_id, this.configs[index]);
    }
    /**
     * Adds a chart configuration to the chart controller.
     * @param title - The title of the chart.
     * @param x_axis - The title of the x-axis.
     * @param y_axis - The title of the y-axis.
     * @param data_points - The data points to display on the chart.
     * @param max - The maximum value of the y-axis.
     */
    add_config(title, x_axis, y_axis, data_points, max = null) {
        this.configs.push({
            title: {
                text: title,
            },
            axisY: {
                title: y_axis,
                maximum: max,
            },
            axisX: {
                title: x_axis,
                minimum: 0,
            },
            zoomEnabled: true,
            data: [
                {
                    name: "Data",
                    type: "area",
                    color: "rgba(69,65,88,0.5)",
                    markerSize: 0,
                    dataPoints: data_points,
                },
            ],
        });
    }
}


/***/ }),

/***/ "./src/controllers/config.controller.ts":
/*!**********************************************!*\
  !*** ./src/controllers/config.controller.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConfigController: () => (/* binding */ ConfigController)
/* harmony export */ });
/**
 * This class is used to create a singleton configuration controller that
 * can be used to store the current configuration.
 */
class ConfigController {
    // Singleton instance
    static instance;
    // Configuration object
    _config;
    constructor() {
        this._config = {};
    }
    /**
     * Returns the singleton instance of ConfigController
     * @returns The singleton instance of ConfigController
     */
    static get_instance() {
        // If the singleton instance does not exist, create it
        if (!ConfigController.instance) {
            // Create the singleton instance
            ConfigController.instance = new ConfigController();
        }
        return ConfigController.instance;
    }
    /**
     * Returns the configuration object.
     * @returns The configuration object.
     */
    get config() {
        // Return the configuration object
        return this._config;
    }
    /**
     * Sets the configuration object.
     * @param new_value - The new configuration object.
     */
    set config(new_value) {
        this._config = new_value;
    }
}


/***/ }),

/***/ "./src/controllers/mouse.controller.ts":
/*!*********************************************!*\
  !*** ./src/controllers/mouse.controller.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mouse: () => (/* binding */ Mouse),
/* harmony export */   MouseModeSymbols: () => (/* binding */ MouseModeSymbols),
/* harmony export */   MouseModes: () => (/* binding */ MouseModes)
/* harmony export */ });
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.ts");

// Define the different modes for mouse interaction.
const MouseModeSymbols = ["IDLE", "PAN", "GOAL", "WALL", "RADIOACTIVE", "REMOVE"];
// ModesEnum is used to access the different modes by index.
const MouseModes = {
    IDLE: 0,
    PAN: 1,
    GOAL: 2,
    WALL: 3,
    RADIOACTIVE: 4,
    REMOVE: 5,
};
/** This class is used to create a mouse controller that can be used to manage mouse events. */
class Mouse {
    grid_size;
    middle_click;
    left_click;
    right_click;
    pixel_size;
    mode;
    grid_coord;
    prev_grid_coord;
    canvas_coord;
    clicked_coord;
    constructor(pixel_size, grid_size) {
        this.grid_size = grid_size;
        this.grid_coord = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0);
        this.prev_grid_coord = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0);
        this.canvas_coord = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0);
        this.clicked_coord = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(0, 0);
        this.middle_click = false;
        this.left_click = false;
        this.right_click = false;
        this.pixel_size = pixel_size;
        this.mode = MouseModes.IDLE;
    }
    /**
     * This method is triggered when the mouse moves in the canvas.
     * @param event - The mouse move event.
     */
    mouse_move(event) {
        event.preventDefault();
        // Update the coordinates based on mouse position.
        this.canvas_coord.x = event.offsetX;
        this.canvas_coord.y = event.offsetY;
        // Store the previous grid coordinates.
        this.prev_grid_coord.x = this.grid_coord.x;
        this.prev_grid_coord.y = this.grid_coord.y;
        // Calculate new grid coordinates based on the canvas and pixel size.
        this.grid_coord.x = Math.floor(this.canvas_coord.x / this.pixel_size);
        this.grid_coord.y = Math.floor(this.canvas_coord.y / this.pixel_size);
        // Fix grid coordinates within canvas boundaries.
        if (this.grid_coord.x >= this.grid_size)
            this.grid_coord.x -= 1;
        if (this.grid_coord.y >= this.grid_size)
            this.grid_coord.y -= 1;
        if (this.grid_coord.x <= 0)
            this.grid_coord.x = 0;
        if (this.grid_coord.y <= 0)
            this.grid_coord.y = 0;
    }
    /**
     * This method is triggered when the mouse click is released.
     * @param event - The mouse up event.
     */
    mouse_up(event) {
        event.preventDefault();
        // Identify and handle different mouse buttons upon release.
        if (event.button === 0)
            this.left_click = false; // Left mouse button released
        if (event.button === 1)
            this.middle_click = false; // Middle mouse button released
        if (event.button === 2)
            this.right_click = false; // Right mouse button released
    }
    /**
     * This method is triggered when the mouse is clicked.
     * @param event - The mouse down event.
     */
    mouse_down(event) {
        event.preventDefault();
        // Identify and set flags for different mouse buttons upon click.
        this.left_click = event.button === 0; // Left mouse button clicked
        this.middle_click = event.button === 1; // Middle mouse button clicked
        this.right_click = event.button === 2; // Right mouse button clicked
        // Store the coordinates of the click.
        this.clicked_coord.x = this.canvas_coord.x;
        this.clicked_coord.y = this.canvas_coord.y;
    }
    /**
     * This method is triggered when the mouse enters the canvas.
     * @param event - The mouse enter event.
     */
    mouse_enter(event) {
        // Identify and set flags for different mouse buttons upon entering the canvas.
        this.left_click = !!(event.buttons & 1); // Left mouse button clicked
        this.right_click = !!(event.buttons & 2); // Right mouse button clicked
        this.middle_click = !!(event.buttons & 4); // Middle mouse button clicked
        // Store the coordinates of the mouse pointer upon entering the canvas.
        this.clicked_coord.x = this.canvas_coord.x;
        this.clicked_coord.y = this.canvas_coord.y;
    }
    /** This method is triggered when the mouse leaves the canvas. */
    mouse_leave() {
        // Left mouse button released
        this.left_click = false;
        // Middle mouse button released
        this.middle_click = false;
        // Right mouse button released
        this.right_click = false;
    }
}


/***/ }),

/***/ "./src/controllers/renderer.controller.ts":
/*!************************************************!*\
  !*** ./src/controllers/renderer.controller.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Renderer)
/* harmony export */ });
/* harmony import */ var _config_theme_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/theme.config */ "./src/config/theme.config.ts");
/* harmony import */ var _environment_Grid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../environment/Grid */ "./src/environment/Grid.ts");
/* harmony import */ var _structures_Queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../structures/Queue */ "./src/structures/Queue.ts");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.ts");




/** This class is used to create a renderer that can be used to render the simulation. */
class Renderer {
    canvas;
    ctx;
    pixel_size;
    to_fill;
    to_clear;
    constructor(canvas, ctx, pixel_size) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.pixel_size = pixel_size;
        this.to_fill = new _structures_Queue__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.to_clear = new _structures_Queue__WEBPACK_IMPORTED_MODULE_2__["default"]();
    }
    /**
     * Draws a rectangle on the canvas.
     * @param cell - The cell to render.
     * @param x - The x-coordinate to start drawing from.
     * @param y - The y-coordinate to start drawing from.
     * @param width - The width the component to draw.
     * @param height - The height of the component to draw.
     * @param colour - The colour of the component to draw.
     */
    draw_rect(cell, x, y, width, height, colour) {
        // Set the fill style to the specified colour.
        this.ctx.fillStyle = colour;
        // Fill a rectangle on the canvas representing the cell.
        this.ctx.fillRect(cell.coordinate.x * 15 + x, cell.coordinate.y * 15 + y, width, height);
    }
    /**
     * Renders an organism with rotation degrees specified.
     * @param cell - The cell to render.
     * @param degrees_to_rotate - The rotation degrees of the organism.
     */
    render_organism_cell(cell, degrees_to_rotate) {
        const cell_x = cell.coordinate.x * this.pixel_size;
        const cell_y = cell.coordinate.y * this.pixel_size;
        this.ctx.save();
        // Translate to the center of the cell.
        this.ctx.translate(cell_x + this.pixel_size / 2, cell_y + this.pixel_size / 2);
        // Rotate the entire cell by rotationDegrees.
        this.ctx.rotate((degrees_to_rotate * Math.PI) / 180);
        // Draw a rectangle centered at (0, 0) to represent the organism.
        this.ctx.fillRect(-this.pixel_size / 2, -this.pixel_size / 2, this.pixel_size, this.pixel_size); // Draw a rectangle centered at (0, 0)
        // Colours used for drawing shapes.
        const colour = cell.owner.genome.colour;
        const transparent = "#282a36";
        const black = "#000";
        // Drawing various shapes to represent the organism.
        this.draw_sub_shape(0, 0, 15, 15, black);
        this.draw_sub_shape(0, 0, 3, 3, transparent);
        this.draw_sub_shape(6, 0, 3, 2, transparent);
        this.draw_sub_shape(12, 0, 3, 3, transparent);
        this.draw_sub_shape(2, 2, 2, 2, transparent);
        this.draw_sub_shape(11, 2, 2, 2, transparent);
        this.draw_sub_shape(4, 1, 1, 1, colour);
        this.draw_sub_shape(10, 1, 1, 1, colour);
        this.draw_sub_shape(5, 2, 1, 1, colour);
        this.draw_sub_shape(9, 2, 1, 1, colour);
        this.draw_sub_shape(5, 3, 5, 1, colour);
        this.draw_sub_shape(4, 4, 7, 1, colour);
        this.draw_sub_shape(3, 5, 9, 1, colour);
        this.draw_sub_shape(2, 6, 3, 5, colour);
        this.draw_sub_shape(10, 6, 3, 5, colour);
        this.draw_sub_shape(6, 6, 3, 5, colour);
        this.draw_sub_shape(2, 9, 11, 2, colour);
        this.draw_sub_shape(4, 11, 2, 2, colour);
        this.draw_sub_shape(9, 11, 2, 2, colour);
        this.draw_sub_shape(7, 12, 1, 1, transparent);
        this.draw_sub_shape(3, 13, 1, 1, colour);
        this.draw_sub_shape(11, 13, 1, 1, colour);
        this.draw_sub_shape(6, 13, 3, 1, transparent);
        this.draw_sub_shape(4, 14, 7, 1, transparent);
        this.draw_sub_shape(0, 7, 1, 4, transparent);
        this.draw_sub_shape(0, 11, 2, 4, transparent);
        this.draw_sub_shape(14, 7, 1, 4, transparent);
        this.draw_sub_shape(13, 11, 2, 4, transparent);
        this.draw_sub_shape(1, 4, 1, 3, colour);
        this.draw_sub_shape(13, 4, 1, 3, colour);
        this.ctx.restore();
    }
    /**
     * Draws a sub-shape within a grid cell.
     * @param x - The x-coordinate of the sub-shape.
     * @param y - The y-coordinate of the sub-shape.
     * @param width - The width of the sub-shape.
     * @param height - The height of the sub-shape.
     * @param colour - The colour of the sub-shape.
     */
    draw_sub_shape(x, y, width, height, colour) {
        // Set the fill colour for the sub-shape
        this.ctx.fillStyle = colour;
        // Draw the sub-shape starting from the top-left corner
        this.ctx.fillRect(x - this.pixel_size / 2, y - this.pixel_size / 2, width, height);
    }
    /**
     * Renders a food cell.
     * @param cell - The cell to render.
     */
    render_food_cell(cell) {
        const transparent = "#282a36";
        const food = "#44475a";
        // Render the food cell with specific shapes and colours at various positions within the cell
        this.draw_rect(cell, 0, 0, 15, 15, transparent);
        this.draw_rect(cell, 6, 3, 3, 9, food);
        this.draw_rect(cell, 4, 4, 2, 7, food);
        this.draw_rect(cell, 9, 4, 2, 7, food);
        this.draw_rect(cell, 3, 6, 1, 3, food);
        this.draw_rect(cell, 11, 6, 1, 3, food);
    }
    /**
     * Renders a cell.
     * @param cell - The cell to render.
     */
    render_cell(cell) {
        // Check if the cell is highlighted and, if so, call the 'highlight_cell' method and return
        if (cell.is_highlighted)
            this.draw_cell(cell, _config_theme_config__WEBPACK_IMPORTED_MODULE_0__["default"].HIGHLIGHTED);
        // Check if the cell is selected and, if so, call the 'select_cell' method and return
        else if (cell.is_selected)
            this.draw_cell(cell, _config_theme_config__WEBPACK_IMPORTED_MODULE_0__["default"].SELECTED);
        // Check if the cell contains an organism
        else if (cell.state == _environment_Grid__WEBPACK_IMPORTED_MODULE_1__.CellStates.ORGANISM) {
            // Check if the organism's owner is alive before rendering the organism cell
            if (cell.owner && cell.owner.alive) {
                // Calculate the rotation angle based on the owner's direction
                let rotation = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.to_angle)(cell.owner.direction);
                // Adjust rotation to handle specific angles (needs improvement)
                if (rotation == 315 || rotation == 0 || rotation == 45)
                    rotation = 0;
                else if (rotation == 90)
                    rotation = 90;
                else if (rotation == 135 || rotation == 180 || rotation == 225)
                    rotation = 180;
                else if (rotation == 270)
                    rotation == 270;
                // Render the organism cell with the adjusted rotation
                this.render_organism_cell(cell, rotation);
            }
        }
        else if (cell.state == _environment_Grid__WEBPACK_IMPORTED_MODULE_1__.CellStates.EMPTY) {
            // Render an empty cell if the cell state is 'EMPTY'
            this.draw_cell(cell, _config_theme_config__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY);
        }
        else if (cell.state == _environment_Grid__WEBPACK_IMPORTED_MODULE_1__.CellStates.FOOD) {
            // Render a food cell if the cell state is 'FOOD'
            this.render_food_cell(cell);
        }
        else if (cell.state == _environment_Grid__WEBPACK_IMPORTED_MODULE_1__.CellStates.RADIOACTIVE) {
            // Render a radioactive cell if the cell state is 'RADIOACTIVE'
            this.draw_cell(cell, _config_theme_config__WEBPACK_IMPORTED_MODULE_0__["default"].RADIOACTIVE);
        }
        else if (cell.state == _environment_Grid__WEBPACK_IMPORTED_MODULE_1__.CellStates.WALL) {
            // Render a wall cell if the cell state is 'WALL'
            this.draw_cell(cell, _config_theme_config__WEBPACK_IMPORTED_MODULE_0__["default"].WALL);
        }
    }
    /**
     * Draws a cell on the canvas.
     * @param cell - The cell to render.
     * @param colour - The colour to render the cell with.
     */
    draw_cell(cell, colour) {
        // Set the fill style to a yellow colour
        this.ctx.fillStyle = colour;
        // Fill the cell with the specified colour at the cell's coordinates using the pixel size
        this.ctx.fillRect(cell.coordinate.x * this.pixel_size, cell.coordinate.y * this.pixel_size, this.pixel_size, this.pixel_size);
    }
    /** Clears the canvas. */
    clear_canvas() {
        // Set the fill style to a dark colour
        this.ctx.fillStyle = "#282a36";
        // Fill the entire canvas with the specified colour
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    /**
     * Clears a cell on the canvas.
     * @param cell - The cell to clear.
     */
    clear_cell(cell) {
        this.draw_cell(cell, _config_theme_config__WEBPACK_IMPORTED_MODULE_0__["default"].EMPTY);
    }
}


/***/ }),

/***/ "./src/controllers/simulation.controller.ts":
/*!**************************************************!*\
  !*** ./src/controllers/simulation.controller.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Simulation)
/* harmony export */ });
/* harmony import */ var _components_Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Settings */ "./src/components/Settings.ts");
/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../environment */ "./src/environment/index.ts");
/* harmony import */ var _components_DOMElements__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/DOMElements */ "./src/components/DOMElements.ts");



/** This class is used to create a simulation that can be used to simulate the environment. */
class Simulation {
    // Define properties for update loop
    current_update_fps;
    last_update_time;
    last_update_dt;
    // Define properties for render loop
    current_render_fps;
    last_render_time;
    last_render_dt;
    // Define other properties
    is_running;
    rendering_enabled;
    has_started;
    // Define configuration and loop variables
    config;
    update_loop;
    render_loop;
    // Define environment and population variables
    environment;
    // Constructor for the Simulation class
    constructor(config) {
        // Set the configuration
        this.config = config;
        // Initialize update loop properties
        this.current_update_fps = 0;
        this.last_update_time = window.performance.now();
        this.last_update_dt = 0;
        // Initialize render loop properties
        this.current_render_fps = 0;
        this.last_render_time = window.performance.now();
        this.last_render_dt = 0;
        // Initialize other properties
        this.is_running = false;
        this.rendering_enabled = true;
        this.has_started = false;
        // Initialize loop variables
        this.update_loop = undefined;
        this.render_loop = undefined;
        // Initialize population and environment
        this.environment = new _environment__WEBPACK_IMPORTED_MODULE_1__.Environment("canvas", this.config);
        // Setup render loop
        this.setup_render_loop();
        // Render target update and render FPS elements
        (0,_components_Settings__WEBPACK_IMPORTED_MODULE_0__.render_fps_element)(_components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.target_update_fps, this.config.TARGET_UPDATE_FPS);
        (0,_components_Settings__WEBPACK_IMPORTED_MODULE_0__.render_fps_element)(_components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.target_render_fps, this.config.TARGET_RENDER_FPS);
    }
    /**
     * Runs prechecks to validate the configuration before execution.
     * @returns A boolean value indicating whether the prechecks have passed.
     */
    run_prechecks() {
        // Check if the population size exceeds the maximum allowed grid size
        if (this.config.POPULATION > this.config.GRID_SIZE ** 2) {
            const error = "Population size cannot be greater than Grid size squared.";
            alert(error);
            return false;
        }
        // Check if no goal has been set.
        if (!this.config.GOAL_COORD && !this.config.GOAL_FOOD) {
            alert("No goal has been set.");
            return false;
        }
        // Check if coordinate goal and food goal are both enabled.
        if (this.config.GOAL_COORD && this.config.GOAL_FOOD) {
            alert("Cannot have both coordinate and food goal enabled.");
            return false;
        }
        // Check if coordinate goal is enabled and no goal coordinates have been set.
        if (this.config.GOAL_COORD && this.environment.goal_coordinates.length == 0) {
            alert("No goal coordinates have been set.");
            return false;
        }
        // Checks have passed, so return true.
        return true;
    }
    /**
     * Initializes the simulation.
     */
    init() {
        // Initialize the environment
        this.environment.init();
        // Set the started_simulation flag to true.
        this.has_started = true;
    }
    /** Sets up the render loop. */
    setup_render_loop() {
        // Check if rendering is enabled
        if (this.rendering_enabled) {
            // Setup the render loop
            this.render_loop = setInterval(() => {
                this.render_simulation();
            }, 1000 / this.config.TARGET_RENDER_FPS);
        }
    }
    /**
     * Starts the simulation engine.
     * @returns A boolean value indicating whether the simulation engine has started.
     */
    start_engine() {
        // Run prechecks to validate the configuration before execution.
        if (!this.run_prechecks())
            return false;
        // Check if simulation has been started before.
        if (!this.has_started)
            this.init();
        // Check if render loop is running and stop it if it is.
        if (this.render_loop != undefined) {
            clearInterval(this.render_loop);
            this.render_loop = undefined;
        }
        // Check if the simulation is not running.
        if (!this.is_running) {
            // Set the is_running flag to true.
            this.is_running = true;
            // Start the update loop
            this.update_loop = setInterval(() => {
                // Update the simulation
                this.update_simulation();
                // Update HTML elements with simulation data
                _components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.generation.innerHTML = this.environment.generation.toString();
                _components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.tick_count.innerHTML = this.environment.ticks.toString();
                _components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.organisms_alive.innerHTML = this.environment.alive.toString();
                // Check if the current update FPS is greater than or equal to the target update FPS.
                if (this.current_update_fps >= this.config.TARGET_RENDER_FPS && this.render_loop != undefined) {
                    // Stop the render loop
                    clearInterval(this.render_loop);
                    this.render_loop = undefined;
                }
                else {
                    // Check if the current render FPS is less than the target render FPS and the render loop is not running.
                    if (this.current_render_fps < this.config.TARGET_RENDER_FPS && this.render_loop == undefined) {
                        // Start the render loop.
                        this.setup_render_loop();
                    }
                }
            }, 1000 / this.config.TARGET_UPDATE_FPS);
        }
        return true;
    }
    /** Stops the simulation engine. */
    stop_engine() {
        if (this.is_running) {
            this.is_running = false;
            clearInterval(this.update_loop);
            clearInterval(this.render_loop);
            this.setup_render_loop();
        }
    }
    /** Restarts the simulation engine. */
    restart_engine() {
        this.stop_engine();
        this.start_engine();
    }
    /** Updates the simulation. */
    update_simulation() {
        // Calculate the time since the last update by subtracting the current time from the last update time.
        this.last_update_dt = window.performance.now() - this.last_update_time;
        // Set the last update time to the current time.
        this.last_update_time = window.performance.now();
        // Calculate the current update FPS by dividing 1000 by the last update delta time.
        this.current_update_fps = 1000 / this.last_update_dt;
        // Update the environment.
        this.environment.update();
        // Check if the render loop is not running and rendering is enabled.
        if (this.render_loop === undefined && this.rendering_enabled) {
            // Render the simulation
            this.render_simulation();
        }
        else {
            // Update current FPS
            (0,_components_Settings__WEBPACK_IMPORTED_MODULE_0__.render_fps_element)(_components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.current_update_fps, this.current_update_fps);
        }
    }
    /** Renders the simulation. */
    render_simulation() {
        // Check if the render loop is running.
        if (this.render_loop) {
            // Calculate the time since the last render by subtracting the current time from the last render time.
            this.last_render_dt = window.performance.now() - this.last_render_time;
            // Set the last render time to the current time.
            this.last_render_time = window.performance.now();
        }
        else {
            // Set the last render time to match the last update time.
            this.last_render_dt = this.last_update_dt;
        }
        // Calculate the current render FPS by dividing 1000 by the last render delta time.
        this.current_render_fps = 1000 / this.last_render_dt;
        // Render the environment.
        this.environment.render();
        // Update FPS elements.
        (0,_components_Settings__WEBPACK_IMPORTED_MODULE_0__.render_fps_element)(_components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.current_update_fps, this.current_update_fps);
        (0,_components_Settings__WEBPACK_IMPORTED_MODULE_0__.render_fps_element)(_components_DOMElements__WEBPACK_IMPORTED_MODULE_2__.DOMElements.current_render_fps, this.current_render_fps);
    }
}


/***/ }),

/***/ "./src/environment/Grid.ts":
/*!*********************************!*\
  !*** ./src/environment/Grid.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AllCellStates: () => (/* binding */ AllCellStates),
/* harmony export */   CellStates: () => (/* binding */ CellStates),
/* harmony export */   Grid: () => (/* binding */ Grid),
/* harmony export */   GridCell: () => (/* binding */ GridCell)
/* harmony export */ });
/* harmony import */ var _utils_get_random_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/get_random_vector */ "./src/utils/get_random_vector.ts");

// Various Cell States that a GridCell can take.
const CellStates = {
    EMPTY: 0,
    ORGANISM: 1,
    WALL: 2,
    FOOD: 3,
    RADIOACTIVE: 4,
};
// Create an array of the keys of the CellStates.
const AllCellStates = Object.keys(CellStates);
/** This class is used to create a grid cell that can be used to represent a cell in the grid. */
class GridCell {
    coordinate;
    _owner;
    _state;
    is_selected;
    is_highlighted;
    energy;
    /**
     * Builds a new grid cell.
     * @param x - The x-coordinate of the cell.
     * @param y - The y-coordinate of the cell.
     * @param state - The state of the cell.
     */
    constructor(x, y, state = CellStates.EMPTY) {
        this.coordinate = { x, y };
        this._owner = null;
        this._state = state;
        this.is_selected = false;
        this.is_highlighted = false;
        this.energy = 0;
    }
    /** This method is used to clear the grid cell. */
    clear() {
        // Reset the owner of the cell to null
        this._owner = null;
        // Set the state of the cell to EMPTY
        this._state = CellStates.EMPTY;
    }
    /**
     * This method is used to get the owner of the grid cell.
     * @returns The owner of the grid cell.
     */
    get owner() {
        // Retrieve and return the owner of the GridCell
        return this._owner;
    }
    /**
     * This method is used to set the owner of the grid cell.
     * @param owner - The owner of the grid cell.
     */
    set owner(owner) {
        // Check if an owner is provided
        if (owner) {
            // If an owner is provided, set the owner of the GridCell
            this._owner = owner;
            // Update the state of the GridCell to indicate it's occupied by an organism
            this._state = CellStates.ORGANISM;
        }
        else {
            // If no owner is provided, reset the owner to null
            this._owner = null;
        }
    }
    /**
     * This method is used to get the state of the grid cell.
     * @returns The state of the grid cell.
     */
    get state() {
        // Retrieve and return the state of the GridCell
        return this._state;
    }
    /**
     * This method is used to set the state of the grid cell.
     * @param state - The state of the grid cell.
     */
    set state(state) {
        // Set the state of the GridCell to the provided state value
        this._state = state;
    }
}
/** This class is used to create a grid that can be used to represent the environment. */
class Grid {
    _data;
    grid_size;
    renderer;
    occupied;
    /**
     * Builds a new grid.
     * @param grid_size - The size of the grid.
     * @param renderer - The renderer to use for rendering the grid.
     */
    constructor(grid_size, renderer) {
        this._data = new Array(grid_size);
        this.renderer = renderer;
        this.grid_size = grid_size;
        this.occupied = 0;
        this.init();
    }
    /** This method is used to initialize the grid. */
    init() {
        // Loop through each row (x-axis) of the grid
        for (let x = 0; x < this.grid_size; x++) {
            // Create a new array to represent a column of grid cells
            const column = new Array(this.grid_size);
            // Loop through each column (y-axis) of the grid
            for (let y = 0; y < this.grid_size; y++) {
                // Create a new GridCell instance with the current x and y coordinates
                const cell = new GridCell(x, y);
                // Assign the cell to the current column in the grid
                column[y] = cell;
            }
            // Assign the column to the grid data at the current x position
            this._data[x] = column;
        }
    }
    /** This method is used to clear the grid. */
    clear_grid() {
        // Reset the grid data to an empty array
        this._data = [];
        // Re-initialize the grid to clear all grid cells
        this.init();
    }
    /**
     * This method is used to check if the specified cell is valid.
     * @param coordinate - The coordinate to check.
     * @returns Whether the specified cell is valid.
     */
    is_valid_cell_at(coordinate) {
        // Check if the specified coordinate is within the grid boundaries
        return coordinate.x >= 0 && coordinate.y >= 0 && coordinate.x < this.grid_size && coordinate.y < this.grid_size;
    }
    /**
     * This method is used to check if the specified cell is empty.
     * @param coordinate - The coordinate to check.
     * @returns Whether the specified cell is empty.
     */
    is_cell_empty(coordinate) {
        // Check if the provided cell coordinate is valid within the grid
        if (this.is_valid_cell_at(coordinate)) {
            // Retrieve the state of the cell at the specified coordinate and check if it's empty
            return this._data[coordinate.x][coordinate.y].state == CellStates.EMPTY;
        }
        else {
            // Throw an error if the provided cell coordinate is not valid
            throw Error(`Not a valid cell. ${coordinate.x} ${coordinate.y}`);
        }
    }
    /**
     * This method is used to get the cell at the specified coordinate.
     * @param coordinate - The coordinate to check.
     * @returns The cell at the specified coordinate.
     */
    get_cell_at(coordinate) {
        // Check if the provided cell coordinate is within the grid
        if (this.is_valid_cell_at(coordinate)) {
            // Retrieve and return the GridCell at the specified coordinate
            return this._data[coordinate.x][coordinate.y];
        }
        else {
            // Throw an error if the provided cell coordinate is not valid
            throw Error(`Not a valid cell. ${coordinate.x} ${coordinate.y}`);
        }
    }
    /**
     * Sets the owner of a cell.
     * @param coordinate - The coordinate of the cell to set the owner of.
     * @param owner - The owner to set.
     */
    set_cell_owner(coordinate, owner) {
        // Check if the provided cell coordinate is within the grid
        if (this.is_valid_cell_at(coordinate)) {
            // Retrieve the cell at the specified coordinate
            const cell = this.get_cell_at(coordinate);
            // Set the owner of the cell to the specified organism
            cell.owner = owner;
            // Add the cell to the 'to_fill' set in the renderer
            this.renderer.to_fill.enqueue(cell);
            // Increment the count of occupied cells
            this.occupied += 1;
        }
    }
    /**
     * Sets the state of a cell.
     * @param coordinate The coordinate of the cell to set the state of.
     * @param state The state to set.
     */
    set_cell_state(coordinate, state) {
        // Check if the provided cell coordinate is within the grid
        if (this.is_valid_cell_at(coordinate)) {
            // Retrieve the cell at the specified coordinate
            const cell = this.get_cell_at(coordinate);
            // Set the state of the cell to the provided state
            cell.state = state;
            // If the cell state is 'FOOD', set its energy to 1 and clear its owner
            if (cell.state == CellStates.FOOD) {
                cell.energy = 1;
            }
            // Clear the owner of the cell
            cell.owner = null;
            // Add the cell to the 'to_fill' set in the renderer
            this.renderer.to_fill.enqueue(cell);
            // Increment the count of occupied cells
            this.occupied += 1;
        }
    }
    /**
     * Sets the selected state of a cell.
     * @param coordinate - The coordinate of the cell to set the selected state of.
     * @param selected - The selected state to set.
     */
    set_cell_selected(coordinate, selected) {
        // Check if the provided cell coordinate is within the grid
        if (this.is_valid_cell_at(coordinate)) {
            // Retrieve the cell at the specified coordinate
            const cell = this.get_cell_at(coordinate);
            // Set the 'is_selected' property of the cell to the provided value
            cell.is_selected = selected;
            // Add the cell to the 'to_fill' set in the renderer for rendering purposes
            this.renderer.to_fill.enqueue(cell);
        }
    }
    /**
     * Sets the highlighted state of a cell.
     * @param coordinate - The coordinate of the cell to set the highlighted state of.
     * @param highlighted - The highlighted state to set.
     */
    set_cell_highlighted(coordinate, highlighted) {
        // Check if the provided cell coordinate is within the grid
        if (this.is_valid_cell_at(coordinate)) {
            // Retrieve the cell at the specified coordinate
            const cell = this.get_cell_at(coordinate);
            // Set the 'is_highlighted' property of the cell to the provided value
            cell.is_highlighted = highlighted;
            // Add the cell to the 'to_fill' set in the renderer for rendering purposes
            this.renderer.to_fill.enqueue(cell);
        }
    }
    /**
     * Clears the state of a cell.
     * @param coordinate - The coordinate of the cell to clear the state of.
     */
    clear_cell_state(coordinate) {
        // Check if the provided cell coordinate is within the grid
        if (this.is_valid_cell_at(coordinate)) {
            // Retrieve the cell at the specified coordinate
            const cell = this.get_cell_at(coordinate);
            // Remove owner of the cell
            cell.owner = null;
            // Check if the cell's energy is less than or equal to zero
            if (cell.energy <= 0) {
                // Set cell state to EMPTY and add it to the 'to_clear' set in the renderer for clearing
                cell.state = CellStates.EMPTY;
                this.renderer.to_clear.enqueue(cell);
            }
            else {
                // Set cell state to FOOD and add it to both 'to_clear' and 'to_fill' sets in the renderer
                cell.state = CellStates.FOOD;
                this.renderer.to_clear.enqueue(cell);
                this.renderer.to_fill.enqueue(cell);
            }
            // Reduce the count of occupied cells
            this.occupied -= 1;
        }
    }
    /**
     * This method is used to fetch a random empty cell from the grid.
     * @returns A random empty cell from the grid.
     */
    fetch_empty_cell() {
        // Check if the grid is fully occupied, throw an error if no empty cells are available
        if (this.occupied === this.grid_size ** 2) {
            alert("No empty cells left!");
            throw Error("No empty cells left!");
        }
        // Generate a random coordinate within the grid
        let random_coord = (0,_utils_get_random_vector__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 0, this.grid_size - 1, this.grid_size - 1);
        // Loop until an empty cell is found using the generated random coordinates
        while (!this.is_cell_empty(random_coord)) {
            random_coord = (0,_utils_get_random_vector__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 0, this.grid_size - 1, this.grid_size - 1);
        }
        return random_coord; // Return the coordinates of the found empty cell
    }
}


/***/ }),

/***/ "./src/environment/index.ts":
/*!**********************************!*\
  !*** ./src/environment/index.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Environment: () => (/* binding */ Environment)
/* harmony export */ });
/* harmony import */ var _algorithms_GeneticAlgorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../algorithms/GeneticAlgorithm */ "./src/algorithms/GeneticAlgorithm.ts");
/* harmony import */ var _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/DOMElements */ "./src/components/DOMElements.ts");
/* harmony import */ var _controllers_canvas_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controllers/canvas.controller */ "./src/controllers/canvas.controller.ts");
/* harmony import */ var _controllers_chart_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/chart.controller */ "./src/controllers/chart.controller.ts");
/* harmony import */ var _models_Gene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../models/Gene */ "./src/models/Gene.ts");
/* harmony import */ var _models_Organism__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../models/Organism */ "./src/models/Organism.ts");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.ts");
/* harmony import */ var _utils_get_random_vector__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/get_random_vector */ "./src/utils/get_random_vector.ts");
/* harmony import */ var _Grid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Grid */ "./src/environment/Grid.ts");









// Environment class.
class Environment extends _controllers_canvas_controller__WEBPACK_IMPORTED_MODULE_2__["default"] {
    population;
    ticks;
    generation;
    overall_fitness;
    best_fitness;
    species_count;
    alive;
    best_fitness_data_points;
    overall_fitness_data_points;
    number_of_species_data_points;
    species_data_points;
    species;
    chart;
    // Builds a new Environment instance.
    constructor(canvas_id, config) {
        super(canvas_id, config);
        this.population = [];
        this.ticks = 0;
        this.generation = 0;
        this.best_fitness = 1;
        this.overall_fitness = 1;
        this.species_count = Infinity;
        this.alive = 0;
        this.best_fitness_data_points = [];
        this.overall_fitness_data_points = [];
        this.number_of_species_data_points = [];
        this.species = new Set();
        this.chart = new _controllers_chart_controller__WEBPACK_IMPORTED_MODULE_3__["default"]("chart");
        this.chart.add_config("Best Fitness", "Generation", "Best Fitness", this.best_fitness_data_points, 1);
        this.chart.add_config("Overall Fitness", "Generation", "Overall Fitness", this.overall_fitness_data_points, 1);
        this.chart.add_config("Number of Species", "Generation", "Number of Species", this.number_of_species_data_points);
        this.chart.switch_chart(0);
    }
    /**
     * Adds an Organism to the environment and configures knowledge.
     * @param gene_data - The gene data to be used to create the organism.
     * @param coordinate - The coordinate to place the organism at.
     * @returns Whether the addition was successful.
     */
    add_organism(gene_data, coordinate) {
        // Check if the population size has exceeded the configured limit.
        if (this.population.length > this.config.POPULATION) {
            // Display an alert if the population size limit is exceeded.
            alert("Population size cannot be greater than Grid size squared.");
            // Return false as the addition is not permitted.
            return false;
        }
        // If no coordinate is provided, fetch an empty cell from the grid.
        if (!coordinate)
            coordinate = this.grid.fetch_empty_cell();
        // Create a new Organism instance with the provided gene data, grid, configuration, and population index.
        const organism = new _models_Organism__WEBPACK_IMPORTED_MODULE_5__["default"](coordinate, gene_data, this.grid, this.config);
        // Set the cell owner as the newly created organism.
        this.grid.set_cell_owner(coordinate, organism);
        // Add the new organism to the population array.
        this.population.push(organism);
        // Return true to indicate successful addition of the organism.
        return true;
    }
    /** Drops food randomly within a defined area in the grid. */
    drop_food() {
        // Loop to drop food 1000 times.
        for (let i = 0; i < 1000; i++) {
            // Calculate the center of the grid.
            const center = Math.floor(this.config.GRID_SIZE / 2);
            // Set a cell state to FOOD at a randomly generated coordinate within a specified range around the center.
            this.grid.set_cell_state((0,_utils_get_random_vector__WEBPACK_IMPORTED_MODULE_7__["default"])(center - 10, center - 10, center + 10, center + 10), _Grid__WEBPACK_IMPORTED_MODULE_8__.CellStates.FOOD);
        }
    }
    /** Updates the simulation chart. */
    update_charts() {
        // Adds data points to the chart.
        this.best_fitness_data_points.push({
            x: this.generation,
            y: this.best_fitness,
        });
        this.overall_fitness_data_points.push({
            x: this.generation,
            y: this.overall_fitness,
        });
        this.number_of_species_data_points.push({
            x: this.generation,
            y: this.species_count,
        });
        // Updates and renders the chart.
        this.chart.chart.render();
    }
    /** Initializes the environment. */
    init() {
        // Populate the environment until the desired population size is reached.
        while (this.population.length != this.config.POPULATION) {
            const data = [];
            // Generate genes for each organism.
            for (let i = 0; i < this.config.NUMBER_OF_GENES; i++) {
                data.push(new _models_Gene__WEBPACK_IMPORTED_MODULE_4__["default"](this.config.NUMBER_OF_HIDDEN_NEURONS));
            }
            // Add an organism with generated genes to the environment.
            this.add_organism(data);
        }
        // If the configuration specifies to drop food, distribute food within the environment.
        if (this.config.GOAL_FOOD) {
            this.drop_food();
        }
    }
    /** Resets the environment for the next generation. */
    next_generation() {
        // Calculate fitness of all individuals based on the configured goals.
        if (this.config.GOAL_COORD) {
            this.population = (0,_algorithms_GeneticAlgorithm__WEBPACK_IMPORTED_MODULE_0__.calculate_and_sort_fitness)(this.population, "coord", {
                goal_coordinates: this.goal_coordinates,
                max_distances_to_goal: this.max_distances_to_goal,
            });
        }
        else if (this.config.GOAL_FOOD) {
            this.population = (0,_algorithms_GeneticAlgorithm__WEBPACK_IMPORTED_MODULE_0__.calculate_and_sort_fitness)(this.population, "food");
        }
        let best_found = false;
        let fitness_sum = 0;
        // Find the best individual and calculate the fitness sum, which is to be used to calculate the overall fitness.
        for (const organism of this.population) {
            // Add the organism's colour to the species set.
            if (organism.genome.colour)
                this.species.add(organism.genome.colour);
            if (organism.alive)
                fitness_sum += organism.fitness;
            if (!best_found && organism.alive) {
                this.best_fitness = organism.fitness;
                best_found = true;
            }
            this.grid.clear_cell_state(organism.coordinate);
        }
        // Calculate the overall fitness of the population.
        this.overall_fitness = this.alive > 0 ? fitness_sum / this.alive : 0;
        // Select and crossover individuals based on the configured genetic algorithm.
        this.population = (0,_algorithms_GeneticAlgorithm__WEBPACK_IMPORTED_MODULE_0__.select_and_crossover)(this.population, this.config);
        // Reset tick count and increment generation count.
        this.species_count = this.species.size;
        this.update_charts();
        this.ticks = 0;
        this.generation++;
        // Update HTML elements with simulation data.
        _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.best_fitness.innerHTML = this.best_fitness.toPrecision(3).toString();
        _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.overall_fitness.innerHTML = this.overall_fitness.toPrecision(3).toString();
        _components_DOMElements__WEBPACK_IMPORTED_MODULE_1__.DOMElements.number_of_species.innerHTML = this.species_count.toString();
        this.species = new Set();
        // If the goal is to distribute food, do so within the environment.
        if (this.config.GOAL_FOOD) {
            this.drop_food();
        }
    }
    /** Updates the environment based on the configured goals and conditions. */
    update() {
        if (this.ticks > this.config.TICKS_PER_GENERATION) {
            this.next_generation();
        }
        else {
            this.alive = 0;
            // Iterate through the list of organisms and perform actions based on the environment's rules.
            for (const organism of this.population) {
                if (organism.alive) {
                    this.alive++;
                    const offset = organism.action();
                    const new_coordinate = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_6__.add_vector)(organism.coordinate, offset);
                    if (this.grid.is_valid_cell_at(new_coordinate) && this.grid.is_cell_empty(new_coordinate)) {
                        // Update coordinates if the new cell is empty.
                        organism.direction = offset;
                        organism.coordinate = new_coordinate;
                    }
                    else if (this.grid.is_valid_cell_at(new_coordinate) && this.grid.get_cell_at(new_coordinate).state == _Grid__WEBPACK_IMPORTED_MODULE_8__.CellStates.RADIOACTIVE) {
                        // Clear cell if it's radioactive, marking organism as dead.
                        this.grid.clear_cell_state(organism.coordinate);
                        organism.alive = false;
                        this.alive--;
                    }
                    else if (this.grid.is_valid_cell_at(new_coordinate) && this.grid.get_cell_at(new_coordinate).state == _Grid__WEBPACK_IMPORTED_MODULE_8__.CellStates.FOOD) {
                        // Clear cell, consume food, and update coordinates if it's food.
                        this.grid.clear_cell_state(organism.coordinate);
                        if (organism.energy == 0) {
                            this.grid.get_cell_at(new_coordinate).energy -= 1;
                            organism.energy = 1;
                        }
                        organism.direction = offset;
                        organism.coordinate = new_coordinate;
                    }
                }
            }
        }
        this.ticks++;
    }
    /** Renders the environment on the canvas. */
    render() {
        // Clear cells that are not selected and fill others based on to_clear and to_fill lists.
        let cell = this.renderer.to_clear.dequeue();
        while (cell != null) {
            if (!cell.is_selected)
                this.renderer.clear_cell(cell);
            else
                this.renderer.render_cell(cell);
            cell = this.renderer.to_clear.dequeue();
        }
        cell = this.renderer.to_fill.dequeue();
        // Fill cells based on the to_fill list.
        while (cell != null) {
            this.renderer.render_cell(cell);
            cell = this.renderer.to_fill.dequeue();
        }
    }
}


/***/ }),

/***/ "./src/models/Brain.ts":
/*!*****************************!*\
  !*** ./src/models/Brain.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HiddenNeuron: () => (/* binding */ HiddenNeuron),
/* harmony export */   "default": () => (/* binding */ Brain)
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constants_Directions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/Directions */ "./src/constants/Directions.ts");
/* harmony import */ var _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/InputNeurons */ "./src/constants/InputNeurons.ts");
/* harmony import */ var _environment_Grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../environment/Grid */ "./src/environment/Grid.ts");
/* harmony import */ var _utils_weight_as_float__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/weight_as_float */ "./src/utils/weight_as_float.ts");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.ts");
/* harmony import */ var _Neurons__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Neurons */ "./src/models/Neurons.ts");







/** This class is used to create a hidden neuron in a neural network. */
class HiddenNeuron {
    // Unique identifier for the hidden neuron.
    identifer;
    // Number of incoming connections that are from either sensors or other neurons.
    inputs;
    // Number of outcoming connections from the neuron.
    outputs;
    // Number of input connections that go back into the neuron.
    self_inputs;
}
/** This class is used to create a brain for an organism. */
class Brain {
    coordinate;
    grid;
    genome_data;
    // Used temporarily to store the neural network's inputs, outputs, and hidden neurons.
    inputs;
    outputs;
    hidden;
    // Complete list of hidden neurons.
    hidden_neurons;
    // All neural network connections.
    connections;
    // Number of sensors, neurons and actions.
    num_input_neurons;
    num_hidden_neurons;
    num_output_neurons;
    constructor(coordinate, grid, genome_data, num_input_neurons, num_hidden_neurons, num_output_neurons) {
        // References to the organism's coordinate and the grid.
        this.coordinate = coordinate;
        this.grid = grid;
        this.genome_data = genome_data;
        this.inputs = {};
        this.outputs = {};
        this.hidden = {};
        this.hidden_neurons = [];
        this.connections = [];
        this.num_input_neurons = num_input_neurons;
        this.num_hidden_neurons = num_hidden_neurons;
        this.num_output_neurons = num_output_neurons;
        this.wire_brain();
    }
    /** This method is used to convert an organism's genome into a neural network brain. */
    wire_brain() {
        // List to store neural network connections.
        const connections = this.obtain_connections();
        // Map of the hidden neurons and their number of inputs and outputs.
        const hidden_neuron_map = this.create_hidden_neuron_map(connections);
        // Remove connections to neurons with no outputs or neurons that feed themselves.
        this.prune_connections(connections, hidden_neuron_map);
        // Create a renumbered connection array based on the node map.
        this.create_connections(connections, hidden_neuron_map);
        this.create_hidden_neuron_array(hidden_neuron_map);
    }
    /**
     * Allows the organism to look in a specific direction and return the state of the cell.
     * @param direction - The direction to look in.
     * @returns The normalized state of the cell.
     */
    observation_sensor(direction) {
        let current_vector = { x: this.coordinate.x, y: this.coordinate.y };
        let vector;
        // Determine the vector based on the direction parameter.
        if (direction == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_NORTH)
            vector = _constants_Directions__WEBPACK_IMPORTED_MODULE_1__["default"].NORTH;
        else if (direction == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_EAST)
            vector = _constants_Directions__WEBPACK_IMPORTED_MODULE_1__["default"].EAST;
        else if (direction == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_SOUTH)
            vector = _constants_Directions__WEBPACK_IMPORTED_MODULE_1__["default"].SOUTH;
        else if (direction == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_WEST)
            vector = _constants_Directions__WEBPACK_IMPORTED_MODULE_1__["default"].WEST;
        else {
            throw Error("Direction not correct.");
        }
        // Update the current vector based on the determined direction.
        current_vector = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.add_vector)(current_vector, vector);
        // Check if the updated vector represents a valid cell in the grid.
        if (this.grid.is_valid_cell_at(current_vector)) {
            // Retrieve the cell at the updated vector.
            const cell = this.grid.get_cell_at(current_vector);
            // Return the normalized state of the cell.
            return cell.state / _environment_Grid__WEBPACK_IMPORTED_MODULE_3__.AllCellStates.length;
        }
        // If no valid observation is found, return 0.
        return 0.0;
    }
    /**
     * Allows the organism to obtain information about its current coordinates.
     * @param sensor - The sensor to use.
     * @returns The normalized value of the sensor.
     */
    coordinate_sensor(sensor) {
        if (sensor == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.X_COORDINATE && this.grid.grid_size) {
            // Calculate and return the normalized x-coordinate.
            return this.coordinate.x / this.grid.grid_size;
        }
        else if (sensor == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.Y_COORDINATE && this.grid.grid_size) {
            // Calculate and return the normalized y-coordinate.
            return this.coordinate.y / this.grid.grid_size;
        }
        else if (sensor == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_NORTH) {
            // Calculate and return the normalized distance to the northern boundary.
            return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.euclidean_distance)(this.coordinate, { x: this.coordinate.x, y: 0 }) / this.grid.grid_size;
        }
        else if (sensor == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_WEST) {
            // Calculate and return the normalized distance to the western boundary.
            return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.euclidean_distance)(this.coordinate, { x: 0, y: this.coordinate.y }) / this.grid.grid_size;
        }
        else if (sensor == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_EAST) {
            // Calculate and return the normalized distance to the eastern boundary.
            return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.euclidean_distance)(this.coordinate, { x: this.grid.grid_size, y: this.coordinate.y }) / this.grid.grid_size;
        }
        else if (sensor == _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_SOUTH) {
            // Calculate and return the normalized distance to the southern boundary.
            return (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.euclidean_distance)(this.coordinate, { x: this.coordinate.x, y: this.grid.grid_size }) / this.grid.grid_size;
        }
        else {
            // Return 0.0 if the sensor doesn't match any predefined sensor type.
            return 0.0;
        }
    }
    /**
     * Allows the organism to obtain information from a specific sensor.
     * @param sensor_id - The sensor identifier.
     * @returns - The value of the sensor.
     */
    get_sensor(sensor_id) {
        if ([
            _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.X_COORDINATE,
            _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.Y_COORDINATE,
            _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_NORTH,
            _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_EAST,
            _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_SOUTH,
            _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.BOUNDARY_WEST,
        ].includes(sensor_id)) {
            // Call coordinate_sensor method for coordinate-related sensors and return the obtained value.
            return this.coordinate_sensor(sensor_id);
        }
        else if ([_constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_NORTH, _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_EAST, _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_SOUTH, _constants_InputNeurons__WEBPACK_IMPORTED_MODULE_2__.InputNeurons.LOOK_WEST].includes(sensor_id)) {
            // Call observation_sensor method for direction observation sensors and return the obtained value.
            return this.observation_sensor(sensor_id);
        }
        // Return 0.0 for sensors that don't match any predefined type.
        return 0.0;
    }
    /**
     * Performs a feed-forward computation in the neural network.
     * @returns An array of output levels for all action neurons.
     */
    feed_forward() {
        // This array stores the output levels for all of the action neurons.
        const action_levels = new Array(this.num_output_neurons).fill(0.0);
        // The weighted inputs to each neuron are accumulated in neuron_accumulators.
        const neuron_accumulators = new Array(this.hidden_neurons.length).fill(0.0);
        let neuron_outputs_computed = false;
        for (const connection of this.connections) {
            if (connection.sink_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.OUTPUT && !neuron_outputs_computed) {
                // Compute the output of neurons in the range (-1.0..1.0) using the hyperbolic tangent function.
                for (let neuron_index = 0; neuron_index < this.hidden_neurons.length; neuron_index++) {
                    if (this.hidden_neurons[neuron_index].driven) {
                        this.hidden_neurons[neuron_index].output = Math.tanh(neuron_accumulators[neuron_index]);
                    }
                }
                neuron_outputs_computed = true;
            }
            // Obtain the input value of the connection from a sensor neuron or another neuron.
            // The values are summed and later passed through a transfer function (hyperbolic tangent function).
            let input_val = 0.0;
            if (connection.source_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.INPUT) {
                // Read the sensor data using the sensor identifier.
                input_val = this.get_sensor(connection.source_id);
            }
            else {
                input_val = this.hidden_neurons[connection.source_id].output;
            }
            // Weight the connection's value and add it to the accumulator of the corresponding neuron or action.
            if (connection.sink_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.OUTPUT) {
                action_levels[connection.sink_id] += input_val * (0,_utils_weight_as_float__WEBPACK_IMPORTED_MODULE_4__["default"])(connection.weight);
            }
            else {
                neuron_accumulators[connection.sink_id] += input_val * (0,_utils_weight_as_float__WEBPACK_IMPORTED_MODULE_4__["default"])(connection.weight);
            }
        }
        return action_levels;
    }
    /**
     * Obtains a list of connections from the genome.
     * @returns A list of connections from the genome.
     */
    obtain_connections() {
        // Initialize an array to store connections.
        const connection_array = [];
        // Check if the genome data exists.
        if (this.genome_data) {
            // Iterate through the genome data to process each gene.
            for (const gene of this.genome_data) {
                // Renumber the source neuron or sensor using modulo operator based on the total number of input or hidden neurons.
                if (gene.source_type === _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                    gene.source_id %= this.num_hidden_neurons;
                }
                else {
                    gene.source_id %= this.num_input_neurons;
                }
                // Renumber the sink neuron or action using modulo operator based on the total number of output or hidden neurons.
                if (gene.sink_type === _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                    gene.sink_id %= this.num_hidden_neurons;
                }
                else {
                    gene.sink_id %= this.num_output_neurons;
                }
                // Add the renumbered gene to the connection list.
                connection_array.push(gene);
            }
        }
        // Return the obtained list of connections.
        return connection_array;
    }
    /**
     * Creates a map of hidden neurons and their corresponding input and output counts.
     * @param connection_array - The connection array to process.
     * @returns A map of hidden neurons and their corresponding input and output counts.
     */
    create_hidden_neuron_map(connection_array) {
        // Initialize a map to store hidden neurons and their input/output counts.
        const hidden_neuron_map = new Map();
        // Iterate through the connection array to process each connection.
        for (const connection of connection_array) {
            // Check if the sink type is a hidden neuron.
            if (connection.sink_type === _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                // Check if the connection is a self-input to the hidden neuron.
                const self_input = connection.source_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN && connection.source_id == connection.sink_id;
                // Check if the hidden neuron already exists in the map.
                if (hidden_neuron_map.has(connection.sink_id)) {
                    const node = hidden_neuron_map.get(connection.sink_id);
                    if (node) {
                        // Update the input/output counts for the existing hidden neuron.
                        if (self_input)
                            node.self_inputs++;
                        else
                            node.inputs++;
                    }
                    else {
                        // If the neuron is not in the node map, add it with the appropriate input/output values.
                        hidden_neuron_map.set(connection.sink_id, {
                            identifer: 0,
                            outputs: 0,
                            self_inputs: self_input ? 1 : 0,
                            inputs: self_input ? 0 : 1,
                        });
                    }
                }
            }
            // Check if the source type is a hidden neuron.
            if (connection.source_type === _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                // Check if the hidden neuron already exists in the map.
                if (hidden_neuron_map.has(connection.source_id)) {
                    const node = hidden_neuron_map.get(connection.source_id);
                    if (node)
                        node.outputs++;
                }
                else {
                    // If the neuron is not in the node map, add it with the appropriate input/output values.
                    hidden_neuron_map.set(connection.source_id, {
                        identifer: 0,
                        outputs: 1,
                        self_inputs: 0,
                        inputs: 0,
                    });
                }
            }
        }
        // Return the created map of neurons with their input/output counts.
        return hidden_neuron_map;
    }
    /**
     * Removes connections to a specific neuron from the connection list and updates the node map accordingly.
     * @param connection_array - The connection array to process.
     * @param hidden_neuron_map - The hidden neuron map to update.
     * @param neuron_number - The neuron number to remove connections to.
     */
    remove_connections_to_neuron(connection_array, hidden_neuron_map, neuron_number) {
        // Loop through the connection array.
        for (let i = 0; i < connection_array.length;) {
            const neuron = connection_array[i];
            // Check if the current connection's sink is the specified neuron.
            if (neuron.sink_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN && neuron.sink_id === neuron_number) {
                // If the connection's sink is the specified neuron, handle the removal process.
                // Check if the source of the connection is also a hidden neuron.
                if (neuron.source_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                    // If the source is a hidden neuron, decrement the outputs of that neuron in the map.
                    const node = hidden_neuron_map.get(neuron.source_id);
                    if (node)
                        node.outputs--;
                }
                // Remove the connection from the connection list.
                connection_array.splice(i, 1);
            }
            else {
                // Move to the next connection in the list.
                i++;
            }
        }
    }
    /**
     * Removes useless connections from the connection list and updates the node map accordingly.
     * @param connections - The connection array to process.
     * @param hidden_neuron_map - The hidden neuron map to update.
     */
    prune_connections(connections, hidden_neuron_map) {
        // Flag to track if connections are pruned.
        let connections_pruned = false;
        // Loop until no more connections are pruned.
        while (!connections_pruned) {
            connections_pruned = true;
            // Iterate through hidden neurons in the map.
            for (const node_number of hidden_neuron_map.keys()) {
                // Retrieve the details of the current node from the map.
                const node = hidden_neuron_map.get(node_number);
                // Look for neurons with zero outputs or neurons that feed themselves.
                if (node && node.outputs === node.self_inputs) {
                    // If found, set the flag to false to continue pruning.
                    connections_pruned = false;
                    // Remove connections leading to the identified neuron and delete it from the map.
                    this.remove_connections_to_neuron(connections, hidden_neuron_map, node_number);
                    hidden_neuron_map.delete(node_number);
                }
            }
        }
    }
    /**
     * Creates a renumbered connection list based on the node map.
     * @param connection_array - The connection array to process.
     * @param hidden_neuron_map - The hidden neuron map to update.
     */
    create_connections(connection_array, hidden_neuron_map) {
        let new_number = 0;
        // Renumber neurons in the hidden_neuron_map.
        for (const node of hidden_neuron_map.values()) {
            node.identifer = new_number++;
        }
        // Iterate through connection_array to update connections with renumbered neuron IDs.
        for (const connection of connection_array) {
            if (connection.sink_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                const new_connection = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(connection);
                // Fix the destination neuron number using the updated node map.
                const node = hidden_neuron_map.get(new_connection.sink_id);
                if (node)
                    new_connection.sink_id = node.identifer;
                // If the source is a neuron, fix its number too using the updated node map.
                if (new_connection.source_type === _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                    const node = hidden_neuron_map.get(new_connection.source_id);
                    if (node)
                        new_connection.source_id = node.identifer;
                }
                // Add the modified connection to the updated connections array.
                this.connections.push(new_connection);
            }
        }
        // Process connections from sensor/neuron to an action.
        for (const connection of connection_array) {
            if (connection.sink_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.OUTPUT) {
                const new_conn = (0,lodash__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(connection);
                // If the source is a hidden neuron, fix its number using the updated node map.
                if (new_conn.source_type === _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.HIDDEN) {
                    const node = hidden_neuron_map.get(new_conn.source_id);
                    if (node)
                        new_conn.source_id = node.identifer;
                }
                // Add the modified connection to the updated connections array.
                this.connections.push(new_conn);
            }
            // Group input neurons, hidden neurons, and output neurons into their respective sets.
            if (connection.source_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.INPUT)
                this.inputs[connection.source_id] = undefined;
            else
                this.hidden[connection.source_id] = undefined;
            if (connection.sink_type == _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neurons.OUTPUT)
                this.outputs[connection.sink_id] = undefined;
            else
                this.hidden[connection.sink_id] = undefined;
        }
    }
    /**
     * Creates a hidden neuron array based on the node map.
     * @param hidden_neuron_map - The hidden neuron map to process.
     * @returns A hidden neuron array based on the node map.
     */
    create_hidden_neuron_array(hidden_neuron_map) {
        // Loop through each node in the hidden_neuron_map.
        for (const node of hidden_neuron_map.values()) {
            // Create a new Neuron instance.
            const neuron = new _Neurons__WEBPACK_IMPORTED_MODULE_6__.Neuron();
            // Set the initial output to 0.5.
            neuron.output = 0.5;
            // Check if the neuron has inputs to drive its output.
            neuron.driven = node.inputs !== 0;
            // Add the newly created neuron to the hidden_neurons array.
            this.hidden_neurons.push(neuron);
        }
        // Return the updated hidden_neurons array.
        return this.hidden_neurons;
    }
}


/***/ }),

/***/ "./src/models/Gene.ts":
/*!****************************!*\
  !*** ./src/models/Gene.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Gene)
/* harmony export */ });
/* harmony import */ var _utils_get_random_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/get_random_number */ "./src/utils/get_random_number.ts");

/** This class is used to create a gene that can be used to store information */
class Gene {
    // Source of the connection is either an input neuron/hidden neuron.
    source_type;
    // Identifer of which input neuron/hidden neuron.
    source_id;
    // Sink of the connection is either an output neuron/hidden neuron
    sink_type;
    // Identifier of which output neuron/hidden neuron.
    sink_id;
    // The weight of the connection.
    weight;
    // Builds a new gene.
    constructor(NUMBER_OF_HIDDEN_NEURONS) {
        this.source_type = (0,_utils_get_random_number__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 1);
        this.source_id = (0,_utils_get_random_number__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 0x7fff) % NUMBER_OF_HIDDEN_NEURONS;
        this.sink_type = (0,_utils_get_random_number__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 1);
        this.sink_id = (0,_utils_get_random_number__WEBPACK_IMPORTED_MODULE_0__["default"])(0, 0x7fff) % NUMBER_OF_HIDDEN_NEURONS;
        this.weight = Math.round(Math.random() * 0xffff) - 0x8000;
    }
}


/***/ }),

/***/ "./src/models/Genome.ts":
/*!******************************!*\
  !*** ./src/models/Genome.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Genome)
/* harmony export */ });
/** This class is used to create a genome that can be used to store information */
class Genome {
    data;
    colour;
    /** Builds a new genome from a given set of genes. */
    constructor(genome) {
        this.data = genome;
        this.colour = this.get_colour(genome);
    }
    // Obtains a colour for the organism based on its genome.
    get_colour(genome) {
        let genome_string = "";
        // Convert each individual gene into a genome string.
        for (const gene of genome) {
            genome_string += `${gene.source_type},${gene.source_id},${gene.sink_type},${gene.sink_id},${gene.weight}`;
        }
        // Create a unique hash from the genome string.
        let hash = 0;
        for (let i = 0; i < genome_string.length; i++) {
            hash = (hash << 5) - hash + genome_string.charCodeAt(i);
        }
        // Calculate the rgb codes using the hash.
        let r = (hash & 0xff0000) >> 16;
        let g = (hash & 0x00ff00) >> 8;
        let b = hash & 0x0000ff;
        // Normalize RGB values to fit within the range of 0-255.
        r = Math.floor(r % 256);
        g = Math.floor(g % 256);
        b = Math.floor(b % 256);
        return `rgb(${r}, ${g}, ${b})`;
    }
}


/***/ }),

/***/ "./src/models/Neurons.ts":
/*!*******************************!*\
  !*** ./src/models/Neurons.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Neuron: () => (/* binding */ Neuron),
/* harmony export */   Neurons: () => (/* binding */ Neurons)
/* harmony export */ });
// Identifiers for each type of neuron.
const Neurons = {
    INPUT: 1,
    OUTPUT: 1,
    HIDDEN: 0,
};
/** This class is used to create a neuron that can be used to store information. */
class Neuron {
    // Output value of the neuron.
    output;
    // Undriven neurons have fixed output values.
    driven;
    // Builds a new neuron.
    constructor() {
        this.output = 0.0;
        this.driven = false;
    }
}


/***/ }),

/***/ "./src/models/Organism.ts":
/*!********************************!*\
  !*** ./src/models/Organism.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Organism)
/* harmony export */ });
/* harmony import */ var _constants_Directions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/Directions */ "./src/constants/Directions.ts");
/* harmony import */ var _constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants/OutputNeurons */ "./src/constants/OutputNeurons.ts");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.ts");
/* harmony import */ var _utils_probability_to_boolean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/probability_to_boolean */ "./src/utils/probability_to_boolean.ts");
/* harmony import */ var _Brain__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Brain */ "./src/models/Brain.ts");
/* harmony import */ var _Genome__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Genome */ "./src/models/Genome.ts");






/** This class is used to represent an organism in the simulation. */
class Organism {
    _coordinate;
    genome;
    brain;
    fitness;
    alive;
    energy;
    direction;
    config;
    grid;
    // Constructs a new Organism object.
    constructor(coordinate, genome, grid, config) {
        this.grid = grid;
        this._coordinate = coordinate;
        // If a genome has been given, use this genome, else create a new random genome.
        this.genome = new _Genome__WEBPACK_IMPORTED_MODULE_5__["default"](genome);
        this.config = config;
        this.brain = new _Brain__WEBPACK_IMPORTED_MODULE_4__["default"](this.coordinate, this.grid, this.genome.data, this.config.NUMBER_OF_INPUTS, this.config.NUMBER_OF_HIDDEN_NEURONS, this.config.NUMBER_OF_OUTPUTS);
        this.direction = _constants_Directions__WEBPACK_IMPORTED_MODULE_0__["default"].NORTH;
        this.fitness = null;
        this.alive = true;
        this.energy = 0;
    }
    /**
     * Sets the coordinate of the organism.
     * @param coordinate - The new coordinate of the organism.
     */
    set coordinate(coordinate) {
        // Clears the current cell state of the organism's previous coordinate.
        this.grid.clear_cell_state(this.coordinate);
        // Sets the cell owner to the current organism at the new specified coordinate.
        this.grid.set_cell_owner(coordinate, this);
        // Updates the organism's _coordinate property with the new coordinate value.
        this._coordinate = coordinate;
    }
    /**
     * Gets the coordinate of the organism.
     * @returns The coordinate of the organism.
     */
    get coordinate() {
        return this._coordinate;
    }
    /**
     * Performs an action based on the organism's brain.
     * @returns The coordinate offset of the action.
     */
    action() {
        // Perform Neural Network Feed Forward to obtain action levels.
        const action_levels = this.brain.feed_forward();
        // Compute the action to take based on the action levels.
        return this.compute_movement_offset(action_levels);
    }
    /**
     * Computes the action based on the action levels.
     * @param action_levels - The action levels to compute the action from.
     * @returns
     */
    compute_movement_offset(action_levels) {
        // 'move_x' and 'move_y' represent the urge to move in the X and Y direction respectively.
        let move_x = action_levels[_constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_1__.OutputNeurons.MOVE_X];
        let move_y = action_levels[_constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_1__.OutputNeurons.MOVE_Y];
        // Accumulate the urge to move based on specific output neurons representing directions.
        move_x += action_levels[_constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_1__.OutputNeurons.MOVE_EAST];
        move_x -= action_levels[_constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_1__.OutputNeurons.MOVE_WEST];
        move_y += action_levels[_constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_1__.OutputNeurons.MOVE_NORTH];
        move_y -= action_levels[_constants_OutputNeurons__WEBPACK_IMPORTED_MODULE_1__.OutputNeurons.MOVE_SOUTH];
        // The hyperbolic tangent function confines movement values between -1.0 and 1.0.
        move_x = Math.tanh(move_x);
        move_y = Math.tanh(move_y);
        // Calculate probabilities based on absolute values.
        const prob_x = +(0,_utils_probability_to_boolean__WEBPACK_IMPORTED_MODULE_3__["default"])(Math.abs(move_x));
        const prob_y = +(0,_utils_probability_to_boolean__WEBPACK_IMPORTED_MODULE_3__["default"])(Math.abs(move_y));
        // Determine direction of movement based on the sign of the values. (signum function)
        const signum_x = move_x < 0.0 ? -1 : 1;
        const signum_y = move_y < 0.0 ? -1 : 1;
        // Create a vector representing the calculated movement based on probabilities and directions.
        const offset = (0,_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.make_vector)(prob_x * signum_x, prob_y * signum_y);
        return offset;
    }
}


/***/ }),

/***/ "./src/structures/Queue.ts":
/*!*********************************!*\
  !*** ./src/structures/Queue.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Queue)
/* harmony export */ });
/** Represents a node in a queue. */
class QueueNode {
    value;
    next;
    /** Builds a new QueueNode instance. */
    constructor(value) {
        // Assign the provided value to the node.
        this.value = value;
        // Set the next node to null.
        this.next = null;
    }
}
/** Class for creating a queue. */
class Queue {
    front;
    rear;
    /** Builds a new Queue instance. */
    constructor() {
        // Set the front and rear nodes to null.
        this.front = null;
        // Set the rear node to null.
        this.rear = null;
    }
    /**
     * Adds a value to the queue.
     * @param value - The value to enqueue.
     */
    enqueue(value) {
        const node = new QueueNode(value);
        if (this.rear === null) {
            this.front = node;
            this.rear = node;
        }
        else {
            this.rear.next = node;
            this.rear = node;
        }
    }
    /**
     * Removes a value from the queue.
     * @returns The value at the front of the queue.
     */
    dequeue() {
        if (this.front === null) {
            this.rear = null;
            return null;
        }
        else {
            const node = this.front;
            this.front = this.front.next;
            return node.value;
        }
    }
}


/***/ }),

/***/ "./src/utils/export_object.ts":
/*!************************************!*\
  !*** ./src/utils/export_object.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ export_object)
/* harmony export */ });
/**
 * Export an object as a JSON file.
 * @param object - The object to export.
 * @param export_name - The name of the exported file.
 */
function export_object(object, export_name) {
    // Create a data string from the object.
    const data_string = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(object));
    // Create a link element and set its attributes.
    const download_anchor_node = document.createElement("a");
    download_anchor_node.setAttribute("href", data_string);
    download_anchor_node.setAttribute("download", export_name + ".json");
    // Append the link element to the document body.
    document.body.appendChild(download_anchor_node);
    // Click the link element to download the JSON file.
    download_anchor_node.click();
    // Remove the link element from the document body.
    download_anchor_node.remove();
}


/***/ }),

/***/ "./src/utils/geometry.ts":
/*!*******************************!*\
  !*** ./src/utils/geometry.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add_vector: () => (/* binding */ add_vector),
/* harmony export */   euclidean_distance: () => (/* binding */ euclidean_distance),
/* harmony export */   make_vector: () => (/* binding */ make_vector),
/* harmony export */   rotate_point: () => (/* binding */ rotate_point),
/* harmony export */   to_angle: () => (/* binding */ to_angle),
/* harmony export */   to_radians: () => (/* binding */ to_radians)
/* harmony export */ });
/**
 * Converts an angle to radians.
 * @param angle - The angle to convert to radians.
 * @returns The angle in radians.
 */
function to_radians(angle) {
    return (Math.PI / 180) * angle;
}
/**
 * Calculates the Euclidean distance between two coordinates.
 * @param first_coord - The first coordinate.
 * @param second_coord - The second coordinate.
 * @returns The Euclidean distance between the two coordinates.
 */
function euclidean_distance(first_coord, second_coord) {
    return Math.sqrt(Math.pow(second_coord.y - first_coord.y, 2) + Math.pow(second_coord.x - first_coord.x, 2));
}
/**
 * Rotates a point about a pivot by a specified angle.
 * @param point - The point to rotate.
 * @param pivot - The pivot to rotate the point about.
 * @param angle - The angle to rotate the point by.
 * @returns The rotated point.
 */
function rotate_point(point, pivot, angle) {
    if (typeof point.x == "number" && typeof point.y == "number") {
        const radians = to_radians(angle);
        const cos = Math.cos(radians);
        const sin = Math.sin(radians);
        const nx = Math.round(cos * (point.x - pivot.x) + sin * (point.y - pivot.y) + pivot.x);
        const ny = Math.round(cos * (point.y - pivot.y) - sin * (point.x - pivot.x) + pivot.y);
        return { x: nx, y: ny };
    }
    else {
        throw Error("Cannot rotate point as coordinates are not of type number.");
    }
}
/**
 * Performs addition of two vectors.
 * @param first_coord
 * @param second_coord
 * @returns The sum of the two vectors.
 */
function add_vector(first_coord, second_coord) {
    return { x: first_coord.x + second_coord.x, y: first_coord.y + second_coord.y };
}
/**
 * Creates a coordinate object, treating as a vector.
 * @param x - The x-coordinate of the vector.
 * @param y - The y-coordinate of the vector.
 * @returns The coordinate object.
 */
const make_vector = (x, y) => {
    return { x: x, y: y };
};
/**
 * Converts a point to an angle in degrees.
 * @param point - The point to convert to an angle.
 * @returns The angle in degrees.
 */
function to_angle(point) {
    const firstAngle = Math.atan2(1, 0);
    const secondAngle = Math.atan2(point.y, point.x);
    const angle = secondAngle - firstAngle;
    return Math.abs((angle * 180) / Math.PI);
}


/***/ }),

/***/ "./src/utils/get_max_distance.ts":
/*!***************************************!*\
  !*** ./src/utils/get_max_distance.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   max_distance_to_point: () => (/* binding */ max_distance_to_point)
/* harmony export */ });
// Function to calculate the maximum distance between a point and any other point in a grid of a given size.
function max_distance_to_point(size, x_coord, y_coord) {
    let max_distance = 0;
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            const distance = Math.sqrt((i - x_coord) ** 2 + (j - y_coord) ** 2);
            max_distance = Math.max(max_distance, distance);
        }
    }
    return max_distance;
}


/***/ }),

/***/ "./src/utils/get_random_number.ts":
/*!****************************************!*\
  !*** ./src/utils/get_random_number.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ get_random_number)
/* harmony export */ });
/**
 * Generates a random number between min inclusive and max inclusive.
 * @param min - The minimum number.
 * @param max - The maximum number.
 * @returns - A random number between min and max.
 */
function get_random_number(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1) + min);
}


/***/ }),

/***/ "./src/utils/get_random_vector.ts":
/*!****************************************!*\
  !*** ./src/utils/get_random_vector.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ get_random_vector)
/* harmony export */ });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry */ "./src/utils/geometry.ts");
/* harmony import */ var _get_random_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get_random_number */ "./src/utils/get_random_number.ts");


/**
 * Generates a random vector between minimum and maximum inclusive.
 * @param min_x - The minimum x-coordinate.
 * @param min_y - The minimum y-coordinate.
 * @param max_x - The maximum x-coordinate.
 * @param max_y -  The maximum y-coordinate.
 * @returns - A random vector between minimum and maximum inclusive.
 */
function get_random_vector(min_x, min_y, max_x, max_y) {
    const rand_x = (0,_get_random_number__WEBPACK_IMPORTED_MODULE_1__["default"])(min_x, max_x);
    const rand_y = (0,_get_random_number__WEBPACK_IMPORTED_MODULE_1__["default"])(min_y, max_y);
    return (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.make_vector)(rand_x, rand_y);
}


/***/ }),

/***/ "./src/utils/get_style.ts":
/*!********************************!*\
  !*** ./src/utils/get_style.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ get_style)
/* harmony export */ });
/**
 * Obtains an element's specific style.
 * @param element - The element to obtain the style from.
 * @param property-  The style property to obtain.
 * @returns - The value of the style property.
 */
function get_style(element, property) {
    const html_element = document.getElementById(element);
    const styles = window.getComputedStyle(html_element);
    const value = styles.getPropertyValue(property);
    return value;
}


/***/ }),

/***/ "./src/utils/probability_to_boolean.ts":
/*!*********************************************!*\
  !*** ./src/utils/probability_to_boolean.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ probability_to_boolean)
/* harmony export */ });
/**
 * Converts a probability factor to a boolean value.
 * @param factor - The probability factor.
 * @returns - A boolean value.
 */
function probability_to_boolean(factor) {
    return Math.random() < factor;
}


/***/ }),

/***/ "./src/utils/read_file.ts":
/*!********************************!*\
  !*** ./src/utils/read_file.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   read_file: () => (/* binding */ read_file)
/* harmony export */ });
/**
 * Function to read a file.
 * @param event - The event that triggered the function.
 * @returns - The data from the file.
 */
function read_file(event) {
    return new Promise((resolve) => {
        const target = event.target;
        const file = target.files[0];
        const reader = new FileReader();
        reader.readAsText(file, "UTF-8");
        reader.onload = (event) => {
            const result = event.target.result;
            const data = JSON.parse(result);
            resolve(data);
        };
    });
}


/***/ }),

/***/ "./src/utils/weight_as_float.ts":
/*!**************************************!*\
  !*** ./src/utils/weight_as_float.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ weight_as_float)
/* harmony export */ });
// Returns the weight as a float.
function weight_as_float(weight) {
    // Weight range = -32768 to 32767.
    // Dividing by 6553.6 scales the weight between -5 and 5.
    return weight / 6553.6;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_Buttons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Buttons */ "./src/components/Buttons.ts");
/* harmony import */ var _components_ImportExport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/ImportExport */ "./src/components/ImportExport.ts");
/* harmony import */ var _components_Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Settings */ "./src/components/Settings.ts");
/* harmony import */ var _controllers_simulation_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controllers/simulation.controller */ "./src/controllers/simulation.controller.ts");
/* harmony import */ var _controllers_config_controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controllers/config.controller */ "./src/controllers/config.controller.ts");
/* harmony import */ var _config_simulation_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config/simulation.config */ "./src/config/simulation.config.ts");






const config = _controllers_config_controller__WEBPACK_IMPORTED_MODULE_4__.ConfigController.get_instance();
// Set the default configuration.
config.config = _config_simulation_config__WEBPACK_IMPORTED_MODULE_5__.DefaultSimulationConfig;
const simulation = new _controllers_simulation_controller__WEBPACK_IMPORTED_MODULE_3__["default"](config.config);
// Render settings
(0,_components_Settings__WEBPACK_IMPORTED_MODULE_2__.render_settings)(simulation, config.config);
// Register event listeners for the four main buttons.
(0,_components_Buttons__WEBPACK_IMPORTED_MODULE_0__.register_show_controls)();
(0,_components_Buttons__WEBPACK_IMPORTED_MODULE_0__.register_rendering_enabled_button)(simulation);
(0,_components_Buttons__WEBPACK_IMPORTED_MODULE_0__.register_sim_restart_button)();
(0,_components_Buttons__WEBPACK_IMPORTED_MODULE_0__.register_sim_start_stop_button)(simulation);
// Other buttons in the control menu.
(0,_components_Buttons__WEBPACK_IMPORTED_MODULE_0__.register_download_neuralnet_button)();
(0,_components_Buttons__WEBPACK_IMPORTED_MODULE_0__.register_fps_slider)(simulation, config.config);
(0,_components_Buttons__WEBPACK_IMPORTED_MODULE_0__.register_switch_chart)(simulation);
// Import Buttons
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.register_import_organisms_button)(simulation);
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.register_import_simulation_button)(simulation);
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.register_import_config_button)(simulation);
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.register_import_environment_button)(simulation);
// Export Buttons
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.register_export_config_button)(config.config);
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.register_export_environment_button)(simulation);
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.export_population_button)(simulation);
(0,_components_ImportExport__WEBPACK_IMPORTED_MODULE_1__.register_export_simulation_button)(simulation, config.config);

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxhQUFhLE9BQU87O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLEVBQUU7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxRQUFRO0FBQ1IsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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ZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUSxXQUFXO0FBQ2xDLGVBQWUsU0FBUztBQUN4QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsbURBQW1ELGlCQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUJBQW1CO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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ZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FB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QVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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U0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxlQUFlO0FBQzlCLGVBQWUsaUJBQWlCO0FBQ2hDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssT0FBTyxnQkFBZ0I7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJEQUEyRDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0NBQXdDO0FBQ3RFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QVMsQ0FBQztRQUM5QixNQUFNLEtBQUssR0FBRyxNQUFNLENBQUM7UUFDckIsb0RBQW9EO1FBRXBELElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzdDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ3pDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU07UUFDaEQsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztRQUM1Qix1REFBdUQ7UUFDdkQsSUFBSSxDQUFDLEdB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dWxhdG9yLy4vbm9kZV9tb2R1bGVzL0BjYW52YXNqcy9jaGFydHMvY2FudmFzanMubWluLmpzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2FsZ29yaXRobXMvR2VuZXRpY0FsZ29yaXRobS50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2FsZ29yaXRobXMvTmV1cmFsTmV0RGlhZ3JhbS50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2NvbXBvbmVudHMvQnV0dG9ucy50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2NvbXBvbmVudHMvRE9NRWxlbWVudHMudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9jb21wb25lbnRzL0ltcG9ydEV4cG9ydC50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2NvbXBvbmVudHMvU2V0dGluZ3MudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9jb25maWcvc2ltdWxhdGlvbi5jb25maWcudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9jb25maWcvdGhlbWUuY29uZmlnLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvY29uc3RhbnRzL0RpcmVjdGlvbnMudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9jb25zdGFudHMvSW5wdXROZXVyb25zLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvY29uc3RhbnRzL091dHB1dE5ldXJvbnMudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9jb250cm9sbGVycy9jYW52YXMuY29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2NvbnRyb2xsZXJzL2NoYXJ0LmNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9jb250cm9sbGVycy9jb25maWcuY29udHJvbGxlci50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2NvbnRyb2xsZXJzL21vdXNlLmNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9jb250cm9sbGVycy9yZW5kZXJlci5jb250cm9sbGVyLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvY29udHJvbGxlcnMvc2ltdWxhdGlvbi5jb250cm9sbGVyLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvZW52aXJvbm1lbnQvR3JpZC50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL2Vudmlyb25tZW50L2luZGV4LnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvbW9kZWxzL0JyYWluLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvbW9kZWxzL0dlbmUudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9tb2RlbHMvR2Vub21lLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvbW9kZWxzL05ldXJvbnMudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9tb2RlbHMvT3JnYW5pc20udHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9zdHJ1Y3R1cmVzL1F1ZXVlLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvdXRpbHMvZXhwb3J0X29iamVjdC50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL3V0aWxzL2dlb21ldHJ5LnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvdXRpbHMvZ2V0X21heF9kaXN0YW5jZS50cyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yLy4vc3JjL3V0aWxzL2dldF9yYW5kb21fbnVtYmVyLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvdXRpbHMvZ2V0X3JhbmRvbV92ZWN0b3IudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy91dGlscy9nZXRfc3R5bGUudHMiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy91dGlscy9wcm9iYWJpbGl0eV90b19ib29sZWFuLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvdXRpbHMvcmVhZF9maWxlLnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3IvLi9zcmMvdXRpbHMvd2VpZ2h0X2FzX2Zsb2F0LnRzIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3Ivd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yL3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2V2b2x1dGlvbl9zaW11bGF0b3Ivd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9ldm9sdXRpb25fc2ltdWxhdG9yL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vZXZvbHV0aW9uX3NpbXVsYXRvci8uL3NyYy9tYWluLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFxyXG4gQ2FudmFzSlMgQ2hhcnQgLSB2My43LjMzIEdBIC0gaHR0cHM6Ly9jYW52YXNqcy5jb20vIFxyXG4gQ29weXJpZ2h0IDIwMjMgZmVub3BpeFxyXG5cclxuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSBMaWNlbnNlIEluZm9ybWF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiBDYW52YXNKUyBDaGFydCBpcyBhIGNvbW1lcmNpYWwgcHJvZHVjdCB3aGljaCByZXF1aXJlcyBwdXJjaGFzZSBvZiBsaWNlbnNlLiBXaXRob3V0IGEgY29tbWVyY2lhbCBsaWNlbnNlIHlvdSBjYW4gdXNlIGl0IGZvciBldmFsdWF0aW9uIHB1cnBvc2VzIGZvciB1cHRvIDMwIGRheXMuIFBsZWFzZSByZWZlciB0byB0aGUgZm9sbG93aW5nIGxpbmsgZm9yIGZ1cnRoZXIgZGV0YWlscy5cclxuIGh0dHBzOi8vY2FudmFzanMuY29tL2xpY2Vuc2UvXHJcblxyXG5cclxuIC0tLS0tLS0tLS0tLS0tLS0tLS0tLUZyZWUgZm9yIE5vbi1Db21tZXJjaWFsIFVzZS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiBcclxuIEZvciBub24tY29tbWVyY2lhbCBwdXJwb3NlcyB5b3UgY2FuIHVzZSB0aGUgc29mdHdhcmUgZm9yIGZyZWUgdW5kZXIgQ3JlYXRpdmUgQ29tbW9ucyBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBMaWNlbnNlLlxyXG4gQSBjcmVkaXQgTGluayBpcyBhZGRlZCB0byB0aGUgY2hhcnQgd2hpY2ggc2hvdWxkIGJlIHByZXNlcnZlZC4gUmVmZXIgdG8gdGhlIGZvbGxvd2luZyBsaW5rIGZvciBmdXJ0aGVyIGRldGFpbHMgb24gdGhlIHNhbWUuXHJcbiBodHRwczovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL2RlZWQuZW5fVVNcclxuICovXHJcblxyXG4vKnRzbGludDpkaXNhYmxlKi9cclxuLyplc2xpbnQtZGlzYWJsZSovXHJcbi8qanNoaW50IGlnbm9yZTpzdGFydCovXHJcbihmdW5jdGlvbigpe2Z1bmN0aW9uIG9hKGgscCl7aC5wcm90b3R5cGU9ZGIocC5wcm90b3R5cGUpO2gucHJvdG90eXBlLmNvbnN0cnVjdG9yPWg7aC5iYXNlPXAucHJvdG90eXBlfWZ1bmN0aW9uIGRiKGgpe2Z1bmN0aW9uIHAoKXt9cC5wcm90b3R5cGU9aDtyZXR1cm4gbmV3IHB9ZnVuY3Rpb24gWGEoaCxwLEUpe1wibWlsbGlzZWNvbmRcIj09PUU/aC5zZXRNaWxsaXNlY29uZHMoaC5nZXRNaWxsaXNlY29uZHMoKSsxKnApOlwic2Vjb25kXCI9PT1FP2guc2V0U2Vjb25kcyhoLmdldFNlY29uZHMoKSsxKnApOlwibWludXRlXCI9PT1FP2guc2V0TWludXRlcyhoLmdldE1pbnV0ZXMoKSsxKnApOlwiaG91clwiPT09RT9oLnNldEhvdXJzKGguZ2V0SG91cnMoKSsxKnApOlwiZGF5XCI9PT1FP2guc2V0RGF0ZShoLmdldERhdGUoKSsxKnApOlwid2Vla1wiPT09RT9oLnNldERhdGUoaC5nZXREYXRlKCkrNypwKTpcIm1vbnRoXCI9PT1FP2guc2V0TW9udGgoaC5nZXRNb250aCgpKzEqcCk6XCJ5ZWFyXCI9PT1FJiZoLnNldEZ1bGxZZWFyKGguZ2V0RnVsbFllYXIoKStcbjEqcCk7cmV0dXJuIGh9ZnVuY3Rpb24gY2EoaCxwKXt2YXIgRT0hMTswPmgmJihFPSEwLGgqPS0xKTtoPVwiXCIraDtmb3IocD1wP3A6MTtoLmxlbmd0aDxwOyloPVwiMFwiK2g7cmV0dXJuIEU/XCItXCIraDpofWZ1bmN0aW9uIEhhKGgpe2lmKCFoKXJldHVybiBoO2g9aC5yZXBsYWNlKC9eXFxzXFxzKi8sXCJcIik7Zm9yKHZhciBwPS9cXHMvLEU9aC5sZW5ndGg7cC50ZXN0KGguY2hhckF0KC0tRSkpOyk7cmV0dXJuIGguc2xpY2UoMCxFKzEpfWZ1bmN0aW9uIERhKGgpe2gucm91bmRSZWN0PWZ1bmN0aW9uKGgsRSxyLHcscWEsQSxCLHYpe0ImJih0aGlzLmZpbGxTdHlsZT1CKTt2JiYodGhpcy5zdHJva2VTdHlsZT12KTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHFhJiYocWE9NSk7dGhpcy5saW5lV2lkdGg9QTt0aGlzLmJlZ2luUGF0aCgpO3RoaXMubW92ZVRvKGgrcWEsRSk7dGhpcy5saW5lVG8oaCtyLXFhLEUpO3RoaXMucXVhZHJhdGljQ3VydmVUbyhoK3IsRSxoK3IsRStxYSk7dGhpcy5saW5lVG8oaCtcbnIsRSt3LXFhKTt0aGlzLnF1YWRyYXRpY0N1cnZlVG8oaCtyLEUrdyxoK3ItcWEsRSt3KTt0aGlzLmxpbmVUbyhoK3FhLEUrdyk7dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGgsRSt3LGgsRSt3LXFhKTt0aGlzLmxpbmVUbyhoLEUrcWEpO3RoaXMucXVhZHJhdGljQ3VydmVUbyhoLEUsaCtxYSxFKTt0aGlzLmNsb3NlUGF0aCgpO0ImJnRoaXMuZmlsbCgpO3YmJjA8QSYmdGhpcy5zdHJva2UoKX19ZnVuY3Rpb24gUmEoaCxwKXtyZXR1cm4gaC1wfWZ1bmN0aW9uIFgoaCl7dmFyIHA9KChoJjE2NzExNjgwKT4+MTYpLnRvU3RyaW5nKDE2KSxFPSgoaCY2NTI4MCk+PjgpLnRvU3RyaW5nKDE2KTtoPSgoaCYyNTUpPj4wKS50b1N0cmluZygxNik7cD0yPnAubGVuZ3RoP1wiMFwiK3A6cDtFPTI+RS5sZW5ndGg/XCIwXCIrRTpFO2g9Mj5oLmxlbmd0aD9cIjBcIitoOmg7cmV0dXJuXCIjXCIrcCtFK2h9ZnVuY3Rpb24gZWIoaCxwKXt2YXIgRT10aGlzLmxlbmd0aD4+PjAscj1OdW1iZXIocCl8fDAscj0wPnI/TWF0aC5jZWlsKHIpOlxuTWF0aC5mbG9vcihyKTtmb3IoMD5yJiYocis9RSk7cjxFO3IrKylpZihyIGluIHRoaXMmJnRoaXNbcl09PT1oKXJldHVybiByO3JldHVybi0xfWZ1bmN0aW9uIHIoaCl7cmV0dXJuIG51bGw9PT1ofHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGh9ZnVuY3Rpb24gRWEoaCl7aC5pbmRleE9mfHwoaC5pbmRleE9mPWViKTtyZXR1cm4gaH1mdW5jdGlvbiBmYihoKXtpZih2YS5mU0RlYyloW2lhKFwiYGVlRHdkb3VNaHJ1ZG9kc1wiKV0oaWEoXCJlYHVgQG9obGB1aG5vSHVkc2B1aG5vRG9lXCIpLGZ1bmN0aW9uKCl7dmEuX2ZUV20mJnZhLl9mVFdtKGgpfSl9ZnVuY3Rpb24gWWEoaCxwLEUpe0U9RXx8XCJub3JtYWxcIjt2YXIgcj1oK1wiX1wiK3ArXCJfXCIrRSx3PVphW3JdO2lmKGlzTmFOKHcpKXt0cnl7aWYoIXJhKXt2YXIgcWE9ZG9jdW1lbnQuYm9keTtyYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtyYS5pbm5lckhUTUw9XCJcIjt2YXIgQT1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk1wZ3lpXCIpO1xucmEuYXBwZW5kQ2hpbGQoQSk7cWEuYXBwZW5kQ2hpbGQocmEpfXJhLnN0eWxlLmRpc3BsYXk9XCJcIjtWKHJhLHtwb3NpdGlvbjpcImFic29sdXRlXCIsbGVmdDpcIjBweFwiLHRvcDpcIi0yMDAwMHB4XCIscGFkZGluZzpcIjBweFwiLG1hcmdpbjpcIjBweFwiLGJvcmRlcjpcIm5vbmVcIix3aGl0ZVNwYWNlOlwicHJlXCIsbGluZUhlaWdodDpcIm5vcm1hbFwiLGZvbnRGYW1pbHk6aCxmb250U2l6ZTpwK1wicHhcIixmb250V2VpZ2h0OkV9KTt3PU1hdGgucm91bmQocmEub2Zmc2V0SGVpZ2h0KTtyYS5zdHlsZS5kaXNwbGF5PVwibm9uZVwifWNhdGNoKEIpe3c9TWF0aC5jZWlsKDEuMSpwKX13PU1hdGgubWF4KHcscCk7WmFbcl09d31yZXR1cm4gd31mdW5jdGlvbiBKKGgscCl7dmFyIEU9W107aWYoRT17c29saWQ6W10sc2hvcnREYXNoOlszLDFdLHNob3J0RG90OlsxLDFdLHNob3J0RGFzaERvdDpbMywxLDEsMV0sc2hvcnREYXNoRG90RG90OlszLDEsMSwxLDEsMV0sZG90OlsxLDJdLGRhc2g6WzQsMl0sZGFzaERvdDpbNCxcbjIsMSwyXSxsb25nRGFzaDpbOCwyXSxsb25nRGFzaERvdDpbOCwyLDEsMl0sbG9uZ0Rhc2hEb3REb3Q6WzgsMiwxLDIsMSwyXX1baHx8XCJzb2xpZFwiXSlmb3IodmFyIHI9MDtyPEUubGVuZ3RoO3IrKylFW3JdKj1wO2Vsc2UgRT1bXTtyZXR1cm4gRX1mdW5jdGlvbiBQKGgscCxFLHcsaGEpe3c9d3x8W107aGE9cihoYSk/Z2I/e3Bhc3NpdmU6ITEsY2FwdHVyZTohMX06ITE6aGE7dy5wdXNoKFtoLHAsRSxoYV0pO3JldHVybiBoLmFkZEV2ZW50TGlzdGVuZXI/KGguYWRkRXZlbnRMaXN0ZW5lcihwLEUsaGEpLEUpOmguYXR0YWNoRXZlbnQ/KHc9ZnVuY3Rpb24ocCl7cD1wfHx3aW5kb3cuZXZlbnQ7cC5wcmV2ZW50RGVmYXVsdD1wLnByZXZlbnREZWZhdWx0fHxmdW5jdGlvbigpe3AucmV0dXJuVmFsdWU9ITF9O3Auc3RvcFByb3BhZ2F0aW9uPXAuc3RvcFByb3BhZ2F0aW9ufHxmdW5jdGlvbigpe3AuY2FuY2VsQnViYmxlPSEwfTtFLmNhbGwoaCxwKX0saC5hdHRhY2hFdmVudChcIm9uXCIrcCxcbncpLHcpOiExfWZ1bmN0aW9uIGhiKGgpe2lmKGguX21lbnVCdXR0b24paC5leHBvcnRFbmFibGVkPyhWKGguX21lbnVCdXR0b24se2JhY2tncm91bmRDb2xvcjpoLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcixjb2xvcjpoLnRvb2xiYXIuZm9udENvbG9yfSksTWEoaC5fbWVudUJ1dHRvbiksc2EoaCxoLl9tZW51QnV0dG9uLFwibWVudVwiKSk6d2EoaC5fbWVudUJ1dHRvbik7ZWxzZSBpZihoLmV4cG9ydEVuYWJsZWQmJncpe3ZhciBwPSExO2guX21lbnVCdXR0b249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtzYShoLGguX21lbnVCdXR0b24sXCJtZW51XCIpO2guX3Rvb2xCYXIuYXBwZW5kQ2hpbGQoaC5fbWVudUJ1dHRvbik7UChoLl9tZW51QnV0dG9uLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGgpe3A9ITB9LGguYWxsRE9NRXZlbnRIYW5kbGVycyk7UChoLl9tZW51QnV0dG9uLFwiY2xpY2tcIixmdW5jdGlvbigpe1wibm9uZVwiIT09aC5fZHJvcGRvd25NZW51LnN0eWxlLmRpc3BsYXl8fFxuaC5fZHJvcERvd25DbG9zZVRpbWUmJjUwMD49KG5ldyBEYXRlKS5nZXRUaW1lKCktaC5fZHJvcERvd25DbG9zZVRpbWUuZ2V0VGltZSgpfHwoaC5fZHJvcGRvd25NZW51LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLGguX21lbnVCdXR0b24uYmx1cigpLGguX2Ryb3Bkb3duTWVudS5mb2N1cygpKX0saC5hbGxET01FdmVudEhhbmRsZXJzLCEwKTtQKGguX21lbnVCdXR0b24sXCJtb3VzZW1vdmVcIixmdW5jdGlvbigpe3B8fChWKGguX21lbnVCdXR0b24se2JhY2tncm91bmRDb2xvcjpoLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvck9uSG92ZXIsY29sb3I6aC50b29sYmFyLmZvbnRDb2xvck9uSG92ZXJ9KSwwPj1uYXZpZ2F0b3IudXNlckFnZW50LnNlYXJjaChcIk1TSUVcIikmJlYoaC5fbWVudUJ1dHRvbi5jaGlsZE5vZGVzWzBdLHtXZWJraXRGaWx0ZXI6XCJpbnZlcnQoMTAwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMTAwJSlcIn0pKX0saC5hbGxET01FdmVudEhhbmRsZXJzLCEwKTtQKGguX21lbnVCdXR0b24sXG5cIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtwfHwoVihoLl9tZW51QnV0dG9uLHtiYWNrZ3JvdW5kQ29sb3I6aC50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3IsY29sb3I6aC50b29sYmFyLmZvbnRDb2xvcn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmVihoLl9tZW51QnV0dG9uLmNoaWxkTm9kZXNbMF0se1dlYmtpdEZpbHRlcjpcImludmVydCgwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMCUpXCJ9KSl9LGguYWxsRE9NRXZlbnRIYW5kbGVycywhMCl9aWYoaC5leHBvcnRFbmFibGVkJiZoLl9kcm9wZG93bk1lbnUpe1YoaC5fZHJvcGRvd25NZW51LHtiYWNrZ3JvdW5kQ29sb3I6aC50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3IsY29sb3I6aC50b29sYmFyLmZvbnRDb2xvcn0pO2Zvcih2YXIgRT1oLl9kcm9wZG93bk1lbnUuY2hpbGROb2RlcyxyPVtoLl9jdWx0dXJlSW5mby5wcmludFRleHQsaC5fY3VsdHVyZUluZm8uc2F2ZUpQR1RleHQsaC5fY3VsdHVyZUluZm8uc2F2ZVBOR1RleHRdLFxuaGE9MDtoYTxFLmxlbmd0aDtoYSsrKVYoRVtoYV0se2JhY2tncm91bmRDb2xvcjpoLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcixjb2xvcjpoLnRvb2xiYXIuZm9udENvbG9yfSksRVtoYV0uaW5uZXJIVE1MPXJbaGFdfWVsc2UhaC5fZHJvcGRvd25NZW51JiYoaC5leHBvcnRFbmFibGVkJiZ3KSYmKHA9ITEsaC5fZHJvcGRvd25NZW51PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksaC5fZHJvcGRvd25NZW51LnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsLTEpLEU9LTEhPT1oLnRoZW1lLmluZGV4T2YoXCJkYXJrXCIpP1wiYmxhY2tcIjpcIiM4ODg4ODhcIixWKGguX2Ryb3Bkb3duTWVudSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHpJbmRleDoxLHVzZXJTZWxlY3Q6XCJub25lXCIsTW96VXNlclNlZWxjdDpcIm5vbmVcIixXZWJraXRVc2VyU2VsZWN0Olwibm9uZVwiLG1zVXNlclNlbGVjdDpcIm5vbmVcIixjdXJzb3I6XCJwb2ludGVyXCIscmlnaHQ6XCIwcHhcIix0b3A6XCIyNXB4XCIsbWluV2lkdGg6XCIxMjBweFwiLFxub3V0bGluZTowLGZvbnRTaXplOlwiMTRweFwiLGZvbnRGYW1pbHk6XCJBcmlhbCwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmXCIscGFkZGluZzpcIjVweCAwcHggNXB4IDBweFwiLHRleHRBbGlnbjpcImxlZnRcIixsaW5lSGVpZ2h0OlwiMTBweFwiLGJhY2tncm91bmRDb2xvcjpoLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcixib3hTaGFkb3c6XCIycHggMnB4IDEwcHhcIitFfSksaC5fZHJvcGRvd25NZW51LnN0eWxlLmRpc3BsYXk9XCJub25lXCIsaC5fdG9vbEJhci5hcHBlbmRDaGlsZChoLl9kcm9wZG93bk1lbnUpLFAoaC5fZHJvcGRvd25NZW51LFwiYmx1clwiLGZ1bmN0aW9uKCl7d2EoaC5fZHJvcGRvd25NZW51KTtoLl9kcm9wRG93bkNsb3NlVGltZT1uZXcgRGF0ZX0saC5hbGxET01FdmVudEhhbmRsZXJzLCEwKSxFPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksVihFLHtwYWRkaW5nOlwiMTJweCA4cHggMTJweCA4cHhcIn0pLEUuaW5uZXJIVE1MPWguX2N1bHR1cmVJbmZvLnByaW50VGV4dCxFLnN0eWxlLmJhY2tncm91bmRDb2xvcj1cbmgudG9vbGJhci5pdGVtQmFja2dyb3VuZENvbG9yLEUuc3R5bGUuY29sb3I9aC50b29sYmFyLmZvbnRDb2xvcixoLl9kcm9wZG93bk1lbnUuYXBwZW5kQ2hpbGQoRSksUChFLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGgpe3A9ITB9LGguYWxsRE9NRXZlbnRIYW5kbGVycyksUChFLFwibW91c2Vtb3ZlXCIsZnVuY3Rpb24oKXtwfHwodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9aC50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3JPbkhvdmVyLHRoaXMuc3R5bGUuY29sb3I9aC50b29sYmFyLmZvbnRDb2xvck9uSG92ZXIpfSxoLmFsbERPTUV2ZW50SGFuZGxlcnMsITApLFAoRSxcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtwfHwodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9aC50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3IsdGhpcy5zdHlsZS5jb2xvcj1oLnRvb2xiYXIuZm9udENvbG9yKX0saC5hbGxET01FdmVudEhhbmRsZXJzLCEwKSxQKEUsXCJjbGlja1wiLGZ1bmN0aW9uKCl7aC5wcmludCgpO1xud2EoaC5fZHJvcGRvd25NZW51KX0saC5hbGxET01FdmVudEhhbmRsZXJzLCEwKSxFPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksVihFLHtwYWRkaW5nOlwiMTJweCA4cHggMTJweCA4cHhcIn0pLEUuaW5uZXJIVE1MPWguX2N1bHR1cmVJbmZvLnNhdmVKUEdUZXh0LEUuc3R5bGUuYmFja2dyb3VuZENvbG9yPWgudG9vbGJhci5pdGVtQmFja2dyb3VuZENvbG9yLEUuc3R5bGUuY29sb3I9aC50b29sYmFyLmZvbnRDb2xvcixoLl9kcm9wZG93bk1lbnUuYXBwZW5kQ2hpbGQoRSksUChFLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGgpe3A9ITB9LGguYWxsRE9NRXZlbnRIYW5kbGVycyksUChFLFwibW91c2Vtb3ZlXCIsZnVuY3Rpb24oKXtwfHwodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9aC50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3JPbkhvdmVyLHRoaXMuc3R5bGUuY29sb3I9aC50b29sYmFyLmZvbnRDb2xvck9uSG92ZXIpfSxoLmFsbERPTUV2ZW50SGFuZGxlcnMsITApLFAoRSxcblwibW91c2VvdXRcIixmdW5jdGlvbigpe3B8fCh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcj1oLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcix0aGlzLnN0eWxlLmNvbG9yPWgudG9vbGJhci5mb250Q29sb3IpfSxoLmFsbERPTUV2ZW50SGFuZGxlcnMsITApLFAoRSxcImNsaWNrXCIsZnVuY3Rpb24oKXtoLmV4cG9ydENoYXJ0KHtmb3JtYXQ6XCJqcGVnXCIsZmlsZU5hbWU6aC5leHBvcnRGaWxlTmFtZX0pO3dhKGguX2Ryb3Bkb3duTWVudSl9LGguYWxsRE9NRXZlbnRIYW5kbGVycywhMCksRT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFYoRSx7cGFkZGluZzpcIjEycHggOHB4IDEycHggOHB4XCJ9KSxFLmlubmVySFRNTD1oLl9jdWx0dXJlSW5mby5zYXZlUE5HVGV4dCxFLnN0eWxlLmJhY2tncm91bmRDb2xvcj1oLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcixFLnN0eWxlLmNvbG9yPWgudG9vbGJhci5mb250Q29sb3IsaC5fZHJvcGRvd25NZW51LmFwcGVuZENoaWxkKEUpLFAoRSxcblwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGgpe3A9ITB9LGguYWxsRE9NRXZlbnRIYW5kbGVycyksUChFLFwibW91c2Vtb3ZlXCIsZnVuY3Rpb24oKXtwfHwodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9aC50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3JPbkhvdmVyLHRoaXMuc3R5bGUuY29sb3I9aC50b29sYmFyLmZvbnRDb2xvck9uSG92ZXIpfSxoLmFsbERPTUV2ZW50SGFuZGxlcnMsITApLFAoRSxcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtwfHwodGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9aC50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3IsdGhpcy5zdHlsZS5jb2xvcj1oLnRvb2xiYXIuZm9udENvbG9yKX0saC5hbGxET01FdmVudEhhbmRsZXJzLCEwKSxQKEUsXCJjbGlja1wiLGZ1bmN0aW9uKCl7aC5leHBvcnRDaGFydCh7Zm9ybWF0OlwicG5nXCIsZmlsZU5hbWU6aC5leHBvcnRGaWxlTmFtZX0pO3dhKGguX2Ryb3Bkb3duTWVudSl9LGguYWxsRE9NRXZlbnRIYW5kbGVycywhMCkpfWZ1bmN0aW9uICRhKGgsXG5wLEUpe2gqPWxhO3AqPWxhO2g9RS5nZXRJbWFnZURhdGEoaCxwLDIsMikuZGF0YTtwPSEwO2ZvcihFPTA7ND5FO0UrKylpZihoW0VdIT09aFtFKzRdfGhbRV0hPT1oW0UrOF18aFtFXSE9PWhbRSsxMl0pe3A9ITE7YnJlYWt9cmV0dXJuIHA/aFswXTw8MTZ8aFsxXTw8OHxoWzJdOjB9ZnVuY3Rpb24gbWEoaCxwLEUpe3JldHVybiBoIGluIHA/cFtoXTpFW2hdfWZ1bmN0aW9uIE5hKGgscCxFLHhhKXt3JiZhYj8oeGE9IXIoeGEpJiZ4YT9oLmdldENvbnRleHQoXCIyZFwiLHt3aWxsUmVhZEZyZXF1ZW50bHk6ITB9KTpoLmdldENvbnRleHQoXCIyZFwiKSxPYT14YS53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx4YS5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx4YS5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW98fHhhLm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvfHx4YS5iYWNraW5nU3RvcmVQaXhlbFJhdGlvfHwxLGxhPVNhL09hLGgud2lkdGg9cCpsYSxoLmhlaWdodD1FKmxhLFNhIT09XG5PYSYmKGguc3R5bGUud2lkdGg9cCtcInB4XCIsaC5zdHlsZS5oZWlnaHQ9RStcInB4XCIseGEuc2NhbGUobGEsbGEpKSk6KGgud2lkdGg9cCxoLmhlaWdodD1FKX1mdW5jdGlvbiBpYihoKXtpZighamIpe3ZhciBwPSExLEU9ITE7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBwYS5DaGFydC5jcmVkaXRIcmVmPyhoLmNyZWRpdEhyZWY9aWEoXCJpdXVxcjsuLmJgb3dgcmtyL2JubC5cIiksaC5jcmVkaXRUZXh0PWlhKFwiQmBvd2ByS1IvYm5sXCIpKToocD1oLnVwZGF0ZU9wdGlvbihcImNyZWRpdFRleHRcIiksRT1oLnVwZGF0ZU9wdGlvbihcImNyZWRpdEhyZWZcIikpO2lmKGguY3JlZGl0SHJlZiYmaC5jcmVkaXRUZXh0KXtoLl9jcmVkaXRMaW5rfHwoaC5fY3JlZGl0TGluaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxoLl9jcmVkaXRMaW5rLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJjYW52YXNqcy1jaGFydC1jcmVkaXRcIiksaC5fY3JlZGl0TGluay5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLFwiSmF2YVNjcmlwdCBDaGFydHNcIiksXG5WKGguX2NyZWRpdExpbmsse291dGxpbmU6XCJub25lXCIsbWFyZ2luOlwiMHB4XCIscG9zaXRpb246XCJhYnNvbHV0ZVwiLHJpZ2h0OlwiMnB4XCIsdG9wOmguaGVpZ2h0LTE0K1wicHhcIixjb2xvcjpcImRpbWdyZXlcIix0ZXh0RGVjb3JhdGlvbjpcIm5vbmVcIixmb250U2l6ZTpcIjExcHhcIixmb250RmFtaWx5OlwiQ2FsaWJyaSwgTHVjaWRhIEdyYW5kZSwgTHVjaWRhIFNhbnMgVW5pY29kZSwgQXJpYWwsIHNhbnMtc2VyaWZcIn0pLGguX2NyZWRpdExpbmsuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwtMSksaC5fY3JlZGl0TGluay5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIixcIl9ibGFua1wiKSk7aWYoMD09PWgucmVuZGVyQ291bnR8fHB8fEUpaC5fY3JlZGl0TGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsaC5jcmVkaXRIcmVmKSxoLl9jcmVkaXRMaW5rLmlubmVySFRNTD1oLmNyZWRpdFRleHQ7aC5fY3JlZGl0TGluayYmaC5jcmVkaXRIcmVmJiZoLmNyZWRpdFRleHQ/KGguX2NyZWRpdExpbmsucGFyZW50RWxlbWVudHx8XG5oLl9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZChoLl9jcmVkaXRMaW5rKSxoLl9jcmVkaXRMaW5rLnN0eWxlLnRvcD1oLmhlaWdodC0xNCtcInB4XCIpOmguX2NyZWRpdExpbmsucGFyZW50RWxlbWVudCYmaC5fY2FudmFzSlNDb250YWluZXIucmVtb3ZlQ2hpbGQoaC5fY3JlZGl0TGluayl9fX1mdW5jdGlvbiB1YShoLHAsRSl7SWEmJih0aGlzLmNhbnZhc0NvdW50fD0wLHdpbmRvdy5jb25zb2xlLmxvZygrK3RoaXMuY2FudmFzQ291bnQpKTt2YXIgcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO3Iuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixcImNhbnZhc2pzLWNoYXJ0LWNhbnZhc1wiKTtOYShyLGgscCxFKTt3fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIEdfdm1sQ2FudmFzTWFuYWdlcnx8R192bWxDYW52YXNNYW5hZ2VyLmluaXRFbGVtZW50KHIpO3JldHVybiByfWZ1bmN0aW9uIFYoaCxwKXtmb3IodmFyIHIgaW4gcCloLnN0eWxlW3JdPXBbcl19ZnVuY3Rpb24gc2EoaCxwLFxucil7cC5nZXRBdHRyaWJ1dGUoXCJzdGF0ZVwiKXx8KHAuc3R5bGUuYmFja2dyb3VuZENvbG9yPWgudG9vbGJhci5pdGVtQmFja2dyb3VuZENvbG9yLHAuc3R5bGUuY29sb3I9aC50b29sYmFyLmZvbnRDb2xvcixwLnN0eWxlLmJvcmRlcj1cIm5vbmVcIixWKHAse1dlYmtpdFVzZXJTZWxlY3Q6XCJub25lXCIsTW96VXNlclNlbGVjdDpcIm5vbmVcIixtc1VzZXJTZWxlY3Q6XCJub25lXCIsdXNlclNlbGVjdDpcIm5vbmVcIn0pKTtwLmdldEF0dHJpYnV0ZShcInN0YXRlXCIpIT09ciYmKHAuc2V0QXR0cmlidXRlKFwic3RhdGVcIixyKSxwLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImJ1dHRvblwiKSxWKHAse3BhZGRpbmc6XCI1cHggMTJweFwiLGN1cnNvcjpcInBvaW50ZXJcIixcImZsb2F0XCI6XCJsZWZ0XCIsd2lkdGg6XCI0MHB4XCIsaGVpZ2h0OlwiMjVweFwiLG91dGxpbmU6XCIwcHhcIix2ZXJ0aWNhbEFsaWduOlwiYmFzZWxpbmVcIixsaW5lSGVpZ2h0OlwiMFwifSkscC5pbm5lckhUTUw9XCI8aW1nIHNyYz0nXCIra2Jbcl0uaW1hZ2UrXCInIGFsdD0nXCIrXG5oLl9jdWx0dXJlSW5mb1tyK1wiVGV4dFwiXStcIicgLz5cIixWKHAuY2hpbGROb2Rlc1swXSx7aGVpZ2h0OlwiOTUlXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIn0pKTtwLnNldEF0dHJpYnV0ZShcInRpdGxlXCIsaC5fY3VsdHVyZUluZm9bcitcIlRleHRcIl0pfWZ1bmN0aW9uIE1hKCl7Zm9yKHZhciBoPW51bGwscD0wO3A8YXJndW1lbnRzLmxlbmd0aDtwKyspaD1hcmd1bWVudHNbcF0saC5zdHlsZSYmKGguc3R5bGUuZGlzcGxheT1cImlubGluZVwiKX1mdW5jdGlvbiB3YSgpe2Zvcih2YXIgaD1udWxsLHA9MDtwPGFyZ3VtZW50cy5sZW5ndGg7cCsrKShoPWFyZ3VtZW50c1twXSkmJmguc3R5bGUmJihoLnN0eWxlLmRpc3BsYXk9XCJub25lXCIpfWZ1bmN0aW9uIFRhKGgscCxyLHcsaGEpe2lmKG51bGw9PT1ofHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGgpcmV0dXJuXCJ1bmRlZmluZWRcIj09PXR5cGVvZiByP3A6cjtoPXBhcnNlRmxvYXQoaC50b1N0cmluZygpKSooMDw9aC50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpP1xucC8xMDA6MSk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3JiYoaD1NYXRoLm1pbih3LGgpLFwidW5kZWZpbmVkXCIhPT10eXBlb2YgaGEmJihoPU1hdGgubWF4KGhhLGgpKSk7cmV0dXJuIWlzTmFOKGgpJiZoPD1wJiYwPD1oP2g6XCJ1bmRlZmluZWRcIj09PXR5cGVvZiByP3A6cn1mdW5jdGlvbiBHKGgscCxFLHcsaGEpe3RoaXMuX2RlZmF1bHRzS2V5PWg7dGhpcy5fdGhlbWVPcHRpb25zS2V5PXA7dGhpcy5faW5kZXg9dzt0aGlzLnBhcmVudD1oYTt0aGlzLl9ldmVudExpc3RlbmVycz1bXTtoPXt9O3RoaXMudGhlbWUmJnIodGhpcy5wYXJlbnQpJiZyKHApJiZyKHcpP2g9cih0aGlzLnByZWRlZmluZWRUaGVtZXNbdGhpcy50aGVtZV0pP3RoaXMucHJlZGVmaW5lZFRoZW1lcy5saWdodDE6dGhpcy5wcmVkZWZpbmVkVGhlbWVzW3RoaXMudGhlbWVdOnRoaXMucGFyZW50JiYodGhpcy5wYXJlbnQudGhlbWVPcHRpb25zJiZ0aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbcF0pJiYobnVsbD09PXc/aD10aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbcF06XG4wPHRoaXMucGFyZW50LnRoZW1lT3B0aW9uc1twXS5sZW5ndGgmJih3PU1hdGgubWluKHRoaXMucGFyZW50LnRoZW1lT3B0aW9uc1twXS5sZW5ndGgtMSx3KSxoPXRoaXMucGFyZW50LnRoZW1lT3B0aW9uc1twXVt3XSkpO3RoaXMudGhlbWVPcHRpb25zPWg7dGhpcy5vcHRpb25zPUU/RTp7X2lzUGxhY2Vob2xkZXI6ITB9O3RoaXMuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMsaCl9ZnVuY3Rpb24gRmEoaCxwLHIsdyxoYSl7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBoYSYmKGhhPTApO3RoaXMuX3BhZGRpbmc9aGE7dGhpcy5feDE9aDt0aGlzLl95MT1wO3RoaXMuX3gyPXI7dGhpcy5feTI9dzt0aGlzLl9yaWdodE9jY3VwaWVkPXRoaXMuX2xlZnRPY2N1cGllZD10aGlzLl9ib3R0b21PY2N1cGllZD10aGlzLl90b3BPY2N1cGllZD10aGlzLl9wYWRkaW5nfWZ1bmN0aW9uIGphKGgscCl7amEuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJUZXh0QmxvY2tcIixudWxsLHAsbnVsbCxudWxsKTt0aGlzLmN0eD1cbmg7dGhpcy5faXNEaXJ0eT0hMDt0aGlzLl93cmFwcGVkVGV4dD1udWxsO3RoaXMuX2luaXRpYWxpemUoKX1mdW5jdGlvbiBVYShoLHApe1VhLmJhc2UuY29uc3RydWN0b3IuY2FsbCh0aGlzLFwiVG9vbGJhclwiLFwidG9vbGJhclwiLHAsbnVsbCxoKTt0aGlzLmNoYXJ0PWg7dGhpcy5jYW52YXM9aC5jYW52YXM7dGhpcy5jdHg9dGhpcy5jaGFydC5jdHg7dGhpcy5vcHRpb25zTmFtZT1cInRvb2xiYXJcIn1mdW5jdGlvbiB6YShoLHApe3phLmJhc2UuY29uc3RydWN0b3IuY2FsbCh0aGlzLFwiVGl0bGVcIixcInRpdGxlXCIscCxudWxsLGgpO3RoaXMuY2hhcnQ9aDt0aGlzLmNhbnZhcz1oLmNhbnZhczt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLm9wdGlvbnNOYW1lPVwidGl0bGVcIjtpZihyKHRoaXMub3B0aW9ucy5tYXJnaW4pJiZoLm9wdGlvbnMuc3VidGl0bGVzKWZvcih2YXIgRT1oLm9wdGlvbnMuc3VidGl0bGVzLHc9MDt3PEUubGVuZ3RoO3crKylpZigocihFW3ddLmhvcml6b250YWxBbGlnbikmJlxuXCJjZW50ZXJcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWdufHxFW3ddLmhvcml6b250YWxBbGlnbj09PXRoaXMuaG9yaXpvbnRhbEFsaWduKSYmKHIoRVt3XS52ZXJ0aWNhbEFsaWduKSYmXCJ0b3BcIj09PXRoaXMudmVydGljYWxBbGlnbnx8RVt3XS52ZXJ0aWNhbEFsaWduPT09dGhpcy52ZXJ0aWNhbEFsaWduKSYmIUVbd10uZG9ja0luc2lkZVBsb3RBcmVhPT09IXRoaXMuZG9ja0luc2lkZVBsb3RBcmVhKXt0aGlzLm1hcmdpbj0wO2JyZWFrfVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmZvbnRTaXplJiYodGhpcy5mb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmZvbnRTaXplKSk7dGhpcy5oZWlnaHQ9dGhpcy53aWR0aD1udWxsO3RoaXMuYm91bmRzPXt4MTpudWxsLHkxOm51bGwseDI6bnVsbCx5MjpudWxsfX1mdW5jdGlvbiBKYShoLHAscil7SmEuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJTdWJ0aXRsZVwiLFwic3VidGl0bGVzXCIscCxyLGgpO1xudGhpcy5jaGFydD1oO3RoaXMuY2FudmFzPWguY2FudmFzO3RoaXMuY3R4PXRoaXMuY2hhcnQuY3R4O3RoaXMub3B0aW9uc05hbWU9XCJzdWJ0aXRsZXNcIjt0aGlzLmlzT3B0aW9uc0luQXJyYXk9ITA7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMuZm9udFNpemUmJih0aGlzLmZvbnRTaXplPXRoaXMuY2hhcnQuZ2V0QXV0b0ZvbnRTaXplKHRoaXMuZm9udFNpemUpKTt0aGlzLmhlaWdodD10aGlzLndpZHRoPW51bGw7dGhpcy5ib3VuZHM9e3gxOm51bGwseTE6bnVsbCx4MjpudWxsLHkyOm51bGx9fWZ1bmN0aW9uIFZhKCl7dGhpcy5wb29sPVtdfWZ1bmN0aW9uIEthKGgpe3ZhciBwO2gmJkxhW2hdJiYocD1MYVtoXSk7S2EuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJDdWx0dXJlSW5mb1wiLG51bGwscCxudWxsLG51bGwpfXZhciBJYT0hMSx2YT17fSx3PSEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0LHBhPXtDaGFydDp7d2lkdGg6NTAwLFxuaGVpZ2h0OjQwMCx6b29tRW5hYmxlZDohMSx6b29tVHlwZTpcInhcIixiYWNrZ3JvdW5kQ29sb3I6XCJ3aGl0ZVwiLHRoZW1lOlwibGlnaHQxXCIsYW5pbWF0aW9uRW5hYmxlZDohMSxhbmltYXRpb25EdXJhdGlvbjoxMjAwLGRhdGFQb2ludFdpZHRoOm51bGwsZGF0YVBvaW50TWluV2lkdGg6bnVsbCxkYXRhUG9pbnRNYXhXaWR0aDpudWxsLGNvbG9yU2V0OlwiY29sb3JTZXQxXCIsY3VsdHVyZTpcImVuXCIsY3JlZGl0VGV4dDpcIkNhbnZhc0pTXCIsaW50ZXJhY3Rpdml0eUVuYWJsZWQ6ITAsZXhwb3J0RW5hYmxlZDohMSxleHBvcnRGaWxlTmFtZTpcIkNoYXJ0XCIscmFuZ2VDaGFuZ2luZzpudWxsLHJhbmdlQ2hhbmdlZDpudWxsLHB1YmxpY1Byb3BlcnRpZXM6e3RpdGxlOlwicmVhZFdyaXRlXCIsc3VidGl0bGVzOlwicmVhZFdyaXRlXCIsdG9vbGJhcjpcInJlYWRXcml0ZVwiLHRvb2xUaXA6XCJyZWFkV3JpdGVcIixsZWdlbmQ6XCJyZWFkV3JpdGVcIixheGlzWDpcInJlYWRXcml0ZVwiLGF4aXNZOlwicmVhZFdyaXRlXCIsYXhpc1gyOlwicmVhZFdyaXRlXCIsXG5heGlzWTI6XCJyZWFkV3JpdGVcIixkYXRhOlwicmVhZFdyaXRlXCIsb3B0aW9uczpcInJlYWRXcml0ZVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY29udGFpbmVyOlwicmVhZE9ubHlcIixzZWxlY3RlZENvbG9yU2V0OlwicmVhZE9ubHlcIn19LFRpdGxlOntwYWRkaW5nOjAsdGV4dDpudWxsLHZlcnRpY2FsQWxpZ246XCJ0b3BcIixob3Jpem9udGFsQWxpZ246XCJjZW50ZXJcIixmb250U2l6ZToyMCxmb250RmFtaWx5OlwiQ2FsaWJyaVwiLGZvbnRXZWlnaHQ6XCJub3JtYWxcIixmb250Q29sb3I6XCJibGFja1wiLGZvbnRTdHlsZTpcIm5vcm1hbFwiLGJvcmRlclRoaWNrbmVzczowLGJvcmRlckNvbG9yOlwiYmxhY2tcIixjb3JuZXJSYWRpdXM6MCxiYWNrZ3JvdW5kQ29sb3I6dz9cInRyYW5zcGFyZW50XCI6bnVsbCxtYXJnaW46NSx3cmFwOiEwLG1heFdpZHRoOm51bGwsZG9ja0luc2lkZVBsb3RBcmVhOiExLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixib3VuZHM6XCJyZWFkT25seVwiLGNoYXJ0OlwicmVhZE9ubHlcIn19LFxuU3VidGl0bGU6e3BhZGRpbmc6MCx0ZXh0Om51bGwsdmVydGljYWxBbGlnbjpcInRvcFwiLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwiLGZvbnRTaXplOjE0LGZvbnRGYW1pbHk6XCJDYWxpYnJpXCIsZm9udFdlaWdodDpcIm5vcm1hbFwiLGZvbnRDb2xvcjpcImJsYWNrXCIsZm9udFN0eWxlOlwibm9ybWFsXCIsYm9yZGVyVGhpY2tuZXNzOjAsYm9yZGVyQ29sb3I6XCJibGFja1wiLGNvcm5lclJhZGl1czowLGJhY2tncm91bmRDb2xvcjpudWxsLG1hcmdpbjoyLHdyYXA6ITAsbWF4V2lkdGg6bnVsbCxkb2NrSW5zaWRlUGxvdEFyZWE6ITEscHVibGljUHJvcGVydGllczp7b3B0aW9uczpcInJlYWRXcml0ZVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sVG9vbGJhcjp7aXRlbUJhY2tncm91bmRDb2xvcjpcIndoaXRlXCIsaXRlbUJhY2tncm91bmRDb2xvck9uSG92ZXI6XCIjMjE5NmYzXCIsYnV0dG9uQm9yZGVyQ29sb3I6XCIjMjE5NmYzXCIsYnV0dG9uQm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlwiYmxhY2tcIixcbmZvbnRDb2xvck9uSG92ZXI6XCJ3aGl0ZVwiLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixjaGFydDpcInJlYWRPbmx5XCJ9fSxMZWdlbmQ6e25hbWU6bnVsbCx2ZXJ0aWNhbEFsaWduOlwiY2VudGVyXCIsaG9yaXpvbnRhbEFsaWduOlwicmlnaHRcIixmb250U2l6ZToxNCxmb250RmFtaWx5OlwiY2FsaWJyaVwiLGZvbnRXZWlnaHQ6XCJub3JtYWxcIixmb250Q29sb3I6XCJibGFja1wiLGZvbnRTdHlsZTpcIm5vcm1hbFwiLGN1cnNvcjpudWxsLGl0ZW1tb3VzZW92ZXI6bnVsbCxpdGVtbW91c2VvdXQ6bnVsbCxpdGVtbW91c2Vtb3ZlOm51bGwsaXRlbWNsaWNrOm51bGwsZG9ja0luc2lkZVBsb3RBcmVhOiExLHJldmVyc2VkOiExLGJhY2tncm91bmRDb2xvcjp3P1widHJhbnNwYXJlbnRcIjpudWxsLGJvcmRlckNvbG9yOnc/XCJ0cmFuc3BhcmVudFwiOm51bGwsYm9yZGVyVGhpY2tuZXNzOjAsY29ybmVyUmFkaXVzOjAsbWF4V2lkdGg6bnVsbCxtYXhIZWlnaHQ6bnVsbCxtYXJrZXJNYXJnaW46bnVsbCxcbml0ZW1NYXhXaWR0aDpudWxsLGl0ZW1XaWR0aDpudWxsLGl0ZW1XcmFwOiEwLGl0ZW1UZXh0Rm9ybWF0dGVyOm51bGwscHVibGljUHJvcGVydGllczp7b3B0aW9uczpcInJlYWRXcml0ZVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sVG9vbFRpcDp7ZW5hYmxlZDohMCxzaGFyZWQ6ITEsYW5pbWF0aW9uRW5hYmxlZDohMCxjb250ZW50Om51bGwsY29udGVudEZvcm1hdHRlcjpudWxsLHJldmVyc2VkOiExLGJhY2tncm91bmRDb2xvcjp3P1wicmdiYSgyNTUsMjU1LDI1NSwuOSlcIjpcInJnYigyNTUsMjU1LDI1NSlcIixib3JkZXJDb2xvcjpudWxsLGJvcmRlclRoaWNrbmVzczoyLGNvcm5lclJhZGl1czo1LGZvbnRTaXplOjE0LGZvbnRDb2xvcjpcImJsYWNrXCIsZm9udEZhbWlseTpcIkNhbGlicmksIEFyaWFsLCBHZW9yZ2lhLCBzZXJpZjtcIixmb250V2VpZ2h0Olwibm9ybWFsXCIsZm9udFN0eWxlOlwiaXRhbGljXCIsdXBkYXRlZDpudWxsLGhpZGRlbjpudWxsLHB1YmxpY1Byb3BlcnRpZXM6e29wdGlvbnM6XCJyZWFkV3JpdGVcIixcbmNoYXJ0OlwicmVhZE9ubHlcIn19LEF4aXM6e21pbmltdW06bnVsbCxtYXhpbXVtOm51bGwsdmlld3BvcnRNaW5pbXVtOm51bGwsdmlld3BvcnRNYXhpbXVtOm51bGwsaW50ZXJ2YWw6bnVsbCxpbnRlcnZhbFR5cGU6bnVsbCxyZXZlcnNlZDohMSxsb2dhcml0aG1pYzohMSxsb2dhcml0aG1CYXNlOjEwLHRpdGxlOm51bGwsdGl0bGVGb250Q29sb3I6XCJibGFja1wiLHRpdGxlRm9udFNpemU6MjAsdGl0bGVGb250RmFtaWx5OlwiYXJpYWxcIix0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIix0aXRsZUZvbnRTdHlsZTpcIm5vcm1hbFwiLHRpdGxlV3JhcDohMCx0aXRsZU1heFdpZHRoOm51bGwsdGl0bGVCYWNrZ3JvdW5kQ29sb3I6dz9cInRyYW5zcGFyZW50XCI6bnVsbCx0aXRsZUJvcmRlckNvbG9yOnc/XCJ0cmFuc3BhcmVudFwiOm51bGwsdGl0bGVCb3JkZXJUaGlja25lc3M6MCx0aXRsZUNvcm5lclJhZGl1czowLGxhYmVsQW5nbGU6MCxsYWJlbEZvbnRGYW1pbHk6XCJhcmlhbFwiLGxhYmVsRm9udENvbG9yOlwiYmxhY2tcIixcbmxhYmVsRm9udFNpemU6MTIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250U3R5bGU6XCJub3JtYWxcIixsYWJlbEF1dG9GaXQ6ITAsbGFiZWxXcmFwOiEwLGxhYmVsTWF4V2lkdGg6bnVsbCxsYWJlbEZvcm1hdHRlcjpudWxsLGxhYmVsQmFja2dyb3VuZENvbG9yOnc/XCJ0cmFuc3BhcmVudFwiOm51bGwsbGFiZWxCb3JkZXJDb2xvcjp3P1widHJhbnNwYXJlbnRcIjpudWxsLGxhYmVsQm9yZGVyVGhpY2tuZXNzOjAsbGFiZWxDb3JuZXJSYWRpdXM6MCxsYWJlbFBsYWNlbWVudDpcIm91dHNpZGVcIixsYWJlbFRleHRBbGlnbjpcImxlZnRcIixwcmVmaXg6XCJcIixzdWZmaXg6XCJcIixpbmNsdWRlWmVybzohMSx0aWNrTGVuZ3RoOjUsdGlja0NvbG9yOlwiYmxhY2tcIix0aWNrVGhpY2tuZXNzOjEsdGlja1BsYWNlbWVudDpcIm91dHNpZGVcIixsaW5lQ29sb3I6XCJibGFja1wiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwiLGdyaWRDb2xvcjpcIiNBMEEwQTBcIixncmlkVGhpY2tuZXNzOjAsXG5ncmlkRGFzaFR5cGU6XCJzb2xpZFwiLGludGVybGFjZWRDb2xvcjp3P1widHJhbnNwYXJlbnRcIjpudWxsLHZhbHVlRm9ybWF0U3RyaW5nOm51bGwsbWFyZ2luOjIscHVibGljUHJvcGVydGllczp7b3B0aW9uczpcInJlYWRXcml0ZVwiLHN0cmlwTGluZXM6XCJyZWFkV3JpdGVcIixzY2FsZUJyZWFrczpcInJlYWRXcml0ZVwiLGNyb3NzaGFpcjpcInJlYWRXcml0ZVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sU3RyaXBMaW5lOnt2YWx1ZTpudWxsLHN0YXJ0VmFsdWU6bnVsbCxlbmRWYWx1ZTpudWxsLGNvbG9yOlwib3JhbmdlXCIsb3BhY2l0eTpudWxsLHRoaWNrbmVzczoyLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsbGFiZWw6XCJcIixsYWJlbFBsYWNlbWVudDpcImluc2lkZVwiLGxhYmVsQWxpZ246XCJmYXJcIixsYWJlbFdyYXA6ITAsbGFiZWxNYXhXaWR0aDpudWxsLGxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsbGFiZWxCb3JkZXJDb2xvcjp3P1widHJhbnNwYXJlbnRcIjpudWxsLGxhYmVsQm9yZGVyVGhpY2tuZXNzOjAsXG5sYWJlbENvcm5lclJhZGl1czowLGxhYmVsRm9udEZhbWlseTpcImFyaWFsXCIsbGFiZWxGb250Q29sb3I6XCJvcmFuZ2VcIixsYWJlbEZvbnRTaXplOjEyLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udFN0eWxlOlwibm9ybWFsXCIsbGFiZWxGb3JtYXR0ZXI6bnVsbCxzaG93T25Ub3A6ITEscHVibGljUHJvcGVydGllczp7b3B0aW9uczpcInJlYWRXcml0ZVwiLGF4aXM6XCJyZWFkT25seVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sU2NhbGVCcmVha3M6e2F1dG9DYWxjdWxhdGU6ITEsY29sbGFwc2libGVUaHJlc2hvbGQ6XCIyNSVcIixtYXhOdW1iZXJPZkF1dG9CcmVha3M6MixzcGFjaW5nOjgsdHlwZTpcInN0cmFpZ2h0XCIsY29sb3I6XCIjRkZGRkZGXCIsZmlsbE9wYWNpdHk6MC45LGxpbmVUaGlja25lc3M6MixsaW5lQ29sb3I6XCIjRTE2RTZFXCIsbGluZURhc2hUeXBlOlwic29saWRcIixwdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsY3VzdG9tQnJlYWtzOlwicmVhZFdyaXRlXCIsXG5heGlzOlwicmVhZE9ubHlcIixhdXRvQnJlYWtzOlwicmVhZE9ubHlcIixib3VuZHM6XCJyZWFkT25seVwiLGNoYXJ0OlwicmVhZE9ubHlcIn19LEJyZWFrOntzdGFydFZhbHVlOm51bGwsZW5kVmFsdWU6bnVsbCxzcGFjaW5nOjgsdHlwZTpcInN0cmFpZ2h0XCIsY29sb3I6XCIjRkZGRkZGXCIsZmlsbE9wYWNpdHk6MC45LGxpbmVUaGlja25lc3M6MixsaW5lQ29sb3I6XCIjRTE2RTZFXCIsbGluZURhc2hUeXBlOlwic29saWRcIixwdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsc2NhbGVCcmVha3M6XCJyZWFkT25seVwiLGJvdW5kczpcInJlYWRPbmx5XCIsY2hhcnQ6XCJyZWFkT25seVwifX0sQ3Jvc3NoYWlyOntlbmFibGVkOiExLHNuYXBUb0RhdGFQb2ludDohMSxjb2xvcjpcImdyZXlcIixvcGFjaXR5Om51bGwsdGhpY2tuZXNzOjIsbGluZURhc2hUeXBlOlwic29saWRcIixsYWJlbDpcIlwiLGxhYmVsV3JhcDohMCxsYWJlbE1heFdpZHRoOm51bGwsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6dz9cImdyZXlcIjpudWxsLFxubGFiZWxCb3JkZXJDb2xvcjp3P1wiZ3JleVwiOm51bGwsbGFiZWxCb3JkZXJUaGlja25lc3M6MCxsYWJlbENvcm5lclJhZGl1czowLGxhYmVsRm9udEZhbWlseTp3P1wiQ2FsaWJyaSwgT3B0aW1hLCBDYW5kYXJhLCBWZXJkYW5hLCBHZW5ldmEsIHNhbnMtc2VyaWZcIjpcImNhbGlicmlcIixsYWJlbEZvbnRTaXplOjEyLGxhYmVsRm9udENvbG9yOlwiI2ZmZlwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udFN0eWxlOlwibm9ybWFsXCIsbGFiZWxGb3JtYXR0ZXI6bnVsbCx2YWx1ZUZvcm1hdFN0cmluZzpudWxsLHVwZGF0ZWQ6bnVsbCxoaWRkZW46bnVsbCxwdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsYXhpczpcInJlYWRPbmx5XCIsYm91bmRzOlwicmVhZE9ubHlcIixjaGFydDpcInJlYWRPbmx5XCJ9fSxEYXRhU2VyaWVzOntuYW1lOm51bGwsZGF0YVBvaW50czpudWxsLGxhYmVsOlwiXCIsYmV2ZWxFbmFibGVkOiExLGhpZ2hsaWdodEVuYWJsZWQ6ITAsY3Vyc29yOlwiZGVmYXVsdFwiLFxuaW5kZXhMYWJlbDpcIlwiLGluZGV4TGFiZWxQbGFjZW1lbnQ6XCJhdXRvXCIsaW5kZXhMYWJlbE9yaWVudGF0aW9uOlwiaG9yaXpvbnRhbFwiLGluZGV4TGFiZWxUZXh0QWxpZ246XCJsZWZ0XCIsaW5kZXhMYWJlbEZvbnRDb2xvcjpcImJsYWNrXCIsaW5kZXhMYWJlbEZvbnRTaXplOjEyLGluZGV4TGFiZWxGb250U3R5bGU6XCJub3JtYWxcIixpbmRleExhYmVsRm9udEZhbWlseTpcIkFyaWFsXCIsaW5kZXhMYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixpbmRleExhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsaW5kZXhMYWJlbExpbmVDb2xvcjpcImdyYXlcIixpbmRleExhYmVsTGluZVRoaWNrbmVzczoxLGluZGV4TGFiZWxMaW5lRGFzaFR5cGU6XCJzb2xpZFwiLGluZGV4TGFiZWxNYXhXaWR0aDpudWxsLGluZGV4TGFiZWxXcmFwOiEwLGluZGV4TGFiZWxGb3JtYXR0ZXI6bnVsbCxsaW5lVGhpY2tuZXNzOjIsbGluZURhc2hUeXBlOlwic29saWRcIixjb25uZWN0TnVsbERhdGE6ITEsbnVsbERhdGFMaW5lRGFzaFR5cGU6XCJkYXNoXCIsXG5jb2xvcjpudWxsLGxpbmVDb2xvcjpudWxsLHJpc2luZ0NvbG9yOlwid2hpdGVcIixmYWxsaW5nQ29sb3I6XCJyZWRcIixmaWxsT3BhY2l0eTpudWxsLHN0YXJ0QW5nbGU6MCxyYWRpdXM6bnVsbCxpbm5lclJhZGl1czpudWxsLG5lY2tIZWlnaHQ6bnVsbCxuZWNrV2lkdGg6bnVsbCxyZXZlcnNlZDohMSx2YWx1ZVJlcHJlc2VudHM6bnVsbCxsaW5rZWREYXRhU2VyaWVzSW5kZXg6bnVsbCx3aGlza2VyVGhpY2tuZXNzOjIsd2hpc2tlckRhc2hUeXBlOlwic29saWRcIix3aGlza2VyQ29sb3I6bnVsbCx3aGlza2VyTGVuZ3RoOm51bGwsc3RlbVRoaWNrbmVzczoyLHN0ZW1Db2xvcjpudWxsLHN0ZW1EYXNoVHlwZTpcInNvbGlkXCIsdXBwZXJCb3hDb2xvcjpcIndoaXRlXCIsbG93ZXJCb3hDb2xvcjpcIndoaXRlXCIsdHlwZTpcImNvbHVtblwiLHhWYWx1ZVR5cGU6XCJudW1iZXJcIixheGlzWFR5cGU6XCJwcmltYXJ5XCIsYXhpc1lUeXBlOlwicHJpbWFyeVwiLGF4aXNYSW5kZXg6MCxheGlzWUluZGV4OjAseFZhbHVlRm9ybWF0U3RyaW5nOm51bGwsXG55VmFsdWVGb3JtYXRTdHJpbmc6bnVsbCx6VmFsdWVGb3JtYXRTdHJpbmc6bnVsbCxwZXJjZW50Rm9ybWF0U3RyaW5nOm51bGwsc2hvd0luTGVnZW5kOm51bGwsbGVnZW5kTWFya2VyVHlwZTpudWxsLGxlZ2VuZE1hcmtlckNvbG9yOm51bGwsbGVnZW5kVGV4dDpudWxsLGxlZ2VuZE1hcmtlckJvcmRlckNvbG9yOnc/XCJ0cmFuc3BhcmVudFwiOm51bGwsbGVnZW5kTWFya2VyQm9yZGVyVGhpY2tuZXNzOjAsbWFya2VyVHlwZTpcImNpcmNsZVwiLG1hcmtlckNvbG9yOm51bGwsbWFya2VyU2l6ZTpudWxsLG1hcmtlckJvcmRlckNvbG9yOnc/XCJ0cmFuc3BhcmVudFwiOm51bGwsbWFya2VyQm9yZGVyVGhpY2tuZXNzOjAsbW91c2VvdmVyOm51bGwsbW91c2VvdXQ6bnVsbCxtb3VzZW1vdmU6bnVsbCxjbGljazpudWxsLHRvb2xUaXBDb250ZW50Om51bGwsdmlzaWJsZTohMCxwdWJsaWNQcm9wZXJ0aWVzOntvcHRpb25zOlwicmVhZFdyaXRlXCIsYXhpc1g6XCJyZWFkV3JpdGVcIixheGlzWTpcInJlYWRXcml0ZVwiLFxuY2hhcnQ6XCJyZWFkT25seVwifX0sVGV4dEJsb2NrOnt4OjAseTowLHdpZHRoOm51bGwsaGVpZ2h0Om51bGwsbWF4V2lkdGg6bnVsbCxtYXhIZWlnaHQ6bnVsbCxwYWRkaW5nOjAsYW5nbGU6MCx0ZXh0OlwiXCIsaG9yaXpvbnRhbEFsaWduOlwiY2VudGVyXCIsdGV4dEFsaWduOlwibGVmdFwiLGZvbnRTaXplOjEyLGZvbnRGYW1pbHk6XCJjYWxpYnJpXCIsZm9udFdlaWdodDpcIm5vcm1hbFwiLGZvbnRDb2xvcjpcImJsYWNrXCIsZm9udFN0eWxlOlwibm9ybWFsXCIsYm9yZGVyVGhpY2tuZXNzOjAsYm9yZGVyQ29sb3I6XCJibGFja1wiLGNvcm5lclJhZGl1czowLGJhY2tncm91bmRDb2xvcjpudWxsLHRleHRCYXNlbGluZTpcInRvcFwifSxDdWx0dXJlSW5mbzp7ZGVjaW1hbFNlcGFyYXRvcjpcIi5cIixkaWdpdEdyb3VwU2VwYXJhdG9yOlwiLFwiLHpvb21UZXh0OlwiWm9vbVwiLHBhblRleHQ6XCJQYW5cIixyZXNldFRleHQ6XCJSZXNldFwiLG1lbnVUZXh0OlwiTW9yZSBPcHRpb25zXCIsc2F2ZUpQR1RleHQ6XCJTYXZlIGFzIEpQRUdcIixzYXZlUE5HVGV4dDpcIlNhdmUgYXMgUE5HXCIsXG5wcmludFRleHQ6XCJQcmludFwiLGRheXM6XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKSxzaG9ydERheXM6XCJTdW4gTW9uIFR1ZSBXZWQgVGh1IEZyaSBTYXRcIi5zcGxpdChcIiBcIiksbW9udGhzOlwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXCIuc3BsaXQoXCIgXCIpfX0sTGE9e2VuOnt9fSxCPXc/XCJUcmVidWNoZXQgTVMsIEhlbHZldGljYSwgc2Fucy1zZXJpZlwiOlwiQXJpYWxcIixHYT13P1wiSW1wYWN0LCBDaGFyY29hbCwgc2Fucy1zZXJpZlwiOlwiQXJpYWxcIixBYT17Y29sb3JTZXQxOlwiIzRGODFCQyAjQzA1MDRFICM5QkJCNTggIzIzQkZBQSAjODA2NEExICM0QUFDQzUgI0Y3OTY0NyAjN0Y2MDg0ICM3N0EwMzMgIzMzNTU4QiAjRTU5NTY2XCIuc3BsaXQoXCIgXCIpLFxuY29sb3JTZXQyOlwiIzZENzhBRCAjNTFDREEwICNERjc5NzAgIzRDOUNBMCAjQUU3RDk5ICNDOUQ0NUMgIzU1OTJBRCAjREY4NzREICM1MkJDQTggIzhFN0FBMyAjRTNDQjY0ICNDNzdCODUgI0MzOTc2MiAjOEREMTdFICNCNTc5NTIgI0ZDQzI2Q1wiLnNwbGl0KFwiIFwiKSxjb2xvclNldDM6XCIjOENBMUJDICMzNjg0NUMgIzAxN0U4MiAjOENCOUQwICM3MDhDOTggIzk0ODM4RCAjRjA4ODkxICMwMzY2QTcgIzAwODI3NiAjRUU3NzU3ICNFNUJBM0EgI0YyOTkwQiAjMDM1NTdCICM3ODI5NzBcIi5zcGxpdChcIiBcIil9LEssYWEsUSxVLFo7YWE9XCIjMzMzMzMzXCI7UT1cIiMwMDAwMDBcIjtLPVwiIzY2NjY2NlwiO1o9VT1cIiMwMDAwMDBcIjt2YXIgZmE9MjAsdj0xNCxXYT17Y29sb3JTZXQ6XCJjb2xvclNldDFcIixiYWNrZ3JvdW5kQ29sb3I6XCIjRkZGRkZGXCIsdGl0bGU6e2ZvbnRGYW1pbHk6R2EsZm9udFNpemU6MzIsZm9udENvbG9yOmFhLGZvbnRXZWlnaHQ6XCJub3JtYWxcIix2ZXJ0aWNhbEFsaWduOlwidG9wXCIsXG5tYXJnaW46NX0sc3VidGl0bGVzOlt7Zm9udEZhbWlseTpHYSxmb250U2l6ZTp2LGZvbnRDb2xvcjphYSxmb250V2VpZ2h0Olwibm9ybWFsXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fV0sZGF0YTpbe2luZGV4TGFiZWxGb250RmFtaWx5OkIsaW5kZXhMYWJlbEZvbnRTaXplOnYsaW5kZXhMYWJlbEZvbnRDb2xvcjphYSxpbmRleExhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGluZGV4TGFiZWxMaW5lVGhpY2tuZXNzOjF9XSxheGlzWDpbe3RpdGxlRm9udEZhbWlseTpCLHRpdGxlRm9udFNpemU6ZmEsdGl0bGVGb250Q29sb3I6YWEsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlEsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpLLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6SyxncmlkVGhpY2tuZXNzOjAsZ3JpZENvbG9yOkssc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTpCLFxubGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiI0ZGNzMwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsY29sb3I6XCIjRkY3MzAwXCIsdGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNFRUVFRUVcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpaLGNvbG9yOlUsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiNCQkJCQkJcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIn19XSxheGlzWDI6W3t0aXRsZUZvbnRGYW1pbHk6Qix0aXRsZUZvbnRTaXplOmZhLHRpdGxlRm9udENvbG9yOmFhLHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixcbmxhYmVsRm9udENvbG9yOlEsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpLLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6SyxncmlkVGhpY2tuZXNzOjAsZ3JpZENvbG9yOkssc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRUVFRUVFXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6Wixjb2xvcjpVLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRhc2hcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjQkJCQkJCXCIsbGluZVRoaWNrbmVzczoxLFxubGluZURhc2hUeXBlOlwic29saWRcIn19XSxheGlzWTpbe3RpdGxlRm9udEZhbWlseTpCLHRpdGxlRm9udFNpemU6ZmEsdGl0bGVGb250Q29sb3I6YWEsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlEsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpLLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6SyxncmlkVGhpY2tuZXNzOjEsZ3JpZENvbG9yOkssc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRUVFRUVFXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsXG5sYWJlbEJhY2tncm91bmRDb2xvcjpaLGNvbG9yOlUsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiNCQkJCQkJcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIn19XSxheGlzWTI6W3t0aXRsZUZvbnRGYW1pbHk6Qix0aXRsZUZvbnRTaXplOmZhLHRpdGxlRm9udENvbG9yOmFhLHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpRLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MSxsaW5lQ29sb3I6Syx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOkssZ3JpZFRoaWNrbmVzczoxLGdyaWRDb2xvcjpLLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsXG5sYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRUVFRUVFXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6Wixjb2xvcjpVLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRhc2hcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjQkJCQkJCXCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCJ9fV0sbGVnZW5kOntmb250RmFtaWx5OkIsZm9udFNpemU6MTQsZm9udENvbG9yOmFhLGZvbnRXZWlnaHQ6XCJib2xkXCIsdmVydGljYWxBbGlnbjpcImJvdHRvbVwiLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwifSx0b29sVGlwOntmb250RmFtaWx5OkIsZm9udFNpemU6MTQsZm9udFN0eWxlOlwibm9ybWFsXCIsY29ybmVyUmFkaXVzOjAsYm9yZGVyVGhpY2tuZXNzOjF9LFxudG9vbGJhcjp7aXRlbUJhY2tncm91bmRDb2xvcjpcIndoaXRlXCIsaXRlbUJhY2tncm91bmRDb2xvck9uSG92ZXI6XCIjMjE5NmYzXCIsYnV0dG9uQm9yZGVyQ29sb3I6XCIjMjE5NmYzXCIsYnV0dG9uQm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlwiYmxhY2tcIixmb250Q29sb3JPbkhvdmVyOlwid2hpdGVcIn19O1E9YWE9XCIjRjVGNUY1XCI7Sz1cIiNGRkZGRkZcIjtVPVwiIzQwQkFGMVwiO1o9XCIjRjVGNUY1XCI7dmFyIGZhPTIwLHY9MTQsYmI9e2NvbG9yU2V0OlwiY29sb3JTZXQyXCIsdGl0bGU6e2ZvbnRGYW1pbHk6Qixmb250U2l6ZTozMyxmb250Q29sb3I6XCIjM0EzQTNBXCIsZm9udFdlaWdodDpcImJvbGRcIix2ZXJ0aWNhbEFsaWduOlwidG9wXCIsbWFyZ2luOjV9LHN1YnRpdGxlczpbe2ZvbnRGYW1pbHk6Qixmb250U2l6ZTp2LGZvbnRDb2xvcjpcIiMzQTNBM0FcIixmb250V2VpZ2h0Olwibm9ybWFsXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fV0sZGF0YTpbe2luZGV4TGFiZWxGb250RmFtaWx5OkIsaW5kZXhMYWJlbEZvbnRTaXplOnYsXG5pbmRleExhYmVsRm9udENvbG9yOlwiIzY2NjY2NlwiLGluZGV4TGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsaW5kZXhMYWJlbExpbmVUaGlja25lc3M6MX1dLGF4aXNYOlt7dGl0bGVGb250RmFtaWx5OkIsdGl0bGVGb250U2l6ZTpmYSx0aXRsZUZvbnRDb2xvcjpcIiM2NjY2NjZcIix0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjNjY2NjY2XCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpcIiNCQkJCQkJcIix0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOlwiI0JCQkJCQlwiLGdyaWRUaGlja25lc3M6MSxncmlkQ29sb3I6XCIjQkJCQkJCXCIsc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNGRkE1MDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGQTUwMFwiLFxudGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNFRUVFRUVcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpcImJsYWNrXCIsY29sb3I6XCJibGFja1wiLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRvdFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiNCQkJCQkJcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIn19XSxheGlzWDI6W3t0aXRsZUZvbnRGYW1pbHk6Qix0aXRsZUZvbnRTaXplOmZhLHRpdGxlRm9udENvbG9yOlwiIzY2NjY2NlwiLHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiM2NjY2NjZcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjEsbGluZUNvbG9yOlwiI0JCQkJCQlwiLHRpY2tDb2xvcjpcIiNCQkJCQkJcIixcbnRpY2tUaGlja25lc3M6MSxncmlkVGhpY2tuZXNzOjEsZ3JpZENvbG9yOlwiI0JCQkJCQlwiLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRkZBNTAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRkE1MDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiI0VFRUVFRVwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOlwiYmxhY2tcIixjb2xvcjpcImJsYWNrXCIsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZG90XCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiI0JCQkJCQlwiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwifX1dLGF4aXNZOlt7dGl0bGVGb250RmFtaWx5OkIsXG50aXRsZUZvbnRTaXplOmZhLHRpdGxlRm9udENvbG9yOlwiIzY2NjY2NlwiLHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiM2NjY2NjZcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjAsbGluZUNvbG9yOlwiI0JCQkJCQlwiLHRpY2tDb2xvcjpcIiNCQkJCQkJcIix0aWNrVGhpY2tuZXNzOjEsZ3JpZFRoaWNrbmVzczoxLGdyaWRDb2xvcjpcIiNCQkJCQkJcIixzdHJpcExpbmVzOlt7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiI0ZGQTUwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsY29sb3I6XCIjRkZBNTAwXCIsdGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNFRUVFRUVcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixcbmxhYmVsQmFja2dyb3VuZENvbG9yOlwiYmxhY2tcIixjb2xvcjpcImJsYWNrXCIsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZG90XCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiI0JCQkJCQlwiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwifX1dLGF4aXNZMjpbe3RpdGxlRm9udEZhbWlseTpCLHRpdGxlRm9udFNpemU6ZmEsdGl0bGVGb250Q29sb3I6XCIjNjY2NjY2XCIsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiIzY2NjY2NlwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MCxsaW5lQ29sb3I6XCIjQkJCQkJCXCIsdGlja0NvbG9yOlwiI0JCQkJCQlwiLHRpY2tUaGlja25lc3M6MSxncmlkVGhpY2tuZXNzOjEsZ3JpZENvbG9yOlwiI0JCQkJCQlwiLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsXG5sYWJlbEZvbnRDb2xvcjpcIiNGRkE1MDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGQTUwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRUVFRUVFXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6XCJibGFja1wiLGNvbG9yOlwiYmxhY2tcIix0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkb3RcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjQkJCQkJCXCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCJ9fV0sbGVnZW5kOntmb250RmFtaWx5OkIsZm9udFNpemU6MTQsZm9udENvbG9yOlwiIzNBM0EzQVwiLGZvbnRXZWlnaHQ6XCJib2xkXCIsdmVydGljYWxBbGlnbjpcImJvdHRvbVwiLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwifSx0b29sVGlwOntmb250RmFtaWx5OkIsXG5mb250U2l6ZToxNCxmb250U3R5bGU6XCJub3JtYWxcIixjb3JuZXJSYWRpdXM6MCxib3JkZXJUaGlja25lc3M6MX0sdG9vbGJhcjp7aXRlbUJhY2tncm91bmRDb2xvcjpcIndoaXRlXCIsaXRlbUJhY2tncm91bmRDb2xvck9uSG92ZXI6XCIjMjE5NmYzXCIsYnV0dG9uQm9yZGVyQ29sb3I6XCIjMjE5NmYzXCIsYnV0dG9uQm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlwiYmxhY2tcIixmb250Q29sb3JPbkhvdmVyOlwid2hpdGVcIn19O1E9YWE9XCIjRjVGNUY1XCI7Sz1cIiNGRkZGRkZcIjtVPVwiIzQwQkFGMVwiO1o9XCIjRjVGNUY1XCI7ZmE9MjA7dj0xNDtHYT17Y29sb3JTZXQ6XCJjb2xvclNldDEyXCIsYmFja2dyb3VuZENvbG9yOlwiIzJBMkEyQVwiLHRpdGxlOntmb250RmFtaWx5OkdhLGZvbnRTaXplOjMyLGZvbnRDb2xvcjphYSxmb250V2VpZ2h0Olwibm9ybWFsXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fSxzdWJ0aXRsZXM6W3tmb250RmFtaWx5OkdhLGZvbnRTaXplOnYsZm9udENvbG9yOmFhLGZvbnRXZWlnaHQ6XCJub3JtYWxcIixcbnZlcnRpY2FsQWxpZ246XCJ0b3BcIixtYXJnaW46NX1dLHRvb2xiYXI6e2l0ZW1CYWNrZ3JvdW5kQ29sb3I6XCIjNjY2NjY2XCIsaXRlbUJhY2tncm91bmRDb2xvck9uSG92ZXI6XCIjRkY3MzcyXCIsYnV0dG9uQm9yZGVyQ29sb3I6XCIjRkY3MzcyXCIsYnV0dG9uQm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlwiI0Y1RjVGNVwiLGZvbnRDb2xvck9uSG92ZXI6XCIjRjVGNUY1XCJ9LGRhdGE6W3tpbmRleExhYmVsRm9udEZhbWlseTpCLGluZGV4TGFiZWxGb250U2l6ZTp2LGluZGV4TGFiZWxGb250Q29sb3I6USxpbmRleExhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGluZGV4TGFiZWxMaW5lVGhpY2tuZXNzOjF9XSxheGlzWDpbe3RpdGxlRm9udEZhbWlseTpCLHRpdGxlRm9udFNpemU6ZmEsdGl0bGVGb250Q29sb3I6USx0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6USxsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjEsXG5saW5lQ29sb3I6Syx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOkssZ3JpZFRoaWNrbmVzczowLGdyaWRDb2xvcjpLLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOlosY29sb3I6VSx0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkYXNoXCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiIzc3Nzc3N1wiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwiLGNvbG9yOlwiIzExMTExMVwifX1dLGF4aXNYMjpbe3RpdGxlRm9udEZhbWlseTpCLFxudGl0bGVGb250U2l6ZTpmYSx0aXRsZUZvbnRDb2xvcjpRLHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpRLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxpbmVUaGlja25lc3M6MSxsaW5lQ29sb3I6Syx0aWNrVGhpY2tuZXNzOjEsdGlja0NvbG9yOkssZ3JpZFRoaWNrbmVzczowLGdyaWRDb2xvcjpLLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOlosY29sb3I6VSx0aGlja25lc3M6MSxcbmxpbmVEYXNoVHlwZTpcImRhc2hcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjNzc3Nzc3XCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsY29sb3I6XCIjMTExMTExXCJ9fV0sYXhpc1k6W3t0aXRsZUZvbnRGYW1pbHk6Qix0aXRsZUZvbnRTaXplOmZhLHRpdGxlRm9udENvbG9yOlEsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlEsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpLLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6SyxncmlkVGhpY2tuZXNzOjEsZ3JpZENvbG9yOkssc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLFxuY29sb3I6XCIjRkY3MzAwXCIsdGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiMwMDAwMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpaLGNvbG9yOlUsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiM3Nzc3NzdcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIixjb2xvcjpcIiMxMTExMTFcIn19XSxheGlzWTI6W3t0aXRsZUZvbnRGYW1pbHk6Qix0aXRsZUZvbnRTaXplOmZhLHRpdGxlRm9udENvbG9yOlEsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlEsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpLLHRpY2tUaGlja25lc3M6MSxcbnRpY2tDb2xvcjpLLGdyaWRUaGlja25lc3M6MSxncmlkQ29sb3I6SyxzdHJpcExpbmVzOlt7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiI0ZGNzMwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsY29sb3I6XCIjRkY3MzAwXCIsdGhpY2tuZXNzOjF9XSxjcm9zc2hhaXI6e2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiMwMDAwMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpaLGNvbG9yOlUsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiM3Nzc3NzdcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIixjb2xvcjpcIiMxMTExMTFcIn19XSxsZWdlbmQ6e2ZvbnRGYW1pbHk6Qixmb250U2l6ZToxNCxcbmZvbnRDb2xvcjphYSxmb250V2VpZ2h0OlwiYm9sZFwiLHZlcnRpY2FsQWxpZ246XCJib3R0b21cIixob3Jpem9udGFsQWxpZ246XCJjZW50ZXJcIn0sdG9vbFRpcDp7Zm9udEZhbWlseTpCLGZvbnRTaXplOjE0LGZvbnRTdHlsZTpcIm5vcm1hbFwiLGNvcm5lclJhZGl1czowLGJvcmRlclRoaWNrbmVzczoxLGZvbnRDb2xvcjpRLGJhY2tncm91bmRDb2xvcjpcInJnYmEoMCwgMCwgMCwgLjcpXCJ9fTtLPVwiI0ZGRkZGRlwiO1E9YWE9XCIjRkFGQUZBXCI7VT1cIiM0MEJBRjFcIjtaPVwiI0Y1RjVGNVwiO3ZhciBmYT0yMCx2PTE0LGNiPXtsaWdodDE6V2EsbGlnaHQyOmJiLGRhcmsxOkdhLGRhcmsyOntjb2xvclNldDpcImNvbG9yU2V0MlwiLGJhY2tncm91bmRDb2xvcjpcIiMzMjM3M0FcIix0aXRsZTp7Zm9udEZhbWlseTpCLGZvbnRTaXplOjMyLGZvbnRDb2xvcjphYSxmb250V2VpZ2h0Olwibm9ybWFsXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fSxzdWJ0aXRsZXM6W3tmb250RmFtaWx5OkIsZm9udFNpemU6dixmb250Q29sb3I6YWEsXG5mb250V2VpZ2h0Olwibm9ybWFsXCIsdmVydGljYWxBbGlnbjpcInRvcFwiLG1hcmdpbjo1fV0sdG9vbGJhcjp7aXRlbUJhY2tncm91bmRDb2xvcjpcIiM2NjY2NjZcIixpdGVtQmFja2dyb3VuZENvbG9yT25Ib3ZlcjpcIiNGRjczNzJcIixidXR0b25Cb3JkZXJDb2xvcjpcIiNGRjczNzJcIixidXR0b25Cb3JkZXJUaGlja25lc3M6MSxmb250Q29sb3I6XCIjRjVGNUY1XCIsZm9udENvbG9yT25Ib3ZlcjpcIiNGNUY1RjVcIn0sZGF0YTpbe2luZGV4TGFiZWxGb250RmFtaWx5OkIsaW5kZXhMYWJlbEZvbnRTaXplOnYsaW5kZXhMYWJlbEZvbnRDb2xvcjpRLGluZGV4TGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsaW5kZXhMYWJlbExpbmVUaGlja25lc3M6MX1dLGF4aXNYOlt7dGl0bGVGb250RmFtaWx5OkIsdGl0bGVGb250U2l6ZTpmYSx0aXRsZUZvbnRDb2xvcjpRLHRpdGxlRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpRLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLFxubGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpLLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6SyxncmlkVGhpY2tuZXNzOjAsZ3JpZENvbG9yOkssc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjMDAwMDAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6Wixjb2xvcjpVLHRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcImRhc2hcIn0sc2NhbGVCcmVha3M6e3R5cGU6XCJ6aWd6YWdcIixzcGFjaW5nOlwiMiVcIixsaW5lQ29sb3I6XCIjNzc3Nzc3XCIsbGluZVRoaWNrbmVzczoxLGxpbmVEYXNoVHlwZTpcInNvbGlkXCIsY29sb3I6XCIjMTExMTExXCJ9fV0sXG5heGlzWDI6W3t0aXRsZUZvbnRGYW1pbHk6Qix0aXRsZUZvbnRTaXplOmZhLHRpdGxlRm9udENvbG9yOlEsdGl0bGVGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlEsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGluZVRoaWNrbmVzczoxLGxpbmVDb2xvcjpLLHRpY2tUaGlja25lc3M6MSx0aWNrQ29sb3I6SyxncmlkVGhpY2tuZXNzOjAsZ3JpZENvbG9yOkssc3RyaXBMaW5lczpbe2xhYmVsRm9udEZhbWlseTpCLGxhYmVsRm9udFNpemU6dixsYWJlbEZvbnRDb2xvcjpcIiNGRjczMDBcIixsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEJhY2tncm91bmRDb2xvcjpudWxsLGNvbG9yOlwiI0ZGNzMwMFwiLHRoaWNrbmVzczoxfV0sY3Jvc3NoYWlyOntsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjMDAwMDAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6WixcbmNvbG9yOlUsdGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwiZGFzaFwifSxzY2FsZUJyZWFrczp7dHlwZTpcInppZ3phZ1wiLHNwYWNpbmc6XCIyJVwiLGxpbmVDb2xvcjpcIiM3Nzc3NzdcIixsaW5lVGhpY2tuZXNzOjEsbGluZURhc2hUeXBlOlwic29saWRcIixjb2xvcjpcIiMxMTExMTFcIn19XSxheGlzWTpbe3RpdGxlRm9udEZhbWlseTpCLHRpdGxlRm9udFNpemU6ZmEsdGl0bGVGb250Q29sb3I6USx0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6USxsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjAsbGluZUNvbG9yOkssdGlja1RoaWNrbmVzczoxLHRpY2tDb2xvcjpLLGdyaWRUaGlja25lc3M6MSxncmlkQ29sb3I6SyxzdHJpcExpbmVzOlt7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiI0ZGNzMwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOm51bGwsXG5jb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOlosY29sb3I6VSx0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkYXNoXCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiIzc3Nzc3N1wiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwiLGNvbG9yOlwiIzExMTExMVwifX1dLGF4aXNZMjpbe3RpdGxlRm9udEZhbWlseTpCLHRpdGxlRm9udFNpemU6ZmEsdGl0bGVGb250Q29sb3I6USx0aXRsZUZvbnRXZWlnaHQ6XCJub3JtYWxcIixsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6USxsYWJlbEZvbnRXZWlnaHQ6XCJub3JtYWxcIixsaW5lVGhpY2tuZXNzOjAsbGluZUNvbG9yOkssdGlja1RoaWNrbmVzczoxLFxudGlja0NvbG9yOkssZ3JpZFRoaWNrbmVzczoxLGdyaWRDb2xvcjpLLHN0cmlwTGluZXM6W3tsYWJlbEZvbnRGYW1pbHk6QixsYWJlbEZvbnRTaXplOnYsbGFiZWxGb250Q29sb3I6XCIjRkY3MzAwXCIsbGFiZWxGb250V2VpZ2h0Olwibm9ybWFsXCIsbGFiZWxCYWNrZ3JvdW5kQ29sb3I6bnVsbCxjb2xvcjpcIiNGRjczMDBcIix0aGlja25lc3M6MX1dLGNyb3NzaGFpcjp7bGFiZWxGb250RmFtaWx5OkIsbGFiZWxGb250U2l6ZTp2LGxhYmVsRm9udENvbG9yOlwiIzAwMDAwMFwiLGxhYmVsRm9udFdlaWdodDpcIm5vcm1hbFwiLGxhYmVsQmFja2dyb3VuZENvbG9yOlosY29sb3I6VSx0aGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJkYXNoXCJ9LHNjYWxlQnJlYWtzOnt0eXBlOlwiemlnemFnXCIsc3BhY2luZzpcIjIlXCIsbGluZUNvbG9yOlwiIzc3Nzc3N1wiLGxpbmVUaGlja25lc3M6MSxsaW5lRGFzaFR5cGU6XCJzb2xpZFwiLGNvbG9yOlwiIzExMTExMVwifX1dLGxlZ2VuZDp7Zm9udEZhbWlseTpCLGZvbnRTaXplOjE0LFxuZm9udENvbG9yOmFhLGZvbnRXZWlnaHQ6XCJib2xkXCIsdmVydGljYWxBbGlnbjpcImJvdHRvbVwiLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwifSx0b29sVGlwOntmb250RmFtaWx5OkIsZm9udFNpemU6MTQsZm9udFN0eWxlOlwibm9ybWFsXCIsY29ybmVyUmFkaXVzOjAsYm9yZGVyVGhpY2tuZXNzOjEsZm9udENvbG9yOlEsYmFja2dyb3VuZENvbG9yOlwicmdiYSgwLCAwLCAwLCAuNylcIn19LHRoZW1lMTpXYSx0aGVtZTI6YmIsdGhlbWUzOldhfSxUPXtudW1iZXJEdXJhdGlvbjoxLHllYXJEdXJhdGlvbjozMTQ0OTZFNSxtb250aER1cmF0aW9uOjI1OTJFNix3ZWVrRHVyYXRpb246NjA0OEU1LGRheUR1cmF0aW9uOjg2NEU1LGhvdXJEdXJhdGlvbjozNkU1LG1pbnV0ZUR1cmF0aW9uOjZFNCxzZWNvbmREdXJhdGlvbjoxRTMsbWlsbGlzZWNvbmREdXJhdGlvbjoxLGRheU9mV2Vla0Zyb21JbnQ6XCJTdW5kYXkgTW9uZGF5IFR1ZXNkYXkgV2VkbmVzZGF5IFRodXJzZGF5IEZyaWRheSBTYXR1cmRheVwiLnNwbGl0KFwiIFwiKX07XG4oZnVuY3Rpb24oKXt2YS5mU0RlYz1mdW5jdGlvbihoKXtmb3IodmFyIHA9XCJcIixyPTA7cjxoLmxlbmd0aDtyKyspcCs9U3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLmNlaWwoaC5sZW5ndGgvNTcvNSleaC5jaGFyQ29kZUF0KHIpKTtyZXR1cm4gcH07ZGVsZXRlIHBhW3ZhLmZTRGVjKFwiQmlgc3VcIildW3ZhLmZTRGVjKFwiYnNkZWh1SXNkZ1wiKV07dmEucHJvPXtzQ0g6cGFbdmEuZlNEZWMoXCJCaWBzdVwiKV1bdmEuZlNEZWMoXCJic2RlaHVJc2RnXCIpXX19KSgpO3ZhciBnYj1mdW5jdGlvbigpe3ZhciBoPSExO3RyeXt2YXIgcD1PYmplY3QuZGVmaW5lUHJvcGVydHkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7aD0hMDtyZXR1cm4hMX19KTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciYmKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLG51bGwscCksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsbnVsbCxwKSl9Y2F0Y2gocil7aD1cbiExfXJldHVybiBofSgpLFphPXt9LHJhPW51bGwsbGI9ZnVuY3Rpb24oKXt0aGlzLmN0eC5jbGVhclJlY3QoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO3RoaXMuYmFja2dyb3VuZENvbG9yJiYodGhpcy5jdHguZmlsbFN0eWxlPXRoaXMuYmFja2dyb3VuZENvbG9yLHRoaXMuY3R4LmZpbGxSZWN0KDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSl9LHlhPWZ1bmN0aW9uKGgpe2gud2lkdGg9MTtoLmhlaWdodD0xO2guZ2V0Q29udGV4dChcIjJkXCIpJiZoLmdldENvbnRleHQoXCIyZFwiKS5jbGVhclJlY3QoMCwwLDEsMSl9LG1iPWZ1bmN0aW9uKGgscCxyKXtwPU1hdGgubWluKHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpO3JldHVybiBNYXRoLm1heChcInRoZW1lNFwiPT09dGhpcy50aGVtZT8wOjMwMDw9cD8xMjoxMSxNYXRoLnJvdW5kKHAqKGgvNDAwKSkpfSxCYT1mdW5jdGlvbigpe3ZhciBoPS9EezEsNH18TXsxLDR9fFl7MSw0fXxoezEsMn18SHsxLDJ9fG17MSwyfXxzezEsMn18ZnsxLDN9fHR7MSwyfXxUezEsMn18S3x6ezEsM318XCJbXlwiXSpcInwnW14nXSonL2csXG5wPVwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIikscj1cIlN1biBNb24gVHVlIFdlZCBUaHUgRnJpIFNhdFwiLnNwbGl0KFwiIFwiKSx3PVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSxoYT1cIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXCIuc3BsaXQoXCIgXCIpLEI9L1xcYig/OltQTUNFQV1bU0RQXVR8KD86UGFjaWZpY3xNb3VudGFpbnxDZW50cmFsfEVhc3Rlcm58QXRsYW50aWMpICg/OlN0YW5kYXJkfERheWxpZ2h0fFByZXZhaWxpbmcpIFRpbWV8KD86R01UfFVUQykoPzpbLStdXFxkezR9KT8pXFxiL2csQT0vW14tK1xcZEEtWl0vZztyZXR1cm4gZnVuY3Rpb24odixKLE4pe3ZhciBLPU4/Ti5kYXlzOnAsWD1OP04ubW9udGhzOncsUD1OP04uc2hvcnREYXlzOlxucixUPU4/Ti5zaG9ydE1vbnRoczpoYTtOPVwiXCI7dmFyIFY9ITE7dj12JiZ2LmdldFRpbWU/djp2P25ldyBEYXRlKHYpOm5ldyBEYXRlO2lmKGlzTmFOKHYpKXRocm93IFN5bnRheEVycm9yKFwiaW52YWxpZCBkYXRlXCIpO1wiVVRDOlwiPT09Si5zbGljZSgwLDQpJiYoSj1KLnNsaWNlKDQpLFY9ITApO049Vj9cImdldFVUQ1wiOlwiZ2V0XCI7dmFyIEc9dltOK1wiRGF0ZVwiXSgpLE09dltOK1wiRGF5XCJdKCksVz12W04rXCJNb250aFwiXSgpLGE9dltOK1wiRnVsbFllYXJcIl0oKSxkPXZbTitcIkhvdXJzXCJdKCksYz12W04rXCJNaW51dGVzXCJdKCksYj12W04rXCJTZWNvbmRzXCJdKCksZT12W04rXCJNaWxsaXNlY29uZHNcIl0oKSxmPVY/MDp2LmdldFRpbWV6b25lT2Zmc2V0KCk7cmV0dXJuIE49Si5yZXBsYWNlKGgsZnVuY3Rpb24obCl7c3dpdGNoKGwpe2Nhc2UgXCJEXCI6cmV0dXJuIEc7Y2FzZSBcIkREXCI6cmV0dXJuIGNhKEcsMik7Y2FzZSBcIkRERFwiOnJldHVybiBQW01dO2Nhc2UgXCJEREREXCI6cmV0dXJuIEtbTV07Y2FzZSBcIk1cIjpyZXR1cm4gVytcbjE7Y2FzZSBcIk1NXCI6cmV0dXJuIGNhKFcrMSwyKTtjYXNlIFwiTU1NXCI6cmV0dXJuIFRbV107Y2FzZSBcIk1NTU1cIjpyZXR1cm4gWFtXXTtjYXNlIFwiWVwiOnJldHVybiBwYXJzZUludChTdHJpbmcoYSkuc2xpY2UoLTIpKTtjYXNlIFwiWVlcIjpyZXR1cm4gY2EoU3RyaW5nKGEpLnNsaWNlKC0yKSwyKTtjYXNlIFwiWVlZXCI6cmV0dXJuIGNhKFN0cmluZyhhKS5zbGljZSgtMyksMyk7Y2FzZSBcIllZWVlcIjpyZXR1cm4gY2EoYSw0KTtjYXNlIFwiaFwiOnJldHVybiBkJTEyfHwxMjtjYXNlIFwiaGhcIjpyZXR1cm4gY2EoZCUxMnx8MTIsMik7Y2FzZSBcIkhcIjpyZXR1cm4gZDtjYXNlIFwiSEhcIjpyZXR1cm4gY2EoZCwyKTtjYXNlIFwibVwiOnJldHVybiBjO2Nhc2UgXCJtbVwiOnJldHVybiBjYShjLDIpO2Nhc2UgXCJzXCI6cmV0dXJuIGI7Y2FzZSBcInNzXCI6cmV0dXJuIGNhKGIsMik7Y2FzZSBcImZcIjpyZXR1cm4gY2EoU3RyaW5nKGUpLDMpLnNsaWNlKDAsMSk7Y2FzZSBcImZmXCI6cmV0dXJuIGNhKFN0cmluZyhlKSwzKS5zbGljZSgwLFxuMik7Y2FzZSBcImZmZlwiOnJldHVybiBjYShTdHJpbmcoZSksMykuc2xpY2UoMCwzKTtjYXNlIFwidFwiOnJldHVybiAxMj5kP1wiYVwiOlwicFwiO2Nhc2UgXCJ0dFwiOnJldHVybiAxMj5kP1wiYW1cIjpcInBtXCI7Y2FzZSBcIlRcIjpyZXR1cm4gMTI+ZD9cIkFcIjpcIlBcIjtjYXNlIFwiVFRcIjpyZXR1cm4gMTI+ZD9cIkFNXCI6XCJQTVwiO2Nhc2UgXCJLXCI6cmV0dXJuIFY/XCJVVENcIjooU3RyaW5nKHYpLm1hdGNoKEIpfHxbXCJcIl0pLnBvcCgpLnJlcGxhY2UoQSxcIlwiKTtjYXNlIFwielwiOnJldHVybigwPGY/XCItXCI6XCIrXCIpK01hdGguZmxvb3IoTWF0aC5hYnMoZikvNjApO2Nhc2UgXCJ6elwiOnJldHVybigwPGY/XCItXCI6XCIrXCIpK2NhKE1hdGguZmxvb3IoTWF0aC5hYnMoZikvNjApLDIpO2Nhc2UgXCJ6enpcIjpyZXR1cm4oMDxmP1wiLVwiOlwiK1wiKStjYShNYXRoLmZsb29yKE1hdGguYWJzKGYpLzYwKSwyKStjYShNYXRoLmFicyhmKSU2MCwyKTtkZWZhdWx0OnJldHVybiBsLnNsaWNlKDEsbC5sZW5ndGgtMSl9fSl9fSgpLG5iPWZ1bmN0aW9uKGgpe3ZhciBwPVxuMD5oO2lmKDE+TWF0aC5hYnMoaCkpe3ZhciByPXBhcnNlSW50KGgudG9TdHJpbmcoKS5zcGxpdChcImUtXCIpWzFdKTtyJiYoaD0ocD8tMSpoOmgpKk1hdGgucG93KDEwLHItMSksaD1cIjAuXCIrQXJyYXkocikuam9pbihcIjBcIikraC50b1N0cmluZygpLnN1YnN0cmluZygyKSxoPXA/XCItXCIraDpoKX1lbHNlIHI9cGFyc2VJbnQoaC50b1N0cmluZygpLnNwbGl0KFwiK1wiKVsxXSksMjA8ciYmKHItPTIwLGgvPU1hdGgucG93KDEwLHIpLGg9aC50b1N0cmluZygpK0FycmF5KHIrMSkuam9pbihcIjBcIikpO3JldHVybiBTdHJpbmcoaCl9LGRhPWZ1bmN0aW9uKGgscCxyKXtpZihudWxsPT09aClyZXR1cm5cIlwiO2lmKCFpc0Zpbml0ZShoKSlyZXR1cm4gaDtoPU51bWJlcihoKTt2YXIgdz0wPmg/ITA6ITE7dyYmKGgqPS0xKTt2YXIgQj1yP3IuZGVjaW1hbFNlcGFyYXRvcjpcIi5cIix2PXI/ci5kaWdpdEdyb3VwU2VwYXJhdG9yOlwiLFwiLEE9XCJcIjtwPVN0cmluZyhwKTt2YXIgQT0xLEo9cj1cIlwiLEs9LTEsTj1bXSxcblg9W10sUD0wLFQ9MCxWPTAsRz0hMSxRPTAsSj1wLm1hdGNoKC9cIlteXCJdKlwifCdbXiddKid8W2VFXVsrLV0qWzBdK3xbLF0rWy5dfFxcdTIwMzB8Li9nKTtwPW51bGw7Zm9yKHZhciBNPTA7SiYmTTxKLmxlbmd0aDtNKyspaWYocD1KW01dLFwiLlwiPT09cCYmMD5LKUs9TTtlbHNle2lmKFwiJVwiPT09cClBKj0xMDA7ZWxzZSBpZihcIlxcdTIwMzBcIj09PXApe0EqPTFFMztjb250aW51ZX1lbHNlIGlmKFwiLFwiPT09cFswXSYmXCIuXCI9PT1wW3AubGVuZ3RoLTFdKXtBLz1NYXRoLnBvdygxRTMscC5sZW5ndGgtMSk7Sz1NK3AubGVuZ3RoLTE7Y29udGludWV9ZWxzZVwiRVwiIT09cFswXSYmXCJlXCIhPT1wWzBdfHxcIjBcIiE9PXBbcC5sZW5ndGgtMV18fChHPSEwKTswPks/KE4ucHVzaChwKSxcIiNcIj09PXB8fFwiMFwiPT09cD9QKys6XCIsXCI9PT1wJiZWKyspOihYLnB1c2gocCksXCIjXCIhPT1wJiZcIjBcIiE9PXB8fFQrKyl9RyYmKHA9TWF0aC5mbG9vcihoKSxKPS1NYXRoLmZsb29yKE1hdGgubG9nKGgpL01hdGguTE4xMCtcbjEpLFE9MD09PWg/MDowPT09cD8tKFArSik6bmIocCkubGVuZ3RoLVAsQS89TWF0aC5wb3coMTAsUSkpOzA+SyYmKEs9TSk7QT0oaCpBKS50b0ZpeGVkKFQpO3A9QS5zcGxpdChcIi5cIik7QT0ocFswXStcIlwiKS5zcGxpdChcIlwiKTtoPShwWzFdK1wiXCIpLnNwbGl0KFwiXCIpO0EmJlwiMFwiPT09QVswXSYmQS5zaGlmdCgpO2ZvcihHPUo9TT1UPUs9MDswPE4ubGVuZ3RoOylpZihwPU4ucG9wKCksXCIjXCI9PT1wfHxcIjBcIj09PXApaWYoSysrLEs9PT1QKXt2YXIgVz1BLEE9W107aWYoXCIwXCI9PT1wKWZvcihwPVAtVC0oVz9XLmxlbmd0aDowKTswPHA7KVcudW5zaGlmdChcIjBcIikscC0tO2Zvcig7MDxXLmxlbmd0aDspcj1XLnBvcCgpK3IsRysrLDA9PT1HJUomJihNPT09ViYmMDxXLmxlbmd0aCkmJihyPXYrcil9ZWxzZSAwPEEubGVuZ3RoPyhyPUEucG9wKCkrcixUKyssRysrKTpcIjBcIj09PXAmJihyPVwiMFwiK3IsVCsrLEcrKyksMD09PUclSiYmKE09PT1WJiYwPEEubGVuZ3RoKSYmKHI9dityKTtlbHNlXCJFXCIhPT1cbnBbMF0mJlwiZVwiIT09cFswXXx8XCIwXCIhPT1wW3AubGVuZ3RoLTFdfHwhL1tlRV1bKy1dKlswXSsvLnRlc3QocCk/XCIsXCI9PT1wPyhNKyssSj1HLEc9MCwwPEEubGVuZ3RoJiYocj12K3IpKTpyPTE8cC5sZW5ndGgmJignXCInPT09cFswXSYmJ1wiJz09PXBbcC5sZW5ndGgtMV18fFwiJ1wiPT09cFswXSYmXCInXCI9PT1wW3AubGVuZ3RoLTFdKT9wLnNsaWNlKDEscC5sZW5ndGgtMSkrcjpwK3I6KHA9MD5RP3AucmVwbGFjZShcIitcIixcIlwiKS5yZXBsYWNlKFwiLVwiLFwiXCIpOnAucmVwbGFjZShcIi1cIixcIlwiKSxyKz1wLnJlcGxhY2UoL1swXSsvLGZ1bmN0aW9uKGEpe3JldHVybiBjYShRLGEubGVuZ3RoKX0pKTt2PVwiXCI7Zm9yKE49ITE7MDxYLmxlbmd0aDspcD1YLnNoaWZ0KCksXCIjXCI9PT1wfHxcIjBcIj09PXA/MDxoLmxlbmd0aCYmMCE9PU51bWJlcihoLmpvaW4oXCJcIikpPyh2Kz1oLnNoaWZ0KCksTj0hMCk6XCIwXCI9PT1wJiYodis9XCIwXCIsTj0hMCk6MTxwLmxlbmd0aCYmKCdcIic9PT1wWzBdJiYnXCInPT09cFtwLmxlbmd0aC1cbjFdfHxcIidcIj09PXBbMF0mJlwiJ1wiPT09cFtwLmxlbmd0aC0xXSk/dis9cC5zbGljZSgxLHAubGVuZ3RoLTEpOlwiRVwiIT09cFswXSYmXCJlXCIhPT1wWzBdfHxcIjBcIiE9PXBbcC5sZW5ndGgtMV18fCEvW2VFXVsrLV0qWzBdKy8udGVzdChwKT92Kz1wOihwPTA+UT9wLnJlcGxhY2UoXCIrXCIsXCJcIikucmVwbGFjZShcIi1cIixcIlwiKTpwLnJlcGxhY2UoXCItXCIsXCJcIiksdis9cC5yZXBsYWNlKC9bMF0rLyxmdW5jdGlvbihhKXtyZXR1cm4gY2EoUSxhLmxlbmd0aCl9KSk7cis9KE4/QjpcIlwiKSt2O3JldHVybiB3P1wiLVwiK3I6cn0sUGE9ZnVuY3Rpb24oaCl7dmFyIHA9MCxyPTA7aD1ofHx3aW5kb3cuZXZlbnQ7aC5vZmZzZXRYfHwwPT09aC5vZmZzZXRYPyhwPWgub2Zmc2V0WCxyPWgub2Zmc2V0WSk6aC5sYXllclh8fDA9PWgubGF5ZXJYPyhwPWgubGF5ZXJYLHI9aC5sYXllclkpOihwPWgucGFnZVgtaC50YXJnZXQub2Zmc2V0TGVmdCxyPWgucGFnZVktaC50YXJnZXQub2Zmc2V0VG9wKTtyZXR1cm57eDpwLHk6cn19LFxuYWI9ITAsU2E9d2luZG93LmRldmljZVBpeGVsUmF0aW98fDEsT2E9MSxsYT1hYj9TYS9PYToxLFk9ZnVuY3Rpb24oaCxwLHIsdyx2LEIsQSxKLEssTixYLFQsUCl7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBQJiYoUD0xKTtBPUF8fDA7Sj1KfHxcImJsYWNrXCI7dmFyIEc9MTU8dy1wJiYxNTx2LXI/ODowLjM1Kk1hdGgubWluKHctcCx2LXIpO2guYmVnaW5QYXRoKCk7aC5tb3ZlVG8ocCxyKTtoLnNhdmUoKTtoLmZpbGxTdHlsZT1CO2guZ2xvYmFsQWxwaGE9UDtoLmZpbGxSZWN0KHAscix3LXAsdi1yKTtoLmdsb2JhbEFscGhhPTE7MDxBJiYoUD0wPT09QSUyPzA6MC41LGguYmVnaW5QYXRoKCksaC5saW5lV2lkdGg9QSxoLnN0cm9rZVN0eWxlPUosaC5tb3ZlVG8ocCxyKSxoLnJlY3QocC1QLHItUCx3LXArMipQLHYtcisyKlApLGguc3Ryb2tlKCkpO2gucmVzdG9yZSgpOyEwPT09SyYmKGguc2F2ZSgpLGguYmVnaW5QYXRoKCksaC5tb3ZlVG8ocCxyKSxoLmxpbmVUbyhwK0cscitHKSxoLmxpbmVUbyh3LVxuRyxyK0cpLGgubGluZVRvKHcsciksaC5jbG9zZVBhdGgoKSxBPWguY3JlYXRlTGluZWFyR3JhZGllbnQoKHcrcCkvMixyK0csKHcrcCkvMixyKSxBLmFkZENvbG9yU3RvcCgwLEIpLEEuYWRkQ29sb3JTdG9wKDEsXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIC40KVwiKSxoLmZpbGxTdHlsZT1BLGguZmlsbCgpLGgucmVzdG9yZSgpKTshMD09PU4mJihoLnNhdmUoKSxoLmJlZ2luUGF0aCgpLGgubW92ZVRvKHAsdiksaC5saW5lVG8ocCtHLHYtRyksaC5saW5lVG8ody1HLHYtRyksaC5saW5lVG8odyx2KSxoLmNsb3NlUGF0aCgpLEE9aC5jcmVhdGVMaW5lYXJHcmFkaWVudCgodytwKS8yLHYtRywodytwKS8yLHYpLEEuYWRkQ29sb3JTdG9wKDAsQiksQS5hZGRDb2xvclN0b3AoMSxcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjQpXCIpLGguZmlsbFN0eWxlPUEsaC5maWxsKCksaC5yZXN0b3JlKCkpOyEwPT09WCYmKGguc2F2ZSgpLGguYmVnaW5QYXRoKCksaC5tb3ZlVG8ocCxyKSxoLmxpbmVUbyhwK0cscitcbkcpLGgubGluZVRvKHArRyx2LUcpLGgubGluZVRvKHAsdiksaC5jbG9zZVBhdGgoKSxBPWguY3JlYXRlTGluZWFyR3JhZGllbnQocCtHLCh2K3IpLzIscCwodityKS8yKSxBLmFkZENvbG9yU3RvcCgwLEIpLEEuYWRkQ29sb3JTdG9wKDEsXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSlcIiksaC5maWxsU3R5bGU9QSxoLmZpbGwoKSxoLnJlc3RvcmUoKSk7ITA9PT1UJiYoaC5zYXZlKCksaC5iZWdpblBhdGgoKSxoLm1vdmVUbyh3LHIpLGgubGluZVRvKHctRyxyK0cpLGgubGluZVRvKHctRyx2LUcpLGgubGluZVRvKHcsdiksQT1oLmNyZWF0ZUxpbmVhckdyYWRpZW50KHctRywodityKS8yLHcsKHYrcikvMiksQS5hZGRDb2xvclN0b3AoMCxCKSxBLmFkZENvbG9yU3RvcCgxLFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpXCIpLGguZmlsbFN0eWxlPUEsQS5hZGRDb2xvclN0b3AoMCxCKSxBLmFkZENvbG9yU3RvcCgxLFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpXCIpLGguZmlsbFN0eWxlPUEsaC5maWxsKCksXG5oLmNsb3NlUGF0aCgpLGgucmVzdG9yZSgpKX0saWE9ZnVuY3Rpb24oaCl7Zm9yKHZhciBwPVwiXCIscj0wO3I8aC5sZW5ndGg7cisrKXArPVN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5jZWlsKGgubGVuZ3RoLzU3LzUpXmguY2hhckNvZGVBdChyKSk7cmV0dXJuIHB9LGpiPXdpbmRvdyYmKHdpbmRvd1tpYShcIm1uYmB1aG5vXCIpXSYmd2luZG93W2lhKFwibW5iYHVobm9cIildLmhyZWYmJndpbmRvd1tpYShcIm1uYmB1aG5vXCIpXS5ocmVmLmluZGV4T2YmJigtMSE9PXdpbmRvd1tpYShcIm1uYmB1aG5vXCIpXS5ocmVmLmluZGV4T2YoaWEoXCJiYG93YHJrci9ibmxcIikpfHwtMSE9PXdpbmRvd1tpYShcIm1uYmB1aG5vXCIpXS5ocmVmLmluZGV4T2YoaWEoXCJnZG9ucWh5L2JubFwiKSl8fC0xIT09d2luZG93W2lhKFwibW5iYHVobm9cIildLmhyZWYuaW5kZXhPZihpYShcImdoZWVtZFwiKSkpKSYmLTE9PT13aW5kb3dbaWEoXCJtbmJgdWhub1wiKV0uaHJlZi5pbmRleE9mKGlhKFwiZ2hlZW1kXCIpKSxrYj17cmVzZXQ6e2ltYWdlOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDSUFBQUFlQ0FZQUFBQkovOHdVQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBUGpTVVJCVkZoSHhWZEphRk5SRlAxSi9qd2tQNU14c2JhQzFXSkVnbFN4T0ZBWElzRnBWUkUzZ2dpMUs5MG9iaW9SUkJBMzNYWG5RbmNpaXJoUWNNQ2RvcmdReEJrWFdsUkVrRktzV2t2NW5wdmNrcC9YbnpScEtoNjRrTHc3MzNmZmZlOUwvd3JMMCttVlVkTzh1VFNaM01CTC93ZTJxZzRya3VTcG9kQ0VMc3RYRTQ2emlWa0xRNkZRY0dPbWVTU3E2d2Q0YVY1MGQzZHJXamo4a1FLWkpUVWM5a3hGR2Vudjc5ZFpyRGtzVFNUV1dKcDJRWXRFUGlFcnlzeXpkWDBMc3hzQ1FSOGtlWDhnczZSSElrOHlzZGdLRmcyRzUzbWh1T1Bzc2hUbEJqS2FGbzFnN1NxTE5vU2hLTGRGWFQ4aHVRL3BhTFNieGF0WW5jMm1ITU00aHIxOFZpOFRJdkNtWEYzdllyVzZjRjIzZ0dUT2swTTF3QTRSS3ZPbXE2dkxaUlZKaXB2bVNXVDZ0WjZDU0VZa2NvNVY1MFZQVDQrRDdSd09xaTZSaVNabTBmSit2Z2dTcWtlb3lwZHNObXV5ZWxOd2JYc2JndmtXWU10ekRXTnZXYWlqb3lPQnFFK2hWSzhhYmNzc1VlWFEvWWZLeWkwZ0ZZdjFJcGdmb2ozNGZZR1RKTE9ZSkEwT0Rpcm9rMzJHTE44WGhVV0N3U2VzMWhJd0JnNkx5ZEovdEVlUlJhcEFkVXArd1NBaVpjaHRaWldXZ0FaK0pOcEQ4cGVZWFFWSzlVd1V4TnB6T0s4cHE5N2tVUlpoWVRDS0J3UEQ3aDJ6SytqczdNeWk3RDhGb2QrMFRrTUk4K0VNQW5nTEdjL1d0QkZXYXdrRkhGbm9qL3Q5S0xnR21GMEIzUWZreEMrRWFyeGtkaG5GWWxGTFkwNlVTcVV3TDdVTWpJQ0hmaC93T2Myc0NxaHB4R2JDa0x2TDdFVURiRjczKzZEa21WV0I2emk3eFVEUVNMZVl2V2pBSUx2bTl6RW5rSmhsYlJjRFFaY3Y2S2cyQWlweVQvQXh3NndLbHFWU3F4RGRqRjhJemZvZDEzcVVSZHJHL254ZWhZK3hHaCtoMENTekt5Z0d2U05RSWNjMDk3QkkyNGpiOWhheDZrajJFN09yTUZYMWlsK0lDRWYyTnJQYmhpWExsK2ZZbCtVN3pLNGlZZHNEY3lMR2Yrb2ZGbGt3Y04rczEwS2htcHVZaGh0bTBoQ0xWSUZMME1Ec3FObERJcXk5eDJDTHMxakw2T3ZySTd2UFJidG9oWEc2ZUZtc0ZuSERHQXA2bjlBZ3l1VnlTUlpyR3ZST3hSZ0lmTFhoempyTlluTkJVeE5YL2RNZ1JXVDFtdDRYTERvdmFBcEQ1M0U5VzNpbE5YNU01NUxKSHBSdElzZ0F2Y2lSNFdXY2dLMkR2YjFZcWdYZXZtRjh6MnpFQlRjS0czOUVmU0tzVDlFYmhWVWFJMkZaTytvWklxSW14b2w2ajY2L2hjQXU0c1NONHZjMVpQb0tlb0U2UkdoWUwyWVlBK3ltT1NTaTBaMHdXbnRidGtHVVdDdmZTRFhJeE9OcmFaL0ZZOTBLVWZOVHBmQzVzcG5OTGd4b1lOblI5Uk80RjhvZlhFSE9nb2dDUUU5OXcrZkYyWHcrYjdPNTlyRU9zeVJxR0VmcFZvYURNUVExQ1pyRzQ2YmNNNkFaMEMvd1BxTmZIbGlxZWp5VHlTeGg5VHFRcEwreG1iSWxrQjlTbEFBQUFBQkpSVTVFcmtKZ2dnPT1cIn0sXG5wYW46e2ltYWdlOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCNEFBQUFlQ0FZQUFBQTdNSzZpQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBSUNTVVJCVkVoTHhaYlBhaE5SR01Vbi81TXB1QWlCRUFJdWZRR2Z6cjVFNDBZcHRCWGFqWXp1ZENFdUdxUytnR2xyRndxdURHUlR1dEJkWWZ5ZHpKM0x6ZVFtSkdadWUrRHcvWjE3TW5mbXU1UG9mOUhyOVo2MVdxMGJXWk1LajI2M082eFdxOTl3VTlsT3B6UE1LZ0VoRWNSdWNOT2Npb09LKzBSekJoTnZ0OXRQVjRubVZGMTkrT1doVnF0OXhYZ0ZYWnErOGxDdjExOVVLcFVKN2lYMkZtdkZUS3o4UkgzNFlkQnNOazh3VnRqRTRmR1l3bTh3cnJEaTNXQkc1b0tYWkdSU1M5aEd1TkZvakxUZTJsRno1eFRoV1pJa3RheXlpRTJGZFQzcnpYQlh6N2tyS2lMOGMxN3dBS0ZEakN1czJBdlcrWUdaOXkySkYwVkZSdU1QZkkvL3JzQ0UvQytzMjZzNGdRdTl1bDdyNE50ZUt4N0g4WE9DNzI0eE5OR2JhTnUrK0lyQnFiT1Y3VGozRmdNUnZjL1lLT3IzKzNzRTQ3d2dFdC9CbC9nYUs1Y0hiTlUxMXZZU1h5bGZwSzdYT3ZqdXVtUHA0V2NvaXB1MzBRc2V6MnVNWFl6NGxmSSttT213b3RoWStTTGlYSnk3bUtWcFdzM1NpMENvT01mZUk5T2Q0M1dpYytqTytaVnYrY3JzbTlRU05oVVc5TFhTZW9QQllMWG9wdGhHdUZRZ2RJeHhoWStVRHdsdDF4NUNaMWhYK05UVWR0L09JdmpLYURTbXVPSmZhSVZOUEtYK1cxOGovUExBMi9rUjQ0cDVTZDhIYkhuZ1QveVRmTlJXVVhYMTRaY0wzd21YMCtUTGY4WU83Q0dUOHlGRTV6QjMvZ25leTI1L09FVFJQOUN0UERGZTVqU2hBQUFBQUVsRlRrU3VRbUNDXCJ9LFxuem9vbTp7aW1hZ2U6XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUI0QUFBQWVDQVlBQUFBN01LNmlBQUFBSUdOSVVrMEFBSG9sQUFDQWd3QUErZjhBQUlEcEFBQjFNQUFBNm1BQUFEcVlBQUFYYjVKZnhVWUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFMV1NVUkJWRWhMdlpaTGFCTlJGSWFieWZ0QklnRWZxQ0NCb0NDNk1ZcWlYWWlJajRVNzZVNFg3c1VIYmhRaFVCZml4aFpFVUJEQjE2WXVGRVJhVWFRTEs3b29DT0pqNFVLdFlFRlUwRXB0U2hPL0E5UGgzanMzazhsby9lSG5QN24zblAvTTNMbHpNejFoa1V3bU56aU9jeUtSU0Z5RnQrTHhlRC9jMldxMVltN0t2ME0ybTExT3MxT3hXR3ljbjFPd1pYQ0d1WGZ3SWhlemtkOS9qUmdOVDJMNGxkaHMxcGJrWDVPTEplNGV1Vnh1R1FhUENhM21uVWp0Sng3QkR1S3VzSlRDVjZqVlZHSFRNdVlSanhtYTd5SU9oVGdGWTZqTmFBS2V3MnhQS3BWYXk5Z2FubWt2aitNNDQ4L01mSmRUNUs1R2c0SEphY1JuZ1BGZ3FWUmFSTndXMUI0aTd5ZWhXZnNFRGR6MUsrQTAxQW94UElxR0FpdXdHZmtPVFk4KzFBNnU3QXlpRlRCMkh1MEtQSXJkaU9uekhMV0R5YmVJbXZ5K1dxMm1aYTViVUhzRDBacHorS3hIZFdReW1WNmtBYjFFbHFlT1JnSkx2Z25SZGoxK1IxQWZ6a0l2U1VqeFZqUVNhclZha3J1ZUlQVDgrSDFGNWpTVXkrV1hpSnJVWUJWV3lWeFU0UEVVOFR6aGZhaWpVcW5NSVdyamFZNDkyZVdSd2RLT0lxcm5JeG5Yd0xMZVJMd2syR1F6ckVNamcwYXZFYlh4a0l4cjRPb09JbXBqMlF3eUZnbXMxa29hL1NaVUc4cyswaUduRWhOZkNOWEVoeklYQlZ6ME1jVHpFdkorNzBQOW9ORnR4RXplaTNhRllyRll4bXVTVVBXU3Y5WWk5SU1tMnhFMVdlNTZNcDFPVjRuRHdxRm1CRFY5Z2s5QUVoNGdadEZITnQ4VzRrQVVDb1hGNU1vclk5Wi9rRG5pOW5EdjdoYzBpMmZoZ0x2VHRYOGE5OVBvTVBQYWdURlB4b2ZSem1ESjl5TStBeUVtVGZnR3lzWWJRY2ZoRHpQUEpEbVgwYzdnRGc0Z3M5QnFGSVdobS9OY3Q1SDhndEJxMUk3VWZJYnR2bUl1b2FHUWNwK2ZkcGJiU000M2VFSDV3cndMYlhtaG0vZlU2M1ZIWGpjdW9rN2hFQnlGWS9BZUhHQzhMNS9QTDNIVDV4R0gxdVl3ZlBPSUNHbytDQmNVMHZ3TzFCcXpVcUlMRGwvei85VllJTWZwZGRpQWM0N2pEUDhCc1VwYjEzd09MUndBQUFBQVNVVk9SSzVDWUlJPVwifSxcbm1lbnU6e2ltYWdlOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDUUFBQUFlQ0FZQUFBQkU0YnhUQUFBQUlHTklVazBBQUhvbEFBQ0Fnd0FBK2Y4QUFJRHBBQUIxTUFBQTZtQUFBRHFZQUFBWGI1SmZ4VVlBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBRG9TVVJCVkZoSDdkYzlDc0pBRkFUZ1J4SUlCQ3dDcVpLQVRYNXNiYXdzWTJNdldPdEY5QUI2QVU4Z2d1QUpiRDJBbloyVlhRVC9LbzJUWUdDTDJPWXRZUWMrQnVZQSsxaEN0bkNWd01tMjdTR2FYcERKSUFpQ3ZDa1ZSMDVoR09aTk4zSGtGTWR4M25RUlIwNis3Ni9SMUljRkxKbE5RRVdsbVdsQlR3SnRLTEtIeW5laFpxbmpPR00wUFlXUlZYazYxQzM3cDd4bFozSGs1SG5lQ2sxZG1NSDgxMXhHb0tMU3pEaVF3SUJaQjRvY29QSmRxTmtEdDJ5S2x1ZVdSVkdVdHp5M3JQd28zc1dSVTNuTGp1TEk2T082N29aTTAwd013M2hybXBaeDBYVTlzeXhyUjBUMEJlTXBiOWRuZVNSMkFBQUFBRWxGVGtTdVFtQ0NcIn19O1xuRy5wcm90b3R5cGUuc2V0T3B0aW9ucz1mdW5jdGlvbihoLHApe2lmKHBhW3RoaXMuX2RlZmF1bHRzS2V5XSl7dmFyIHI9cGFbdGhpcy5fZGVmYXVsdHNLZXldLHc7Zm9yKHcgaW4gcilcInB1YmxpY1Byb3BlcnRpZXNcIiE9PXcmJnIuaGFzT3duUHJvcGVydHkodykmJih0aGlzW3ddPWgmJncgaW4gaD9oW3ddOnAmJncgaW4gcD9wW3ddOnJbd10pfWVsc2UgSWEmJndpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZyhcImRlZmF1bHRzIG5vdCBzZXRcIil9O0cucHJvdG90eXBlLmdldD1mdW5jdGlvbihoKXt2YXIgcD1wYVt0aGlzLl9kZWZhdWx0c0tleV07aWYoXCJvcHRpb25zXCI9PT1oKXJldHVybiB0aGlzLm9wdGlvbnMmJnRoaXMub3B0aW9ucy5faXNQbGFjZWhvbGRlcj9udWxsOnRoaXMub3B0aW9ucztpZihwLmhhc093blByb3BlcnR5KGgpfHxwLnB1YmxpY1Byb3BlcnRpZXMmJnAucHVibGljUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShoKSlyZXR1cm4gdGhpc1toXTt3aW5kb3cuY29uc29sZSYmXG53aW5kb3cuY29uc29sZS5sb2coJ1Byb3BlcnR5IFwiJytoK1wiXFxcIiBkb2Vzbid0IGV4aXN0LiBQbGVhc2UgY2hlY2sgZm9yIHR5cG8uXCIpfTtHLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oaCxwLHIpe3I9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiByPyEwOnI7dmFyIHc9cGFbdGhpcy5fZGVmYXVsdHNLZXldO2lmKFwib3B0aW9uc1wiPT09aCl0aGlzLmNyZWF0ZVVzZXJPcHRpb25zKHApO2Vsc2UgaWYody5oYXNPd25Qcm9wZXJ0eShoKXx8dy5wdWJsaWNQcm9wZXJ0aWVzJiZ3LnB1YmxpY1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoaCkmJlwicmVhZFdyaXRlXCI9PT13LnB1YmxpY1Byb3BlcnRpZXNbaF0pdGhpcy5vcHRpb25zLl9pc1BsYWNlaG9sZGVyJiZ0aGlzLmNyZWF0ZVVzZXJPcHRpb25zKCksdGhpcy5vcHRpb25zW2hdPXA7ZWxzZXt3aW5kb3cuY29uc29sZSYmKHcucHVibGljUHJvcGVydGllcyYmdy5wdWJsaWNQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGgpJiZcInJlYWRPbmx5XCI9PT13LnB1YmxpY1Byb3BlcnRpZXNbaF0/XG53aW5kb3cuY29uc29sZS5sb2coJ1Byb3BlcnR5IFwiJytoKydcIiBpcyByZWFkLW9ubHkuJyk6d2luZG93LmNvbnNvbGUubG9nKCdQcm9wZXJ0eSBcIicraCtcIlxcXCIgZG9lc24ndCBleGlzdC4gUGxlYXNlIGNoZWNrIGZvciB0eXBvLlwiKSk7cmV0dXJufXImJih0aGlzLnN0b2NrQ2hhcnR8fHRoaXMuY2hhcnR8fHRoaXMpLnJlbmRlcigpfTtHLnByb3RvdHlwZS5hZGRUbz1mdW5jdGlvbihoLHAscix3KXt3PVwidW5kZWZpbmVkXCI9PT10eXBlb2Ygdz8hMDp3O3ZhciB2PXBhW3RoaXMuX2RlZmF1bHRzS2V5XTt2Lmhhc093blByb3BlcnR5KGgpfHx2LnB1YmxpY1Byb3BlcnRpZXMmJnYucHVibGljUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShoKSYmXCJyZWFkV3JpdGVcIj09PXYucHVibGljUHJvcGVydGllc1toXT8odGhpcy5vcHRpb25zLl9pc1BsYWNlaG9sZGVyJiZ0aGlzLmNyZWF0ZVVzZXJPcHRpb25zKCksXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnNbaF0mJih0aGlzLm9wdGlvbnNbaF09XG5bXSksaD10aGlzLm9wdGlvbnNbaF0scj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHJ8fG51bGw9PT1yP2gubGVuZ3RoOnIsaC5zcGxpY2UociwwLHApLHcmJih0aGlzLnN0b2NrQ2hhcnR8fHRoaXMuY2hhcnR8fHRoaXMpLnJlbmRlcigpKTp3aW5kb3cuY29uc29sZSYmKHYucHVibGljUHJvcGVydGllcyYmdi5wdWJsaWNQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGgpJiZcInJlYWRPbmx5XCI9PT12LnB1YmxpY1Byb3BlcnRpZXNbaF0/d2luZG93LmNvbnNvbGUubG9nKCdQcm9wZXJ0eSBcIicraCsnXCIgaXMgcmVhZC1vbmx5LicpOndpbmRvdy5jb25zb2xlLmxvZygnUHJvcGVydHkgXCInK2grXCJcXFwiIGRvZXNuJ3QgZXhpc3QuIFBsZWFzZSBjaGVjayBmb3IgdHlwby5cIikpfTtHLnByb3RvdHlwZS5jcmVhdGVVc2VyT3B0aW9ucz1mdW5jdGlvbihoKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGh8fHRoaXMub3B0aW9ucy5faXNQbGFjZWhvbGRlcilpZih0aGlzLnBhcmVudC5vcHRpb25zLl9pc1BsYWNlaG9sZGVyJiZcbnRoaXMucGFyZW50LmNyZWF0ZVVzZXJPcHRpb25zKCksdGhpcy5pc09wdGlvbnNJbkFycmF5KXt0aGlzLnBhcmVudC5vcHRpb25zW3RoaXMub3B0aW9uc05hbWVdfHwodGhpcy5wYXJlbnQub3B0aW9uc1t0aGlzLm9wdGlvbnNOYW1lXT1bXSk7dmFyIHA9dGhpcy5wYXJlbnQub3B0aW9uc1t0aGlzLm9wdGlvbnNOYW1lXSxyPXAubGVuZ3RoO3RoaXMub3B0aW9ucy5faXNQbGFjZWhvbGRlcnx8KEVhKHApLHI9cC5pbmRleE9mKHRoaXMub3B0aW9ucykpO3RoaXMub3B0aW9ucz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGg/e306aDtwW3JdPXRoaXMub3B0aW9uc31lbHNlIHRoaXMub3B0aW9ucz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGg/e306aCxoPXRoaXMucGFyZW50Lm9wdGlvbnMsdGhpcy5vcHRpb25zTmFtZT9wPXRoaXMub3B0aW9uc05hbWU6KHA9dGhpcy5fZGVmYXVsdHNLZXkpJiYwIT09cC5sZW5ndGg/KHI9cC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSwxPHAubGVuZ3RoJiYocj1yLmNvbmNhdChwLnNsaWNlKDEpKSksXG5wPXIpOnA9dm9pZCAwLGhbcF09dGhpcy5vcHRpb25zfTtHLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oaCl7aD1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGg/ITA6aDtpZih0aGlzLmlzT3B0aW9uc0luQXJyYXkpe3ZhciBwPXRoaXMucGFyZW50Lm9wdGlvbnNbdGhpcy5vcHRpb25zTmFtZV07RWEocCk7dmFyIHI9cC5pbmRleE9mKHRoaXMub3B0aW9ucyk7MDw9ciYmcC5zcGxpY2UociwxKX1lbHNlIGRlbGV0ZSB0aGlzLnBhcmVudC5vcHRpb25zW3RoaXMub3B0aW9uc05hbWVdO2gmJih0aGlzLnN0b2NrQ2hhcnR8fHRoaXMuY2hhcnR8fHRoaXMpLnJlbmRlcigpfTtHLnByb3RvdHlwZS51cGRhdGVPcHRpb249ZnVuY3Rpb24oaCl7IXBhW3RoaXMuX2RlZmF1bHRzS2V5XSYmKElhJiZ3aW5kb3cuY29uc29sZSkmJmNvbnNvbGUubG9nKFwiZGVmYXVsdHMgbm90IHNldFwiKTt2YXIgcD1wYVt0aGlzLl9kZWZhdWx0c0tleV0sdz17fSx2PXRoaXNbaF0sQj10aGlzLl90aGVtZU9wdGlvbnNLZXksXG5KPXRoaXMuX2luZGV4O3RoaXMudGhlbWUmJnIodGhpcy5wYXJlbnQpJiZyKEIpJiZyKEopP3c9cih0aGlzLnByZWRlZmluZWRUaGVtZXNbdGhpcy50aGVtZV0pP3RoaXMucHJlZGVmaW5lZFRoZW1lcy5saWdodDE6dGhpcy5wcmVkZWZpbmVkVGhlbWVzW3RoaXMudGhlbWVdOnRoaXMucGFyZW50JiYodGhpcy5wYXJlbnQudGhlbWVPcHRpb25zJiZ0aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbQl0pJiYobnVsbD09PUo/dz10aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbQl06MDx0aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbQl0ubGVuZ3RoJiYodz1NYXRoLm1pbih0aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbQl0ubGVuZ3RoLTEsSiksdz10aGlzLnBhcmVudC50aGVtZU9wdGlvbnNbQl1bd10pKTt0aGlzLnRoZW1lT3B0aW9ucz13O2ggaW4gcCYmKHY9aCBpbiB0aGlzLm9wdGlvbnM/dGhpcy5vcHRpb25zW2hdOncmJmggaW4gdz93W2hdOnBbaF0pO2lmKHY9PT10aGlzW2hdKXJldHVybiExO3RoaXNbaF09XG52O3JldHVybiEwfTtHLnByb3RvdHlwZS50cmFja0NoYW5nZXM9ZnVuY3Rpb24oaCl7aWYoIXRoaXMuc2Vzc2lvblZhcmlhYmxlcyl0aHJvd1wiU2Vzc2lvbiBWYXJpYWJsZSBTdG9yZSBub3Qgc2V0XCI7dGhpcy5zZXNzaW9uVmFyaWFibGVzW2hdPXRoaXMub3B0aW9uc1toXX07Ry5wcm90b3R5cGUuaXNCZWluZ1RyYWNrZWQ9ZnVuY3Rpb24oaCl7dGhpcy5vcHRpb25zLl9vbGRPcHRpb25zfHwodGhpcy5vcHRpb25zLl9vbGRPcHRpb25zPXt9KTtyZXR1cm4gdGhpcy5vcHRpb25zLl9vbGRPcHRpb25zW2hdPyEwOiExfTtHLnByb3RvdHlwZS5oYXNPcHRpb25DaGFuZ2VkPWZ1bmN0aW9uKGgpe2lmKCF0aGlzLnNlc3Npb25WYXJpYWJsZXMpdGhyb3dcIlNlc3Npb24gVmFyaWFibGUgU3RvcmUgbm90IHNldFwiO3JldHVybiB0aGlzLnNlc3Npb25WYXJpYWJsZXNbaF0hPT10aGlzLm9wdGlvbnNbaF19O0cucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oaCxwLHIpe2gmJnAmJih0aGlzLl9ldmVudExpc3RlbmVyc1toXT1cbnRoaXMuX2V2ZW50TGlzdGVuZXJzW2hdfHxbXSx0aGlzLl9ldmVudExpc3RlbmVyc1toXS5wdXNoKHtjb250ZXh0OnJ8fHRoaXMsZXZlbnRIYW5kbGVyOnB9KSl9O0cucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oaCxwKXtpZihoJiZwJiZ0aGlzLl9ldmVudExpc3RlbmVyc1toXSlmb3IodmFyIHI9dGhpcy5fZXZlbnRMaXN0ZW5lcnNbaF0sdz0wO3c8ci5sZW5ndGg7dysrKWlmKHJbd10uZXZlbnRIYW5kbGVyPT09cCl7clt3XS5zcGxpY2UodywxKTticmVha319O0cucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzPWZ1bmN0aW9uKCl7dGhpcy5fZXZlbnRMaXN0ZW5lcnM9W119O0cucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24oaCxwLHIpe2lmKGgmJnRoaXMuX2V2ZW50TGlzdGVuZXJzW2hdKXtwPXB8fHt9O2Zvcih2YXIgdz10aGlzLl9ldmVudExpc3RlbmVyc1toXSx2PTA7djx3Lmxlbmd0aDt2Kyspd1t2XS5ldmVudEhhbmRsZXIuY2FsbCh3W3ZdLmNvbnRleHQsXG5wKX1cImZ1bmN0aW9uXCI9PT10eXBlb2YgdGhpc1toXSYmdGhpc1toXS5jYWxsKHJ8fHRoaXMuY2hhcnQscCl9O0ZhLnByb3RvdHlwZS5yZWdpc3RlclNwYWNlPWZ1bmN0aW9uKGgscCl7XCJ0b3BcIj09PWg/dGhpcy5fdG9wT2NjdXBpZWQrPXAuaGVpZ2h0OlwiYm90dG9tXCI9PT1oP3RoaXMuX2JvdHRvbU9jY3VwaWVkKz1wLmhlaWdodDpcImxlZnRcIj09PWg/dGhpcy5fbGVmdE9jY3VwaWVkKz1wLndpZHRoOlwicmlnaHRcIj09PWgmJih0aGlzLl9yaWdodE9jY3VwaWVkKz1wLndpZHRoKX07RmEucHJvdG90eXBlLnVuUmVnaXN0ZXJTcGFjZT1mdW5jdGlvbihoLHApe1widG9wXCI9PT1oP3RoaXMuX3RvcE9jY3VwaWVkLT1wLmhlaWdodDpcImJvdHRvbVwiPT09aD90aGlzLl9ib3R0b21PY2N1cGllZC09cC5oZWlnaHQ6XCJsZWZ0XCI9PT1oP3RoaXMuX2xlZnRPY2N1cGllZC09cC53aWR0aDpcInJpZ2h0XCI9PT1oJiYodGhpcy5fcmlnaHRPY2N1cGllZC09cC53aWR0aCl9O0ZhLnByb3RvdHlwZS5nZXRGcmVlU3BhY2U9XG5mdW5jdGlvbigpe3JldHVybnt4MTp0aGlzLl94MSt0aGlzLl9sZWZ0T2NjdXBpZWQseTE6dGhpcy5feTErdGhpcy5fdG9wT2NjdXBpZWQseDI6dGhpcy5feDItdGhpcy5fcmlnaHRPY2N1cGllZCx5Mjp0aGlzLl95Mi10aGlzLl9ib3R0b21PY2N1cGllZCx3aWR0aDp0aGlzLl94Mi10aGlzLl94MS10aGlzLl9yaWdodE9jY3VwaWVkLXRoaXMuX2xlZnRPY2N1cGllZCxoZWlnaHQ6dGhpcy5feTItdGhpcy5feTEtdGhpcy5fYm90dG9tT2NjdXBpZWQtdGhpcy5fdG9wT2NjdXBpZWR9fTtGYS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLl9yaWdodE9jY3VwaWVkPXRoaXMuX2xlZnRPY2N1cGllZD10aGlzLl9ib3R0b21PY2N1cGllZD10aGlzLl90b3BPY2N1cGllZD10aGlzLl9wYWRkaW5nfTtvYShqYSxHKTtqYS5wcm90b3R5cGUuX2luaXRpYWxpemU9ZnVuY3Rpb24oKXtyKHRoaXMucGFkZGluZyl8fFwib2JqZWN0XCIhPT10eXBlb2YgdGhpcy5wYWRkaW5nP3RoaXMudG9wUGFkZGluZz1cbnRoaXMucmlnaHRQYWRkaW5nPXRoaXMuYm90dG9tUGFkZGluZz10aGlzLmxlZnRQYWRkaW5nPU51bWJlcih0aGlzLnBhZGRpbmcpfDA6KHRoaXMudG9wUGFkZGluZz1yKHRoaXMucGFkZGluZy50b3ApPzA6TnVtYmVyKHRoaXMucGFkZGluZy50b3ApfDAsdGhpcy5yaWdodFBhZGRpbmc9cih0aGlzLnBhZGRpbmcucmlnaHQpPzA6TnVtYmVyKHRoaXMucGFkZGluZy5yaWdodCl8MCx0aGlzLmJvdHRvbVBhZGRpbmc9cih0aGlzLnBhZGRpbmcuYm90dG9tKT8wOk51bWJlcih0aGlzLnBhZGRpbmcuYm90dG9tKXwwLHRoaXMubGVmdFBhZGRpbmc9cih0aGlzLnBhZGRpbmcubGVmdCk/MDpOdW1iZXIodGhpcy5wYWRkaW5nLmxlZnQpfDApfTtqYS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGgpe2lmKDAhPT10aGlzLmZvbnRTaXplKXtoJiZ0aGlzLmN0eC5zYXZlKCk7dmFyIHA9dGhpcy5jdHguZm9udDt0aGlzLmN0eC50ZXh0QmFzZWxpbmU9dGhpcy50ZXh0QmFzZWxpbmU7dmFyIHI9MDt0aGlzLl9pc0RpcnR5JiZcbnRoaXMubWVhc3VyZVRleHQodGhpcy5jdHgpO3RoaXMuY3R4LnRyYW5zbGF0ZSh0aGlzLngsdGhpcy55K3IpO1wibWlkZGxlXCI9PT10aGlzLnRleHRCYXNlbGluZSYmKHI9LXRoaXMuX2xpbmVIZWlnaHQvMik7dGhpcy5jdHguZm9udD10aGlzLl9nZXRGb250U3RyaW5nKCk7dGhpcy5jdHgucm90YXRlKE1hdGguUEkvMTgwKnRoaXMuYW5nbGUpO3ZhciB3PTAsdj10aGlzLnRvcFBhZGRpbmcsQj1udWxsO3RoaXMuY3R4LnJvdW5kUmVjdHx8RGEodGhpcy5jdHgpOygwPHRoaXMuYm9yZGVyVGhpY2tuZXNzJiZ0aGlzLmJvcmRlckNvbG9yfHx0aGlzLmJhY2tncm91bmRDb2xvcikmJnRoaXMuY3R4LnJvdW5kUmVjdCgwLHIsdGhpcy53aWR0aCx0aGlzLmhlaWdodCx0aGlzLmNvcm5lclJhZGl1cyx0aGlzLmJvcmRlclRoaWNrbmVzcyx0aGlzLmJhY2tncm91bmRDb2xvcix0aGlzLmJvcmRlckNvbG9yKTt0aGlzLmN0eC5maWxsU3R5bGU9dGhpcy5mb250Q29sb3I7Zm9yKHI9MDtyPHRoaXMuX3dyYXBwZWRUZXh0LmxpbmVzLmxlbmd0aDtyKyspe0I9XG50aGlzLl93cmFwcGVkVGV4dC5saW5lc1tyXTtpZihcInJpZ2h0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbnx8XCJyaWdodFwiPT09dGhpcy50ZXh0QWxpZ24pdz10aGlzLndpZHRoLUIud2lkdGgtdGhpcy5yaWdodFBhZGRpbmc7ZWxzZSBpZihcImxlZnRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWdufHxcImxlZnRcIj09PXRoaXMudGV4dEFsaWduKXc9dGhpcy5sZWZ0UGFkZGluZztlbHNlIGlmKFwiY2VudGVyXCI9PT10aGlzLmhvcml6b250YWxBbGlnbnx8XCJjZW50ZXJcIj09PXRoaXMudGV4dEFsaWduKXc9KHRoaXMud2lkdGgtKHRoaXMubGVmdFBhZGRpbmcrdGhpcy5yaWdodFBhZGRpbmcpKS8yLUIud2lkdGgvMit0aGlzLmxlZnRQYWRkaW5nO3RoaXMuY3R4LmZpbGxUZXh0KEIudGV4dCx3LHYpO3YrPUIuaGVpZ2h0fXRoaXMuY3R4LmZvbnQ9cDtoJiZ0aGlzLmN0eC5yZXN0b3JlKCl9fTtqYS5wcm90b3R5cGUuc2V0VGV4dD1mdW5jdGlvbihoKXt0aGlzLnRleHQ9aDt0aGlzLl9pc0RpcnR5PSEwO3RoaXMuX3dyYXBwZWRUZXh0PVxubnVsbH07amEucHJvdG90eXBlLm1lYXN1cmVUZXh0PWZ1bmN0aW9uKCl7dGhpcy5fbGluZUhlaWdodD1ZYSh0aGlzLmZvbnRGYW1pbHksdGhpcy5mb250U2l6ZSx0aGlzLmZvbnRXZWlnaHQpO2lmKG51bGw9PT10aGlzLm1heFdpZHRoKXRocm93XCJQbGVhc2Ugc2V0IG1heFdpZHRoIGFuZCBoZWlnaHQgZm9yIFRleHRCbG9ja1wiO3RoaXMuX3dyYXBUZXh0KHRoaXMuY3R4KTt0aGlzLl9pc0RpcnR5PSExO3JldHVybnt3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodH19O2phLnByb3RvdHlwZS5fZ2V0TGluZVdpdGhXaWR0aD1mdW5jdGlvbihoLHAscil7aD1TdHJpbmcoaCk7aWYoIWgpcmV0dXJue3RleHQ6XCJcIix3aWR0aDowfTt2YXIgdz1yPTAsdj1oLmxlbmd0aC0xLEI9SW5maW5pdHk7Zm9yKHRoaXMuY3R4LmZvbnQ9dGhpcy5fZ2V0Rm9udFN0cmluZygpO3c8PXY7KXt2YXIgQj1NYXRoLmZsb29yKCh3K3YpLzIpLEE9aC5zdWJzdHIoMCxCKzEpO3I9dGhpcy5jdHgubWVhc3VyZVRleHQoQSkud2lkdGg7XG5pZihyPHApdz1CKzE7ZWxzZSBpZihyPnApdj1CLTE7ZWxzZSBicmVha31yPnAmJjE8QS5sZW5ndGgmJihBPUEuc3Vic3RyKDAsQS5sZW5ndGgtMSkscj10aGlzLmN0eC5tZWFzdXJlVGV4dChBKS53aWR0aCk7cD0hMDtpZihBLmxlbmd0aD09PWgubGVuZ3RofHxcIiBcIj09PWhbQS5sZW5ndGhdKXA9ITE7cCYmKGg9QS5zcGxpdChcIiBcIiksMTxoLmxlbmd0aCYmaC5wb3AoKSxBPWguam9pbihcIiBcIikscj10aGlzLmN0eC5tZWFzdXJlVGV4dChBKS53aWR0aCk7cmV0dXJue3RleHQ6QSx3aWR0aDpyfX07amEucHJvdG90eXBlLl93cmFwVGV4dD1mdW5jdGlvbigpe3ZhciBoPW5ldyBTdHJpbmcoSGEoU3RyaW5nKHRoaXMudGV4dCkpKSxyPVtdLHc9dGhpcy5jdHguZm9udCx2PTAsQj0wO3RoaXMuY3R4LmZvbnQ9dGhpcy5fZ2V0Rm9udFN0cmluZygpO2lmKDA9PT10aGlzLmZyb250U2l6ZSlCPXY9MDtlbHNlIGZvcig7MDxoLmxlbmd0aDspe3ZhciBKPXRoaXMubWF4SGVpZ2h0LSh0aGlzLnRvcFBhZGRpbmcrXG50aGlzLmJvdHRvbVBhZGRpbmcpLEE9dGhpcy5fZ2V0TGluZVdpdGhXaWR0aChoLHRoaXMubWF4V2lkdGgtKHRoaXMubGVmdFBhZGRpbmcrdGhpcy5yaWdodFBhZGRpbmcpLCExKTtBLmhlaWdodD10aGlzLl9saW5lSGVpZ2h0O3IucHVzaChBKTt2YXIgRz1CLEI9TWF0aC5tYXgoQixBLndpZHRoKSx2PXYrQS5oZWlnaHQsaD1IYShoLnNsaWNlKEEudGV4dC5sZW5ndGgsaC5sZW5ndGgpKTtKJiZ2PkomJihBPXIucG9wKCksdi09QS5oZWlnaHQsQj1HKX10aGlzLl93cmFwcGVkVGV4dD17bGluZXM6cix3aWR0aDpCLGhlaWdodDp2fTt0aGlzLndpZHRoPUIrKHRoaXMubGVmdFBhZGRpbmcrdGhpcy5yaWdodFBhZGRpbmcpO3RoaXMuaGVpZ2h0PXYrKHRoaXMudG9wUGFkZGluZyt0aGlzLmJvdHRvbVBhZGRpbmcpO3RoaXMuY3R4LmZvbnQ9d307amEucHJvdG90eXBlLl9nZXRGb250U3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGg7aD1cIlwiKyh0aGlzLmZvbnRTdHlsZT90aGlzLmZvbnRTdHlsZStcIiBcIjpcblwiXCIpO2grPXRoaXMuZm9udFdlaWdodD90aGlzLmZvbnRXZWlnaHQrXCIgXCI6XCJcIjtoKz10aGlzLmZvbnRTaXplP3RoaXMuZm9udFNpemUrXCJweCBcIjpcIlwiO3ZhciByPXRoaXMuZm9udEZhbWlseT90aGlzLmZvbnRGYW1pbHkrXCJcIjpcIlwiOyF3JiZyJiYocj1yLnNwbGl0KFwiLFwiKVswXSxcIidcIiE9PXJbMF0mJidcIichPT1yWzBdJiYocj1cIidcIityK1wiJ1wiKSk7cmV0dXJuIGgrPXJ9O29hKFVhLEcpO29hKHphLEcpO3phLnByb3RvdHlwZS5zZXRMYXlvdXQ9ZnVuY3Rpb24oKXtpZih0aGlzLnRleHQpe3ZhciBoPXRoaXMuZG9ja0luc2lkZVBsb3RBcmVhP3RoaXMuY2hhcnQucGxvdEFyZWE6dGhpcy5jaGFydCxwPWgubGF5b3V0TWFuYWdlci5nZXRGcmVlU3BhY2UoKSx3PXAueDEsdj1wLnkxLEI9MCxKPTAsQT10aGlzLmNoYXJ0Ll9tZW51QnV0dG9uJiZ0aGlzLmNoYXJ0LmV4cG9ydEVuYWJsZWQmJlwidG9wXCI9PT10aGlzLnZlcnRpY2FsQWxpZ24/NDA6MCxHLEs7XCJ0b3BcIj09PXRoaXMudmVydGljYWxBbGlnbnx8XG5cImJvdHRvbVwiPT09dGhpcy52ZXJ0aWNhbEFsaWduPyhudWxsPT09dGhpcy5tYXhXaWR0aCYmKHRoaXMubWF4V2lkdGg9cC53aWR0aC00LUEqKFwiY2VudGVyXCI9PT10aGlzLmhvcml6b250YWxBbGlnbj8yOjEpKSxKPTAuNSpwLmhlaWdodC10aGlzLm1hcmdpbi0yLEI9MCk6XCJjZW50ZXJcIj09PXRoaXMudmVydGljYWxBbGlnbiYmKFwibGVmdFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ258fFwicmlnaHRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduPyhudWxsPT09dGhpcy5tYXhXaWR0aCYmKHRoaXMubWF4V2lkdGg9cC5oZWlnaHQtNCksSj0wLjUqcC53aWR0aC10aGlzLm1hcmdpbi0yKTpcImNlbnRlclwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24mJihudWxsPT09dGhpcy5tYXhXaWR0aCYmKHRoaXMubWF4V2lkdGg9cC53aWR0aC00KSxKPTAuNSpwLmhlaWdodC00KSk7dmFyIE47cih0aGlzLnBhZGRpbmcpfHxcIm51bWJlclwiIT09dHlwZW9mIHRoaXMucGFkZGluZz9yKHRoaXMucGFkZGluZyl8fFwib2JqZWN0XCIhPT1cbnR5cGVvZiB0aGlzLnBhZGRpbmd8fChOPXRoaXMucGFkZGluZy50b3A/dGhpcy5wYWRkaW5nLnRvcDp0aGlzLnBhZGRpbmcuYm90dG9tP3RoaXMucGFkZGluZy5ib3R0b206MCxOKz10aGlzLnBhZGRpbmcuYm90dG9tP3RoaXMucGFkZGluZy5ib3R0b206dGhpcy5wYWRkaW5nLnRvcD90aGlzLnBhZGRpbmcudG9wOjApOk49Mip0aGlzLnBhZGRpbmc7dGhpcy53cmFwfHwoSj1NYXRoLm1pbihKLDEuNSp0aGlzLmZvbnRTaXplK04pKTtKPW5ldyBqYSh0aGlzLmN0eCx7Zm9udFNpemU6dGhpcy5mb250U2l6ZSxmb250RmFtaWx5OnRoaXMuZm9udEZhbWlseSxmb250Q29sb3I6dGhpcy5mb250Q29sb3IsZm9udFN0eWxlOnRoaXMuZm9udFN0eWxlLGZvbnRXZWlnaHQ6dGhpcy5mb250V2VpZ2h0LGhvcml6b250YWxBbGlnbjp0aGlzLmhvcml6b250YWxBbGlnbix0ZXh0QWxpZ246dGhpcy5ob3Jpem9udGFsQWxpZ24sdmVydGljYWxBbGlnbjp0aGlzLnZlcnRpY2FsQWxpZ24sYm9yZGVyQ29sb3I6dGhpcy5ib3JkZXJDb2xvcixcbmJvcmRlclRoaWNrbmVzczp0aGlzLmJvcmRlclRoaWNrbmVzcyxiYWNrZ3JvdW5kQ29sb3I6dGhpcy5iYWNrZ3JvdW5kQ29sb3IsbWF4V2lkdGg6dGhpcy5tYXhXaWR0aCxtYXhIZWlnaHQ6Sixjb3JuZXJSYWRpdXM6dGhpcy5jb3JuZXJSYWRpdXMsdGV4dDp0aGlzLnRleHQscGFkZGluZzp0aGlzLnBhZGRpbmcsdGV4dEJhc2VsaW5lOlwibWlkZGxlXCJ9KTtOPUoubWVhc3VyZVRleHQoKTtcInRvcFwiPT09dGhpcy52ZXJ0aWNhbEFsaWdufHxcImJvdHRvbVwiPT09dGhpcy52ZXJ0aWNhbEFsaWduPyhcInRvcFwiPT09dGhpcy52ZXJ0aWNhbEFsaWduPyh2PXAueTErMit0aGlzLmZvbnRTaXplLzIrNCxLPVwidG9wXCIpOlwiYm90dG9tXCI9PT10aGlzLnZlcnRpY2FsQWxpZ24mJih2PXAueTItMi1OLmhlaWdodCt0aGlzLmZvbnRTaXplLzIrNCxLPVwiYm90dG9tXCIpLFwibGVmdFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24/dz1wLngxKzI6XCJjZW50ZXJcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduP3c9cC54MStwLndpZHRoL1xuMi1OLndpZHRoLzI6XCJyaWdodFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24mJih3PXAueDItMi1OLndpZHRoLUEpLEc9dGhpcy5ob3Jpem9udGFsQWxpZ24sdGhpcy53aWR0aD1OLndpZHRoLHRoaXMuaGVpZ2h0PU4uaGVpZ2h0KTpcImNlbnRlclwiPT09dGhpcy52ZXJ0aWNhbEFsaWduJiYoXCJsZWZ0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj8odz1wLngxKzIrKHRoaXMuZm9udFNpemUvMis0KSx2PXAueTItMi0odGhpcy5tYXhXaWR0aC8yLU4ud2lkdGgvMiksQj0tOTAsSz1cImxlZnRcIix0aGlzLndpZHRoPU4uaGVpZ2h0LHRoaXMuaGVpZ2h0PU4ud2lkdGgpOlwicmlnaHRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduPyh3PXAueDItMi0odGhpcy5mb250U2l6ZS8yKzQpLHY9cC55MSsyKyh0aGlzLm1heFdpZHRoLzItTi53aWR0aC8yKSxCPTkwLEs9XCJyaWdodFwiLHRoaXMud2lkdGg9Ti5oZWlnaHQsdGhpcy5oZWlnaHQ9Ti53aWR0aCk6XCJjZW50ZXJcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduJiZcbih2PWgueTErKGguaGVpZ2h0LzItTi5oZWlnaHQvMikrdGhpcy5mb250U2l6ZS8yKzQsdz1oLngxKyhoLndpZHRoLzItTi53aWR0aC8yKSxLPVwiY2VudGVyXCIsdGhpcy53aWR0aD1OLndpZHRoLHRoaXMuaGVpZ2h0PU4uaGVpZ2h0KSxHPVwiY2VudGVyXCIpO0oueD13O0oueT12O0ouYW5nbGU9QjtKLmhvcml6b250YWxBbGlnbj1HO3RoaXMuX3RleHRCbG9jaz1KO2gubGF5b3V0TWFuYWdlci5yZWdpc3RlclNwYWNlKEsse3dpZHRoOnRoaXMud2lkdGgrKFwibGVmdFwiPT09S3x8XCJyaWdodFwiPT09Sz90aGlzLm1hcmdpbisyOjApLGhlaWdodDp0aGlzLmhlaWdodCsoXCJ0b3BcIj09PUt8fFwiYm90dG9tXCI9PT1LP3RoaXMubWFyZ2luKzI6MCl9KTt0aGlzLmJvdW5kcz17eDE6dyx5MTp2LHgyOncrdGhpcy53aWR0aCx5Mjp2K3RoaXMuaGVpZ2h0fTt0aGlzLmN0eC50ZXh0QmFzZWxpbmU9XCJ0b3BcIn19O3phLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt0aGlzLl90ZXh0QmxvY2smJnRoaXMuX3RleHRCbG9jay5yZW5kZXIoITApfTtcbm9hKEphLEcpO0phLnByb3RvdHlwZS5zZXRMYXlvdXQ9emEucHJvdG90eXBlLnNldExheW91dDtKYS5wcm90b3R5cGUucmVuZGVyPXphLnByb3RvdHlwZS5yZW5kZXI7VmEucHJvdG90eXBlLmdldD1mdW5jdGlvbihoLHIpe3ZhciB3PW51bGw7MDx0aGlzLnBvb2wubGVuZ3RoPyh3PXRoaXMucG9vbC5wb3AoKSxOYSh3LGgscikpOnc9dWEoaCxyKTtyZXR1cm4gd307VmEucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24oaCl7dGhpcy5wb29sLnB1c2goaCl9O29hKEthLEcpO3ZhciBRYT17YWRkVGhlbWU6ZnVuY3Rpb24oaCxyKXtjYltoXT1yfSxhZGRDb2xvclNldDpmdW5jdGlvbihoLHIpe0FhW2hdPXJ9LGFkZEN1bHR1cmVJbmZvOmZ1bmN0aW9uKGgscil7TGFbaF09cn0sZm9ybWF0TnVtYmVyOmZ1bmN0aW9uKGgscix3KXt3PXd8fFwiZW5cIjtpZihMYVt3XSlyZXR1cm4gZGEoaCxyfHxcIiMsIyMwLiMjXCIsbmV3IEthKHcpKTt0aHJvd1wiVW5rbm93biBDdWx0dXJlIE5hbWVcIjt9LGZvcm1hdERhdGU6ZnVuY3Rpb24oaCxcbnIsdyl7dz13fHxcImVuXCI7aWYoTGFbd10pcmV0dXJuIEJhKGgscnx8XCJERCBNTU0gWVlZWVwiLG5ldyBLYSh3KSk7dGhyb3dcIlVua25vd24gQ3VsdHVyZSBOYW1lXCI7fX07XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBtb2R1bGUmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9UWE6XCJmdW5jdGlvblwiPT09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZnVuY3Rpb24oKXtyZXR1cm4gUWF9KTood2luZG93LkNhbnZhc0pTJiZ3aW5kb3cuY29uc29sZSYmd2luZG93LmNvbnNvbGUubG9nKFwiQ2FudmFzSlMgbmFtZXNwYWNlIGFscmVhZHkgZXhpc3RzLiBJZiB5b3UgYXJlIGxvYWRpbmcgYm90aCBjaGFydCBhbmQgc3RvY2tjaGFydCBzY3JpcHRzLCBqdXN0IGxvYWQgc3RvY2tjaGFydCBhbG9uZSBhcyBpdCBpbmNsdWRlcyBhbGwgY2hhcnQgZmVhdHVyZXMuXCIpLHdpbmRvdy5DYW52YXNKUz13aW5kb3cuQ2FudmFzSlM/d2luZG93LkNhbnZhc0pTOlxuUWEpO0I9UWEuQ2hhcnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBoKGEsZCl7cmV0dXJuIGEueC1kLnh9ZnVuY3Rpb24gcChhLGQsYyl7ZD1kfHx7fTtyKGMpPyh0aGlzLnByZWRlZmluZWRUaGVtZXM9Y2IsdGhpcy5vcHRpb25zTmFtZT10aGlzLnBhcmVudD10aGlzLmluZGV4PW51bGwpOih0aGlzLnBhcmVudD1jLnBhcmVudCx0aGlzLmluZGV4PWMuaW5kZXgsdGhpcy5wcmVkZWZpbmVkVGhlbWVzPWMucHJlZGVmaW5lZFRoZW1lcyx0aGlzLm9wdGlvbnNOYW1lPWMub3B0aW9uc05hbWUsdGhpcy5zdG9ja0NoYXJ0PWMuc3RvY2tDaGFydCx0aGlzLnBhbmVsPWEsdGhpcy5pc09wdGlvbnNJbkFycmF5PWMuaXNPcHRpb25zSW5BcnJheSk7dGhpcy50aGVtZT1yKGQudGhlbWUpfHxyKHRoaXMucHJlZGVmaW5lZFRoZW1lc1tkLnRoZW1lXSk/XCJsaWdodDFcIjpkLnRoZW1lO3AuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJDaGFydFwiLHRoaXMub3B0aW9uc05hbWUsZCx0aGlzLmluZGV4LHRoaXMucGFyZW50KTtcbnZhciBiPXRoaXM7dGhpcy5fY29udGFpbmVySWQ9YTt0aGlzLl9vYmplY3RzSW5pdGlhbGl6ZWQ9ITE7dGhpcy5vdmVybGFpZENhbnZhc0N0eD10aGlzLmN0eD1udWxsO3RoaXMuX2luZGV4TGFiZWxzPVtdO3RoaXMuX3BhblRpbWVySWQ9MDt0aGlzLl9sYXN0VG91Y2hFdmVudFR5cGU9XCJcIjt0aGlzLl9sYXN0VG91Y2hEYXRhPW51bGw7dGhpcy5pc0FuaW1hdGluZz0hMTt0aGlzLnJlbmRlckNvdW50PTA7dGhpcy5kaXNhYmxlVG9vbFRpcD10aGlzLmFuaW1hdGVkUmVuZGVyPSExO3RoaXMuY2FudmFzUG9vbD1uZXcgVmE7dGhpcy5hbGxET01FdmVudEhhbmRsZXJzPVtdO3RoaXMucGFuRW5hYmxlZD0hMTt0aGlzLl9kZWZhdWx0Q3Vyc29yPVwiZGVmYXVsdFwiO3RoaXMucGxvdEFyZWE9e2NhbnZhczpudWxsLGN0eDpudWxsLHgxOjAseTE6MCx4MjowLHkyOjAsd2lkdGg6MCxoZWlnaHQ6MH07dGhpcy5fZGF0YUluUmVuZGVyZWRPcmRlcj1bXTsodGhpcy5jb250YWluZXI9XCJzdHJpbmdcIj09PVxudHlwZW9mIHRoaXMuX2NvbnRhaW5lcklkP2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuX2NvbnRhaW5lcklkKTp0aGlzLl9jb250YWluZXJJZCk/KHRoaXMuY29udGFpbmVyLmlubmVySFRNTD1cIlwiLGQ9YT0wLGE9dGhpcy5vcHRpb25zLndpZHRoP3RoaXMud2lkdGg6MDx0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aD90aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDp0aGlzLndpZHRoLGQ9dGhpcy5vcHRpb25zLmhlaWdodD90aGlzLmhlaWdodDowPHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodD90aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ6dGhpcy5oZWlnaHQsdGhpcy53aWR0aD1hLHRoaXMuaGVpZ2h0PWQsdGhpcy54MT10aGlzLnkxPTAsdGhpcy54Mj10aGlzLndpZHRoLHRoaXMueTI9dGhpcy5oZWlnaHQsdGhpcy5zZWxlY3RlZENvbG9yU2V0PVwidW5kZWZpbmVkXCIhPT10eXBlb2YgQWFbdGhpcy5jb2xvclNldF0/QWFbdGhpcy5jb2xvclNldF06QWEuY29sb3JTZXQxLFxudGhpcy5fY2FudmFzSlNDb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLFwiY2FudmFzanMtY2hhcnQtY29udGFpbmVyXCIpLHRoaXMuX2NhbnZhc0pTQ29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIix0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ249XCJsZWZ0XCIsdGhpcy5fY2FudmFzSlNDb250YWluZXIuc3R5bGUuY3Vyc29yPVwiYXV0b1wiLHRoaXMuX2NhbnZhc0pTQ29udGFpbmVyLnN0eWxlLmRpcmVjdGlvbj1cImx0clwiLHd8fCh0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5zdHlsZS5oZWlnaHQ9XCIwcHhcIiksdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzSlNDb250YWluZXIpLHRoaXMuY2FudmFzPXVhKGEsZCksdGhpcy5fcHJlUmVuZGVyQ2FudmFzPXVhKGEsZCksdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLFxudGhpcy5jYW52YXMuc3R5bGUuV2Via2l0VXNlclNlbGVjdD1cIm5vbmVcIix0aGlzLmNhbnZhcy5zdHlsZS5Nb3pVc2VyU2VsZWN0PVwibm9uZVwiLHRoaXMuY2FudmFzLnN0eWxlLm1zVXNlclNlbGVjdD1cIm5vbmVcIix0aGlzLmNhbnZhcy5zdHlsZS51c2VyU2VsZWN0PVwibm9uZVwiLHRoaXMuY2FudmFzLmdldENvbnRleHQmJih0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyksdGhpcy5jdHg9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLHRoaXMuY3R4LnRleHRCYXNlbGluZT1cInRvcFwiLERhKHRoaXMuY3R4KSx0aGlzLl9wcmVSZW5kZXJDdHg9dGhpcy5fcHJlUmVuZGVyQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLl9wcmVSZW5kZXJDdHgudGV4dEJhc2VsaW5lPVwidG9wXCIsRGEodGhpcy5fcHJlUmVuZGVyQ3R4KSx3P3RoaXMucGxvdEFyZWEuY3R4PXRoaXMuY3R4Oih0aGlzLnBsb3RBcmVhLmNhbnZhcz11YShhLGQpLHRoaXMucGxvdEFyZWEuY2FudmFzLnN0eWxlLnBvc2l0aW9uPVxuXCJhYnNvbHV0ZVwiLHRoaXMucGxvdEFyZWEuY2FudmFzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsXCJwbG90QXJlYUNhbnZhc1wiKSx0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnBsb3RBcmVhLmNhbnZhcyksdGhpcy5wbG90QXJlYS5jdHg9dGhpcy5wbG90QXJlYS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpKSx0aGlzLm92ZXJsYWlkQ2FudmFzPXVhKGEsZCksdGhpcy5vdmVybGFpZENhbnZhcy5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy5vdmVybGFpZENhbnZhcy5zdHlsZS53ZWJraXRUYXBIaWdobGlnaHRDb2xvcj1cInRyYW5zcGFyZW50XCIsdGhpcy5vdmVybGFpZENhbnZhcy5zdHlsZS5XZWJraXRVc2VyU2VsZWN0PVwibm9uZVwiLHRoaXMub3ZlcmxhaWRDYW52YXMuc3R5bGUuTW96VXNlclNlbGVjdD1cIm5vbmVcIix0aGlzLm92ZXJsYWlkQ2FudmFzLnN0eWxlLm1zVXNlclNlbGVjdD1cIm5vbmVcIix0aGlzLm92ZXJsYWlkQ2FudmFzLnN0eWxlLnVzZXJTZWxlY3Q9XG5cIm5vbmVcIix0aGlzLm92ZXJsYWlkQ2FudmFzLmdldENvbnRleHQmJih0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYWlkQ2FudmFzKSx0aGlzLm92ZXJsYWlkQ2FudmFzQ3R4PXRoaXMub3ZlcmxhaWRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLHRoaXMub3ZlcmxhaWRDYW52YXNDdHgudGV4dEJhc2VsaW5lPVwidG9wXCIsRGEodGhpcy5vdmVybGFpZENhbnZhc0N0eCkpLHRoaXMuX2V2ZW50TWFuYWdlcj1uZXcgWih0aGlzKSx0aGlzLndpbmRvd1Jlc2l6ZUhhbmRsZXI9UCh3aW5kb3csXCJyZXNpemVcIixmdW5jdGlvbigpe2IuX3VwZGF0ZVNpemUoKSYmYi5yZW5kZXIoKX0sdGhpcy5hbGxET01FdmVudEhhbmRsZXJzKSx0aGlzLl90b29sQmFyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5fdG9vbEJhci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLFwiY2FudmFzanMtY2hhcnQtdG9vbGJhclwiKSxWKHRoaXMuX3Rvb2xCYXIse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixcbnJpZ2h0OlwiMXB4XCIsdG9wOlwiMXB4XCJ9KSx0aGlzLl9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl90b29sQmFyKSx0aGlzLmJvdW5kcz17eDE6MCx5MTowLHgyOnRoaXMud2lkdGgseTI6dGhpcy5oZWlnaHR9LFAodGhpcy5vdmVybGFpZENhbnZhcyxcImNsaWNrXCIsZnVuY3Rpb24oYSl7Yi5fbW91c2VFdmVudEhhbmRsZXIoYSl9LHRoaXMuYWxsRE9NRXZlbnRIYW5kbGVycyksUCh0aGlzLm92ZXJsYWlkQ2FudmFzLFwibW91c2Vtb3ZlXCIsZnVuY3Rpb24oYSl7Yi5fbW91c2VFdmVudEhhbmRsZXIoYSl9LHRoaXMuYWxsRE9NRXZlbnRIYW5kbGVycyksUCh0aGlzLm92ZXJsYWlkQ2FudmFzLFwibW91c2V1cFwiLGZ1bmN0aW9uKGEpe2IuX21vdXNlRXZlbnRIYW5kbGVyKGEpfSx0aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpLFAodGhpcy5vdmVybGFpZENhbnZhcyxcIm1vdXNlZG93blwiLGZ1bmN0aW9uKGEpe2IuX21vdXNlRXZlbnRIYW5kbGVyKGEpO3dhKGIuX2Ryb3Bkb3duTWVudSl9LFxudGhpcy5hbGxET01FdmVudEhhbmRsZXJzKSxQKHRoaXMub3ZlcmxhaWRDYW52YXMsXCJtb3VzZW91dFwiLGZ1bmN0aW9uKGEpe2IuX21vdXNlRXZlbnRIYW5kbGVyKGEpfSx0aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpLFAodGhpcy5vdmVybGFpZENhbnZhcyx3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/XCJNU1BvaW50ZXJEb3duXCI6XCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oYSl7Yi5fdG91Y2hFdmVudEhhbmRsZXIoYSl9LHRoaXMuYWxsRE9NRXZlbnRIYW5kbGVycyksUCh0aGlzLm92ZXJsYWlkQ2FudmFzLHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZD9cIk1TUG9pbnRlck1vdmVcIjpcInRvdWNobW92ZVwiLGZ1bmN0aW9uKGEpe2IuX3RvdWNoRXZlbnRIYW5kbGVyKGEpfSx0aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpLFAodGhpcy5vdmVybGFpZENhbnZhcyx3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/XCJNU1BvaW50ZXJVcFwiOlwidG91Y2hlbmRcIixmdW5jdGlvbihhKXtiLl90b3VjaEV2ZW50SGFuZGxlcihhKX0sXG50aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpLFAodGhpcy5vdmVybGFpZENhbnZhcyx3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ/XCJNU1BvaW50ZXJDYW5jZWxcIjpcInRvdWNoY2FuY2VsXCIsZnVuY3Rpb24oYSl7Yi5fdG91Y2hFdmVudEhhbmRsZXIoYSl9LHRoaXMuYWxsRE9NRXZlbnRIYW5kbGVycyksdGhpcy50b29sVGlwPW5ldyBVKHRoaXMsdGhpcy5vcHRpb25zLnRvb2xUaXApLHRoaXMuZGF0YT1udWxsLHRoaXMuYXhpc1g9W10sdGhpcy5heGlzWDI9W10sdGhpcy5heGlzWT1bXSx0aGlzLmF4aXNZMj1bXSx0aGlzLnNlc3Npb25WYXJpYWJsZXM9e2F4aXNYOltdLGF4aXNYMjpbXSxheGlzWTpbXSxheGlzWTI6W119KSk6d2luZG93LmNvbnNvbGUmJndpbmRvdy5jb25zb2xlLmxvZygnQ2FudmFzSlMgRXJyb3I6IENoYXJ0IENvbnRhaW5lciB3aXRoIGlkIFwiJyt0aGlzLl9jb250YWluZXJJZCsnXCIgd2FzIG5vdCBmb3VuZCcpfWZ1bmN0aW9uIHYoYSxkKXtmb3IodmFyIGM9XG5bXSxiLGU9MDtlPGEubGVuZ3RoO2UrKylpZigwPT1lKWMucHVzaChhWzBdKTtlbHNle3ZhciBmLGwsdDt0PWUtMTtmPTA9PT10PzA6dC0xO2w9dD09PWEubGVuZ3RoLTE/dDp0KzE7Yj1NYXRoLmFicygoYVtsXS54LWFbZl0ueCkvKDA9PT1hW2xdLngtYVt0XS54PzAuMDE6YVtsXS54LWFbdF0ueCkpKihkLTEpLzIrMTt2YXIgQz0oYVtsXS54LWFbZl0ueCkvYjtiPShhW2xdLnktYVtmXS55KS9iO2NbYy5sZW5ndGhdPWFbdF0ueD5hW2ZdLngmJjA8Q3x8YVt0XS54PGFbZl0ueCYmMD5DP3t4OmFbdF0ueCtDLzMseTphW3RdLnkrYi8zfTp7eDphW3RdLngseTphW3RdLnkrKDE9PT1jLmxlbmd0aD8wOmIvOSl9O3Q9ZTtmPTA9PT10PzA6dC0xO2w9dD09PWEubGVuZ3RoLTE/dDp0KzE7Yj1NYXRoLmFicygoYVtsXS54LWFbZl0ueCkvKDA9PT1hW3RdLngtYVtmXS54PzAuMDE6YVt0XS54LWFbZl0ueCkpKihkLTEpLzIrMTtDPShhW2xdLngtYVtmXS54KS9iO2I9KGFbbF0ueS1hW2ZdLnkpL2I7XG5jW2MubGVuZ3RoXT1hW3RdLng+YVtmXS54JiYwPEN8fGFbdF0ueDxhW2ZdLngmJjA+Qz97eDphW3RdLngtQy8zLHk6YVt0XS55LWIvM306e3g6YVt0XS54LHk6YVt0XS55LWIvOX07Y1tjLmxlbmd0aF09YVtlXX1yZXR1cm4gY31mdW5jdGlvbiBCKGEsZCxjLGIsZSxmLGwsdCxDLGspe3ZhciBtPTA7az8obC5jb2xvcj1mLHQuY29sb3I9Zik6az0xO209Qz9NYXRoLmFicyhlLWMpOk1hdGguYWJzKGItZCk7bT0wPGwudHJpbUxlbmd0aD9NYXRoLmFicyhtKmwudHJpbUxlbmd0aC8xMDApOk1hdGguYWJzKG0tbC5sZW5ndGgpO0M/KGMrPW0vMixlLT1tLzIpOihkKz1tLzIsYi09bS8yKTt2YXIgbT0xPT09TWF0aC5yb3VuZChsLnRoaWNrbmVzcyklMj8wLjU6MCxuPTE9PT1NYXRoLnJvdW5kKHQudGhpY2tuZXNzKSUyPzAuNTowO2Euc2F2ZSgpO2EuZ2xvYmFsQWxwaGE9azthLnN0cm9rZVN0eWxlPXQuY29sb3J8fGY7YS5saW5lV2lkdGg9dC50aGlja25lc3N8fDI7YS5zZXRMaW5lRGFzaCYmXG5hLnNldExpbmVEYXNoKEoodC5kYXNoVHlwZSx0LnRoaWNrbmVzcykpO2EuYmVnaW5QYXRoKCk7QyYmMDx0LnRoaWNrbmVzcz8oYS5tb3ZlVG8oYi1sLnRoaWNrbmVzcy8yLE1hdGgucm91bmQoKGMrZSkvMiktbiksYS5saW5lVG8oZCtsLnRoaWNrbmVzcy8yLE1hdGgucm91bmQoKGMrZSkvMiktbikpOjA8dC50aGlja25lc3MmJihhLm1vdmVUbyhNYXRoLnJvdW5kKChkK2IpLzIpLW4sYytsLnRoaWNrbmVzcy8yKSxhLmxpbmVUbyhNYXRoLnJvdW5kKChkK2IpLzIpLW4sZS1sLnRoaWNrbmVzcy8yKSk7YS5zdHJva2UoKTthLnN0cm9rZVN0eWxlPWwuY29sb3J8fGY7YS5saW5lV2lkdGg9bC50aGlja25lc3N8fDI7YS5zZXRMaW5lRGFzaCYmYS5zZXRMaW5lRGFzaChKKGwuZGFzaFR5cGUsbC50aGlja25lc3MpKTthLmJlZ2luUGF0aCgpO0MmJjA8bC50aGlja25lc3M/KGEubW92ZVRvKGItbSxjKSxhLmxpbmVUbyhiLW0sZSksYS5tb3ZlVG8oZCttLGMpLGEubGluZVRvKGQrbSxlKSk6MDxcbmwudGhpY2tuZXNzJiYoYS5tb3ZlVG8oZCxjK20pLGEubGluZVRvKGIsYyttKSxhLm1vdmVUbyhkLGUtbSksYS5saW5lVG8oYixlLW0pKTthLnN0cm9rZSgpO2EucmVzdG9yZSgpfWZ1bmN0aW9uIEsoYSxkKXtLLmJhc2UuY29uc3RydWN0b3IuY2FsbCh0aGlzLFwiTGVnZW5kXCIsXCJsZWdlbmRcIixkLG51bGwsYSk7dGhpcy5jaGFydD1hO3RoaXMuY2FudmFzPWEuY2FudmFzO3RoaXMuY3R4PXRoaXMuY2hhcnQuY3R4O3RoaXMuZ2hvc3RDdHg9dGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4O3RoaXMuaXRlbXM9W107dGhpcy5vcHRpb25zTmFtZT1cImxlZ2VuZFwiO3RoaXMuaGVpZ2h0PXRoaXMud2lkdGg9MDt0aGlzLm9yaWVudGF0aW9uPW51bGw7dGhpcy5kYXRhU2VyaWVzPVtdO3RoaXMuYm91bmRzPXt4MTpudWxsLHkxOm51bGwseDI6bnVsbCx5MjpudWxsfTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5mb250U2l6ZSYmKHRoaXMuZm9udFNpemU9dGhpcy5jaGFydC5nZXRBdXRvRm9udFNpemUodGhpcy5mb250U2l6ZSkpO1xudGhpcy5saW5lSGVpZ2h0PVlhKHRoaXMuZm9udEZhbWlseSx0aGlzLmZvbnRTaXplLHRoaXMuZm9udFdlaWdodCk7dGhpcy5ob3Jpem9udGFsU3BhY2luZz10aGlzLmZvbnRTaXplfWZ1bmN0aW9uIFEoYSxkLGMsYil7US5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIkRhdGFTZXJpZXNcIixcImRhdGFcIixkLGMsYSk7dGhpcy5jaGFydD1hO3RoaXMuY2FudmFzPWEuY2FudmFzO3RoaXMuX2N0eD1hLmNhbnZhcy5jdHg7dGhpcy5pbmRleD1jO3RoaXMubm9EYXRhUG9pbnRzSW5QbG90QXJlYT0wO3RoaXMuaWQ9Yjt0aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2JdPXtpZDpiLG9iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsZGF0YVNlcmllc0luZGV4OmN9O2E9ZC5kYXRhUG9pbnRzP2QuZGF0YVBvaW50cy5sZW5ndGg6MDt0aGlzLmRhdGFQb2ludEVPcz1bXTtmb3IoZD0wO2Q8YTtkKyspdGhpcy5kYXRhUG9pbnRFT3NbZF09e307dGhpcy5kYXRhUG9pbnRJZHM9W107dGhpcy5wbG90VW5pdD1cbltdO3RoaXMuYXhpc1k9dGhpcy5heGlzWD1udWxsO3RoaXMub3B0aW9uc05hbWU9XCJkYXRhXCI7dGhpcy5pc09wdGlvbnNJbkFycmF5PSEwO251bGw9PT10aGlzLmZpbGxPcGFjaXR5JiYodGhpcy50eXBlLm1hdGNoKC9hcmVhL2kpP3RoaXMuZmlsbE9wYWNpdHk9MC43OnRoaXMuZmlsbE9wYWNpdHk9MSk7dGhpcy5heGlzUGxhY2VtZW50PXRoaXMuZ2V0RGVmYXVsdEF4aXNQbGFjZW1lbnQoKTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbmRleExhYmVsRm9udFNpemUmJih0aGlzLmluZGV4TGFiZWxGb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmluZGV4TGFiZWxGb250U2l6ZSkpfWZ1bmN0aW9uIEEoYSxkLGMsYixlLGYpe0EuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJBeGlzXCIsZCxjLGIsYSk7dGhpcy5jaGFydD1hO3RoaXMuY2FudmFzPWEuY2FudmFzO3RoaXMuY3R4PWEuY3R4O3RoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uPXRoaXMubWF4SGVpZ2h0PVxudGhpcy5tYXhXaWR0aD0wO3RoaXMubGFiZWxzPVtdO3RoaXMuZGF0YVNlcmllcz1bXTt0aGlzLl9zdHJpcExpbmVMYWJlbHM9dGhpcy5fdGlja3M9dGhpcy5fbGFiZWxzPW51bGw7dGhpcy5kYXRhSW5mbz17bWluOkluZmluaXR5LG1heDotSW5maW5pdHksdmlld1BvcnRNaW46SW5maW5pdHksdmlld1BvcnRNYXg6LUluZmluaXR5LG1pbkRpZmY6SW5maW5pdHl9O3RoaXMuaXNPcHRpb25zSW5BcnJheT0hMDtcImF4aXNYXCI9PT1lPyhcImxlZnRcIj09PWZ8fFwiYm90dG9tXCI9PT1mPyh0aGlzLm9wdGlvbnNOYW1lPVwiYXhpc1hcIixyKHRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWFtiXSkmJih0aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1hbYl09e30pLHRoaXMuc2Vzc2lvblZhcmlhYmxlcz10aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1hbYl0pOih0aGlzLm9wdGlvbnNOYW1lPVwiYXhpc1gyXCIscih0aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyW2JdKSYmXG4odGhpcy5jaGFydC5zZXNzaW9uVmFyaWFibGVzLmF4aXNYMltiXT17fSksdGhpcy5zZXNzaW9uVmFyaWFibGVzPXRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWDJbYl0pLHRoaXMub3B0aW9ucy5pbnRlcnZhbHx8KHRoaXMuaW50ZXJ2YWxUeXBlPW51bGwpKTpcImxlZnRcIj09PWZ8fFwiYm90dG9tXCI9PT1mPyh0aGlzLm9wdGlvbnNOYW1lPVwiYXhpc1lcIixyKHRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWVtiXSkmJih0aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1lbYl09e30pLHRoaXMuc2Vzc2lvblZhcmlhYmxlcz10aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1lbYl0pOih0aGlzLm9wdGlvbnNOYW1lPVwiYXhpc1kyXCIscih0aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1kyW2JdKSYmKHRoaXMuY2hhcnQuc2Vzc2lvblZhcmlhYmxlcy5heGlzWTJbYl09e30pLHRoaXMuc2Vzc2lvblZhcmlhYmxlcz10aGlzLmNoYXJ0LnNlc3Npb25WYXJpYWJsZXMuYXhpc1kyW2JdKTtcblwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLnRpdGxlRm9udFNpemUmJih0aGlzLnRpdGxlRm9udFNpemU9dGhpcy5jaGFydC5nZXRBdXRvRm9udFNpemUodGhpcy50aXRsZUZvbnRTaXplKSk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSYmKHRoaXMubGFiZWxGb250U2l6ZT10aGlzLmNoYXJ0LmdldEF1dG9Gb250U2l6ZSh0aGlzLmxhYmVsRm9udFNpemUpKTt0aGlzLnR5cGU9ZTtcImF4aXNYXCIhPT1lfHxjJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMuZ3JpZFRoaWNrbmVzc3x8KHRoaXMuZ3JpZFRoaWNrbmVzcz0wKTt0aGlzLl9wb3NpdGlvbj1mO3RoaXMubGluZUNvb3JkaW5hdGVzPXt4MTpudWxsLHkxOm51bGwseDI6bnVsbCx5MjpudWxsLHdpZHRoOm51bGx9O3RoaXMubGFiZWxBbmdsZT0odGhpcy5sYWJlbEFuZ2xlJTM2MCszNjApJTM2MDs5MDx0aGlzLmxhYmVsQW5nbGUmJjI3MD50aGlzLmxhYmVsQW5nbGU/dGhpcy5sYWJlbEFuZ2xlLT1cbjE4MDoyNzA8PXRoaXMubGFiZWxBbmdsZSYmMzYwPj10aGlzLmxhYmVsQW5nbGUmJih0aGlzLmxhYmVsQW5nbGUtPTM2MCk7dGhpcy5vcHRpb25zLnNjYWxlQnJlYWtzJiYodGhpcy5zY2FsZUJyZWFrcz1uZXcgZmEodGhpcy5jaGFydCx0aGlzLm9wdGlvbnMuc2NhbGVCcmVha3MsKyt0aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIubGFzdE9iamVjdElkLHRoaXMpKTt0aGlzLnN0cmlwTGluZXM9W107aWYodGhpcy5vcHRpb25zLnN0cmlwTGluZXMmJjA8dGhpcy5vcHRpb25zLnN0cmlwTGluZXMubGVuZ3RoKWZvcihhPTA7YTx0aGlzLm9wdGlvbnMuc3RyaXBMaW5lcy5sZW5ndGg7YSsrKXRoaXMuc3RyaXBMaW5lcy5wdXNoKG5ldyBOKHRoaXMuY2hhcnQsdGhpcy5vcHRpb25zLnN0cmlwTGluZXNbYV0sYSwrK3RoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5sYXN0T2JqZWN0SWQsdGhpcykpO3RoaXMub3B0aW9ucy5jcm9zc2hhaXImJih0aGlzLmNyb3NzaGFpcj1uZXcgY2EodGhpcy5jaGFydCxcbnRoaXMub3B0aW9ucy5jcm9zc2hhaXIsdGhpcykpO3RoaXMuX3RpdGxlVGV4dEJsb2NrPW51bGw7dGhpcy5oYXNPcHRpb25DaGFuZ2VkKFwidmlld3BvcnRNaW5pbXVtXCIpJiZudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW0mJih0aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtPXZvaWQgMCx0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNaW5pbXVtPW51bGwpO3RoaXMuaGFzT3B0aW9uQ2hhbmdlZChcInZpZXdwb3J0TWluaW11bVwiKXx8aXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bSl8fG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW09bnVsbDp0aGlzLnZpZXdwb3J0TWluaW11bT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtO3RoaXMuaGFzT3B0aW9uQ2hhbmdlZChcInZpZXdwb3J0TWF4aW11bVwiKSYmbnVsbD09PVxudGhpcy52aWV3cG9ydE1heGltdW0mJih0aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtPXZvaWQgMCx0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtPW51bGwpO3RoaXMuaGFzT3B0aW9uQ2hhbmdlZChcInZpZXdwb3J0TWF4aW11bVwiKXx8aXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSl8fG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW09bnVsbDp0aGlzLnZpZXdwb3J0TWF4aW11bT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtO251bGwhPT10aGlzLm1pbmltdW0mJm51bGwhPT10aGlzLnZpZXdwb3J0TWluaW11bSYmKHRoaXMudmlld3BvcnRNaW5pbXVtPU1hdGgubWF4KHRoaXMudmlld3BvcnRNaW5pbXVtLHRoaXMubWluaW11bSkpO251bGwhPT10aGlzLm1heGltdW0mJm51bGwhPT10aGlzLnZpZXdwb3J0TWF4aW11bSYmXG4odGhpcy52aWV3cG9ydE1heGltdW09TWF0aC5taW4odGhpcy52aWV3cG9ydE1heGltdW0sdGhpcy5tYXhpbXVtKSk7dGhpcy50cmFja0NoYW5nZXMoXCJ2aWV3cG9ydE1pbmltdW1cIik7dGhpcy50cmFja0NoYW5nZXMoXCJ2aWV3cG9ydE1heGltdW1cIil9ZnVuY3Rpb24gZmEoYSxkLGMsYil7ZmEuYmFzZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsXCJTY2FsZUJyZWFrc1wiLFwic2NhbGVCcmVha3NcIixkLG51bGwsYik7dGhpcy5pZD1jO3RoaXMuY2hhcnQ9YTt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLmF4aXM9Yjt0aGlzLm9wdGlvbnNOYW1lPVwic2NhbGVCcmVha3NcIjt0aGlzLmlzT3B0aW9uc0luQXJyYXk9ITE7dGhpcy5fYXBwbGllZEJyZWFrcz1bXTt0aGlzLmN1c3RvbUJyZWFrcz1bXTt0aGlzLmF1dG9CcmVha3M9W107XCJzdHJpbmdcIj09PXR5cGVvZiB0aGlzLnNwYWNpbmc/KHRoaXMuc3BhY2luZz1wYXJzZUZsb2F0KHRoaXMuc3BhY2luZyksdGhpcy5zcGFjaW5nPWlzTmFOKHRoaXMuc3BhY2luZyk/XG44OigxMDx0aGlzLnNwYWNpbmc/MTA6dGhpcy5zcGFjaW5nKStcIiVcIik6XCJudW1iZXJcIiE9PXR5cGVvZiB0aGlzLnNwYWNpbmcmJih0aGlzLnNwYWNpbmc9OCk7dGhpcy5hdXRvQ2FsY3VsYXRlJiYodGhpcy5tYXhOdW1iZXJPZkF1dG9CcmVha3M9TWF0aC5taW4odGhpcy5tYXhOdW1iZXJPZkF1dG9CcmVha3MsNSkpO2lmKHRoaXMub3B0aW9ucy5jdXN0b21CcmVha3MmJjA8dGhpcy5vcHRpb25zLmN1c3RvbUJyZWFrcy5sZW5ndGgpe2ZvcihhPTA7YTx0aGlzLm9wdGlvbnMuY3VzdG9tQnJlYWtzLmxlbmd0aDthKyspdGhpcy5jdXN0b21CcmVha3MucHVzaChuZXcgYWEodGhpcy5jaGFydCxcImN1c3RvbUJyZWFrc1wiLHRoaXMub3B0aW9ucy5jdXN0b21CcmVha3NbYV0sYSwrK3RoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5sYXN0T2JqZWN0SWQsdGhpcykpLFwibnVtYmVyXCI9PT10eXBlb2YgdGhpcy5jdXN0b21CcmVha3NbYV0uc3RhcnRWYWx1ZSYmKFwibnVtYmVyXCI9PT10eXBlb2YgdGhpcy5jdXN0b21CcmVha3NbYV0uZW5kVmFsdWUmJlxudGhpcy5jdXN0b21CcmVha3NbYV0uZW5kVmFsdWUhPT10aGlzLmN1c3RvbUJyZWFrc1thXS5zdGFydFZhbHVlKSYmdGhpcy5fYXBwbGllZEJyZWFrcy5wdXNoKHRoaXMuY3VzdG9tQnJlYWtzW2FdKTt0aGlzLl9hcHBsaWVkQnJlYWtzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zdGFydFZhbHVlLWIuc3RhcnRWYWx1ZX0pO2ZvcihhPTA7YTx0aGlzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aC0xO2ErKyl0aGlzLl9hcHBsaWVkQnJlYWtzW2FdLmVuZFZhbHVlPj10aGlzLl9hcHBsaWVkQnJlYWtzW2ErMV0uc3RhcnRWYWx1ZSYmKHRoaXMuX2FwcGxpZWRCcmVha3NbYV0uZW5kVmFsdWU9TWF0aC5tYXgodGhpcy5fYXBwbGllZEJyZWFrc1thXS5lbmRWYWx1ZSx0aGlzLl9hcHBsaWVkQnJlYWtzW2ErMV0uZW5kVmFsdWUpLHdpbmRvdy5jb25zb2xlJiZ3aW5kb3cuY29uc29sZS5sb2coXCJDYW52YXNKUyBFcnJvcjogQnJlYWtzIFwiK2ErXCIgYW5kIFwiKyhhKzEpK1wiIGFyZSBvdmVybGFwcGluZy5cIiksXG50aGlzLl9hcHBsaWVkQnJlYWtzLnNwbGljZShhLDIpLGEtLSl9fWZ1bmN0aW9uIGFhKGEsZCxjLGIsZSxmKXthYS5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIkJyZWFrXCIsZCxjLGIsZik7dGhpcy5pZD1lO3RoaXMuY2hhcnQ9YTt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLnNjYWxlQnJlYWtzPWY7dGhpcy5vcHRpb25zTmFtZT1kO3RoaXMuaXNPcHRpb25zSW5BcnJheT0hMDt0aGlzLnR5cGU9Yy50eXBlP3RoaXMudHlwZTpmLnR5cGU7dGhpcy5maWxsT3BhY2l0eT1yKGMuZmlsbE9wYWNpdHkpP2YuZmlsbE9wYWNpdHk6dGhpcy5maWxsT3BhY2l0eTt0aGlzLmxpbmVUaGlja25lc3M9cihjLmxpbmVUaGlja25lc3MpP2YubGluZVRoaWNrbmVzczp0aGlzLmxpbmVUaGlja25lc3M7dGhpcy5jb2xvcj1jLmNvbG9yP3RoaXMuY29sb3I6Zi5jb2xvcjt0aGlzLmxpbmVDb2xvcj1jLmxpbmVDb2xvcj90aGlzLmxpbmVDb2xvcjpmLmxpbmVDb2xvcjt0aGlzLmxpbmVEYXNoVHlwZT1cbmMubGluZURhc2hUeXBlP3RoaXMubGluZURhc2hUeXBlOmYubGluZURhc2hUeXBlOyFyKHRoaXMuc3RhcnRWYWx1ZSkmJnRoaXMuc3RhcnRWYWx1ZS5nZXRUaW1lJiYodGhpcy5zdGFydFZhbHVlPXRoaXMuc3RhcnRWYWx1ZS5nZXRUaW1lKCkpOyFyKHRoaXMuZW5kVmFsdWUpJiZ0aGlzLmVuZFZhbHVlLmdldFRpbWUmJih0aGlzLmVuZFZhbHVlPXRoaXMuZW5kVmFsdWUuZ2V0VGltZSgpKTtcIm51bWJlclwiPT09dHlwZW9mIHRoaXMuc3RhcnRWYWx1ZSYmKFwibnVtYmVyXCI9PT10eXBlb2YgdGhpcy5lbmRWYWx1ZSYmdGhpcy5lbmRWYWx1ZTx0aGlzLnN0YXJ0VmFsdWUpJiYoYT10aGlzLnN0YXJ0VmFsdWUsdGhpcy5zdGFydFZhbHVlPXRoaXMuZW5kVmFsdWUsdGhpcy5lbmRWYWx1ZT1hKTt0aGlzLnNwYWNpbmc9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjLnNwYWNpbmc/Zi5zcGFjaW5nOmMuc3BhY2luZztcInN0cmluZ1wiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5zcGFjaW5nPyh0aGlzLnNwYWNpbmc9XG5wYXJzZUZsb2F0KHRoaXMuc3BhY2luZyksdGhpcy5zcGFjaW5nPWlzTmFOKHRoaXMuc3BhY2luZyk/MDooMTA8dGhpcy5zcGFjaW5nPzEwOnRoaXMuc3BhY2luZykrXCIlXCIpOlwibnVtYmVyXCIhPT10eXBlb2YgdGhpcy5vcHRpb25zLnNwYWNpbmcmJih0aGlzLnNwYWNpbmc9Zi5zcGFjaW5nKTt0aGlzLnNpemU9Zi5wYXJlbnQubG9nYXJpdGhtaWM/MTowfWZ1bmN0aW9uIE4oYSxkLGMsYixlKXtOLmJhc2UuY29uc3RydWN0b3IuY2FsbCh0aGlzLFwiU3RyaXBMaW5lXCIsXCJzdHJpcExpbmVzXCIsZCxjLGUpO3RoaXMuaWQ9Yjt0aGlzLmNoYXJ0PWE7dGhpcy5jdHg9dGhpcy5jaGFydC5jdHg7dGhpcy5sYWJlbD10aGlzLmxhYmVsO3RoaXMuYXhpcz1lO3RoaXMub3B0aW9uc05hbWU9XCJzdHJpcExpbmVzXCI7dGhpcy5pc09wdGlvbnNJbkFycmF5PSEwO3RoaXMuX3RoaWNrbmVzc1R5cGU9XCJwaXhlbFwiO251bGwhPT10aGlzLnN0YXJ0VmFsdWUmJm51bGwhPT10aGlzLmVuZFZhbHVlJiYodGhpcy52YWx1ZT1cbmUubG9nYXJpdGhtaWM/TWF0aC5zcXJ0KCh0aGlzLnN0YXJ0VmFsdWUuZ2V0VGltZT90aGlzLnN0YXJ0VmFsdWUuZ2V0VGltZSgpOnRoaXMuc3RhcnRWYWx1ZSkqKHRoaXMuZW5kVmFsdWUuZ2V0VGltZT90aGlzLmVuZFZhbHVlLmdldFRpbWUoKTp0aGlzLmVuZFZhbHVlKSk6KCh0aGlzLnN0YXJ0VmFsdWUuZ2V0VGltZT90aGlzLnN0YXJ0VmFsdWUuZ2V0VGltZSgpOnRoaXMuc3RhcnRWYWx1ZSkrKHRoaXMuZW5kVmFsdWUuZ2V0VGltZT90aGlzLmVuZFZhbHVlLmdldFRpbWUoKTp0aGlzLmVuZFZhbHVlKSkvMix0aGlzLl90aGlja25lc3NUeXBlPW51bGwpfWZ1bmN0aW9uIGNhKGEsZCxjKXtjYS5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIkNyb3NzaGFpclwiLFwiY3Jvc3NoYWlyXCIsZCxudWxsLGMpO3RoaXMuY2hhcnQ9YTt0aGlzLmN0eD10aGlzLmNoYXJ0LmN0eDt0aGlzLmF4aXM9Yzt0aGlzLm9wdGlvbnNOYW1lPVwiY3Jvc3NoYWlyXCI7dGhpcy5fdGhpY2tuZXNzVHlwZT1cInBpeGVsXCJ9XG5mdW5jdGlvbiBVKGEsZCl7VS5iYXNlLmNvbnN0cnVjdG9yLmNhbGwodGhpcyxcIlRvb2xUaXBcIixcInRvb2xUaXBcIixkLG51bGwsYSk7dGhpcy5jaGFydD1hO3RoaXMuY2FudmFzPWEuY2FudmFzO3RoaXMuY3R4PXRoaXMuY2hhcnQuY3R4O3RoaXMuY3VycmVudERhdGFQb2ludEluZGV4PXRoaXMuY3VycmVudFNlcmllc0luZGV4PS0xO3RoaXMuX3ByZXZZPXRoaXMuX3ByZXZYPU5hTjt0aGlzLmNvbnRhaW5lclRyYW5zaXRpb25EdXJhdGlvbj0wLjE7dGhpcy5tb3pDb250YWluZXJUcmFuc2l0aW9uPXRoaXMuZ2V0Q29udGFpbmVyVHJhbnNpdGlvbih0aGlzLmNvbnRhaW5lclRyYW5zaXRpb25EdXJhdGlvbik7dGhpcy5vcHRpb25zTmFtZT1cInRvb2xUaXBcIjt0aGlzLl9pbml0aWFsaXplKCl9ZnVuY3Rpb24gWihhKXt0aGlzLmNoYXJ0PWE7dGhpcy5sYXN0T2JqZWN0SWQ9MDt0aGlzLm9iamVjdE1hcD1bXTt0aGlzLnJlY3Rhbmd1bGFyUmVnaW9uRXZlbnRTdWJzY3JpcHRpb25zPVtdO3RoaXMucHJldmlvdXNEYXRhUG9pbnRFdmVudE9iamVjdD1cbm51bGw7dGhpcy5naG9zdENhbnZhcz11YSh0aGlzLmNoYXJ0LndpZHRoLHRoaXMuY2hhcnQuaGVpZ2h0LCEwKTt0aGlzLmdob3N0Q3R4PXRoaXMuZ2hvc3RDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO3RoaXMubW91c2VvdmVyZWRPYmplY3RNYXBzPVtdfWZ1bmN0aW9uIGlhKGEpe3RoaXMuY2hhcnQ9YTt0aGlzLmN0eD10aGlzLmNoYXJ0LnBsb3RBcmVhLmN0eDt0aGlzLmFuaW1hdGlvbnM9W107dGhpcy5hbmltYXRpb25SZXF1ZXN0SWQ9bnVsbH1vYShwLEcpO3AucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmFsbERPTUV2ZW50SGFuZGxlcnM7dGhpcy5fYW5pbWF0b3ImJnRoaXMuX2FuaW1hdG9yLmNhbmNlbEFsbEFuaW1hdGlvbnMoKTt0aGlzLl9wYW5UaW1lcklkJiZjbGVhclRpbWVvdXQodGhpcy5fcGFuVGltZXJJZCk7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aDtkKyspe3ZhciBjPWFbZF1bMF0sYj1hW2RdWzFdLGU9YVtkXVsyXSxmPWFbZF1bM10sZj1mfHwhMTtcbmMucmVtb3ZlRXZlbnRMaXN0ZW5lcj9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixlLGYpOmMuZGV0YWNoRXZlbnQmJmMuZGV0YWNoRXZlbnQoXCJvblwiK2IsZSl9dGhpcy5hbGxET01FdmVudEhhbmRsZXJzPVtdO2Zvcih0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCk7dGhpcy5fY2FudmFzSlNDb250YWluZXImJnRoaXMuX2NhbnZhc0pTQ29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKTspdGhpcy5fY2FudmFzSlNDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fY2FudmFzSlNDb250YWluZXIubGFzdENoaWxkKTtmb3IoO3RoaXMuY29udGFpbmVyJiZ0aGlzLmNvbnRhaW5lci5oYXNDaGlsZE5vZGVzKCk7KXRoaXMuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyLmxhc3RDaGlsZCk7Zm9yKDt0aGlzLl9kcm9wZG93bk1lbnUmJnRoaXMuX2Ryb3Bkb3duTWVudS5oYXNDaGlsZE5vZGVzKCk7KXRoaXMuX2Ryb3Bkb3duTWVudS5yZW1vdmVDaGlsZCh0aGlzLl9kcm9wZG93bk1lbnUubGFzdENoaWxkKTtcbnRoaXMuY29udGFpbmVyPXRoaXMuX2NhbnZhc0pTQ29udGFpbmVyPW51bGw7dGhpcy50b29sVGlwLmNvbnRhaW5lcj1udWxsO3RoaXMuY2FudmFzJiZ5YSh0aGlzLmNhbnZhcyk7dGhpcy5vdmVybGFpZENhbnZhcyYmeWEodGhpcy5vdmVybGFpZENhbnZhcyk7dGhpcy5fcHJlUmVuZGVyQ2FudmFzJiZ5YSh0aGlzLl9wcmVSZW5kZXJDYW52YXMpO3RoaXMuX2JyZWFrc0NhbnZhcyYmeWEodGhpcy5fYnJlYWtzQ2FudmFzKTt0aGlzLl9ldmVudE1hbmFnZXImJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdENhbnZhcyYmeWEodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q2FudmFzKTt0aGlzLl90b29sQmFyPXRoaXMuX2Ryb3Bkb3duTWVudT10aGlzLl9tZW51QnV0dG9uPXRoaXMuX3Jlc2V0QnV0dG9uPXRoaXMuX3pvb21CdXR0b249bnVsbH07cC5wcm90b3R5cGUuX3VwZGF0ZU9wdGlvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3RoaXMudXBkYXRlT3B0aW9uKFwid2lkdGhcIik7dGhpcy51cGRhdGVPcHRpb24oXCJoZWlnaHRcIik7XG50aGlzLnVwZGF0ZU9wdGlvbihcImRhdGFQb2ludFdpZHRoXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwiZGF0YVBvaW50TWluV2lkdGhcIik7dGhpcy51cGRhdGVPcHRpb24oXCJkYXRhUG9pbnRNYXhXaWR0aFwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcImludGVyYWN0aXZpdHlFbmFibGVkXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwidGhlbWVcIik7dGhpcy51cGRhdGVPcHRpb24oXCJjb2xvclNldFwiKSYmKHRoaXMuc2VsZWN0ZWRDb2xvclNldD1cInVuZGVmaW5lZFwiIT09dHlwZW9mIEFhW3RoaXMuY29sb3JTZXRdP0FhW3RoaXMuY29sb3JTZXRdOkFhLmNvbG9yU2V0MSk7dGhpcy51cGRhdGVPcHRpb24oXCJiYWNrZ3JvdW5kQ29sb3JcIik7dGhpcy5iYWNrZ3JvdW5kQ29sb3J8fCh0aGlzLmJhY2tncm91bmRDb2xvcj1cInJnYmEoMCwwLDAsMClcIik7dGhpcy51cGRhdGVPcHRpb24oXCJjdWx0dXJlXCIpO3RoaXMuX2N1bHR1cmVJbmZvPW5ldyBLYSh0aGlzLm9wdGlvbnMuY3VsdHVyZSk7dGhpcy51cGRhdGVPcHRpb24oXCJhbmltYXRpb25FbmFibGVkXCIpO1xudGhpcy5hbmltYXRpb25FbmFibGVkPXRoaXMuYW5pbWF0aW9uRW5hYmxlZCYmdzt0aGlzLnVwZGF0ZU9wdGlvbihcImFuaW1hdGlvbkR1cmF0aW9uXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwicmFuZ2VDaGFuZ2luZ1wiKTt0aGlzLnVwZGF0ZU9wdGlvbihcInJhbmdlQ2hhbmdlZFwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcImV4cG9ydEVuYWJsZWRcIik7dGhpcy51cGRhdGVPcHRpb24oXCJleHBvcnRGaWxlTmFtZVwiKTt0aGlzLnVwZGF0ZU9wdGlvbihcInpvb21UeXBlXCIpO3RoaXMudG9vbGJhcj1uZXcgVWEodGhpcyx0aGlzLm9wdGlvbnMudG9vbGJhcik7aWYodGhpcy5vcHRpb25zLnpvb21FbmFibGVkfHx0aGlzLnBhbkVuYWJsZWQpe2lmKHRoaXMuX3pvb21CdXR0b24pVih0aGlzLl96b29tQnV0dG9uLHtib3JkZXJSaWdodDp0aGlzLnRvb2xiYXIuYnV0dG9uQm9yZGVyVGhpY2tuZXNzK1wicHggc29saWQgXCIrdGhpcy50b29sYmFyLmJ1dHRvbkJvcmRlckNvbG9yLGJhY2tncm91bmRDb2xvcjphLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcixcbmNvbG9yOmEudG9vbGJhci5mb250Q29sb3J9KSxzYSh0aGlzLHRoaXMuX3pvb21CdXR0b24sXCJ6b29tXCIpO2Vsc2V7dmFyIGQ9ITE7d2EodGhpcy5fem9vbUJ1dHRvbj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpKTtzYSh0aGlzLHRoaXMuX3pvb21CdXR0b24sXCJwYW5cIik7dGhpcy5fdG9vbEJhci5hcHBlbmRDaGlsZCh0aGlzLl96b29tQnV0dG9uKTt0aGlzLl96b29tQnV0dG9uLnN0eWxlLmJvcmRlclJpZ2h0PXRoaXMudG9vbGJhci5idXR0b25Cb3JkZXJUaGlja25lc3MrXCJweCBzb2xpZCBcIit0aGlzLnRvb2xiYXIuYnV0dG9uQm9yZGVyQ29sb3I7UCh0aGlzLl96b29tQnV0dG9uLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGEpe2Q9ITB9LHRoaXMuYWxsRE9NRXZlbnRIYW5kbGVycyk7UCh0aGlzLl96b29tQnV0dG9uLFwiY2xpY2tcIixmdW5jdGlvbigpe2Euem9vbUVuYWJsZWQ/KGEuem9vbUVuYWJsZWQ9ITEsYS5wYW5FbmFibGVkPSEwLHNhKGEsYS5fem9vbUJ1dHRvbixcInpvb21cIikpOlxuKGEuem9vbUVuYWJsZWQ9ITAsYS5wYW5FbmFibGVkPSExLHNhKGEsYS5fem9vbUJ1dHRvbixcInBhblwiKSk7YS5yZW5kZXIoKX0sdGhpcy5hbGxET01FdmVudEhhbmRsZXJzKTtQKHRoaXMuX3pvb21CdXR0b24sXCJtb3VzZW1vdmVcIixmdW5jdGlvbigpe2Q/ZD0hMTooVihhLl96b29tQnV0dG9uLHtiYWNrZ3JvdW5kQ29sb3I6YS50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3JPbkhvdmVyLGNvbG9yOmEudG9vbGJhci5mb250Q29sb3JPbkhvdmVyLHRyYW5zaXRpb246XCIwLjRzXCIsV2Via2l0VHJhbnNpdGlvbjpcIjAuNHNcIn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmVihhLl96b29tQnV0dG9uLmNoaWxkTm9kZXNbMF0se1dlYmtpdEZpbHRlcjpcImludmVydCgxMDAlKVwiLGZpbHRlcjpcImludmVydCgxMDAlKVwifSkpfSx0aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpO1AodGhpcy5fem9vbUJ1dHRvbixcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtkfHwoVihhLl96b29tQnV0dG9uLFxue2JhY2tncm91bmRDb2xvcjphLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcixjb2xvcjphLnRvb2xiYXIuZm9udENvbG9yLHRyYW5zaXRpb246XCIwLjRzXCIsV2Via2l0VHJhbnNpdGlvbjpcIjAuNHNcIn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmVihhLl96b29tQnV0dG9uLmNoaWxkTm9kZXNbMF0se1dlYmtpdEZpbHRlcjpcImludmVydCgwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMCUpXCJ9KSl9LHRoaXMuYWxsRE9NRXZlbnRIYW5kbGVycyl9dGhpcy5fcmVzZXRCdXR0b24/KFYodGhpcy5fcmVzZXRCdXR0b24se2JvcmRlclJpZ2h0OnRoaXMudG9vbGJhci5idXR0b25Cb3JkZXJUaGlja25lc3MrXCJweCBzb2xpZCBcIit0aGlzLnRvb2xiYXIuYnV0dG9uQm9yZGVyQ29sb3IsYmFja2dyb3VuZENvbG9yOmEudG9vbGJhci5pdGVtQmFja2dyb3VuZENvbG9yLGNvbG9yOmEudG9vbGJhci5mb250Q29sb3J9KSx0aGlzLl9yZXNldEJ1dHRvbi50aXRsZT10aGlzLl9jdWx0dXJlSW5mby5yZXNldFRleHQpOlxuKGQ9ITEsd2EodGhpcy5fcmVzZXRCdXR0b249ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSksc2EodGhpcyx0aGlzLl9yZXNldEJ1dHRvbixcInJlc2V0XCIpLHRoaXMuX3Jlc2V0QnV0dG9uLnN0eWxlLmJvcmRlclJpZ2h0PSh0aGlzLmV4cG9ydEVuYWJsZWQ/dGhpcy50b29sYmFyLmJ1dHRvbkJvcmRlclRoaWNrbmVzczowKStcInB4IHNvbGlkIFwiK3RoaXMudG9vbGJhci5idXR0b25Cb3JkZXJDb2xvcix0aGlzLl90b29sQmFyLmFwcGVuZENoaWxkKHRoaXMuX3Jlc2V0QnV0dG9uKSxQKHRoaXMuX3Jlc2V0QnV0dG9uLFwidG91Y2hzdGFydFwiLGZ1bmN0aW9uKGEpe2Q9ITB9LHRoaXMuYWxsRE9NRXZlbnRIYW5kbGVycyksUCh0aGlzLl9yZXNldEJ1dHRvbixcImNsaWNrXCIsZnVuY3Rpb24oKXthLnRvb2xUaXAuaGlkZSgpO2EudG9vbFRpcCYmYS50b29sVGlwLmVuYWJsZWQmJmEudG9vbFRpcC5kaXNwYXRjaEV2ZW50KFwiaGlkZGVuXCIse2NoYXJ0OmEsdG9vbFRpcDphLnRvb2xUaXB9LFxuYS50b29sVGlwKTthLnpvb21FbmFibGVkfHxhLnBhbkVuYWJsZWQ/KGEuem9vbUVuYWJsZWQ9ITAsYS5wYW5FbmFibGVkPSExLHNhKGEsYS5fem9vbUJ1dHRvbixcInBhblwiKSxhLl9kZWZhdWx0Q3Vyc29yPVwiZGVmYXVsdFwiLGEub3ZlcmxhaWRDYW52YXMuc3R5bGUuY3Vyc29yPWEuX2RlZmF1bHRDdXJzb3IpOihhLnpvb21FbmFibGVkPSExLGEucGFuRW5hYmxlZD0hMSk7aWYoYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYKWZvcih2YXIgYj0wO2I8YS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYLmxlbmd0aDtiKyspYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYW2JdLm5ld1ZpZXdwb3J0TWluaW11bT1udWxsLGEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWFtiXS5uZXdWaWV3cG9ydE1heGltdW09bnVsbDtpZihhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyKWZvcihiPTA7YjxhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyLmxlbmd0aDtiKyspYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNYMltiXS5uZXdWaWV3cG9ydE1pbmltdW09XG5udWxsLGEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWDJbYl0ubmV3Vmlld3BvcnRNYXhpbXVtPW51bGw7aWYoYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZKWZvcihiPTA7YjxhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1kubGVuZ3RoO2IrKylhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1lbYl0ubmV3Vmlld3BvcnRNaW5pbXVtPW51bGwsYS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZW2JdLm5ld1ZpZXdwb3J0TWF4aW11bT1udWxsO2lmKGEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWTIpZm9yKGI9MDtiPGEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWTIubGVuZ3RoO2IrKylhLnNlc3Npb25WYXJpYWJsZXMuYXhpc1kyW2JdLm5ld1ZpZXdwb3J0TWluaW11bT1udWxsLGEuc2Vzc2lvblZhcmlhYmxlcy5heGlzWTJbYl0ubmV3Vmlld3BvcnRNYXhpbXVtPW51bGw7YS5yZXNldE92ZXJsYXllZENhbnZhcygpOzA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmVihhLl9yZXNldEJ1dHRvbi5jaGlsZE5vZGVzWzBdLFxue1dlYmtpdEZpbHRlcjpcImludmVydCgwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMCUpXCJ9KTt3YShhLl96b29tQnV0dG9uLGEuX3Jlc2V0QnV0dG9uKTthLnN0b2NrQ2hhcnQmJihhLnN0b2NrQ2hhcnQuX3JhbmdlRXZlbnRQYXJhbWV0ZXI9e3N0b2NrQ2hhcnQ6YS5zdG9ja0NoYXJ0LHNvdXJjZTpcImNoYXJ0XCIsaW5kZXg6YS5zdG9ja0NoYXJ0LmNoYXJ0cy5pbmRleE9mKGEpLG1pbmltdW06bnVsbCxtYXhpbXVtOm51bGx9KTthLl9kaXNwYXRjaFJhbmdlRXZlbnQoXCJyYW5nZUNoYW5naW5nXCIsXCJyZXNldFwiKTthLnN0b2NrQ2hhcnQmJihhLnN0b2NrQ2hhcnQuX3JhbmdlRXZlbnRQYXJhbWV0ZXIudHlwZT1cInJhbmdlQ2hhbmdpbmdcIixhLnN0b2NrQ2hhcnQuZGlzcGF0Y2hFdmVudChcInJhbmdlQ2hhbmdpbmdcIixhLnN0b2NrQ2hhcnQuX3JhbmdlRXZlbnRQYXJhbWV0ZXIsYS5zdG9ja0NoYXJ0KSk7YS5yZW5kZXIoKTthLnN5bmNDaGFydHMmJmEuc3luY0NoYXJ0cyhudWxsLG51bGwpO2EuX2Rpc3BhdGNoUmFuZ2VFdmVudChcInJhbmdlQ2hhbmdlZFwiLFxuXCJyZXNldFwiKTthLnN0b2NrQ2hhcnQmJihhLnN0b2NrQ2hhcnQuX3JhbmdlRXZlbnRQYXJhbWV0ZXIudHlwZT1cInJhbmdlQ2hhbmdlZFwiLGEuc3RvY2tDaGFydC5kaXNwYXRjaEV2ZW50KFwicmFuZ2VDaGFuZ2VkXCIsYS5zdG9ja0NoYXJ0Ll9yYW5nZUV2ZW50UGFyYW1ldGVyLGEuc3RvY2tDaGFydCkpfSx0aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpLFAodGhpcy5fcmVzZXRCdXR0b24sXCJtb3VzZW1vdmVcIixmdW5jdGlvbigpe2R8fChWKGEuX3Jlc2V0QnV0dG9uLHtiYWNrZ3JvdW5kQ29sb3I6YS50b29sYmFyLml0ZW1CYWNrZ3JvdW5kQ29sb3JPbkhvdmVyLGNvbG9yOmEudG9vbGJhci5mb250Q29sb3JPbkhvdmVyLHRyYW5zaXRpb246XCIwLjRzXCIsV2Via2l0VHJhbnNpdGlvbjpcIjAuNHNcIn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmVihhLl9yZXNldEJ1dHRvbi5jaGlsZE5vZGVzWzBdLHtXZWJraXRGaWx0ZXI6XCJpbnZlcnQoMTAwJSlcIixmaWx0ZXI6XCJpbnZlcnQoMTAwJSlcIn0pKX0sXG50aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpLFAodGhpcy5fcmVzZXRCdXR0b24sXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7ZHx8KFYoYS5fcmVzZXRCdXR0b24se2JhY2tncm91bmRDb2xvcjphLnRvb2xiYXIuaXRlbUJhY2tncm91bmRDb2xvcixjb2xvcjphLnRvb2xiYXIuZm9udENvbG9yLHRyYW5zaXRpb246XCIwLjRzXCIsV2Via2l0VHJhbnNpdGlvbjpcIjAuNHNcIn0pLDA+PW5hdmlnYXRvci51c2VyQWdlbnQuc2VhcmNoKFwiTVNJRVwiKSYmVihhLl9yZXNldEJ1dHRvbi5jaGlsZE5vZGVzWzBdLHtXZWJraXRGaWx0ZXI6XCJpbnZlcnQoMCUpXCIsZmlsdGVyOlwiaW52ZXJ0KDAlKVwifSkpfSx0aGlzLmFsbERPTUV2ZW50SGFuZGxlcnMpLHRoaXMub3ZlcmxhaWRDYW52YXMuc3R5bGUuY3Vyc29yPWEuX2RlZmF1bHRDdXJzb3IpO3RoaXMuem9vbUVuYWJsZWR8fHRoaXMucGFuRW5hYmxlZHx8KHRoaXMuX3pvb21CdXR0b24/KGEuX3pvb21CdXR0b24uZ2V0QXR0cmlidXRlKFwic3RhdGVcIik9PT1hLl9jdWx0dXJlSW5mby56b29tVGV4dD9cbih0aGlzLnBhbkVuYWJsZWQ9ITAsdGhpcy56b29tRW5hYmxlZD0hMSk6KHRoaXMuem9vbUVuYWJsZWQ9ITAsdGhpcy5wYW5FbmFibGVkPSExKSxNYShhLl96b29tQnV0dG9uLGEuX3Jlc2V0QnV0dG9uKSk6KHRoaXMuem9vbUVuYWJsZWQ9ITAsdGhpcy5wYW5FbmFibGVkPSExKSl9ZWxzZSB0aGlzLnBhbkVuYWJsZWQ9dGhpcy56b29tRW5hYmxlZD0hMTtoYih0aGlzKTtcIm5vbmVcIiE9PXRoaXMuX3Rvb2xCYXIuc3R5bGUuZGlzcGxheSYmdGhpcy5fem9vbUJ1dHRvbiYmKHRoaXMucGFuRW5hYmxlZD9zYShhLGEuX3pvb21CdXR0b24sXCJ6b29tXCIpOnNhKGEsYS5fem9vbUJ1dHRvbixcInBhblwiKSxhLl9yZXNldEJ1dHRvbi5nZXRBdHRyaWJ1dGUoXCJzdGF0ZVwiKSE9PWEuX2N1bHR1cmVJbmZvLnJlc2V0VGV4dCYmc2EoYSxhLl9yZXNldEJ1dHRvbixcInJlc2V0XCIpKTt0aGlzLm9wdGlvbnMudG9vbFRpcCYmdGhpcy50b29sVGlwLm9wdGlvbnMhPT10aGlzLm9wdGlvbnMudG9vbFRpcCYmKHRoaXMudG9vbFRpcC5vcHRpb25zPVxudGhpcy5vcHRpb25zLnRvb2xUaXApO2Zvcih2YXIgYyBpbiB0aGlzLnRvb2xUaXAub3B0aW9ucyl0aGlzLnRvb2xUaXAub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShjKSYmdGhpcy50b29sVGlwLnVwZGF0ZU9wdGlvbihjKX07cC5wcm90b3R5cGUuX3VwZGF0ZVNpemU9ZnVuY3Rpb24oKXt2YXIgYTthPVt0aGlzLmNhbnZhcyx0aGlzLm92ZXJsYWlkQ2FudmFzLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdENhbnZhc107dmFyIGQ9MCxjPTA7dGhpcy5vcHRpb25zLndpZHRoP2Q9dGhpcy53aWR0aDp0aGlzLndpZHRoPWQ9MDx0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aD90aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDp0aGlzLndpZHRoO3RoaXMub3B0aW9ucy5oZWlnaHQ/Yz10aGlzLmhlaWdodDp0aGlzLmhlaWdodD1jPTA8dGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0P3RoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodDp0aGlzLmhlaWdodDtpZih0aGlzLmNhbnZhcy53aWR0aCE9PWQqXG5sYXx8dGhpcy5jYW52YXMuaGVpZ2h0IT09YypsYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspTmEoYVtiXSxkLGMpO3RoaXMuYm91bmRzPXt4MTowLHkxOjAseDI6dGhpcy53aWR0aCx5Mjp0aGlzLmhlaWdodCx3aWR0aDp0aGlzLndpZHRoLGhlaWdodDp0aGlzLmhlaWdodH07YT0hMH1lbHNlIGE9ITE7cmV0dXJuIGF9O3AucHJvdG90eXBlLl9pbml0aWFsaXplPWZ1bmN0aW9uKCl7dGhpcy5pc05hdmlnYXRvcj1yKHRoaXMucGFyZW50KXx8cih0aGlzLnBhcmVudC5fZGVmYXVsdHNLZXkpfHxcIk5hdmlnYXRvclwiIT09dGhpcy5wYXJlbnQuX2RlZmF1bHRzS2V5PyExOiEwO3RoaXMuX2FuaW1hdG9yP3RoaXMuX2FuaW1hdG9yLmNhbmNlbEFsbEFuaW1hdGlvbnMoKTp0aGlzLl9hbmltYXRvcj1uZXcgaWEodGhpcyk7dGhpcy5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpO3RoaXMuZGlzYWJsZVRvb2xUaXA9ITE7dGhpcy5fYXhlcz1bXTt0aGlzLmZ1bm5lbFB5cmFtaWRDbGlja0hhbmRsZXI9XG50aGlzLnBpZURvdWdobnV0Q2xpY2tIYW5kbGVyPW51bGw7dGhpcy5fdXBkYXRlT3B0aW9ucygpO3RoaXMuYW5pbWF0ZWRSZW5kZXI9dyYmdGhpcy5hbmltYXRpb25FbmFibGVkJiYwPT09dGhpcy5yZW5kZXJDb3VudDt0aGlzLl91cGRhdGVTaXplKCk7dGhpcy5jbGVhckNhbnZhcygpO3RoaXMuY3R4LmJlZ2luUGF0aCgpO3RoaXMuYXhpc1g9W107dGhpcy5heGlzWDI9W107dGhpcy5heGlzWT1bXTt0aGlzLmF4aXNZMj1bXTt0aGlzLl9pbmRleExhYmVscz1bXTt0aGlzLl9kYXRhSW5SZW5kZXJlZE9yZGVyPVtdO3RoaXMuX2V2ZW50cz1bXTt0aGlzLl9ldmVudE1hbmFnZXImJnRoaXMuX2V2ZW50TWFuYWdlci5yZXNldCgpO3RoaXMucGxvdEluZm89e2F4aXNQbGFjZW1lbnQ6bnVsbCxwbG90VHlwZXM6W119O3RoaXMubGF5b3V0TWFuYWdlcj1uZXcgRmEoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5pc05hdmlnYXRvcj8wOjIpO3RoaXMucGxvdEFyZWEubGF5b3V0TWFuYWdlciYmXG50aGlzLnBsb3RBcmVhLmxheW91dE1hbmFnZXIucmVzZXQoKTt0aGlzLmRhdGE9W107dGhpcy50aXRsZT1udWxsO3RoaXMuc3VidGl0bGVzPVtdO3ZhciBhPTAsZD1udWxsO2lmKHRoaXMub3B0aW9ucy5kYXRhKXtmb3IodmFyIGM9MDtjPHRoaXMub3B0aW9ucy5kYXRhLmxlbmd0aDtjKyspaWYoYSsrLCF0aGlzLm9wdGlvbnMuZGF0YVtjXS50eXBlfHwwPD1wLl9zdXBwb3J0ZWRDaGFydFR5cGVzLmluZGV4T2YodGhpcy5vcHRpb25zLmRhdGFbY10udHlwZSkpe3ZhciBiPW5ldyBRKHRoaXMsdGhpcy5vcHRpb25zLmRhdGFbY10sYS0xLCsrdGhpcy5fZXZlbnRNYW5hZ2VyLmxhc3RPYmplY3RJZCk7XCJlcnJvclwiPT09Yi50eXBlJiYoYi5saW5rZWREYXRhU2VyaWVzSW5kZXg9cih0aGlzLm9wdGlvbnMuZGF0YVtjXS5saW5rZWREYXRhU2VyaWVzSW5kZXgpP2MtMTp0aGlzLm9wdGlvbnMuZGF0YVtjXS5saW5rZWREYXRhU2VyaWVzSW5kZXgsMD5iLmxpbmtlZERhdGFTZXJpZXNJbmRleHx8Yi5saW5rZWREYXRhU2VyaWVzSW5kZXg+PVxudGhpcy5vcHRpb25zLmRhdGEubGVuZ3RofHxcIm51bWJlclwiIT09dHlwZW9mIGIubGlua2VkRGF0YVNlcmllc0luZGV4fHxcImVycm9yXCI9PT10aGlzLm9wdGlvbnMuZGF0YVtiLmxpbmtlZERhdGFTZXJpZXNJbmRleF0udHlwZSkmJihiLmxpbmtlZERhdGFTZXJpZXNJbmRleD1udWxsKTtudWxsPT09Yi5uYW1lJiYoYi5uYW1lPVwiRGF0YVNlcmllcyBcIithKTtudWxsPT09Yi5jb2xvcj8xPHRoaXMub3B0aW9ucy5kYXRhLmxlbmd0aD8oYi5fY29sb3JTZXQ9W3RoaXMuc2VsZWN0ZWRDb2xvclNldFtiLmluZGV4JXRoaXMuc2VsZWN0ZWRDb2xvclNldC5sZW5ndGhdXSxiLmNvbG9yPXRoaXMuc2VsZWN0ZWRDb2xvclNldFtiLmluZGV4JXRoaXMuc2VsZWN0ZWRDb2xvclNldC5sZW5ndGhdKTpiLl9jb2xvclNldD1cImxpbmVcIj09PWIudHlwZXx8XCJzdGVwTGluZVwiPT09Yi50eXBlfHxcInNwbGluZVwiPT09Yi50eXBlfHxcImFyZWFcIj09PWIudHlwZXx8XCJzdGVwQXJlYVwiPT09Yi50eXBlfHxcInNwbGluZUFyZWFcIj09PVxuYi50eXBlfHxcInN0YWNrZWRBcmVhXCI9PT1iLnR5cGV8fFwic3RhY2tlZEFyZWExMDBcIj09PWIudHlwZXx8XCJyYW5nZUFyZWFcIj09PWIudHlwZXx8XCJyYW5nZVNwbGluZUFyZWFcIj09PWIudHlwZXx8XCJjYW5kbGVzdGlja1wiPT09Yi50eXBlfHxcIm9obGNcIj09PWIudHlwZXx8XCJ3YXRlcmZhbGxcIj09PWIudHlwZXx8XCJib3hBbmRXaGlza2VyXCI9PT1iLnR5cGU/W3RoaXMuc2VsZWN0ZWRDb2xvclNldFswXV06dGhpcy5zZWxlY3RlZENvbG9yU2V0OmIuX2NvbG9yU2V0PVtiLmNvbG9yXTtudWxsPT09Yi5tYXJrZXJTaXplJiYoKFwibGluZVwiPT09Yi50eXBlfHxcInN0ZXBMaW5lXCI9PT1iLnR5cGV8fFwic3BsaW5lXCI9PT1iLnR5cGV8fDA8PWIudHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcmVhXCIpKSYmYi5kYXRhUG9pbnRzJiZiLmRhdGFQb2ludHMubGVuZ3RoPHRoaXMud2lkdGgvMTZ8fFwic2NhdHRlclwiPT09Yi50eXBlKSYmKGIubWFya2VyU2l6ZT04KTtcImJ1YmJsZVwiIT09Yi50eXBlJiZcInNjYXR0ZXJcIiE9PVxuYi50eXBlfHwhYi5kYXRhUG9pbnRzfHwoYi5kYXRhUG9pbnRzLnNvbWU/Yi5kYXRhUG9pbnRzLnNvbWUoZnVuY3Rpb24oYSl7cmV0dXJuIGEueH0pJiZiLmRhdGFQb2ludHMuc29ydChoKTpiLmRhdGFQb2ludHMuc29ydChoKSk7dGhpcy5kYXRhLnB1c2goYik7dmFyIGU9Yi5heGlzUGxhY2VtZW50LGQ9ZHx8ZSxmO1wibm9ybWFsXCI9PT1lP1wieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/Zj0nWW91IGNhbm5vdCBjb21iaW5lIFwiJytiLnR5cGUrJ1wiIHdpdGggYmFyIGNoYXJ0JzpcIm5vbmVcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD9mPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2IudHlwZSsnXCIgd2l0aCBwaWUgY2hhcnQnOm51bGw9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJih0aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ9XCJub3JtYWxcIik6XCJ4eVN3YXBwZWRcIj09PWU/XCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD9cbmY9J1lvdSBjYW5ub3QgY29tYmluZSBcIicrYi50eXBlKydcIiB3aXRoIGxpbmUsIGFyZWEsIGNvbHVtbiBvciBwaWUgY2hhcnQnOlwibm9uZVwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P2Y9J1lvdSBjYW5ub3QgY29tYmluZSBcIicrYi50eXBlKydcIiB3aXRoIHBpZSBjaGFydCc6bnVsbD09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmKHRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD1cInh5U3dhcHBlZFwiKTpcIm5vbmVcIj09PWU/XCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD9mPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2IudHlwZSsnXCIgd2l0aCBsaW5lLCBhcmVhLCBjb2x1bW4gb3IgYmFyIGNoYXJ0JzpcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P2Y9J1lvdSBjYW5ub3QgY29tYmluZSBcIicrYi50eXBlKydcIiB3aXRoIGJhciBjaGFydCc6bnVsbD09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmKHRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD1cblwibm9uZVwiKTpudWxsPT09ZSYmXCJub25lXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJihmPSdZb3UgY2Fubm90IGNvbWJpbmUgXCInK2IudHlwZSsnXCIgd2l0aCBwaWUgY2hhcnQnKTtpZihmJiZ3aW5kb3cuY29uc29sZSl7d2luZG93LmNvbnNvbGUubG9nKGYpO3JldHVybn19Zm9yKGM9MDtjPHRoaXMuZGF0YS5sZW5ndGg7YysrKXtpZihcIm5vbmVcIj09ZCYmXCJlcnJvclwiPT09dGhpcy5kYXRhW2NdLnR5cGUmJndpbmRvdy5jb25zb2xlKXt3aW5kb3cuY29uc29sZS5sb2coJ1lvdSBjYW5ub3QgY29tYmluZSBcIicrYi50eXBlKydcIiB3aXRoIGVycm9yIGNoYXJ0Jyk7cmV0dXJufVwiZXJyb3JcIj09PXRoaXMuZGF0YVtjXS50eXBlJiYodGhpcy5kYXRhW2NdLmF4aXNQbGFjZW1lbnQ9dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50PWR8fFwibm9ybWFsXCIsdGhpcy5kYXRhW2NdLl9saW5rZWRTZXJpZXM9bnVsbD09PXRoaXMuZGF0YVtjXS5saW5rZWREYXRhU2VyaWVzSW5kZXg/bnVsbDpcbnRoaXMuZGF0YVt0aGlzLmRhdGFbY10ubGlua2VkRGF0YVNlcmllc0luZGV4XSl9fXRoaXMuX29iamVjdHNJbml0aWFsaXplZD0hMDt0aGlzLl9wbG90QXJlYUVsZW1lbnRzPVtdfTtwLl9zdXBwb3J0ZWRDaGFydFR5cGVzPUVhKFwibGluZSBzdGVwTGluZSBzcGxpbmUgY29sdW1uIGFyZWEgc3RlcEFyZWEgc3BsaW5lQXJlYSBiYXIgYnViYmxlIHNjYXR0ZXIgc3RhY2tlZENvbHVtbiBzdGFja2VkQ29sdW1uMTAwIHN0YWNrZWRCYXIgc3RhY2tlZEJhcjEwMCBzdGFja2VkQXJlYSBzdGFja2VkQXJlYTEwMCBjYW5kbGVzdGljayBvaGxjIGJveEFuZFdoaXNrZXIgcmFuZ2VDb2x1bW4gZXJyb3IgcmFuZ2VCYXIgcmFuZ2VBcmVhIHJhbmdlU3BsaW5lQXJlYSBwaWUgZG91Z2hudXQgZnVubmVsIHB5cmFtaWQgd2F0ZXJmYWxsXCIuc3BsaXQoXCIgXCIpKTtwLnByb3RvdHlwZS5zZXRMYXlvdXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5fcGxvdEFyZWFFbGVtZW50cyxkPTA7ZDx0aGlzLmRhdGEubGVuZ3RoO2QrKylpZihcIm5vcm1hbFwiPT09XG50aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnR8fFwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpe2lmKCF0aGlzLmRhdGFbZF0uYXhpc1lUeXBlfHxcInByaW1hcnlcIj09PXRoaXMuZGF0YVtkXS5heGlzWVR5cGUpaWYodGhpcy5vcHRpb25zLmF4aXNZJiYwPHRoaXMub3B0aW9ucy5heGlzWS5sZW5ndGgpe2lmKCF0aGlzLmF4aXNZLmxlbmd0aClmb3IodmFyIGM9MDtjPHRoaXMub3B0aW9ucy5heGlzWS5sZW5ndGg7YysrKVwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/dGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1lbY109bmV3IEEodGhpcyxcImF4aXNZXCIsdGhpcy5vcHRpb25zLmF4aXNZW2NdLGMsXCJheGlzWVwiLFwibGVmdFwiKSk6XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmdGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1lbY109bmV3IEEodGhpcyxcImF4aXNZXCIsdGhpcy5vcHRpb25zLmF4aXNZW2NdLGMsXCJheGlzWVwiLFxuXCJib3R0b21cIikpO3RoaXMuZGF0YVtkXS5heGlzWT10aGlzLmF4aXNZWzA8PXRoaXMuZGF0YVtkXS5heGlzWUluZGV4JiZ0aGlzLmRhdGFbZF0uYXhpc1lJbmRleDx0aGlzLmF4aXNZLmxlbmd0aD90aGlzLmRhdGFbZF0uYXhpc1lJbmRleDowXTt0aGlzLmF4aXNZWzA8PXRoaXMuZGF0YVtkXS5heGlzWUluZGV4JiZ0aGlzLmRhdGFbZF0uYXhpc1lJbmRleDx0aGlzLmF4aXNZLmxlbmd0aD90aGlzLmRhdGFbZF0uYXhpc1lJbmRleDowXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2RdKX1lbHNlIHRoaXMuYXhpc1kubGVuZ3RofHwoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD90aGlzLl9heGVzLnB1c2godGhpcy5heGlzWVswXT1uZXcgQSh0aGlzLFwiYXhpc1lcIix0aGlzLm9wdGlvbnMuYXhpc1ksMCxcImF4aXNZXCIsXCJsZWZ0XCIpKTpcInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiZ0aGlzLl9heGVzLnB1c2godGhpcy5heGlzWVswXT1uZXcgQSh0aGlzLFxuXCJheGlzWVwiLHRoaXMub3B0aW9ucy5heGlzWSwwLFwiYXhpc1lcIixcImJvdHRvbVwiKSkpLHRoaXMuZGF0YVtkXS5heGlzWT10aGlzLmF4aXNZWzBdLHRoaXMuYXhpc1lbMF0uZGF0YVNlcmllcy5wdXNoKHRoaXMuZGF0YVtkXSk7aWYoXCJzZWNvbmRhcnlcIj09PXRoaXMuZGF0YVtkXS5heGlzWVR5cGUpaWYodGhpcy5vcHRpb25zLmF4aXNZMiYmMDx0aGlzLm9wdGlvbnMuYXhpc1kyLmxlbmd0aCl7aWYoIXRoaXMuYXhpc1kyLmxlbmd0aClmb3IoYz0wO2M8dGhpcy5vcHRpb25zLmF4aXNZMi5sZW5ndGg7YysrKVwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/dGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1kyW2NdPW5ldyBBKHRoaXMsXCJheGlzWTJcIix0aGlzLm9wdGlvbnMuYXhpc1kyW2NdLGMsXCJheGlzWVwiLFwicmlnaHRcIikpOlwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJnRoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNZMltjXT1uZXcgQSh0aGlzLFxuXCJheGlzWTJcIix0aGlzLm9wdGlvbnMuYXhpc1kyW2NdLGMsXCJheGlzWVwiLFwidG9wXCIpKTt0aGlzLmRhdGFbZF0uYXhpc1k9dGhpcy5heGlzWTJbMDw9dGhpcy5kYXRhW2RdLmF4aXNZSW5kZXgmJnRoaXMuZGF0YVtkXS5heGlzWUluZGV4PHRoaXMuYXhpc1kyLmxlbmd0aD90aGlzLmRhdGFbZF0uYXhpc1lJbmRleDowXTt0aGlzLmF4aXNZMlswPD10aGlzLmRhdGFbZF0uYXhpc1lJbmRleCYmdGhpcy5kYXRhW2RdLmF4aXNZSW5kZXg8dGhpcy5heGlzWTIubGVuZ3RoP3RoaXMuZGF0YVtkXS5heGlzWUluZGV4OjBdLmRhdGFTZXJpZXMucHVzaCh0aGlzLmRhdGFbZF0pfWVsc2UgdGhpcy5heGlzWTIubGVuZ3RofHwoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD90aGlzLl9heGVzLnB1c2godGhpcy5heGlzWTJbMF09bmV3IEEodGhpcyxcImF4aXNZMlwiLHRoaXMub3B0aW9ucy5heGlzWTIsMCxcImF4aXNZXCIsXCJyaWdodFwiKSk6XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmXG50aGlzLl9heGVzLnB1c2godGhpcy5heGlzWTJbMF09bmV3IEEodGhpcyxcImF4aXNZMlwiLHRoaXMub3B0aW9ucy5heGlzWTIsMCxcImF4aXNZXCIsXCJ0b3BcIikpKSx0aGlzLmRhdGFbZF0uYXhpc1k9dGhpcy5heGlzWTJbMF0sdGhpcy5heGlzWTJbMF0uZGF0YVNlcmllcy5wdXNoKHRoaXMuZGF0YVtkXSk7aWYoIXRoaXMuZGF0YVtkXS5heGlzWFR5cGV8fFwicHJpbWFyeVwiPT09dGhpcy5kYXRhW2RdLmF4aXNYVHlwZSlpZih0aGlzLm9wdGlvbnMuYXhpc1gmJjA8dGhpcy5vcHRpb25zLmF4aXNYLmxlbmd0aCl7aWYoIXRoaXMuYXhpc1gubGVuZ3RoKWZvcihjPTA7Yzx0aGlzLm9wdGlvbnMuYXhpc1gubGVuZ3RoO2MrKylcIm5vcm1hbFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P3RoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNYW2NdPW5ldyBBKHRoaXMsXCJheGlzWFwiLHRoaXMub3B0aW9ucy5heGlzWFtjXSxjLFwiYXhpc1hcIixcImJvdHRvbVwiKSk6XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmXG50aGlzLl9heGVzLnB1c2godGhpcy5heGlzWFtjXT1uZXcgQSh0aGlzLFwiYXhpc1hcIix0aGlzLm9wdGlvbnMuYXhpc1hbY10sYyxcImF4aXNYXCIsXCJsZWZ0XCIpKTt0aGlzLmRhdGFbZF0uYXhpc1g9dGhpcy5heGlzWFswPD10aGlzLmRhdGFbZF0uYXhpc1hJbmRleCYmdGhpcy5kYXRhW2RdLmF4aXNYSW5kZXg8dGhpcy5heGlzWC5sZW5ndGg/dGhpcy5kYXRhW2RdLmF4aXNYSW5kZXg6MF07dGhpcy5heGlzWFswPD10aGlzLmRhdGFbZF0uYXhpc1hJbmRleCYmdGhpcy5kYXRhW2RdLmF4aXNYSW5kZXg8dGhpcy5heGlzWC5sZW5ndGg/dGhpcy5kYXRhW2RdLmF4aXNYSW5kZXg6MF0uZGF0YVNlcmllcy5wdXNoKHRoaXMuZGF0YVtkXSl9ZWxzZSB0aGlzLmF4aXNYLmxlbmd0aHx8KFwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/dGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1hbMF09bmV3IEEodGhpcyxcImF4aXNYXCIsdGhpcy5vcHRpb25zLmF4aXNYLDAsXCJheGlzWFwiLFwiYm90dG9tXCIpKTpcblwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJnRoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNYWzBdPW5ldyBBKHRoaXMsXCJheGlzWFwiLHRoaXMub3B0aW9ucy5heGlzWCwwLFwiYXhpc1hcIixcImxlZnRcIikpKSx0aGlzLmRhdGFbZF0uYXhpc1g9dGhpcy5heGlzWFswXSx0aGlzLmF4aXNYWzBdLmRhdGFTZXJpZXMucHVzaCh0aGlzLmRhdGFbZF0pO2lmKFwic2Vjb25kYXJ5XCI9PT10aGlzLmRhdGFbZF0uYXhpc1hUeXBlKWlmKHRoaXMub3B0aW9ucy5heGlzWDImJjA8dGhpcy5vcHRpb25zLmF4aXNYMi5sZW5ndGgpe2lmKCF0aGlzLmF4aXNYMi5sZW5ndGgpZm9yKGM9MDtjPHRoaXMub3B0aW9ucy5heGlzWDIubGVuZ3RoO2MrKylcIm5vcm1hbFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50P3RoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNYMltjXT1uZXcgQSh0aGlzLFwiYXhpc1gyXCIsdGhpcy5vcHRpb25zLmF4aXNYMltjXSxjLFwiYXhpc1hcIixcInRvcFwiKSk6XCJ4eVN3YXBwZWRcIj09PVxudGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50JiZ0aGlzLl9heGVzLnB1c2godGhpcy5heGlzWDJbY109bmV3IEEodGhpcyxcImF4aXNYMlwiLHRoaXMub3B0aW9ucy5heGlzWDJbY10sYyxcImF4aXNYXCIsXCJyaWdodFwiKSk7dGhpcy5kYXRhW2RdLmF4aXNYPXRoaXMuYXhpc1gyWzA8PXRoaXMuZGF0YVtkXS5heGlzWEluZGV4JiZ0aGlzLmRhdGFbZF0uYXhpc1hJbmRleDx0aGlzLmF4aXNYMi5sZW5ndGg/dGhpcy5kYXRhW2RdLmF4aXNYSW5kZXg6MF07dGhpcy5heGlzWDJbMDw9dGhpcy5kYXRhW2RdLmF4aXNYSW5kZXgmJnRoaXMuZGF0YVtkXS5heGlzWEluZGV4PHRoaXMuYXhpc1gyLmxlbmd0aD90aGlzLmRhdGFbZF0uYXhpc1hJbmRleDowXS5kYXRhU2VyaWVzLnB1c2godGhpcy5kYXRhW2RdKX1lbHNlIHRoaXMuYXhpc1gyLmxlbmd0aHx8KFwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/dGhpcy5fYXhlcy5wdXNoKHRoaXMuYXhpc1gyWzBdPW5ldyBBKHRoaXMsXCJheGlzWDJcIixcbnRoaXMub3B0aW9ucy5heGlzWDIsMCxcImF4aXNYXCIsXCJ0b3BcIikpOlwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJnRoaXMuX2F4ZXMucHVzaCh0aGlzLmF4aXNYMlswXT1uZXcgQSh0aGlzLFwiYXhpc1gyXCIsdGhpcy5vcHRpb25zLmF4aXNYMiwwLFwiYXhpc1hcIixcInJpZ2h0XCIpKSksdGhpcy5kYXRhW2RdLmF4aXNYPXRoaXMuYXhpc1gyWzBdLHRoaXMuYXhpc1gyWzBdLmRhdGFTZXJpZXMucHVzaCh0aGlzLmRhdGFbZF0pfWlmKHRoaXMuYXhpc1kpe2ZvcihjPTE7Yzx0aGlzLmF4aXNZLmxlbmd0aDtjKyspXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLmF4aXNZW2NdLm9wdGlvbnMuZ3JpZFRoaWNrbmVzcyYmKHRoaXMuYXhpc1lbY10uZ3JpZFRoaWNrbmVzcz0wKTtmb3IoYz0wO2M8dGhpcy5heGlzWS5sZW5ndGgtMTtjKyspXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLmF4aXNZW2NdLm9wdGlvbnMubWFyZ2luJiYodGhpcy5heGlzWVtjXS5tYXJnaW49MTApfWlmKHRoaXMuYXhpc1kyKXtmb3IoYz1cbjE7Yzx0aGlzLmF4aXNZMi5sZW5ndGg7YysrKVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5heGlzWTJbY10ub3B0aW9ucy5ncmlkVGhpY2tuZXNzJiYodGhpcy5heGlzWTJbY10uZ3JpZFRoaWNrbmVzcz0wKTtmb3IoYz0wO2M8dGhpcy5heGlzWTIubGVuZ3RoLTE7YysrKVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5heGlzWTJbY10ub3B0aW9ucy5tYXJnaW4mJih0aGlzLmF4aXNZMltjXS5tYXJnaW49MTApfXRoaXMuYXhpc1kmJjA8dGhpcy5heGlzWS5sZW5ndGgmJih0aGlzLmF4aXNZMiYmMDx0aGlzLmF4aXNZMi5sZW5ndGgpJiYoMDx0aGlzLmF4aXNZWzBdLmdyaWRUaGlja25lc3MmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5heGlzWTJbMF0ub3B0aW9ucy5ncmlkVGhpY2tuZXNzP3RoaXMuYXhpc1kyWzBdLmdyaWRUaGlja25lc3M9MDowPHRoaXMuYXhpc1kyWzBdLmdyaWRUaGlja25lc3MmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5heGlzWVswXS5vcHRpb25zLmdyaWRUaGlja25lc3MmJlxuKHRoaXMuYXhpc1lbMF0uZ3JpZFRoaWNrbmVzcz0wKSk7aWYodGhpcy5heGlzWClmb3IoYz0wO2M8dGhpcy5heGlzWC5sZW5ndGg7YysrKVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5heGlzWFtjXS5vcHRpb25zLmdyaWRUaGlja25lc3MmJih0aGlzLmF4aXNYW2NdLmdyaWRUaGlja25lc3M9MCk7aWYodGhpcy5heGlzWDIpZm9yKGM9MDtjPHRoaXMuYXhpc1gyLmxlbmd0aDtjKyspXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLmF4aXNYMltjXS5vcHRpb25zLmdyaWRUaGlja25lc3MmJih0aGlzLmF4aXNYMltjXS5ncmlkVGhpY2tuZXNzPTApO3RoaXMuYXhpc1gmJjA8dGhpcy5heGlzWC5sZW5ndGgmJih0aGlzLmF4aXNYMiYmMDx0aGlzLmF4aXNYMi5sZW5ndGgpJiYoMDx0aGlzLmF4aXNYWzBdLmdyaWRUaGlja25lc3MmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5heGlzWDJbMF0ub3B0aW9ucy5ncmlkVGhpY2tuZXNzP3RoaXMuYXhpc1gyWzBdLmdyaWRUaGlja25lc3M9MDowPFxudGhpcy5heGlzWDJbMF0uZ3JpZFRoaWNrbmVzcyYmXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLmF4aXNYWzBdLm9wdGlvbnMuZ3JpZFRoaWNrbmVzcyYmKHRoaXMuYXhpc1hbMF0uZ3JpZFRoaWNrbmVzcz0wKSk7Yz0hMTtpZigwPHRoaXMuX2F4ZXMubGVuZ3RoJiZ0aGlzLm9wdGlvbnMuem9vbUVuYWJsZWQmJih0aGlzLnpvb21FbmFibGVkfHx0aGlzLnBhbkVuYWJsZWQpKWZvcihkPTA7ZDx0aGlzLl9heGVzLmxlbmd0aDtkKyspaWYoIXIodGhpcy5fYXhlc1tkXS52aWV3cG9ydE1pbmltdW0pfHwhcih0aGlzLl9heGVzW2RdLnZpZXdwb3J0TWF4aW11bSkpe2M9ITA7YnJlYWt9Yz8oTWEodGhpcy5fem9vbUJ1dHRvbix0aGlzLl9yZXNldEJ1dHRvbiksdGhpcy5fdG9vbEJhci5zdHlsZS5ib3JkZXI9dGhpcy50b29sYmFyLmJ1dHRvbkJvcmRlclRoaWNrbmVzcytcInB4IHNvbGlkIFwiK3RoaXMudG9vbGJhci5idXR0b25Cb3JkZXJDb2xvcix0aGlzLl96b29tQnV0dG9uLnN0eWxlLmJvcmRlclJpZ2h0PVxudGhpcy50b29sYmFyLmJ1dHRvbkJvcmRlclRoaWNrbmVzcytcInB4IHNvbGlkIFwiK3RoaXMudG9vbGJhci5idXR0b25Cb3JkZXJDb2xvcix0aGlzLl9yZXNldEJ1dHRvbi5zdHlsZS5ib3JkZXJSaWdodD0odGhpcy5leHBvcnRFbmFibGVkP3RoaXMudG9vbGJhci5idXR0b25Cb3JkZXJUaGlja25lc3M6MCkrXCJweCBzb2xpZCBcIit0aGlzLnRvb2xiYXIuYnV0dG9uQm9yZGVyQ29sb3IpOih3YSh0aGlzLl96b29tQnV0dG9uLHRoaXMuX3Jlc2V0QnV0dG9uKSx0aGlzLl90b29sQmFyLnN0eWxlLmJvcmRlcj10aGlzLnRvb2xiYXIuYnV0dG9uQm9yZGVyVGhpY2tuZXNzK1wicHggc29saWQgdHJhbnNwYXJlbnRcIix0aGlzLm9wdGlvbnMuem9vbUVuYWJsZWQmJih0aGlzLnpvb21FbmFibGVkPSEwLHRoaXMucGFuRW5hYmxlZD0hMSkpO2ZiKHRoaXMpO3RoaXMuX3Byb2Nlc3NEYXRhKCk7dGhpcy5vcHRpb25zLnRpdGxlJiYodGhpcy50aXRsZT1uZXcgemEodGhpcyx0aGlzLm9wdGlvbnMudGl0bGUpLFxudGhpcy50aXRsZS5kb2NrSW5zaWRlUGxvdEFyZWE/YS5wdXNoKHRoaXMudGl0bGUpOnRoaXMudGl0bGUuc2V0TGF5b3V0KCkpO2lmKHRoaXMub3B0aW9ucy5zdWJ0aXRsZXMpZm9yKGQ9MDtkPHRoaXMub3B0aW9ucy5zdWJ0aXRsZXMubGVuZ3RoO2QrKyljPW5ldyBKYSh0aGlzLHRoaXMub3B0aW9ucy5zdWJ0aXRsZXNbZF0sZCksdGhpcy5zdWJ0aXRsZXMucHVzaChjKSxjLmRvY2tJbnNpZGVQbG90QXJlYT9hLnB1c2goYyk6Yy5zZXRMYXlvdXQoKTt0aGlzLmxlZ2VuZD1uZXcgSyh0aGlzLHRoaXMub3B0aW9ucy5sZWdlbmQpO2ZvcihkPTA7ZDx0aGlzLmRhdGEubGVuZ3RoO2QrKykodGhpcy5kYXRhW2RdLnNob3dJbkxlZ2VuZHx8XCJwaWVcIj09PXRoaXMuZGF0YVtkXS50eXBlfHxcImRvdWdobnV0XCI9PT10aGlzLmRhdGFbZF0udHlwZXx8XCJmdW5uZWxcIj09PXRoaXMuZGF0YVtkXS50eXBlfHxcInB5cmFtaWRcIj09PXRoaXMuZGF0YVtkXS50eXBlKSYmdGhpcy5sZWdlbmQuZGF0YVNlcmllcy5wdXNoKHRoaXMuZGF0YVtkXSk7XG50aGlzLmxlZ2VuZC5kb2NrSW5zaWRlUGxvdEFyZWE/YS5wdXNoKHRoaXMubGVnZW5kKTp0aGlzLmxlZ2VuZC5zZXRMYXlvdXQoKTtmb3IoZD0wO2Q8dGhpcy5fYXhlcy5sZW5ndGg7ZCsrKWlmKHRoaXMuX2F4ZXNbZF0uc2NhbGVCcmVha3MmJnRoaXMuX2F4ZXNbZF0uc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoKXt3Pyh0aGlzLl9icmVha3NDYW52YXM9dWEodGhpcy53aWR0aCx0aGlzLmhlaWdodCwhMCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4PXRoaXMuX2JyZWFrc0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikpOih0aGlzLl9icmVha3NDYW52YXM9dGhpcy5jYW52YXMsdGhpcy5fYnJlYWtzQ2FudmFzQ3R4PXRoaXMuY3R4KTticmVha310aGlzLl9wcmVSZW5kZXJDYW52YXM9dWEodGhpcy53aWR0aCx0aGlzLmhlaWdodCk7dGhpcy5fcHJlUmVuZGVyQ3R4PXRoaXMuX3ByZVJlbmRlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XCJub3JtYWxcIiE9PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmXG5cInh5U3dhcHBlZFwiIT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50fHxBLnNldExheW91dCh0aGlzLmF4aXNYLHRoaXMuYXhpc1gyLHRoaXMuYXhpc1ksdGhpcy5heGlzWTIsdGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50LHRoaXMubGF5b3V0TWFuYWdlci5nZXRGcmVlU3BhY2UoKSl9O3AucHJvdG90eXBlLnJlbmRlckVsZW1lbnRzPWZ1bmN0aW9uKCl7aWYodGhpcy5oZWlnaHQpe3ZhciBhPXRoaXMuX3Bsb3RBcmVhRWxlbWVudHM7dGhpcy50aXRsZSYmIXRoaXMudGl0bGUuZG9ja0luc2lkZVBsb3RBcmVhJiZ0aGlzLnRpdGxlLnJlbmRlcigpO2Zvcih2YXIgZD0wO2Q8dGhpcy5zdWJ0aXRsZXMubGVuZ3RoO2QrKyl0aGlzLnN1YnRpdGxlc1tkXS5kb2NrSW5zaWRlUGxvdEFyZWF8fHRoaXMuc3VidGl0bGVzW2RdLnJlbmRlcigpO3RoaXMubGVnZW5kLmRvY2tJbnNpZGVQbG90QXJlYXx8dGhpcy5sZWdlbmQucmVuZGVyKCk7aWYoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudHx8XG5cInh5U3dhcHBlZFwiPT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50KUEucmVuZGVyKHRoaXMuYXhpc1gsdGhpcy5heGlzWDIsdGhpcy5heGlzWSx0aGlzLmF4aXNZMix0aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpO2Vsc2UgaWYoXCJub25lXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpdGhpcy5wcmVwYXJlUGxvdEFyZWEoKTtlbHNlIHJldHVybjtmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKWFbZF0uc2V0TGF5b3V0KCksYVtkXS5yZW5kZXIoKTt2YXIgYz1bXTtpZih0aGlzLmFuaW1hdGVkUmVuZGVyKXt2YXIgYj11YSh0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KTtiLmdldENvbnRleHQoXCIyZFwiKS5kcmF3SW1hZ2UodGhpcy5jYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpfWliKHRoaXMpO3ZhciBhPXRoaXMuY3R4Lm1pdGVyTGltaXQsZTt0aGlzLmN0eC5taXRlckxpbWl0PTM7dyYmdGhpcy5fYnJlYWtzQ2FudmFzJiYodGhpcy5fcHJlUmVuZGVyQ3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhcyxcbjAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9wcmVSZW5kZXJDdHguZHJhd0ltYWdlKHRoaXMuX2JyZWFrc0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX3ByZVJlbmRlckN0eC5jbGVhclJlY3QoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpKTtmb3IoZD0wO2Q8dGhpcy5wbG90SW5mby5wbG90VHlwZXMubGVuZ3RoO2QrKylmb3IodmFyIGY9dGhpcy5wbG90SW5mby5wbG90VHlwZXNbZF0sbD0wO2w8Zi5wbG90VW5pdHMubGVuZ3RoO2wrKyl7dmFyIHQ9Zi5wbG90VW5pdHNbbF0sQz1udWxsO3QudGFyZ2V0Q2FudmFzJiZ5YSh0LnRhcmdldENhbnZhcyk7dC50YXJnZXRDYW52YXM9bnVsbDt0aGlzLmFuaW1hdGVkUmVuZGVyJiZcbih0LnRhcmdldENhbnZhcz11YSh0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0LnRhcmdldENhbnZhc0N0eD10LnRhcmdldENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksZT10LnRhcmdldENhbnZhc0N0eC5taXRlckxpbWl0LHQudGFyZ2V0Q2FudmFzQ3R4Lm1pdGVyTGltaXQ9Myk7XCJsaW5lXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlckxpbmUodCk6XCJzdGVwTGluZVwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJTdGVwTGluZSh0KTpcInNwbGluZVwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJTcGxpbmUodCk6XCJjb2x1bW5cIj09PXQudHlwZT9DPXRoaXMucmVuZGVyQ29sdW1uKHQpOlwiYmFyXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlckJhcih0KTpcImFyZWFcIj09PXQudHlwZT9DPXRoaXMucmVuZGVyQXJlYSh0KTpcInN0ZXBBcmVhXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlclN0ZXBBcmVhKHQpOlwic3BsaW5lQXJlYVwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJTcGxpbmVBcmVhKHQpOlwic3RhY2tlZENvbHVtblwiPT09XG50LnR5cGU/Qz10aGlzLnJlbmRlclN0YWNrZWRDb2x1bW4odCk6XCJzdGFja2VkQ29sdW1uMTAwXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlclN0YWNrZWRDb2x1bW4xMDAodCk6XCJzdGFja2VkQmFyXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlclN0YWNrZWRCYXIodCk6XCJzdGFja2VkQmFyMTAwXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlclN0YWNrZWRCYXIxMDAodCk6XCJzdGFja2VkQXJlYVwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJTdGFja2VkQXJlYSh0KTpcInN0YWNrZWRBcmVhMTAwXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlclN0YWNrZWRBcmVhMTAwKHQpOlwiYnViYmxlXCI9PT10LnR5cGU/Qz1DPXRoaXMucmVuZGVyQnViYmxlKHQpOlwic2NhdHRlclwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJTY2F0dGVyKHQpOlwicGllXCI9PT10LnR5cGU/dGhpcy5yZW5kZXJQaWUodCk6XCJkb3VnaG51dFwiPT09dC50eXBlP3RoaXMucmVuZGVyUGllKHQpOlwiZnVubmVsXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlckZ1bm5lbCh0KTpcblwicHlyYW1pZFwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJGdW5uZWwodCk6XCJjYW5kbGVzdGlja1wiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJDYW5kbGVzdGljayh0KTpcIm9obGNcIj09PXQudHlwZT9DPXRoaXMucmVuZGVyQ2FuZGxlc3RpY2sodCk6XCJyYW5nZUNvbHVtblwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJSYW5nZUNvbHVtbih0KTpcImVycm9yXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlckVycm9yKHQpOlwicmFuZ2VCYXJcIj09PXQudHlwZT9DPXRoaXMucmVuZGVyUmFuZ2VCYXIodCk6XCJyYW5nZUFyZWFcIj09PXQudHlwZT9DPXRoaXMucmVuZGVyUmFuZ2VBcmVhKHQpOlwicmFuZ2VTcGxpbmVBcmVhXCI9PT10LnR5cGU/Qz10aGlzLnJlbmRlclJhbmdlU3BsaW5lQXJlYSh0KTpcIndhdGVyZmFsbFwiPT09dC50eXBlP0M9dGhpcy5yZW5kZXJXYXRlcmZhbGwodCk6XCJib3hBbmRXaGlza2VyXCI9PT10LnR5cGUmJihDPXRoaXMucmVuZGVyQm94QW5kV2hpc2tlcih0KSk7Zm9yKHZhciBrPTA7azx0LmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtrKyspdGhpcy5fZGF0YUluUmVuZGVyZWRPcmRlci5wdXNoKHRoaXMuZGF0YVt0LmRhdGFTZXJpZXNJbmRleGVzW2tdXSk7XG50aGlzLmFuaW1hdGVkUmVuZGVyJiYodC50YXJnZXRDYW52YXNDdHgubWl0ZXJMaW1pdD1lLEMmJmMucHVzaChDKSl9dGhpcy5jdHgubWl0ZXJMaW1pdD1hO3RoaXMuYW5pbWF0ZWRSZW5kZXImJnRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmYy5wdXNoKHtzb3VyY2U6dGhpcy5fYnJlYWtzQ2FudmFzQ3R4LGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6TS5mYWRlSW5BbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcuZWFzZUluUXVhZCxhbmltYXRpb25CYXNlOjAsc3RhcnRUaW1lUGVyY2VudDowLjd9KTt0aGlzLmFuaW1hdGVkUmVuZGVyJiYwPHRoaXMuX2luZGV4TGFiZWxzLmxlbmd0aCYmKGU9dWEodGhpcy53aWR0aCx0aGlzLmhlaWdodCkuZ2V0Q29udGV4dChcIjJkXCIpLGMucHVzaCh0aGlzLnJlbmRlckluZGV4TGFiZWxzKGUpKSk7dmFyIG09dGhpcztpZigwPGMubGVuZ3RoKW0uZGlzYWJsZVRvb2xUaXA9ITAsbS5fYW5pbWF0b3IuYW5pbWF0ZSgyMDAsXG5tLmFuaW1hdGlvbkR1cmF0aW9uLGZ1bmN0aW9uKGEpe20uY3R4LmNsZWFyUmVjdCgwLDAsbS53aWR0aCxtLmhlaWdodCk7bS5jdHguZHJhd0ltYWdlKGIsMCwwLE1hdGguZmxvb3IobS53aWR0aCpsYSksTWF0aC5mbG9vcihtLmhlaWdodCpsYSksMCwwLG0ud2lkdGgsbS5oZWlnaHQpO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKUM9Y1tlXSwxPmEmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgQy5zdGFydFRpbWVQZXJjZW50P2E+PUMuc3RhcnRUaW1lUGVyY2VudCYmQy5hbmltYXRpb25DYWxsYmFjayhDLmVhc2luZ0Z1bmN0aW9uKGEtQy5zdGFydFRpbWVQZXJjZW50LDAsMSwxLUMuc3RhcnRUaW1lUGVyY2VudCksQyk6Qy5hbmltYXRpb25DYWxsYmFjayhDLmVhc2luZ0Z1bmN0aW9uKGEsMCwxLDEpLEMpO20uZGlzcGF0Y2hFdmVudChcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIix7Y2hhcnQ6bX0pfSxmdW5jdGlvbigpe2M9W107Zm9yKHZhciBhPTA7YTxtLnBsb3RJbmZvLnBsb3RUeXBlcy5sZW5ndGg7YSsrKWZvcih2YXIgZT1cbm0ucGxvdEluZm8ucGxvdFR5cGVzW2FdLGQ9MDtkPGUucGxvdFVuaXRzLmxlbmd0aDtkKyspe3ZhciBmPWUucGxvdFVuaXRzW2RdO2YudGFyZ2V0Q2FudmFzJiZ5YShmLnRhcmdldENhbnZhcyk7Zi50YXJnZXRDYW52YXM9bnVsbH1iPW51bGw7bS5kaXNhYmxlVG9vbFRpcD0hMTttLmRpc3BhdGNoRXZlbnQoXCJkYXRhQW5pbWF0aW9uRW5kXCIse2NoYXJ0Om19KX0pO2Vsc2V7aWYobS5fYnJlYWtzQ2FudmFzKWlmKHcpbS5wbG90QXJlYS5jdHguZHJhd0ltYWdlKG0uX2JyZWFrc0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCk7ZWxzZSBmb3Ioaz0wO2s8bS5fYXhlcy5sZW5ndGg7aysrKW0uX2F4ZXNba10uY3JlYXRlTWFzaygpOzA8bS5faW5kZXhMYWJlbHMubGVuZ3RoJiZtLnJlbmRlckluZGV4TGFiZWxzKCk7bS5kaXNwYXRjaEV2ZW50KFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLHtjaGFydDptfSk7bS5kaXNwYXRjaEV2ZW50KFwiZGF0YUFuaW1hdGlvbkVuZFwiLHtjaGFydDptfSl9dGhpcy5hdHRhY2hQbG90QXJlYUV2ZW50SGFuZGxlcnMoKTtcbnRoaXMuem9vbUVuYWJsZWR8fCh0aGlzLnBhbkVuYWJsZWR8fCF0aGlzLl96b29tQnV0dG9ufHxcIm5vbmVcIj09PXRoaXMuX3pvb21CdXR0b24uc3R5bGUuZGlzcGxheSl8fHdhKHRoaXMuX3pvb21CdXR0b24sdGhpcy5fcmVzZXRCdXR0b24pO3RoaXMudG9vbFRpcC5fdXBkYXRlVG9vbFRpcCgpO3RoaXMucmVuZGVyQ291bnQrKztJYSYmKG09dGhpcyxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnaG9zdENhbnZhc0NvcHlcIik7YSYmKE5hKGEsbS53aWR0aCxtLmhlaWdodCksYS5nZXRDb250ZXh0KFwiMmRcIikuZHJhd0ltYWdlKG0uX2V2ZW50TWFuYWdlci5naG9zdENhbnZhcywwLDApKX0sMkUzKSk7dGhpcy5fYnJlYWtzQ2FudmFzJiYoZGVsZXRlIHRoaXMuX2JyZWFrc0NhbnZhcyxkZWxldGUgdGhpcy5fYnJlYWtzQ2FudmFzQ3R4KTtmb3Ioaz0wO2s8dGhpcy5fYXhlcy5sZW5ndGg7aysrKXRoaXMuX2F4ZXNba10ubWFza0NhbnZhcyYmKGRlbGV0ZSB0aGlzLl9heGVzW2tdLm1hc2tDYW52YXMsXG5kZWxldGUgdGhpcy5fYXhlc1trXS5tYXNrQ3R4KX19O3AucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhKXthJiYodGhpcy5vcHRpb25zPWEpO3RoaXMuX2luaXRpYWxpemUoKTt0aGlzLnNldExheW91dCgpO3RoaXMucmVuZGVyRWxlbWVudHMoKTt0aGlzLl9wcmVSZW5kZXJDYW52YXMmJnlhKHRoaXMuX3ByZVJlbmRlckNhbnZhcyl9O3AucHJvdG90eXBlLmF0dGFjaFBsb3RBcmVhRXZlbnRIYW5kbGVycz1mdW5jdGlvbigpe3RoaXMuYXR0YWNoRXZlbnQoe2NvbnRleHQ6dGhpcyxjaGFydDp0aGlzLG1vdXNlZG93bjp0aGlzLl9wbG90QXJlYU1vdXNlRG93bixtb3VzZXVwOnRoaXMuX3Bsb3RBcmVhTW91c2VVcCxtb3VzZW1vdmU6dGhpcy5fcGxvdEFyZWFNb3VzZU1vdmUsY3Vyc29yOnRoaXMucGFuRW5hYmxlZD9cIm1vdmVcIjpcImRlZmF1bHRcIixjYXB0dXJlOiEwLGJvdW5kczp0aGlzLnBsb3RBcmVhfSl9O3AucHJvdG90eXBlLmNhdGVnb3Jpc2VEYXRhU2VyaWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVxuXCJcIixkPTA7ZDx0aGlzLmRhdGEubGVuZ3RoO2QrKylpZihhPXRoaXMuZGF0YVtkXSxhLmRhdGFQb2ludHMmJigwIT09YS5kYXRhUG9pbnRzLmxlbmd0aCYmYS52aXNpYmxlKSYmMDw9cC5fc3VwcG9ydGVkQ2hhcnRUeXBlcy5pbmRleE9mKGEudHlwZSkpe2Zvcih2YXIgYz1udWxsLGI9ITEsZT1udWxsLGY9ITEsbD0wO2w8dGhpcy5wbG90SW5mby5wbG90VHlwZXMubGVuZ3RoO2wrKylpZih0aGlzLnBsb3RJbmZvLnBsb3RUeXBlc1tsXS50eXBlPT09YS50eXBlKXtiPSEwO2M9dGhpcy5wbG90SW5mby5wbG90VHlwZXNbbF07YnJlYWt9Ynx8KGM9e3R5cGU6YS50eXBlLHRvdGFsRGF0YVNlcmllczowLHBsb3RVbml0czpbXX0sdGhpcy5wbG90SW5mby5wbG90VHlwZXMucHVzaChjKSk7Zm9yKGw9MDtsPGMucGxvdFVuaXRzLmxlbmd0aDtsKyspaWYoYy5wbG90VW5pdHNbbF0uYXhpc1lUeXBlPT09YS5heGlzWVR5cGUmJmMucGxvdFVuaXRzW2xdLmF4aXNYVHlwZT09PWEuYXhpc1hUeXBlJiZcbmMucGxvdFVuaXRzW2xdLmF4aXNZSW5kZXg9PT1hLmF4aXNZSW5kZXgmJmMucGxvdFVuaXRzW2xdLmF4aXNYSW5kZXg9PT1hLmF4aXNYSW5kZXgpe2Y9ITA7ZT1jLnBsb3RVbml0c1tsXTticmVha31mfHwoZT17dHlwZTphLnR5cGUscHJldmlvdXNEYXRhU2VyaWVzQ291bnQ6MCxpbmRleDpjLnBsb3RVbml0cy5sZW5ndGgscGxvdFR5cGU6YyxheGlzWFR5cGU6YS5heGlzWFR5cGUsYXhpc1lUeXBlOmEuYXhpc1lUeXBlLGF4aXNZSW5kZXg6YS5heGlzWUluZGV4LGF4aXNYSW5kZXg6YS5heGlzWEluZGV4LGF4aXNZOlwicHJpbWFyeVwiPT09YS5heGlzWVR5cGU/dGhpcy5heGlzWVswPD1hLmF4aXNZSW5kZXgmJmEuYXhpc1lJbmRleDx0aGlzLmF4aXNZLmxlbmd0aD9hLmF4aXNZSW5kZXg6MF06dGhpcy5heGlzWTJbMDw9YS5heGlzWUluZGV4JiZhLmF4aXNZSW5kZXg8dGhpcy5heGlzWTIubGVuZ3RoP2EuYXhpc1lJbmRleDowXSxheGlzWDpcInByaW1hcnlcIj09PWEuYXhpc1hUeXBlP3RoaXMuYXhpc1hbMDw9XG5hLmF4aXNYSW5kZXgmJmEuYXhpc1hJbmRleDx0aGlzLmF4aXNYLmxlbmd0aD9hLmF4aXNYSW5kZXg6MF06dGhpcy5heGlzWDJbMDw9YS5heGlzWEluZGV4JiZhLmF4aXNYSW5kZXg8dGhpcy5heGlzWDIubGVuZ3RoP2EuYXhpc1hJbmRleDowXSxkYXRhU2VyaWVzSW5kZXhlczpbXSx5VG90YWxzOltdLHlBYnNUb3RhbHM6W119LGMucGxvdFVuaXRzLnB1c2goZSkpO2MudG90YWxEYXRhU2VyaWVzKys7ZS5kYXRhU2VyaWVzSW5kZXhlcy5wdXNoKGQpO2EucGxvdFVuaXQ9ZX1mb3IoZD0wO2Q8dGhpcy5wbG90SW5mby5wbG90VHlwZXMubGVuZ3RoO2QrKylmb3IoYz10aGlzLnBsb3RJbmZvLnBsb3RUeXBlc1tkXSxsPWE9MDtsPGMucGxvdFVuaXRzLmxlbmd0aDtsKyspYy5wbG90VW5pdHNbbF0ucHJldmlvdXNEYXRhU2VyaWVzQ291bnQ9YSxhKz1jLnBsb3RVbml0c1tsXS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGh9O3AucHJvdG90eXBlLmFzc2lnbklkVG9EYXRhUG9pbnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVxuMDthPHRoaXMuZGF0YS5sZW5ndGg7YSsrKXt2YXIgZD10aGlzLmRhdGFbYV07aWYoZC5kYXRhUG9pbnRzKWZvcih2YXIgYz1kLmRhdGFQb2ludHMubGVuZ3RoLGI9MDtiPGM7YisrKWQuZGF0YVBvaW50SWRzW2JdPSsrdGhpcy5fZXZlbnRNYW5hZ2VyLmxhc3RPYmplY3RJZH19O3AucHJvdG90eXBlLl9wcm9jZXNzRGF0YT1mdW5jdGlvbigpe3RoaXMuYXNzaWduSWRUb0RhdGFQb2ludHMoKTt0aGlzLmNhdGVnb3Jpc2VEYXRhU2VyaWVzKCk7Zm9yKHZhciBhPTA7YTx0aGlzLnBsb3RJbmZvLnBsb3RUeXBlcy5sZW5ndGg7YSsrKWZvcih2YXIgZD10aGlzLnBsb3RJbmZvLnBsb3RUeXBlc1thXSxjPTA7YzxkLnBsb3RVbml0cy5sZW5ndGg7YysrKXt2YXIgYj1kLnBsb3RVbml0c1tjXTtcImxpbmVcIj09PWIudHlwZXx8XCJzdGVwTGluZVwiPT09Yi50eXBlfHxcInNwbGluZVwiPT09Yi50eXBlfHxcImNvbHVtblwiPT09Yi50eXBlfHxcImFyZWFcIj09PWIudHlwZXx8XCJzdGVwQXJlYVwiPT09Yi50eXBlfHxcInNwbGluZUFyZWFcIj09PVxuYi50eXBlfHxcImJhclwiPT09Yi50eXBlfHxcImJ1YmJsZVwiPT09Yi50eXBlfHxcInNjYXR0ZXJcIj09PWIudHlwZT90aGlzLl9wcm9jZXNzTXVsdGlzZXJpZXNQbG90VW5pdChiKTpcInN0YWNrZWRDb2x1bW5cIj09PWIudHlwZXx8XCJzdGFja2VkQmFyXCI9PT1iLnR5cGV8fFwic3RhY2tlZEFyZWFcIj09PWIudHlwZT90aGlzLl9wcm9jZXNzU3RhY2tlZFBsb3RVbml0KGIpOlwic3RhY2tlZENvbHVtbjEwMFwiPT09Yi50eXBlfHxcInN0YWNrZWRCYXIxMDBcIj09PWIudHlwZXx8XCJzdGFja2VkQXJlYTEwMFwiPT09Yi50eXBlP3RoaXMuX3Byb2Nlc3NTdGFja2VkMTAwUGxvdFVuaXQoYik6XCJjYW5kbGVzdGlja1wiPT09Yi50eXBlfHxcIm9obGNcIj09PWIudHlwZXx8XCJyYW5nZUNvbHVtblwiPT09Yi50eXBlfHxcInJhbmdlQmFyXCI9PT1iLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1iLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1iLnR5cGV8fFwiZXJyb3JcIj09PWIudHlwZXx8XCJib3hBbmRXaGlza2VyXCI9PT1iLnR5cGU/dGhpcy5fcHJvY2Vzc011bHRpWVBsb3RVbml0KGIpOlxuXCJ3YXRlcmZhbGxcIj09PWIudHlwZSYmdGhpcy5fcHJvY2Vzc1NwZWNpZmljUGxvdFVuaXQoYil9dGhpcy5jYWxjdWxhdGVBdXRvQnJlYWtzKCl9O3AucHJvdG90eXBlLl9wcm9jZXNzTXVsdGlzZXJpZXNQbG90VW5pdD1mdW5jdGlvbihhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKWZvcih2YXIgZD1hLmF4aXNZLmRhdGFJbmZvLGM9YS5heGlzWC5kYXRhSW5mbyxiLGUsZj0hMSxsPTA7bDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtsKyspe3ZhciB0PXRoaXMuZGF0YVthLmRhdGFTZXJpZXNJbmRleGVzW2xdXSxDPTAsaz0hMSxtPSExLG47aWYoXCJub3JtYWxcIj09PXQuYXhpc1BsYWNlbWVudHx8XCJ4eVN3YXBwZWRcIj09PXQuYXhpc1BsYWNlbWVudCl2YXIgcT1hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtP2EuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW06YS5heGlzWC5vcHRpb25zJiZcbmEuYXhpc1gub3B0aW9ucy52aWV3cG9ydE1pbmltdW0/YS5heGlzWC5vcHRpb25zLnZpZXdwb3J0TWluaW11bTphLmF4aXNYLm9wdGlvbnMmJmEuYXhpc1gub3B0aW9ucy5taW5pbXVtP2EuYXhpc1gub3B0aW9ucy5taW5pbXVtOmEuYXhpc1gubG9nYXJpdGhtaWM/MDotSW5maW5pdHksZz1hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtP2EuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW06YS5heGlzWC5vcHRpb25zJiZhLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtP2EuYXhpc1gub3B0aW9ucy52aWV3cG9ydE1heGltdW06YS5heGlzWC5vcHRpb25zJiZhLmF4aXNYLm9wdGlvbnMubWF4aW11bT9hLmF4aXNYLm9wdGlvbnMubWF4aW11bTpJbmZpbml0eTtpZih0LmRhdGFQb2ludHNbQ10ueCYmdC5kYXRhUG9pbnRzW0NdLnguZ2V0VGltZXx8XCJkYXRlVGltZVwiPT09dC54VmFsdWVUeXBlKWY9ITA7Zm9yKEM9MDtDPHQuZGF0YVBvaW50cy5sZW5ndGg7QysrKXtcInVuZGVmaW5lZFwiPT09XG50eXBlb2YgdC5kYXRhUG9pbnRzW0NdLngmJih0LmRhdGFQb2ludHNbQ10ueD1DKyhhLmF4aXNYLmxvZ2FyaXRobWljPzE6MCkpO3QuZGF0YVBvaW50c1tDXS54LmdldFRpbWU/KGY9ITAsYj10LmRhdGFQb2ludHNbQ10ueC5nZXRUaW1lKCkpOmI9dC5kYXRhUG9pbnRzW0NdLng7ZT10LmRhdGFQb2ludHNbQ10ueTtiPGMubWluJiYoYy5taW49Yik7Yj5jLm1heCYmKGMubWF4PWIpO2U8ZC5taW4mJlwibnVtYmVyXCI9PT10eXBlb2YgZSYmKGQubWluPWUpO2U+ZC5tYXgmJlwibnVtYmVyXCI9PT10eXBlb2YgZSYmKGQubWF4PWUpO2lmKDA8Qyl7aWYoYS5heGlzWC5sb2dhcml0aG1pYyl7dmFyIHM9Yi90LmRhdGFQb2ludHNbQy0xXS54OzE+cyYmKHM9MS9zKTtjLm1pbkRpZmY+cyYmMSE9PXMmJihjLm1pbkRpZmY9cyl9ZWxzZSBzPWItdC5kYXRhUG9pbnRzW0MtMV0ueCwwPnMmJihzKj0tMSksYy5taW5EaWZmPnMmJjAhPT1zJiYoYy5taW5EaWZmPXMpO251bGwhPT1lJiZudWxsIT09dC5kYXRhUG9pbnRzW0MtXG4xXS55JiYoYS5heGlzWS5sb2dhcml0aG1pYz8ocz1lL3QuZGF0YVBvaW50c1tDLTFdLnksMT5zJiYocz0xL3MpLGQubWluRGlmZj5zJiYxIT09cyYmKGQubWluRGlmZj1zKSk6KHM9ZS10LmRhdGFQb2ludHNbQy0xXS55LDA+cyYmKHMqPS0xKSxkLm1pbkRpZmY+cyYmMCE9PXMmJihkLm1pbkRpZmY9cykpKX1pZihiPHEmJiFrKW51bGwhPT1lJiYobj1iKTtlbHNle2lmKCFrJiYoaz0hMCwwPEMpKXtDLT0yO2NvbnRpbnVlfWlmKGI+ZyYmIW0pbT0hMDtlbHNlIGlmKGI+ZyYmbSljb250aW51ZTt0LmRhdGFQb2ludHNbQ10ubGFiZWwmJihhLmF4aXNYLmxhYmVsc1tiXT10LmRhdGFQb2ludHNbQ10ubGFiZWwpO2I8Yy52aWV3UG9ydE1pbiYmKGMudmlld1BvcnRNaW49Yik7Yj5jLnZpZXdQb3J0TWF4JiYoYy52aWV3UG9ydE1heD1iKTtudWxsPT09ZT9jLnZpZXdQb3J0TWluPT09YiYmbjxiJiYoYy52aWV3UG9ydE1pbj1uKTooZTxkLnZpZXdQb3J0TWluJiZcIm51bWJlclwiPT09dHlwZW9mIGUmJlxuKGQudmlld1BvcnRNaW49ZSksZT5kLnZpZXdQb3J0TWF4JiZcIm51bWJlclwiPT09dHlwZW9mIGUmJihkLnZpZXdQb3J0TWF4PWUpKX19dC5heGlzWC52YWx1ZVR5cGU9dC54VmFsdWVUeXBlPWY/XCJkYXRlVGltZVwiOlwibnVtYmVyXCJ9fTtwLnByb3RvdHlwZS5fcHJvY2Vzc1N0YWNrZWRQbG90VW5pdD1mdW5jdGlvbihhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXtmb3IodmFyIGQ9YS5heGlzWS5kYXRhSW5mbyxjPWEuYXhpc1guZGF0YUluZm8sYixlLGY9ITEsbD1bXSx0PVtdLEM9SW5maW5pdHksaz0tSW5maW5pdHksbT0wO208YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7bSsrKXt2YXIgbj10aGlzLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1ttXV0scT0wLGc9ITEscz0hMSxoO2lmKFwibm9ybWFsXCI9PT1uLmF4aXNQbGFjZW1lbnR8fFwieHlTd2FwcGVkXCI9PT1uLmF4aXNQbGFjZW1lbnQpdmFyIGJhPWEuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0/XG5hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLnZpZXdwb3J0TWluaW11bT9hLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLm1pbmltdW0/YS5heGlzWC5vcHRpb25zLm1pbmltdW06LUluZmluaXR5LHU9YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bT9hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLnZpZXdwb3J0TWF4aW11bT9hLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLm1heGltdW0/YS5heGlzWC5vcHRpb25zLm1heGltdW06SW5maW5pdHk7aWYobi5kYXRhUG9pbnRzW3FdLngmJm4uZGF0YVBvaW50c1txXS54LmdldFRpbWV8fFwiZGF0ZVRpbWVcIj09PVxubi54VmFsdWVUeXBlKWY9ITA7Zm9yKHE9MDtxPG4uZGF0YVBvaW50cy5sZW5ndGg7cSsrKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIG4uZGF0YVBvaW50c1txXS54JiYobi5kYXRhUG9pbnRzW3FdLng9cSsoYS5heGlzWC5sb2dhcml0aG1pYz8xOjApKTtuLmRhdGFQb2ludHNbcV0ueC5nZXRUaW1lPyhmPSEwLGI9bi5kYXRhUG9pbnRzW3FdLnguZ2V0VGltZSgpKTpiPW4uZGF0YVBvaW50c1txXS54O2U9cihuLmRhdGFQb2ludHNbcV0ueSk/MDpuLmRhdGFQb2ludHNbcV0ueTtiPGMubWluJiYoYy5taW49Yik7Yj5jLm1heCYmKGMubWF4PWIpO2lmKDA8cSl7aWYoYS5heGlzWC5sb2dhcml0aG1pYyl7dmFyIHk9Yi9uLmRhdGFQb2ludHNbcS0xXS54OzE+eSYmKHk9MS95KTtjLm1pbkRpZmY+eSYmMSE9PXkmJihjLm1pbkRpZmY9eSl9ZWxzZSB5PWItbi5kYXRhUG9pbnRzW3EtMV0ueCwwPnkmJih5Kj0tMSksYy5taW5EaWZmPnkmJjAhPT15JiYoYy5taW5EaWZmPXkpO251bGwhPT1lJiZudWxsIT09XG5uLmRhdGFQb2ludHNbcS0xXS55JiYoYS5heGlzWS5sb2dhcml0aG1pYz8wPGUmJih5PWUvbi5kYXRhUG9pbnRzW3EtMV0ueSwxPnkmJih5PTEveSksZC5taW5EaWZmPnkmJjEhPT15JiYoZC5taW5EaWZmPXkpKTooeT1lLW4uZGF0YVBvaW50c1txLTFdLnksMD55JiYoeSo9LTEpLGQubWluRGlmZj55JiYwIT09eSYmKGQubWluRGlmZj15KSkpfWlmKGI8YmEmJiFnKW51bGwhPT1uLmRhdGFQb2ludHNbcV0ueSYmKGg9Yik7ZWxzZXtpZighZyYmKGc9ITAsMDxxKSl7cS09Mjtjb250aW51ZX1pZihiPnUmJiFzKXM9ITA7ZWxzZSBpZihiPnUmJnMpY29udGludWU7bi5kYXRhUG9pbnRzW3FdLmxhYmVsJiYoYS5heGlzWC5sYWJlbHNbYl09bi5kYXRhUG9pbnRzW3FdLmxhYmVsKTtiPGMudmlld1BvcnRNaW4mJihjLnZpZXdQb3J0TWluPWIpO2I+Yy52aWV3UG9ydE1heCYmKGMudmlld1BvcnRNYXg9Yik7bnVsbD09PW4uZGF0YVBvaW50c1txXS55P2Mudmlld1BvcnRNaW49PT1iJiZoPGImJihjLnZpZXdQb3J0TWluPVxuaCk6KGEueVRvdGFsc1tiXT0oYS55VG90YWxzW2JdP2EueVRvdGFsc1tiXTowKStlLGEueUFic1RvdGFsc1tiXT0oYS55QWJzVG90YWxzW2JdP2EueUFic1RvdGFsc1tiXTowKStNYXRoLmFicyhlKSwwPD1lP2xbYl0/bFtiXSs9ZToobFtiXT1lLEM9TWF0aC5taW4oZSxDKSk6dFtiXT90W2JdKz1lOih0W2JdPWUsaz1NYXRoLm1heChlLGspKSl9fWEuYXhpc1kuc2NhbGVCcmVha3MmJihhLmF4aXNZLnNjYWxlQnJlYWtzLmF1dG9DYWxjdWxhdGUmJjE8PWEuYXhpc1kuc2NhbGVCcmVha3MubWF4TnVtYmVyT2ZBdXRvQnJlYWtzKSYmKGQuZGF0YVBvaW50WVBvc2l0aXZlU3Vtcz8oZC5kYXRhUG9pbnRZUG9zaXRpdmVTdW1zLnB1c2guYXBwbHkoZC5kYXRhUG9pbnRZUG9zaXRpdmVTdW1zLGwpLGQuZGF0YVBvaW50WU5lZ2F0aXZlU3Vtcy5wdXNoLmFwcGx5KGQuZGF0YVBvaW50WVBvc2l0aXZlU3Vtcyx0KSk6KGQuZGF0YVBvaW50WVBvc2l0aXZlU3Vtcz1sLGQuZGF0YVBvaW50WU5lZ2F0aXZlU3Vtcz1cbnQpKTtuLmF4aXNYLnZhbHVlVHlwZT1uLnhWYWx1ZVR5cGU9Zj9cImRhdGVUaW1lXCI6XCJudW1iZXJcIn1mb3IocSBpbiBsKWwuaGFzT3duUHJvcGVydHkocSkmJiFpc05hTihxKSYmKGE9bFtxXSxhPGQubWluJiYoZC5taW49TWF0aC5taW4oYSxDKSksYT5kLm1heCYmKGQubWF4PWEpLHE8Yy52aWV3UG9ydE1pbnx8cT5jLnZpZXdQb3J0TWF4fHwoYTxkLnZpZXdQb3J0TWluJiYoZC52aWV3UG9ydE1pbj1NYXRoLm1pbihhLEMpKSxhPmQudmlld1BvcnRNYXgmJihkLnZpZXdQb3J0TWF4PWEpKSk7Zm9yKHEgaW4gdCl0Lmhhc093blByb3BlcnR5KHEpJiYhaXNOYU4ocSkmJihhPXRbcV0sYTxkLm1pbiYmKGQubWluPWEpLGE+ZC5tYXgmJihkLm1heD1NYXRoLm1heChhLGspKSxxPGMudmlld1BvcnRNaW58fHE+Yy52aWV3UG9ydE1heHx8KGE8ZC52aWV3UG9ydE1pbiYmKGQudmlld1BvcnRNaW49YSksYT5kLnZpZXdQb3J0TWF4JiYoZC52aWV3UG9ydE1heD1NYXRoLm1heChhLGspKSkpfX07cC5wcm90b3R5cGUuX3Byb2Nlc3NTdGFja2VkMTAwUGxvdFVuaXQ9XG5mdW5jdGlvbihhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXtmb3IodmFyIGQ9YS5heGlzWS5kYXRhSW5mbyxjPWEuYXhpc1guZGF0YUluZm8sYixlLGY9ITEsbD0hMSx0PSExLEM9W10saz0wO2s8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7aysrKXt2YXIgbT10aGlzLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1trXV0sbj0wLHE9ITEsZz0hMSxzO2lmKFwibm9ybWFsXCI9PT1tLmF4aXNQbGFjZW1lbnR8fFwieHlTd2FwcGVkXCI9PT1tLmF4aXNQbGFjZW1lbnQpdmFyIGg9YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT9hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLnZpZXdwb3J0TWluaW11bT9hLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLm1pbmltdW0/XG5hLmF4aXNYLm9wdGlvbnMubWluaW11bTotSW5maW5pdHksYmE9YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bT9hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLnZpZXdwb3J0TWF4aW11bT9hLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLm1heGltdW0/YS5heGlzWC5vcHRpb25zLm1heGltdW06SW5maW5pdHk7aWYobS5kYXRhUG9pbnRzW25dLngmJm0uZGF0YVBvaW50c1tuXS54LmdldFRpbWV8fFwiZGF0ZVRpbWVcIj09PW0ueFZhbHVlVHlwZSlmPSEwO2ZvcihuPTA7bjxtLmRhdGFQb2ludHMubGVuZ3RoO24rKyl7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBtLmRhdGFQb2ludHNbbl0ueCYmKG0uZGF0YVBvaW50c1tuXS54PW4rKGEuYXhpc1gubG9nYXJpdGhtaWM/MTowKSk7bS5kYXRhUG9pbnRzW25dLnguZ2V0VGltZT9cbihmPSEwLGI9bS5kYXRhUG9pbnRzW25dLnguZ2V0VGltZSgpKTpiPW0uZGF0YVBvaW50c1tuXS54O2U9cihtLmRhdGFQb2ludHNbbl0ueSk/bnVsbDptLmRhdGFQb2ludHNbbl0ueTtiPGMubWluJiYoYy5taW49Yik7Yj5jLm1heCYmKGMubWF4PWIpO2lmKDA8bil7aWYoYS5heGlzWC5sb2dhcml0aG1pYyl7dmFyIHU9Yi9tLmRhdGFQb2ludHNbbi0xXS54OzE+dSYmKHU9MS91KTtjLm1pbkRpZmY+dSYmMSE9PXUmJihjLm1pbkRpZmY9dSl9ZWxzZSB1PWItbS5kYXRhUG9pbnRzW24tMV0ueCwwPnUmJih1Kj0tMSksYy5taW5EaWZmPnUmJjAhPT11JiYoYy5taW5EaWZmPXUpO3IoZSl8fG51bGw9PT1tLmRhdGFQb2ludHNbbi0xXS55fHwoYS5heGlzWS5sb2dhcml0aG1pYz8wPGUmJih1PWUvbS5kYXRhUG9pbnRzW24tMV0ueSwxPnUmJih1PTEvdSksZC5taW5EaWZmPnUmJjEhPT11JiYoZC5taW5EaWZmPXUpKToodT1lLW0uZGF0YVBvaW50c1tuLTFdLnksMD51JiYodSo9LTEpLGQubWluRGlmZj5cbnUmJjAhPT11JiYoZC5taW5EaWZmPXUpKSl9aWYoYjxoJiYhcSludWxsIT09ZSYmKHM9Yik7ZWxzZXtpZighcSYmKHE9ITAsMDxuKSl7bi09Mjtjb250aW51ZX1pZihiPmJhJiYhZylnPSEwO2Vsc2UgaWYoYj5iYSYmZyljb250aW51ZTttLmRhdGFQb2ludHNbbl0ubGFiZWwmJihhLmF4aXNYLmxhYmVsc1tiXT1tLmRhdGFQb2ludHNbbl0ubGFiZWwpO2I8Yy52aWV3UG9ydE1pbiYmKGMudmlld1BvcnRNaW49Yik7Yj5jLnZpZXdQb3J0TWF4JiYoYy52aWV3UG9ydE1heD1iKTtudWxsPT09ZT9jLnZpZXdQb3J0TWluPT09YiYmczxiJiYoYy52aWV3UG9ydE1pbj1zKTooYS55VG90YWxzW2JdPShhLnlUb3RhbHNbYl0/YS55VG90YWxzW2JdOjApK2UsYS55QWJzVG90YWxzW2JdPShhLnlBYnNUb3RhbHNbYl0/YS55QWJzVG90YWxzW2JdOjApK01hdGguYWJzKGUpLDA8PWU/bD0hMDowPmUmJih0PSEwKSxDW2JdPUNbYl0/Q1tiXStNYXRoLmFicyhlKTpNYXRoLmFicyhlKSl9fW0uYXhpc1gudmFsdWVUeXBlPVxubS54VmFsdWVUeXBlPWY/XCJkYXRlVGltZVwiOlwibnVtYmVyXCJ9YS5heGlzWS5sb2dhcml0aG1pYz8oZC5tYXg9cihkLnZpZXdQb3J0TWF4KT85OSpNYXRoLnBvdyhhLmF4aXNZLmxvZ2FyaXRobUJhc2UsLTAuMDUpOk1hdGgubWF4KGQudmlld1BvcnRNYXgsOTkqTWF0aC5wb3coYS5heGlzWS5sb2dhcml0aG1CYXNlLC0wLjA1KSksZC5taW49cihkLnZpZXdQb3J0TWluKT8xOk1hdGgubWluKGQudmlld1BvcnRNaW4sMSkpOmwmJiF0PyhkLm1heD1yKGQudmlld1BvcnRNYXgpPzk5Ok1hdGgubWF4KGQudmlld1BvcnRNYXgsOTkpLGQubWluPXIoZC52aWV3UG9ydE1pbik/MTpNYXRoLm1pbihkLnZpZXdQb3J0TWluLDEpKTpsJiZ0PyhkLm1heD1yKGQudmlld1BvcnRNYXgpPzk5Ok1hdGgubWF4KGQudmlld1BvcnRNYXgsOTkpLGQubWluPXIoZC52aWV3UG9ydE1pbik/LTk5Ok1hdGgubWluKGQudmlld1BvcnRNaW4sLTk5KSk6IWwmJnQmJihkLm1heD1yKGQudmlld1BvcnRNYXgpPy0xOk1hdGgubWF4KGQudmlld1BvcnRNYXgsXG4tMSksZC5taW49cihkLnZpZXdQb3J0TWluKT8tOTk6TWF0aC5taW4oZC52aWV3UG9ydE1pbiwtOTkpKTtkLnZpZXdQb3J0TWluPWQubWluO2Qudmlld1BvcnRNYXg9ZC5tYXg7YS5kYXRhUG9pbnRZU3Vtcz1DfX07cC5wcm90b3R5cGUuX3Byb2Nlc3NNdWx0aVlQbG90VW5pdD1mdW5jdGlvbihhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKWZvcih2YXIgZD1hLmF4aXNZLmRhdGFJbmZvLGM9YS5heGlzWC5kYXRhSW5mbyxiLGUsZixsLHQ9ITEsQz0wO0M8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7QysrKXt2YXIgaz10aGlzLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1tDXV0sbT0wLG49ITEscT0hMSxnLHMsaDtpZihcIm5vcm1hbFwiPT09ay5heGlzUGxhY2VtZW50fHxcInh5U3dhcHBlZFwiPT09ay5heGlzUGxhY2VtZW50KXZhciByPWEuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0/YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bTpcbmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLnZpZXdwb3J0TWluaW11bT9hLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtOmEuYXhpc1gub3B0aW9ucyYmYS5heGlzWC5vcHRpb25zLm1pbmltdW0/YS5heGlzWC5vcHRpb25zLm1pbmltdW06YS5heGlzWC5sb2dhcml0aG1pYz8wOi1JbmZpbml0eSx1PWEuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW0/YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bTphLmF4aXNYLm9wdGlvbnMmJmEuYXhpc1gub3B0aW9ucy52aWV3cG9ydE1heGltdW0/YS5heGlzWC5vcHRpb25zLnZpZXdwb3J0TWF4aW11bTphLmF4aXNYLm9wdGlvbnMmJmEuYXhpc1gub3B0aW9ucy5tYXhpbXVtP2EuYXhpc1gub3B0aW9ucy5tYXhpbXVtOkluZmluaXR5O2lmKGsuZGF0YVBvaW50c1ttXS54JiZrLmRhdGFQb2ludHNbbV0ueC5nZXRUaW1lfHxcImRhdGVUaW1lXCI9PT1rLnhWYWx1ZVR5cGUpdD0hMDtcbmZvcihtPTA7bTxrLmRhdGFQb2ludHMubGVuZ3RoO20rKyl7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBrLmRhdGFQb2ludHNbbV0ueCYmKGsuZGF0YVBvaW50c1ttXS54PW0rKGEuYXhpc1gubG9nYXJpdGhtaWM/MTowKSk7ay5kYXRhUG9pbnRzW21dLnguZ2V0VGltZT8odD0hMCxiPWsuZGF0YVBvaW50c1ttXS54LmdldFRpbWUoKSk6Yj1rLmRhdGFQb2ludHNbbV0ueDtpZigoZT1rLmRhdGFQb2ludHNbbV0ueSkmJmUubGVuZ3RoKXtmPU1hdGgubWluLmFwcGx5KG51bGwsZSk7bD1NYXRoLm1heC5hcHBseShudWxsLGUpO3M9ITA7Zm9yKHZhciB5PTA7eTxlLmxlbmd0aDt5KyspbnVsbD09PWUuayYmKHM9ITEpO3MmJihufHwoaD1nKSxnPWIpfWI8Yy5taW4mJihjLm1pbj1iKTtiPmMubWF4JiYoYy5tYXg9Yik7ZjxkLm1pbiYmKGQubWluPWYpO2w+ZC5tYXgmJihkLm1heD1sKTswPG0mJihhLmF4aXNYLmxvZ2FyaXRobWljPyhzPWIvay5kYXRhUG9pbnRzW20tMV0ueCwxPnMmJihzPTEvcyksXG5jLm1pbkRpZmY+cyYmMSE9PXMmJihjLm1pbkRpZmY9cykpOihzPWItay5kYXRhUG9pbnRzW20tMV0ueCwwPnMmJihzKj0tMSksYy5taW5EaWZmPnMmJjAhPT1zJiYoYy5taW5EaWZmPXMpKSxlJiYobnVsbCE9PWVbMF0mJmsuZGF0YVBvaW50c1ttLTFdLnkmJm51bGwhPT1rLmRhdGFQb2ludHNbbS0xXS55WzBdKSYmKGEuYXhpc1kubG9nYXJpdGhtaWM/KHM9ZVswXS9rLmRhdGFQb2ludHNbbS0xXS55WzBdLDE+cyYmKHM9MS9zKSxkLm1pbkRpZmY+cyYmMSE9PXMmJihkLm1pbkRpZmY9cykpOihzPWVbMF0tay5kYXRhUG9pbnRzW20tMV0ueVswXSwwPnMmJihzKj0tMSksZC5taW5EaWZmPnMmJjAhPT1zJiYoZC5taW5EaWZmPXMpKSkpO2lmKCEoYjxyKXx8bil7aWYoIW4mJihuPSEwLDA8bSkpe20tPTI7Zz1oO2NvbnRpbnVlfWlmKGI+dSYmIXEpcT0hMDtlbHNlIGlmKGI+dSYmcSljb250aW51ZTtrLmRhdGFQb2ludHNbbV0ubGFiZWwmJihhLmF4aXNYLmxhYmVsc1tiXT1rLmRhdGFQb2ludHNbbV0ubGFiZWwpO1xuYjxjLnZpZXdQb3J0TWluJiYoYy52aWV3UG9ydE1pbj1iKTtiPmMudmlld1BvcnRNYXgmJihjLnZpZXdQb3J0TWF4PWIpO2lmKGMudmlld1BvcnRNaW49PT1iJiZlKWZvcih5PTA7eTxlLmxlbmd0aDt5KyspaWYobnVsbD09PWVbeV0mJmc8Yil7Yy52aWV3UG9ydE1pbj1nO2JyZWFrfW51bGw9PT1lP2Mudmlld1BvcnRNaW49PT1iJiZnPGImJihjLnZpZXdQb3J0TWluPWcpOihmPGQudmlld1BvcnRNaW4mJihkLnZpZXdQb3J0TWluPWYpLGw+ZC52aWV3UG9ydE1heCYmKGQudmlld1BvcnRNYXg9bCkpfX1rLmF4aXNYLnZhbHVlVHlwZT1rLnhWYWx1ZVR5cGU9dD9cImRhdGVUaW1lXCI6XCJudW1iZXJcIn19O3AucHJvdG90eXBlLl9wcm9jZXNzU3BlY2lmaWNQbG90VW5pdD1mdW5jdGlvbihhKXtpZihcIndhdGVyZmFsbFwiPT09YS50eXBlJiZhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKWZvcih2YXIgZD1hLmF4aXNZLmRhdGFJbmZvLGM9YS5heGlzWC5kYXRhSW5mbyxcbmIsZSxmPSExLGw9MDtsPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2wrKyl7dmFyIHQ9dGhpcy5kYXRhW2EuZGF0YVNlcmllc0luZGV4ZXNbbF1dLEM9MCxrPSExLG09ITEsbj1iPTA7aWYoXCJub3JtYWxcIj09PXQuYXhpc1BsYWNlbWVudHx8XCJ4eVN3YXBwZWRcIj09PXQuYXhpc1BsYWNlbWVudCl2YXIgcT1hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtP2EuYXhpc1guc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW06YS5heGlzWC5vcHRpb25zJiZhLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtP2EuYXhpc1gub3B0aW9ucy52aWV3cG9ydE1pbmltdW06YS5heGlzWC5vcHRpb25zJiZhLmF4aXNYLm9wdGlvbnMubWluaW11bT9hLmF4aXNYLm9wdGlvbnMubWluaW11bTphLmF4aXNYLmxvZ2FyaXRobWljPzA6LUluZmluaXR5LGc9YS5heGlzWC5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bT9hLmF4aXNYLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtOlxuYS5heGlzWC5vcHRpb25zJiZhLmF4aXNYLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtP2EuYXhpc1gub3B0aW9ucy52aWV3cG9ydE1heGltdW06YS5heGlzWC5vcHRpb25zJiZhLmF4aXNYLm9wdGlvbnMubWF4aW11bT9hLmF4aXNYLm9wdGlvbnMubWF4aW11bTpJbmZpbml0eTtpZih0LmRhdGFQb2ludHNbQ10ueCYmdC5kYXRhUG9pbnRzW0NdLnguZ2V0VGltZXx8XCJkYXRlVGltZVwiPT09dC54VmFsdWVUeXBlKWY9ITA7Zm9yKEM9MDtDPHQuZGF0YVBvaW50cy5sZW5ndGg7QysrKVwidW5kZWZpbmVkXCIhPT10eXBlb2YgdC5kYXRhUG9pbnRzW0NdLmlzQ3VtdWxhdGl2ZVN1bSYmITA9PT10LmRhdGFQb2ludHNbQ10uaXNDdW11bGF0aXZlU3VtPyh0LmRhdGFQb2ludEVPc1tDXS5jdW11bGF0aXZlU3VtWVN0YXJ0VmFsdWU9MCx0LmRhdGFQb2ludEVPc1tDXS5jdW11bGF0aXZlU3VtPTA9PT1DPzA6dC5kYXRhUG9pbnRFT3NbQy0xXS5jdW11bGF0aXZlU3VtLHQuZGF0YVBvaW50c1tDXS55PTA9PT1cbkM/MDp0LmRhdGFQb2ludEVPc1tDLTFdLmN1bXVsYXRpdmVTdW0pOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgdC5kYXRhUG9pbnRzW0NdLmlzSW50ZXJtZWRpYXRlU3VtJiYhMD09PXQuZGF0YVBvaW50c1tDXS5pc0ludGVybWVkaWF0ZVN1bT8odC5kYXRhUG9pbnRFT3NbQ10uY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlPW4sdC5kYXRhUG9pbnRFT3NbQ10uY3VtdWxhdGl2ZVN1bT0wPT09Qz8wOnQuZGF0YVBvaW50RU9zW0MtMV0uY3VtdWxhdGl2ZVN1bSx0LmRhdGFQb2ludHNbQ10ueT0wPT09Qz8wOmIsbj0wPT09Qz8wOnQuZGF0YVBvaW50RU9zW0MtMV0uY3VtdWxhdGl2ZVN1bSxiPTApOihlPVwibnVtYmVyXCIhPT10eXBlb2YgdC5kYXRhUG9pbnRzW0NdLnk/MDp0LmRhdGFQb2ludHNbQ10ueSx0LmRhdGFQb2ludEVPc1tDXS5jdW11bGF0aXZlU3VtWVN0YXJ0VmFsdWU9MD09PUM/MDp0LmRhdGFQb2ludEVPc1tDLTFdLmN1bXVsYXRpdmVTdW0sdC5kYXRhUG9pbnRFT3NbQ10uY3VtdWxhdGl2ZVN1bT1cbjA9PT1DP2U6dC5kYXRhUG9pbnRFT3NbQy0xXS5jdW11bGF0aXZlU3VtK2UsYis9ZSk7Zm9yKEM9MDtDPHQuZGF0YVBvaW50cy5sZW5ndGg7QysrKWlmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgdC5kYXRhUG9pbnRzW0NdLngmJih0LmRhdGFQb2ludHNbQ10ueD1DKyhhLmF4aXNYLmxvZ2FyaXRobWljPzE6MCkpLHQuZGF0YVBvaW50c1tDXS54LmdldFRpbWU/KGY9ITAsYj10LmRhdGFQb2ludHNbQ10ueC5nZXRUaW1lKCkpOmI9dC5kYXRhUG9pbnRzW0NdLngsZT10LmRhdGFQb2ludHNbQ10ueSxiPGMubWluJiYoYy5taW49YiksYj5jLm1heCYmKGMubWF4PWIpLHQuZGF0YVBvaW50RU9zW0NdLmN1bXVsYXRpdmVTdW08ZC5taW4mJihkLm1pbj10LmRhdGFQb2ludEVPc1tDXS5jdW11bGF0aXZlU3VtKSx0LmRhdGFQb2ludEVPc1tDXS5jdW11bGF0aXZlU3VtPmQubWF4JiYoZC5tYXg9dC5kYXRhUG9pbnRFT3NbQ10uY3VtdWxhdGl2ZVN1bSksMDxDJiYoYS5heGlzWC5sb2dhcml0aG1pYz8obj1cbmIvdC5kYXRhUG9pbnRzW0MtMV0ueCwxPm4mJihuPTEvbiksYy5taW5EaWZmPm4mJjEhPT1uJiYoYy5taW5EaWZmPW4pKToobj1iLXQuZGF0YVBvaW50c1tDLTFdLngsMD5uJiYobio9LTEpLGMubWluRGlmZj5uJiYwIT09biYmKGMubWluRGlmZj1uKSksbnVsbCE9PWUmJm51bGwhPT10LmRhdGFQb2ludHNbQy0xXS55JiYoYS5heGlzWS5sb2dhcml0aG1pYz8oZT10LmRhdGFQb2ludEVPc1tDXS5jdW11bGF0aXZlU3VtL3QuZGF0YVBvaW50RU9zW0MtMV0uY3VtdWxhdGl2ZVN1bSwxPmUmJihlPTEvZSksZC5taW5EaWZmPmUmJjEhPT1lJiYoZC5taW5EaWZmPWUpKTooZT10LmRhdGFQb2ludEVPc1tDXS5jdW11bGF0aXZlU3VtLXQuZGF0YVBvaW50RU9zW0MtMV0uY3VtdWxhdGl2ZVN1bSwwPmUmJihlKj0tMSksZC5taW5EaWZmPmUmJjAhPT1lJiYoZC5taW5EaWZmPWUpKSkpLCEoYjxxKXx8ayl7aWYoIWsmJihrPSEwLDA8Qykpe0MtPTI7Y29udGludWV9aWYoYj5nJiYhbSltPSEwO2Vsc2UgaWYoYj5cbmcmJm0pY29udGludWU7dC5kYXRhUG9pbnRzW0NdLmxhYmVsJiYoYS5heGlzWC5sYWJlbHNbYl09dC5kYXRhUG9pbnRzW0NdLmxhYmVsKTtiPGMudmlld1BvcnRNaW4mJihjLnZpZXdQb3J0TWluPWIpO2I+Yy52aWV3UG9ydE1heCYmKGMudmlld1BvcnRNYXg9Yik7MDxDJiYodC5kYXRhUG9pbnRFT3NbQy0xXS5jdW11bGF0aXZlU3VtPGQudmlld1BvcnRNaW4mJihkLnZpZXdQb3J0TWluPXQuZGF0YVBvaW50RU9zW0MtMV0uY3VtdWxhdGl2ZVN1bSksdC5kYXRhUG9pbnRFT3NbQy0xXS5jdW11bGF0aXZlU3VtPmQudmlld1BvcnRNYXgmJihkLnZpZXdQb3J0TWF4PXQuZGF0YVBvaW50RU9zW0MtMV0uY3VtdWxhdGl2ZVN1bSkpO3QuZGF0YVBvaW50RU9zW0NdLmN1bXVsYXRpdmVTdW08ZC52aWV3UG9ydE1pbiYmKGQudmlld1BvcnRNaW49dC5kYXRhUG9pbnRFT3NbQ10uY3VtdWxhdGl2ZVN1bSk7dC5kYXRhUG9pbnRFT3NbQ10uY3VtdWxhdGl2ZVN1bT5kLnZpZXdQb3J0TWF4JiYoZC52aWV3UG9ydE1heD1cbnQuZGF0YVBvaW50RU9zW0NdLmN1bXVsYXRpdmVTdW0pfXQuYXhpc1gudmFsdWVUeXBlPXQueFZhbHVlVHlwZT1mP1wiZGF0ZVRpbWVcIjpcIm51bWJlclwifX07cC5wcm90b3R5cGUuY2FsY3VsYXRlQXV0b0JyZWFrcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiLGMsZSl7aWYoZSlyZXR1cm4gYz1NYXRoLnBvdyhNYXRoLm1pbihjKmEvYixiL2EpLDAuMiksMT49YyYmKGM9TWF0aC5wb3coMT5hPzEvYTpNYXRoLm1pbihiL2EsYSksMC4yNSkpLHtzdGFydFZhbHVlOmEqYyxlbmRWYWx1ZTpiL2N9O2M9MC4yKk1hdGgubWluKGMtYithLGItYSk7MD49YyYmKGM9MC4yNSpNYXRoLm1pbihiLWEsTWF0aC5hYnMoYSkpKTtyZXR1cm57c3RhcnRWYWx1ZTphK2MsZW5kVmFsdWU6Yi1jfX1mdW5jdGlvbiBkKGEpe2lmKGEuZGF0YVNlcmllc0luZGV4ZXMmJiEoMT5hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBiPWEuYXhpc1guc2NhbGVCcmVha3MmJmEuYXhpc1guc2NhbGVCcmVha3MuYXV0b0NhbGN1bGF0ZSYmXG4xPD1hLmF4aXNYLnNjYWxlQnJlYWtzLm1heE51bWJlck9mQXV0b0JyZWFrcyxjPWEuYXhpc1kuc2NhbGVCcmVha3MmJmEuYXhpc1kuc2NhbGVCcmVha3MuYXV0b0NhbGN1bGF0ZSYmMTw9YS5heGlzWS5zY2FsZUJyZWFrcy5tYXhOdW1iZXJPZkF1dG9CcmVha3M7aWYoYnx8Yylmb3IodmFyIGQ9YS5heGlzWS5kYXRhSW5mbyxnPWEuYXhpc1guZGF0YUluZm8sZixsPWcubWluLGs9Zy5tYXgsbT1kLm1pbixuPWQubWF4LGc9Zy5fZGF0YVJhbmdlcyxkPWQuX2RhdGFSYW5nZXMscSx0PTAsQz0wO0M8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7QysrKXt2YXIgaD1lLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1tDXV07aWYoISg0PmguZGF0YVBvaW50cy5sZW5ndGgpKWZvcih0PTA7dDxoLmRhdGFQb2ludHMubGVuZ3RoO3QrKylpZihiJiYocT0oaysxLWwpKk1hdGgubWF4KHBhcnNlRmxvYXQoYS5heGlzWC5zY2FsZUJyZWFrcy5jb2xsYXBzaWJsZVRocmVzaG9sZCl8fDEwLDEwKS8xMDAsXG5mPWguZGF0YVBvaW50c1t0XS54LmdldFRpbWU/aC5kYXRhUG9pbnRzW3RdLnguZ2V0VGltZSgpOmguZGF0YVBvaW50c1t0XS54LHE9TWF0aC5mbG9vcigoZi1sKS9xKSxmPGdbcV0ubWluJiYoZ1txXS5taW49ZiksZj5nW3FdLm1heCYmKGdbcV0ubWF4PWYpKSxjKXt2YXIgcD0obisxLW0pKk1hdGgubWF4KHBhcnNlRmxvYXQoYS5heGlzWS5zY2FsZUJyZWFrcy5jb2xsYXBzaWJsZVRocmVzaG9sZCl8fDEwLDEwKS8xMDA7aWYoKGY9XCJ3YXRlcmZhbGxcIj09PWEudHlwZT9oLmRhdGFQb2ludEVPc1t0XS5jdW11bGF0aXZlU3VtOmguZGF0YVBvaW50c1t0XS55KSYmZi5sZW5ndGgpZm9yKHZhciB3PTA7dzxmLmxlbmd0aDt3KyspcT1NYXRoLmZsb29yKChmW3ddLW0pL3ApLGZbd108ZFtxXS5taW4mJihkW3FdLm1pbj1mW3ddKSxmW3ddPmRbcV0ubWF4JiYoZFtxXS5tYXg9Zlt3XSk7ZWxzZSByKGYpfHwocT1NYXRoLmZsb29yKChmLW0pL3ApLGY8ZFtxXS5taW4mJihkW3FdLm1pbj1mKSxmPlxuZFtxXS5tYXgmJihkW3FdLm1heD1mKSl9fX19ZnVuY3Rpb24gYyhhKXtpZihhLmRhdGFTZXJpZXNJbmRleGVzJiYhKDE+YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpJiZhLmF4aXNYLnNjYWxlQnJlYWtzJiZhLmF4aXNYLnNjYWxlQnJlYWtzLmF1dG9DYWxjdWxhdGUmJjE8PWEuYXhpc1guc2NhbGVCcmVha3MubWF4TnVtYmVyT2ZBdXRvQnJlYWtzKWZvcih2YXIgYj1hLmF4aXNYLmRhdGFJbmZvLGM9Yi5taW4sZD1iLm1heCxmPWIuX2RhdGFSYW5nZXMsZyxsPTAsaz0wO2s8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7aysrKXt2YXIgbT1lLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1trXV07aWYoISg0Pm0uZGF0YVBvaW50cy5sZW5ndGgpKWZvcihsPTA7bDxtLmRhdGFQb2ludHMubGVuZ3RoO2wrKylnPShkKzEtYykqTWF0aC5tYXgocGFyc2VGbG9hdChhLmF4aXNYLnNjYWxlQnJlYWtzLmNvbGxhcHNpYmxlVGhyZXNob2xkKXx8MTAsMTApLzEwMCxiPW0uZGF0YVBvaW50c1tsXS54LmdldFRpbWU/XG5tLmRhdGFQb2ludHNbbF0ueC5nZXRUaW1lKCk6bS5kYXRhUG9pbnRzW2xdLngsZz1NYXRoLmZsb29yKChiLWMpL2cpLGI8ZltnXS5taW4mJihmW2ddLm1pbj1iKSxiPmZbZ10ubWF4JiYoZltnXS5tYXg9Yil9fWZvcih2YXIgYixlPXRoaXMsZj0hMSxsPTA7bDx0aGlzLl9heGVzLmxlbmd0aDtsKyspaWYodGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcyYmdGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcy5hdXRvQ2FsY3VsYXRlJiYxPD10aGlzLl9heGVzW2xdLnNjYWxlQnJlYWtzLm1heE51bWJlck9mQXV0b0JyZWFrcyl7Zj0hMDt0aGlzLl9heGVzW2xdLmRhdGFJbmZvLl9kYXRhUmFuZ2VzPVtdO2Zvcih2YXIgdD0wO3Q8MTAwL01hdGgubWF4KHBhcnNlRmxvYXQodGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcy5jb2xsYXBzaWJsZVRocmVzaG9sZCl8fDEwLDEwKTt0KyspdGhpcy5fYXhlc1tsXS5kYXRhSW5mby5fZGF0YVJhbmdlcy5wdXNoKHttaW46SW5maW5pdHksbWF4Oi1JbmZpbml0eX0pfWlmKGYpe2ZvcihsPVxuMDtsPHRoaXMucGxvdEluZm8ucGxvdFR5cGVzLmxlbmd0aDtsKyspZm9yKGY9dGhpcy5wbG90SW5mby5wbG90VHlwZXNbbF0sdD0wO3Q8Zi5wbG90VW5pdHMubGVuZ3RoO3QrKyliPWYucGxvdFVuaXRzW3RdLFwibGluZVwiPT09Yi50eXBlfHxcInN0ZXBMaW5lXCI9PT1iLnR5cGV8fFwic3BsaW5lXCI9PT1iLnR5cGV8fFwiY29sdW1uXCI9PT1iLnR5cGV8fFwiYXJlYVwiPT09Yi50eXBlfHxcInN0ZXBBcmVhXCI9PT1iLnR5cGV8fFwic3BsaW5lQXJlYVwiPT09Yi50eXBlfHxcImJhclwiPT09Yi50eXBlfHxcImJ1YmJsZVwiPT09Yi50eXBlfHxcInNjYXR0ZXJcIj09PWIudHlwZXx8XCJjYW5kbGVzdGlja1wiPT09Yi50eXBlfHxcIm9obGNcIj09PWIudHlwZXx8XCJyYW5nZUNvbHVtblwiPT09Yi50eXBlfHxcInJhbmdlQmFyXCI9PT1iLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1iLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1iLnR5cGV8fFwid2F0ZXJmYWxsXCI9PT1iLnR5cGV8fFwiZXJyb3JcIj09PWIudHlwZXx8XCJib3hBbmRXaGlza2VyXCI9PT1cbmIudHlwZT9kKGIpOjA8PWIudHlwZS5pbmRleE9mKFwic3RhY2tlZFwiKSYmYyhiKTtmb3IobD0wO2w8dGhpcy5fYXhlcy5sZW5ndGg7bCsrKWlmKHRoaXMuX2F4ZXNbbF0uZGF0YUluZm8uX2RhdGFSYW5nZXMpe3ZhciBDPXRoaXMuX2F4ZXNbbF0uZGF0YUluZm8ubWluO2I9KHRoaXMuX2F4ZXNbbF0uZGF0YUluZm8ubWF4KzEtQykqTWF0aC5tYXgocGFyc2VGbG9hdCh0aGlzLl9heGVzW2xdLnNjYWxlQnJlYWtzLmNvbGxhcHNpYmxlVGhyZXNob2xkKXx8MTAsMTApLzEwMDt2YXIgaz10aGlzLl9heGVzW2xdLmRhdGFJbmZvLl9kYXRhUmFuZ2VzLG0sbixmPVtdO2lmKHRoaXMuX2F4ZXNbbF0uZGF0YUluZm8uZGF0YVBvaW50WVBvc2l0aXZlU3Vtcyl7dmFyIHE9dGhpcy5fYXhlc1tsXS5kYXRhSW5mby5kYXRhUG9pbnRZUG9zaXRpdmVTdW1zO209aztmb3IodCBpbiBxKWlmKHEuaGFzT3duUHJvcGVydHkodCkmJiFpc05hTih0KSYmKG49cVt0XSwhcihuKSkpe3ZhciBnPU1hdGguZmxvb3IoKG4tXG5DKS9iKTtuPG1bZ10ubWluJiYobVtnXS5taW49bik7bj5tW2ddLm1heCYmKG1bZ10ubWF4PW4pfWRlbGV0ZSB0aGlzLl9heGVzW2xdLmRhdGFJbmZvLmRhdGFQb2ludFlQb3NpdGl2ZVN1bXN9aWYodGhpcy5fYXhlc1tsXS5kYXRhSW5mby5kYXRhUG9pbnRZTmVnYXRpdmVTdW1zKXtxPXRoaXMuX2F4ZXNbbF0uZGF0YUluZm8uZGF0YVBvaW50WU5lZ2F0aXZlU3VtczttPWs7Zm9yKHQgaW4gcSlxLmhhc093blByb3BlcnR5KHQpJiYhaXNOYU4odCkmJihuPS0xKnFbdF0scihuKXx8KGc9TWF0aC5mbG9vcigobi1DKS9iKSxuPG1bZ10ubWluJiYobVtnXS5taW49biksbj5tW2ddLm1heCYmKG1bZ10ubWF4PW4pKSk7ZGVsZXRlIHRoaXMuX2F4ZXNbbF0uZGF0YUluZm8uZGF0YVBvaW50WU5lZ2F0aXZlU3Vtc31mb3IodD0wO3Q8ay5sZW5ndGgtMTt0KyspaWYobT1rW3RdLm1heCxpc0Zpbml0ZShtKSlmb3IoO3Q8ay5sZW5ndGgtMTspaWYoQz1rW3QrMV0ubWluLGlzRmluaXRlKEMpKXtuPUMtXG5tO24+YiYmZi5wdXNoKHtkaWZmOm4sc3RhcnQ6bSxlbmQ6Q30pO2JyZWFrfWVsc2UgdCsrO2lmKHRoaXMuX2F4ZXNbbF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzKWZvcih0PTA7dDx0aGlzLl9heGVzW2xdLnNjYWxlQnJlYWtzLmN1c3RvbUJyZWFrcy5sZW5ndGg7dCsrKWZvcihiPTA7YjxmLmxlbmd0aDtiKyspaWYodGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcy5jdXN0b21CcmVha3NbdF0uc3RhcnRWYWx1ZTw9ZltiXS5zdGFydCYmZltiXS5zdGFydDw9dGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcy5jdXN0b21CcmVha3NbdF0uZW5kVmFsdWV8fHRoaXMuX2F4ZXNbbF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzW3RdLnN0YXJ0VmFsdWU8PWZbYl0uc3RhcnQmJmZbYl0uc3RhcnQ8PXRoaXMuX2F4ZXNbbF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzW3RdLmVuZFZhbHVlfHxmW2JdLnN0YXJ0PD10aGlzLl9heGVzW2xdLnNjYWxlQnJlYWtzLmN1c3RvbUJyZWFrc1t0XS5zdGFydFZhbHVlJiZcbnRoaXMuX2F4ZXNbbF0uc2NhbGVCcmVha3MuY3VzdG9tQnJlYWtzW3RdLnN0YXJ0VmFsdWU8PWZbYl0uZW5kfHxmW2JdLnN0YXJ0PD10aGlzLl9heGVzW2xdLnNjYWxlQnJlYWtzLmN1c3RvbUJyZWFrc1t0XS5lbmRWYWx1ZSYmdGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcy5jdXN0b21CcmVha3NbdF0uZW5kVmFsdWU8PWZbYl0uZW5kKWYuc3BsaWNlKGIsMSksYi0tO2Yuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBiLmRpZmYtYS5kaWZmfSk7Zm9yKHQ9MDt0PE1hdGgubWluKGYubGVuZ3RoLHRoaXMuX2F4ZXNbbF0uc2NhbGVCcmVha3MubWF4TnVtYmVyT2ZBdXRvQnJlYWtzKTt0KyspYj1hKGZbdF0uc3RhcnQsZlt0XS5lbmQsdGhpcy5fYXhlc1tsXS5sb2dhcml0aG1pYz90aGlzLl9heGVzW2xdLmRhdGFJbmZvLm1heC90aGlzLl9heGVzW2xdLmRhdGFJbmZvLm1pbjp0aGlzLl9heGVzW2xdLmRhdGFJbmZvLm1heC10aGlzLl9heGVzW2xdLmRhdGFJbmZvLm1pbix0aGlzLl9heGVzW2xdLmxvZ2FyaXRobWljKSxcbnRoaXMuX2F4ZXNbbF0uc2NhbGVCcmVha3MuYXV0b0JyZWFrcy5wdXNoKG5ldyBhYSh0aGlzLFwiYXV0b0JyZWFrc1wiLGIsdCwrK3RoaXMuX2V2ZW50TWFuYWdlci5sYXN0T2JqZWN0SWQsdGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcykpLHRoaXMuX2F4ZXNbbF0uc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MucHVzaCh0aGlzLl9heGVzW2xdLnNjYWxlQnJlYWtzLmF1dG9CcmVha3NbdGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcy5hdXRvQnJlYWtzLmxlbmd0aC0xXSk7dGhpcy5fYXhlc1tsXS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuc3RhcnRWYWx1ZS1iLnN0YXJ0VmFsdWV9KX19fTtwLnByb3RvdHlwZS5yZW5kZXJDcm9zc2hhaXJzPWZ1bmN0aW9uKGEpe2Zvcih2YXIgZD0wO2Q8dGhpcy5heGlzWC5sZW5ndGg7ZCsrKXRoaXMuYXhpc1hbZF0hPWEmJih0aGlzLmF4aXNYW2RdLmNyb3NzaGFpciYmdGhpcy5heGlzWFtkXS5jcm9zc2hhaXIuZW5hYmxlZCYmXG4hdGhpcy5heGlzWFtkXS5jcm9zc2hhaXIuX2hpZGRlbikmJnRoaXMuYXhpc1hbZF0uc2hvd0Nyb3NzaGFpcih0aGlzLmF4aXNYW2RdLmNyb3NzaGFpci5fdXBkYXRlZFZhbHVlKTtmb3IoZD0wO2Q8dGhpcy5heGlzWDIubGVuZ3RoO2QrKyl0aGlzLmF4aXNYMltkXSE9YSYmKHRoaXMuYXhpc1gyW2RdLmNyb3NzaGFpciYmdGhpcy5heGlzWDJbZF0uY3Jvc3NoYWlyLmVuYWJsZWQmJiF0aGlzLmF4aXNYMltkXS5jcm9zc2hhaXIuX2hpZGRlbikmJnRoaXMuYXhpc1gyW2RdLnNob3dDcm9zc2hhaXIodGhpcy5heGlzWDJbZF0uY3Jvc3NoYWlyLl91cGRhdGVkVmFsdWUpO2ZvcihkPTA7ZDx0aGlzLmF4aXNZLmxlbmd0aDtkKyspdGhpcy5heGlzWVtkXSE9YSYmKHRoaXMuYXhpc1lbZF0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNZW2RdLmNyb3NzaGFpci5lbmFibGVkJiYhdGhpcy5heGlzWVtkXS5jcm9zc2hhaXIuX2hpZGRlbikmJnRoaXMuYXhpc1lbZF0uc2hvd0Nyb3NzaGFpcih0aGlzLmF4aXNZW2RdLmNyb3NzaGFpci5fdXBkYXRlZFZhbHVlKTtcbmZvcihkPTA7ZDx0aGlzLmF4aXNZMi5sZW5ndGg7ZCsrKXRoaXMuYXhpc1kyW2RdIT1hJiYodGhpcy5heGlzWTJbZF0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNZMltkXS5jcm9zc2hhaXIuZW5hYmxlZCYmIXRoaXMuYXhpc1kyW2RdLmNyb3NzaGFpci5faGlkZGVuKSYmdGhpcy5heGlzWTJbZF0uc2hvd0Nyb3NzaGFpcih0aGlzLmF4aXNZMltkXS5jcm9zc2hhaXIuX3VwZGF0ZWRWYWx1ZSl9O3AucHJvdG90eXBlLmdldERhdGFQb2ludEF0WFk9ZnVuY3Rpb24oYSxkLGMpe2M9Y3x8ITE7Zm9yKHZhciBiPVtdLGU9dGhpcy5fZGF0YUluUmVuZGVyZWRPcmRlci5sZW5ndGgtMTswPD1lO2UtLSl7dmFyIGY9bnVsbDsoZj10aGlzLl9kYXRhSW5SZW5kZXJlZE9yZGVyW2VdLmdldERhdGFQb2ludEF0WFkoYSxkLGMpKSYmYi5wdXNoKGYpfWE9bnVsbDtkPSExO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspaWYoXCJsaW5lXCI9PT1iW2NdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGVwTGluZVwiPT09YltjXS5kYXRhU2VyaWVzLnR5cGV8fFxuXCJhcmVhXCI9PT1iW2NdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGVwQXJlYVwiPT09YltjXS5kYXRhU2VyaWVzLnR5cGUpaWYoZT1tYShcIm1hcmtlclNpemVcIixiW2NdLmRhdGFQb2ludCxiW2NdLmRhdGFTZXJpZXMpfHw4LGJbY10uZGlzdGFuY2U8PWUvMil7ZD0hMDticmVha31mb3IoYz0wO2M8Yi5sZW5ndGg7YysrKWQmJlwibGluZVwiIT09YltjXS5kYXRhU2VyaWVzLnR5cGUmJlwic3RlcExpbmVcIiE9PWJbY10uZGF0YVNlcmllcy50eXBlJiZcImFyZWFcIiE9PWJbY10uZGF0YVNlcmllcy50eXBlJiZcInN0ZXBBcmVhXCIhPT1iW2NdLmRhdGFTZXJpZXMudHlwZXx8KGE/YltjXS5kaXN0YW5jZTw9YS5kaXN0YW5jZSYmKGE9YltjXSk6YT1iW2NdKTtyZXR1cm4gYX07cC5wcm90b3R5cGUuZ2V0T2JqZWN0QXRYWT1mdW5jdGlvbihhLGQsYyl7dmFyIGI9bnVsbDtpZihjPXRoaXMuZ2V0RGF0YVBvaW50QXRYWShhLGQsY3x8ITEpKWI9Yy5kYXRhU2VyaWVzLmRhdGFQb2ludElkc1tjLmRhdGFQb2ludEluZGV4XTtcbmVsc2UgaWYodyliPSRhKGEsZCx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgpO2Vsc2UgZm9yKGM9MDtjPHRoaXMubGVnZW5kLml0ZW1zLmxlbmd0aDtjKyspe3ZhciBlPXRoaXMubGVnZW5kLml0ZW1zW2NdO2E+PWUueDEmJihhPD1lLngyJiZkPj1lLnkxJiZkPD1lLnkyKSYmKGI9ZS5pZCl9cmV0dXJuIGJ9O3AucHJvdG90eXBlLmdldEF1dG9Gb250U2l6ZT1tYjtwLnByb3RvdHlwZS5yZXNldE92ZXJsYXllZENhbnZhcz1mdW5jdGlvbigpe3RoaXMub3ZlcmxhaWRDYW52YXNDdHguY2xlYXJSZWN0KDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KX07cC5wcm90b3R5cGUuY2xlYXJDYW52YXM9bGI7cC5wcm90b3R5cGUuYXR0YWNoRXZlbnQ9ZnVuY3Rpb24oYSl7dGhpcy5fZXZlbnRzLnB1c2goYSl9O3AucHJvdG90eXBlLl90b3VjaEV2ZW50SGFuZGxlcj1mdW5jdGlvbihhKXtpZihhLmNoYW5nZWRUb3VjaGVzJiZ0aGlzLmludGVyYWN0aXZpdHlFbmFibGVkKXt2YXIgZD1bXSxjPVxuYS5jaGFuZ2VkVG91Y2hlcyxiPWM/Y1swXTphLGU9bnVsbDtzd2l0Y2goYS50eXBlKXtjYXNlIFwidG91Y2hzdGFydFwiOmNhc2UgXCJNU1BvaW50ZXJEb3duXCI6ZD1bXCJtb3VzZW1vdmVcIixcIm1vdXNlZG93blwiXTt0aGlzLl9sYXN0VG91Y2hEYXRhPVBhKGIpO3RoaXMuX2xhc3RUb3VjaERhdGEudGltZT1uZXcgRGF0ZTticmVhaztjYXNlIFwidG91Y2htb3ZlXCI6Y2FzZSBcIk1TUG9pbnRlck1vdmVcIjpkPVtcIm1vdXNlbW92ZVwiXTticmVhaztjYXNlIFwidG91Y2hlbmRcIjpjYXNlIFwiTVNQb2ludGVyVXBcIjp2YXIgZj10aGlzLl9sYXN0VG91Y2hEYXRhJiZ0aGlzLl9sYXN0VG91Y2hEYXRhLnRpbWU/bmV3IERhdGUtdGhpcy5fbGFzdFRvdWNoRGF0YS50aW1lOjAsZD1cInRvdWNoc3RhcnRcIj09PXRoaXMuX2xhc3RUb3VjaEV2ZW50VHlwZXx8XCJNU1BvaW50ZXJEb3duXCI9PT10aGlzLl9sYXN0VG91Y2hFdmVudFR5cGV8fDMwMD5mP1tcIm1vdXNldXBcIixcImNsaWNrXCJdOltcIm1vdXNldXBcIl07YnJlYWs7ZGVmYXVsdDpyZXR1cm59aWYoIShjJiZcbjE8Yy5sZW5ndGgpKXtlPVBhKGIpO2UudGltZT1uZXcgRGF0ZTt0cnl7dmFyIGw9ZS55LXRoaXMuX2xhc3RUb3VjaERhdGEueSxmPWUudGltZS10aGlzLl9sYXN0VG91Y2hEYXRhLnRpbWU7aWYoMTxNYXRoLmFicyhsKSYmdGhpcy5fbGFzdFRvdWNoRGF0YS5zY3JvbGx8fDU8TWF0aC5hYnMobCkmJjI1MD5mKXRoaXMuX2xhc3RUb3VjaERhdGEuc2Nyb2xsPSEwfWNhdGNoKHQpe310aGlzLl9sYXN0VG91Y2hFdmVudFR5cGU9YS50eXBlO2lmKHRoaXMuX2xhc3RUb3VjaERhdGEuc2Nyb2xsJiZ0aGlzLnpvb21FbmFibGVkKXRoaXMuaXNEcmFnJiZ0aGlzLnJlc2V0T3ZlcmxheWVkQ2FudmFzKCksdGhpcy5pc0RyYWc9ITE7ZWxzZSBmb3IoYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGU9ZFtjXSxsPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKSxsLmluaXRNb3VzZUV2ZW50KGUsITAsITAsd2luZG93LDEsYi5zY3JlZW5YLGIuc2NyZWVuWSxiLmNsaWVudFgsYi5jbGllbnRZLCExLFxuITEsITEsITEsMCxudWxsKSxiLnRhcmdldC5kaXNwYXRjaEV2ZW50KGwpLCFyKHRoaXMuX2xhc3RUb3VjaERhdGEuc2Nyb2xsKSYmIXRoaXMuX2xhc3RUb3VjaERhdGEuc2Nyb2xsfHwhdGhpcy5fbGFzdFRvdWNoRGF0YS5zY3JvbGwmJjI1MDxmfHxcImNsaWNrXCI9PT1lKWEucHJldmVudE1hbmlwdWxhdGlvbiYmYS5wcmV2ZW50TWFuaXB1bGF0aW9uKCksYS5wcmV2ZW50RGVmYXVsdCYmYS5jYW5jZWxhYmxlJiZhLnByZXZlbnREZWZhdWx0KCl9fX07cC5wcm90b3R5cGUuX2Rpc3BhdGNoUmFuZ2VFdmVudD1mdW5jdGlvbihhLGQpe3ZhciBjPXtjaGFydDp0aGlzfTtjLnR5cGU9YTtjLnRyaWdnZXI9ZDt2YXIgYj1bXTt0aGlzLmF4aXNYJiYwPHRoaXMuYXhpc1gubGVuZ3RoJiZiLnB1c2goXCJheGlzWFwiKTt0aGlzLmF4aXNYMiYmMDx0aGlzLmF4aXNYMi5sZW5ndGgmJmIucHVzaChcImF4aXNYMlwiKTt0aGlzLmF4aXNZJiYwPHRoaXMuYXhpc1kubGVuZ3RoJiZiLnB1c2goXCJheGlzWVwiKTt0aGlzLmF4aXNZMiYmXG4wPHRoaXMuYXhpc1kyLmxlbmd0aCYmYi5wdXNoKFwiYXhpc1kyXCIpO2Zvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKWlmKHIoY1tiW2VdXSkmJihjW2JbZV1dPVtdKSxcImF4aXNZXCI9PT1iW2VdKWZvcih2YXIgZj0wO2Y8dGhpcy5heGlzWS5sZW5ndGg7ZisrKWNbYltlXV0ucHVzaCh7dmlld3BvcnRNaW5pbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0sdmlld3BvcnRNYXhpbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW19KTtlbHNlIGlmKFwiYXhpc1kyXCI9PT1iW2VdKWZvcihmPTA7Zjx0aGlzLmF4aXNZMi5sZW5ndGg7ZisrKWNbYltlXV0ucHVzaCh7dmlld3BvcnRNaW5pbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0sdmlld3BvcnRNYXhpbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW19KTtlbHNlIGlmKFwiYXhpc1hcIj09PVxuYltlXSlmb3IoZj0wO2Y8dGhpcy5heGlzWC5sZW5ndGg7ZisrKWNbYltlXV0ucHVzaCh7dmlld3BvcnRNaW5pbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0sdmlld3BvcnRNYXhpbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW19KTtlbHNlIGlmKFwiYXhpc1gyXCI9PT1iW2VdKWZvcihmPTA7Zjx0aGlzLmF4aXNYMi5sZW5ndGg7ZisrKWNbYltlXV0ucHVzaCh7dmlld3BvcnRNaW5pbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0sdmlld3BvcnRNYXhpbXVtOnRoaXNbYltlXV1bZl0uc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW19KTt0aGlzLmRpc3BhdGNoRXZlbnQoYSxjLHRoaXMpfTtwLnByb3RvdHlwZS5fbW91c2VFdmVudEhhbmRsZXI9ZnVuY3Rpb24oYSl7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhLnRhcmdldCYmYS5zcmNFbGVtZW50JiZcbihhLnRhcmdldD1hLnNyY0VsZW1lbnQpO3ZhciBkPVBhKGEpLGM9YS50eXBlLGIsZTthLndoaWNoP2U9Mz09YS53aGljaDphLmJ1dHRvbiYmKGU9Mj09YS5idXR0b24pO3AuY2FwdHVyZWRFdmVudFBhcmFtJiYoYj1wLmNhcHR1cmVkRXZlbnRQYXJhbSxcIm1vdXNldXBcIj09PWMmJihwLmNhcHR1cmVkRXZlbnRQYXJhbT1udWxsLGIuY2hhcnQub3ZlcmxhaWRDYW52YXMucmVsZWFzZUNhcHR1cmU/Yi5jaGFydC5vdmVybGFpZENhbnZhcy5yZWxlYXNlQ2FwdHVyZSgpOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLGIuY2hhcnQuX21vdXNlRXZlbnRIYW5kbGVyLCExKSksYi5oYXNPd25Qcm9wZXJ0eShjKSYmKFwibW91c2V1cFwiIT09Y3x8Yi5jaGFydC5vdmVybGFpZENhbnZhcy5yZWxlYXNlQ2FwdHVyZT9hLnRhcmdldCE9PWIuY2hhcnQub3ZlcmxhaWRDYW52YXMmJnd8fGJbY10uY2FsbChiLmNvbnRleHQsZC54LGQueSk6YS50YXJnZXQhPT1cbmIuY2hhcnQub3ZlcmxhaWRDYW52YXMmJihiLmNoYXJ0LmlzRHJhZz0hMSkpKTtpZih0aGlzLmludGVyYWN0aXZpdHlFbmFibGVkKWlmKHRoaXMuX2lnbm9yZU5leHRFdmVudCl0aGlzLl9pZ25vcmVOZXh0RXZlbnQ9ITE7ZWxzZSBpZihhLnByZXZlbnRNYW5pcHVsYXRpb24mJmEucHJldmVudE1hbmlwdWxhdGlvbigpLGEucHJldmVudERlZmF1bHQmJmEucHJldmVudERlZmF1bHQoKSxJYSYmd2luZG93LmNvbnNvbGUmJih3aW5kb3cuY29uc29sZS5sb2coYytcIiAtLVxceDNlIHg6IFwiK2QueCtcIjsgeTpcIitkLnkpLGUmJndpbmRvdy5jb25zb2xlLmxvZyhhLndoaWNoKSxcIm1vdXNldXBcIj09PWMmJndpbmRvdy5jb25zb2xlLmxvZyhcIm1vdXNldXBcIikpLCFlKXtpZighcC5jYXB0dXJlZEV2ZW50UGFyYW0mJnRoaXMuX2V2ZW50cyl7Zm9yKHZhciBmPTA7Zjx0aGlzLl9ldmVudHMubGVuZ3RoO2YrKylpZih0aGlzLl9ldmVudHNbZl0uaGFzT3duUHJvcGVydHkoYykpaWYoYj10aGlzLl9ldmVudHNbZl0sXG5lPWIuYm91bmRzLGQueD49ZS54MSYmZC54PD1lLngyJiZkLnk+PWUueTEmJmQueTw9ZS55Mil7YltjXS5jYWxsKGIuY29udGV4dCxkLngsZC55KTtcIm1vdXNlZG93blwiPT09YyYmITA9PT1iLmNhcHR1cmU/KHAuY2FwdHVyZWRFdmVudFBhcmFtPWIsdGhpcy5vdmVybGFpZENhbnZhcy5zZXRDYXB0dXJlP3RoaXMub3ZlcmxhaWRDYW52YXMuc2V0Q2FwdHVyZSgpOmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLHRoaXMuX21vdXNlRXZlbnRIYW5kbGVyLCExKSk6XCJtb3VzZXVwXCI9PT1jJiYoYi5jaGFydC5vdmVybGFpZENhbnZhcy5yZWxlYXNlQ2FwdHVyZT9iLmNoYXJ0Lm92ZXJsYWlkQ2FudmFzLnJlbGVhc2VDYXB0dXJlKCk6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5fbW91c2VFdmVudEhhbmRsZXIsITEpKTticmVha31lbHNlIGI9bnVsbDthLnRhcmdldC5zdHlsZS5jdXJzb3I9XG5iJiZiLmN1cnNvcj9iLmN1cnNvcjp0aGlzLl9kZWZhdWx0Q3Vyc29yfWM9dGhpcy5wbG90QXJlYTtpZihkLng8Yy54MXx8ZC54PmMueDJ8fGQueTxjLnkxfHxkLnk+Yy55Mil7dGhpcy50b29sVGlwJiZ0aGlzLnRvb2xUaXAuZW5hYmxlZD8odGhpcy50b29sVGlwLmhpZGUoKSx0aGlzLnRvb2xUaXAuZGlzcGF0Y2hFdmVudChcImhpZGRlblwiLHtjaGFydDp0aGlzLHRvb2xUaXA6dGhpcy50b29sVGlwfSx0aGlzLnRvb2xUaXApKTp0aGlzLnJlc2V0T3ZlcmxheWVkQ2FudmFzKCk7Zm9yKGY9MDtmPHRoaXMuYXhpc1gubGVuZ3RoO2YrKyl0aGlzLmF4aXNYW2ZdLmNyb3NzaGFpciYmdGhpcy5heGlzWFtmXS5jcm9zc2hhaXIuZW5hYmxlZCYmKHRoaXMuYXhpc1hbZl0uY3Jvc3NoYWlyLmhpZGUoKSx0aGlzLmF4aXNYW2ZdLmNyb3NzaGFpci5kaXNwYXRjaEV2ZW50KFwiaGlkZGVuXCIse2NoYXJ0OnRoaXMsYXhpczp0aGlzLmF4aXNYW2ZdLm9wdGlvbnN9LHRoaXMuYXhpc1hbZl0uY3Jvc3NoYWlyKSk7XG5mb3IoZj0wO2Y8dGhpcy5heGlzWDIubGVuZ3RoO2YrKyl0aGlzLmF4aXNYMltmXS5jcm9zc2hhaXImJnRoaXMuYXhpc1gyW2ZdLmNyb3NzaGFpci5lbmFibGVkJiYodGhpcy5heGlzWDJbZl0uY3Jvc3NoYWlyLmhpZGUoKSx0aGlzLmF4aXNYMltmXS5jcm9zc2hhaXIuZGlzcGF0Y2hFdmVudChcImhpZGRlblwiLHtjaGFydDp0aGlzLGF4aXM6dGhpcy5heGlzWDJbZl0ub3B0aW9uc30sdGhpcy5heGlzWDJbZl0uY3Jvc3NoYWlyKSk7Zm9yKGY9MDtmPHRoaXMuYXhpc1kubGVuZ3RoO2YrKyl0aGlzLmF4aXNZW2ZdLmNyb3NzaGFpciYmdGhpcy5heGlzWVtmXS5jcm9zc2hhaXIuZW5hYmxlZCYmKHRoaXMuYXhpc1lbZl0uY3Jvc3NoYWlyLmhpZGUoKSx0aGlzLmF4aXNZW2ZdLmNyb3NzaGFpci5kaXNwYXRjaEV2ZW50KFwiaGlkZGVuXCIse2NoYXJ0OnRoaXMsYXhpczp0aGlzLmF4aXNZW2ZdLm9wdGlvbnN9LHRoaXMuYXhpc1lbZl0uY3Jvc3NoYWlyKSk7Zm9yKGY9MDtmPHRoaXMuYXhpc1kyLmxlbmd0aDtmKyspdGhpcy5heGlzWTJbZl0uY3Jvc3NoYWlyJiZcbnRoaXMuYXhpc1kyW2ZdLmNyb3NzaGFpci5lbmFibGVkJiYodGhpcy5heGlzWTJbZl0uY3Jvc3NoYWlyLmhpZGUoKSx0aGlzLmF4aXNZMltmXS5jcm9zc2hhaXIuZGlzcGF0Y2hFdmVudChcImhpZGRlblwiLHtjaGFydDp0aGlzLGF4aXM6dGhpcy5heGlzWTJbZl0ub3B0aW9uc30sdGhpcy5heGlzWTJbZl0uY3Jvc3NoYWlyKSl9dGhpcy5pc0RyYWcmJnRoaXMuem9vbUVuYWJsZWR8fCF0aGlzLl9ldmVudE1hbmFnZXJ8fHRoaXMuX2V2ZW50TWFuYWdlci5tb3VzZUV2ZW50SGFuZGxlcihhKX19O3AucHJvdG90eXBlLl9wbG90QXJlYU1vdXNlRG93bj1mdW5jdGlvbihhLGQpe3RoaXMuaXNEcmFnPSEwO3RoaXMuZHJhZ1N0YXJ0UG9pbnQ9e3g6YSx5OmR9fTtwLnByb3RvdHlwZS5fcGxvdEFyZWFNb3VzZVVwPWZ1bmN0aW9uKGEsZCl7aWYoKFwibm9ybWFsXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnR8fFwieHlTd2FwcGVkXCI9PT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpJiZ0aGlzLmlzRHJhZyl7dmFyIGM9XG5kLXRoaXMuZHJhZ1N0YXJ0UG9pbnQueSxiPWEtdGhpcy5kcmFnU3RhcnRQb2ludC54LGU9MDw9dGhpcy56b29tVHlwZS5pbmRleE9mKFwieFwiKSxmPTA8PXRoaXMuem9vbVR5cGUuaW5kZXhPZihcInlcIiksbD0hMTt0aGlzLnJlc2V0T3ZlcmxheWVkQ2FudmFzKCk7aWYoXCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCl2YXIgdD1mLGY9ZSxlPXQ7aWYodGhpcy5wYW5FbmFibGVkfHx0aGlzLnpvb21FbmFibGVkKXtpZih0aGlzLnBhbkVuYWJsZWQpZm9yKGU9Zj0wO2U8dGhpcy5fYXhlcy5sZW5ndGg7ZSsrKWM9dGhpcy5fYXhlc1tlXSxjLmxvZ2FyaXRobWljP2Mudmlld3BvcnRNaW5pbXVtPGMubWluaW11bT8oZj1jLm1pbmltdW0vYy52aWV3cG9ydE1pbmltdW0sYy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT1jLnZpZXdwb3J0TWluaW11bSpmLGMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW09Yy52aWV3cG9ydE1heGltdW0qXG5mLGw9ITApOmMudmlld3BvcnRNYXhpbXVtPmMubWF4aW11bSYmKGY9Yy52aWV3cG9ydE1heGltdW0vYy5tYXhpbXVtLGMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW09Yy52aWV3cG9ydE1pbmltdW0vZixjLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtPWMudmlld3BvcnRNYXhpbXVtL2YsbD0hMCk6Yy52aWV3cG9ydE1pbmltdW08Yy5taW5pbXVtPyhmPWMubWluaW11bS1jLnZpZXdwb3J0TWluaW11bSxjLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtPWMudmlld3BvcnRNaW5pbXVtK2YsYy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bT1jLnZpZXdwb3J0TWF4aW11bStmLGw9ITApOmMudmlld3BvcnRNYXhpbXVtPmMubWF4aW11bSYmKGY9Yy52aWV3cG9ydE1heGltdW0tYy5tYXhpbXVtLGMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW09Yy52aWV3cG9ydE1pbmltdW0tZixjLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtPVxuYy52aWV3cG9ydE1heGltdW0tZixsPSEwKTtlbHNlIGlmKCghZXx8MjxNYXRoLmFicyhiKSkmJighZnx8MjxNYXRoLmFicyhjKSkmJnRoaXMuem9vbUVuYWJsZWQpe2lmKCF0aGlzLmRyYWdTdGFydFBvaW50KXJldHVybjtjPWU/dGhpcy5kcmFnU3RhcnRQb2ludC54OnRoaXMucGxvdEFyZWEueDE7Yj1mP3RoaXMuZHJhZ1N0YXJ0UG9pbnQueTp0aGlzLnBsb3RBcmVhLnkxO2U9ZT9hOnRoaXMucGxvdEFyZWEueDI7Zj1mP2Q6dGhpcy5wbG90QXJlYS55MjsyPE1hdGguYWJzKGMtZSkmJjI8TWF0aC5hYnMoYi1mKSYmdGhpcy5fem9vbVBhblRvU2VsZWN0ZWRSZWdpb24oYyxiLGUsZikmJihsPSEwKX1sJiYodGhpcy5faWdub3JlTmV4dEV2ZW50PSEwLHRoaXMuX2Rpc3BhdGNoUmFuZ2VFdmVudChcInJhbmdlQ2hhbmdpbmdcIixcInpvb21cIiksdGhpcy5zdG9ja0NoYXJ0JiYodGhpcy5zdG9ja0NoYXJ0Lm5hdmlnYXRvciYmdGhpcy5zdG9ja0NoYXJ0Lm5hdmlnYXRvci5lbmFibGVkKSYmKHRoaXMuc3RvY2tDaGFydC5fcmFuZ2VFdmVudFBhcmFtZXRlcnx8XG4odGhpcy5zdG9ja0NoYXJ0Ll9yYW5nZUV2ZW50UGFyYW1ldGVyPXtzdG9ja0NoYXJ0OnRoaXMuc3RvY2tDaGFydCxzb3VyY2U6XCJjaGFydFwiLGluZGV4OnRoaXMuc3RvY2tDaGFydC5jaGFydHMuaW5kZXhPZih0aGlzKSxtaW5pbXVtOnRoaXMuc3RvY2tDaGFydC5zZXNzaW9uVmFyaWFibGVzLl9heGlzWE1pbixtYXhpbXVtOnRoaXMuc3RvY2tDaGFydC5zZXNzaW9uVmFyaWFibGVzLl9heGlzWE1heH0pLHRoaXMuc3RvY2tDaGFydC5fcmFuZ2VFdmVudFBhcmFtZXRlci50eXBlPVwicmFuZ2VDaGFuZ2luZ1wiLHRoaXMuc3RvY2tDaGFydC5kaXNwYXRjaEV2ZW50KFwicmFuZ2VDaGFuZ2luZ1wiLHRoaXMuc3RvY2tDaGFydC5fcmFuZ2VFdmVudFBhcmFtZXRlcix0aGlzLnN0b2NrQ2hhcnQpKSx0aGlzLnJlbmRlcigpLHRoaXMuX2Rpc3BhdGNoUmFuZ2VFdmVudChcInJhbmdlQ2hhbmdlZFwiLFwiem9vbVwiKSx0aGlzLnN0b2NrQ2hhcnQmJih0aGlzLnN0b2NrQ2hhcnQubmF2aWdhdG9yJiZ0aGlzLnN0b2NrQ2hhcnQubmF2aWdhdG9yLmVuYWJsZWQpJiZcbih0aGlzLnN0b2NrQ2hhcnQuX3JhbmdlRXZlbnRQYXJhbWV0ZXIudHlwZT1cInJhbmdlQ2hhbmdlZFwiLHRoaXMuc3RvY2tDaGFydC5kaXNwYXRjaEV2ZW50KFwicmFuZ2VDaGFuZ2VkXCIsdGhpcy5zdG9ja0NoYXJ0Ll9yYW5nZUV2ZW50UGFyYW1ldGVyLHRoaXMuc3RvY2tDaGFydCkpLGwmJih0aGlzLnpvb21FbmFibGVkJiZcIm5vbmVcIj09PXRoaXMuX3pvb21CdXR0b24uc3R5bGUuZGlzcGxheSkmJihNYSh0aGlzLl96b29tQnV0dG9uLHRoaXMuX3Jlc2V0QnV0dG9uKSxzYSh0aGlzLHRoaXMuX3pvb21CdXR0b24sXCJwYW5cIiksc2EodGhpcyx0aGlzLl9yZXNldEJ1dHRvbixcInJlc2V0XCIpKSl9fXRoaXMuaXNEcmFnPSExO2lmKFwibm9uZVwiIT09dGhpcy5wbG90SW5mby5heGlzUGxhY2VtZW50KXt0aGlzLnJlc2V0T3ZlcmxheWVkQ2FudmFzKCk7aWYodGhpcy5heGlzWCYmMDx0aGlzLmF4aXNYLmxlbmd0aClmb3IobD0wO2w8dGhpcy5heGlzWC5sZW5ndGg7bCsrKXRoaXMuYXhpc1hbbF0uY3Jvc3NoYWlyJiZcbnRoaXMuYXhpc1hbbF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1hbbF0ucmVuZGVyQ3Jvc3NoYWlyKGEsZCk7aWYodGhpcy5heGlzWDImJjA8dGhpcy5heGlzWDIubGVuZ3RoKWZvcihsPTA7bDx0aGlzLmF4aXNYMi5sZW5ndGg7bCsrKXRoaXMuYXhpc1gyW2xdLmNyb3NzaGFpciYmdGhpcy5heGlzWDJbbF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1gyW2xdLnJlbmRlckNyb3NzaGFpcihhLGQpO2lmKHRoaXMuYXhpc1kmJjA8dGhpcy5heGlzWS5sZW5ndGgpZm9yKGw9MDtsPHRoaXMuYXhpc1kubGVuZ3RoO2wrKyl0aGlzLmF4aXNZW2xdLmNyb3NzaGFpciYmdGhpcy5heGlzWVtsXS5jcm9zc2hhaXIuZW5hYmxlZCYmdGhpcy5heGlzWVtsXS5yZW5kZXJDcm9zc2hhaXIoYSxkKTtpZih0aGlzLmF4aXNZMiYmMDx0aGlzLmF4aXNZMi5sZW5ndGgpZm9yKGw9MDtsPHRoaXMuYXhpc1kyLmxlbmd0aDtsKyspdGhpcy5heGlzWTJbbF0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNZMltsXS5jcm9zc2hhaXIuZW5hYmxlZCYmXG50aGlzLmF4aXNZMltsXS5yZW5kZXJDcm9zc2hhaXIoYSxkKTtpZih0aGlzLmF4aXNYJiYwPHRoaXMuYXhpc1gubGVuZ3RoKWZvcihsPTA7bDx0aGlzLmF4aXNYLmxlbmd0aDtsKyspdGhpcy5heGlzWFtsXS5jcm9zc2hhaXImJnRoaXMuYXhpc1hbbF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1hbbF0uY3Jvc3NoYWlyLnJlbmRlckxhYmVsKCk7aWYodGhpcy5heGlzWDImJjA8dGhpcy5heGlzWDIubGVuZ3RoKWZvcihsPTA7bDx0aGlzLmF4aXNYMi5sZW5ndGg7bCsrKXRoaXMuYXhpc1gyW2xdLmNyb3NzaGFpciYmdGhpcy5heGlzWDJbbF0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1gyW2xdLmNyb3NzaGFpci5yZW5kZXJMYWJlbCgpO2lmKHRoaXMuYXhpc1kmJjA8dGhpcy5heGlzWS5sZW5ndGgpZm9yKGw9MDtsPHRoaXMuYXhpc1kubGVuZ3RoO2wrKyl0aGlzLmF4aXNZW2xdLmNyb3NzaGFpciYmdGhpcy5heGlzWVtsXS5jcm9zc2hhaXIuZW5hYmxlZCYmdGhpcy5heGlzWVtsXS5jcm9zc2hhaXIucmVuZGVyTGFiZWwoKTtcbmlmKHRoaXMuYXhpc1kyJiYwPHRoaXMuYXhpc1kyLmxlbmd0aClmb3IobD0wO2w8dGhpcy5heGlzWTIubGVuZ3RoO2wrKyl0aGlzLmF4aXNZMltsXS5jcm9zc2hhaXImJnRoaXMuYXhpc1kyW2xdLmNyb3NzaGFpci5lbmFibGVkJiZ0aGlzLmF4aXNZMltsXS5jcm9zc2hhaXIucmVuZGVyTGFiZWwoKX19O3AucHJvdG90eXBlLl9wbG90QXJlYU1vdXNlTW92ZT1mdW5jdGlvbihhLGQpe2lmKHRoaXMuaXNEcmFnJiZcIm5vbmVcIiE9PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCl7dmFyIGM9MCxiPTAsZT1jPW51bGwsZT0wPD10aGlzLnpvb21UeXBlLmluZGV4T2YoXCJ4XCIpLGY9MDw9dGhpcy56b29tVHlwZS5pbmRleE9mKFwieVwiKSxsPXRoaXM7XCJ4eVN3YXBwZWRcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCYmKGM9ZixmPWUsZT1jKTtjPXRoaXMuZHJhZ1N0YXJ0UG9pbnQueC1hO2I9dGhpcy5kcmFnU3RhcnRQb2ludC55LWQ7aWYoMjxNYXRoLmFicyhjKSYmOD5NYXRoLmFicyhjKSYmXG4odGhpcy5wYW5FbmFibGVkfHx0aGlzLnpvb21FbmFibGVkKSl7dGhpcy50b29sVGlwLmhpZGUoKTt0aGlzLnRvb2xUaXAmJnRoaXMudG9vbFRpcC5lbmFibGVkJiZ0aGlzLnRvb2xUaXAuZGlzcGF0Y2hFdmVudChcImhpZGRlblwiLHtjaGFydDp0aGlzLHRvb2xUaXA6dGhpcy50b29sVGlwfSx0aGlzLnRvb2xUaXApO2Zvcih2YXIgdD0wO3Q8dGhpcy5heGlzWC5sZW5ndGg7dCsrKXRoaXMuYXhpc1hbdF0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNYW3RdLmNyb3NzaGFpci5lbmFibGVkJiYodGhpcy5heGlzWFt0XS5jcm9zc2hhaXIuaGlkZSgpLHRoaXMuYXhpc1hbdF0uY3Jvc3NoYWlyLmRpc3BhdGNoRXZlbnQoXCJoaWRkZW5cIix7Y2hhcnQ6dGhpcyxheGlzOnRoaXMuYXhpc1hbdF0ub3B0aW9uc30sdGhpcy5heGlzWFt0XS5jcm9zc2hhaXIpKTtmb3IodD0wO3Q8dGhpcy5heGlzWDIubGVuZ3RoO3QrKyl0aGlzLmF4aXNYMlt0XS5jcm9zc2hhaXImJnRoaXMuYXhpc1gyW3RdLmNyb3NzaGFpci5lbmFibGVkJiZcbih0aGlzLmF4aXNYMlt0XS5jcm9zc2hhaXIuaGlkZSgpLHRoaXMuYXhpc1gyW3RdLmNyb3NzaGFpci5kaXNwYXRjaEV2ZW50KFwiaGlkZGVuXCIse2NoYXJ0OnRoaXMsYXhpczp0aGlzLmF4aXNYMlt0XS5vcHRpb25zfSx0aGlzLmF4aXNYMlt0XS5jcm9zc2hhaXIpKTtmb3IodD0wO3Q8dGhpcy5heGlzWS5sZW5ndGg7dCsrKXRoaXMuYXhpc1lbdF0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNZW3RdLmNyb3NzaGFpci5lbmFibGVkJiYodGhpcy5heGlzWVt0XS5jcm9zc2hhaXIuaGlkZSgpLHRoaXMuYXhpc1lbdF0uY3Jvc3NoYWlyLmRpc3BhdGNoRXZlbnQoXCJoaWRkZW5cIix7Y2hhcnQ6dGhpcyxheGlzOnRoaXMuYXhpc1lbdF0ub3B0aW9uc30sdGhpcy5heGlzWVt0XS5jcm9zc2hhaXIpKTtmb3IodD0wO3Q8dGhpcy5heGlzWTIubGVuZ3RoO3QrKyl0aGlzLmF4aXNZMlt0XS5jcm9zc2hhaXImJnRoaXMuYXhpc1kyW3RdLmNyb3NzaGFpci5lbmFibGVkJiYodGhpcy5heGlzWTJbdF0uY3Jvc3NoYWlyLmhpZGUoKSxcbnRoaXMuYXhpc1kyW3RdLmNyb3NzaGFpci5kaXNwYXRjaEV2ZW50KFwiaGlkZGVuXCIse2NoYXJ0OnRoaXMsYXhpczp0aGlzLmF4aXNZMlt0XS5vcHRpb25zfSx0aGlzLmF4aXNZMlt0XS5jcm9zc2hhaXIpKX1lbHNlIHRoaXMucGFuRW5hYmxlZHx8dGhpcy56b29tRW5hYmxlZHx8dGhpcy50b29sVGlwLm1vdXNlTW92ZUhhbmRsZXIoYSxkKTtpZigoIWV8fDI8TWF0aC5hYnMoYyl8fCFmfHwyPE1hdGguYWJzKGIpKSYmKHRoaXMucGFuRW5hYmxlZHx8dGhpcy56b29tRW5hYmxlZCkpaWYodGhpcy5wYW5FbmFibGVkKWU9e3gxOmU/dGhpcy5wbG90QXJlYS54MStjOnRoaXMucGxvdEFyZWEueDEseTE6Zj90aGlzLnBsb3RBcmVhLnkxK2I6dGhpcy5wbG90QXJlYS55MSx4MjplP3RoaXMucGxvdEFyZWEueDIrYzp0aGlzLnBsb3RBcmVhLngyLHkyOmY/dGhpcy5wbG90QXJlYS55MitiOnRoaXMucGxvdEFyZWEueTJ9LGNsZWFyVGltZW91dChsLl9wYW5UaW1lcklkKSxsLl9wYW5UaW1lcklkPXNldFRpbWVvdXQoZnVuY3Rpb24oYixcbmMsZSxmKXtyZXR1cm4gZnVuY3Rpb24oKXtsLl96b29tUGFuVG9TZWxlY3RlZFJlZ2lvbihiLGMsZSxmLCEwKSYmKGwuX2Rpc3BhdGNoUmFuZ2VFdmVudChcInJhbmdlQ2hhbmdpbmdcIixcInBhblwiKSxsLnN0b2NrQ2hhcnQmJihsLnN0b2NrQ2hhcnQubmF2aWdhdG9yJiZsLnN0b2NrQ2hhcnQubmF2aWdhdG9yLmVuYWJsZWQpJiYobC5zdG9ja0NoYXJ0Ll9yYW5nZUV2ZW50UGFyYW1ldGVyLnR5cGU9XCJyYW5nZUNoYW5naW5nXCIsbC5zdG9ja0NoYXJ0LmRpc3BhdGNoRXZlbnQoXCJyYW5nZUNoYW5naW5nXCIsbC5zdG9ja0NoYXJ0Ll9yYW5nZUV2ZW50UGFyYW1ldGVyLGwuc3RvY2tDaGFydCkpLGwucmVuZGVyKCksbC5fZGlzcGF0Y2hSYW5nZUV2ZW50KFwicmFuZ2VDaGFuZ2VkXCIsXCJwYW5cIiksbC5zdG9ja0NoYXJ0JiYobC5zdG9ja0NoYXJ0Lm5hdmlnYXRvciYmbC5zdG9ja0NoYXJ0Lm5hdmlnYXRvci5lbmFibGVkKSYmKGwuc3RvY2tDaGFydC5fcmFuZ2VFdmVudFBhcmFtZXRlci50eXBlPVwicmFuZ2VDaGFuZ2VkXCIsXG5sLnN0b2NrQ2hhcnQuZGlzcGF0Y2hFdmVudChcInJhbmdlQ2hhbmdlZFwiLGwuc3RvY2tDaGFydC5fcmFuZ2VFdmVudFBhcmFtZXRlcixsLnN0b2NrQ2hhcnQpKSxsLmRyYWdTdGFydFBvaW50Lng9YSxsLmRyYWdTdGFydFBvaW50Lnk9ZCl9fShlLngxLGUueTEsZS54MixlLnkyKSwwKTtlbHNlIGlmKHRoaXMuem9vbUVuYWJsZWQpe3RoaXMucmVzZXRPdmVybGF5ZWRDYW52YXMoKTtjPXRoaXMub3ZlcmxhaWRDYW52YXNDdHguZ2xvYmFsQWxwaGE7dGhpcy5vdmVybGFpZENhbnZhc0N0eC5maWxsU3R5bGU9XCIjQTg5ODk2XCI7dmFyIGI9ZT90aGlzLmRyYWdTdGFydFBvaW50Lng6dGhpcy5wbG90QXJlYS54MSx0PWY/dGhpcy5kcmFnU3RhcnRQb2ludC55OnRoaXMucGxvdEFyZWEueTEsQz1lP2EtdGhpcy5kcmFnU3RhcnRQb2ludC54OnRoaXMucGxvdEFyZWEueDItdGhpcy5wbG90QXJlYS54MSxrPWY/ZC10aGlzLmRyYWdTdGFydFBvaW50Lnk6dGhpcy5wbG90QXJlYS55Mi10aGlzLnBsb3RBcmVhLnkxO1xudGhpcy52YWxpZGF0ZVJlZ2lvbihiLHQsZT9hOnRoaXMucGxvdEFyZWEueDItdGhpcy5wbG90QXJlYS54MSxmP2Q6dGhpcy5wbG90QXJlYS55Mi10aGlzLnBsb3RBcmVhLnkxLFwieHlcIiE9PXRoaXMuem9vbVR5cGUpLmlzVmFsaWQmJih0aGlzLnJlc2V0T3ZlcmxheWVkQ2FudmFzKCksdGhpcy5vdmVybGFpZENhbnZhc0N0eC5maWxsU3R5bGU9XCIjOTlCMkI1XCIpO3RoaXMub3ZlcmxhaWRDYW52YXNDdHguZ2xvYmFsQWxwaGE9MC43O3RoaXMub3ZlcmxhaWRDYW52YXNDdHguZmlsbFJlY3QoYix0LEMsayk7dGhpcy5vdmVybGFpZENhbnZhc0N0eC5nbG9iYWxBbHBoYT1jfX1lbHNlIGlmKHRoaXMudG9vbFRpcC5tb3VzZU1vdmVIYW5kbGVyKGEsZCksXCJub25lXCIhPT10aGlzLnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpe2lmKHRoaXMuYXhpc1gmJjA8dGhpcy5heGlzWC5sZW5ndGgpZm9yKGU9MDtlPHRoaXMuYXhpc1gubGVuZ3RoO2UrKyl0aGlzLmF4aXNYW2VdLmNyb3NzaGFpciYmdGhpcy5heGlzWFtlXS5jcm9zc2hhaXIuZW5hYmxlZCYmXG50aGlzLmF4aXNYW2VdLnJlbmRlckNyb3NzaGFpcihhLGQpO2lmKHRoaXMuYXhpc1gyJiYwPHRoaXMuYXhpc1gyLmxlbmd0aClmb3IoZT0wO2U8dGhpcy5heGlzWDIubGVuZ3RoO2UrKyl0aGlzLmF4aXNYMltlXS5jcm9zc2hhaXImJnRoaXMuYXhpc1gyW2VdLmNyb3NzaGFpci5lbmFibGVkJiZ0aGlzLmF4aXNYMltlXS5yZW5kZXJDcm9zc2hhaXIoYSxkKTtpZih0aGlzLmF4aXNZJiYwPHRoaXMuYXhpc1kubGVuZ3RoKWZvcihlPTA7ZTx0aGlzLmF4aXNZLmxlbmd0aDtlKyspdGhpcy5heGlzWVtlXS5jcm9zc2hhaXImJnRoaXMuYXhpc1lbZV0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1lbZV0ucmVuZGVyQ3Jvc3NoYWlyKGEsZCk7aWYodGhpcy5heGlzWTImJjA8dGhpcy5heGlzWTIubGVuZ3RoKWZvcihlPTA7ZTx0aGlzLmF4aXNZMi5sZW5ndGg7ZSsrKXRoaXMuYXhpc1kyW2VdLmNyb3NzaGFpciYmdGhpcy5heGlzWTJbZV0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1kyW2VdLnJlbmRlckNyb3NzaGFpcihhLFxuZCk7aWYodGhpcy5heGlzWCYmMDx0aGlzLmF4aXNYLmxlbmd0aClmb3IoZT0wO2U8dGhpcy5heGlzWC5sZW5ndGg7ZSsrKXRoaXMuYXhpc1hbZV0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNYW2VdLmNyb3NzaGFpci5lbmFibGVkJiZ0aGlzLmF4aXNYW2VdLmNyb3NzaGFpci5yZW5kZXJMYWJlbCgpO2lmKHRoaXMuYXhpc1gyJiYwPHRoaXMuYXhpc1gyLmxlbmd0aClmb3IoZT0wO2U8dGhpcy5heGlzWDIubGVuZ3RoO2UrKyl0aGlzLmF4aXNYMltlXS5jcm9zc2hhaXImJnRoaXMuYXhpc1gyW2VdLmNyb3NzaGFpci5lbmFibGVkJiZ0aGlzLmF4aXNYMltlXS5jcm9zc2hhaXIucmVuZGVyTGFiZWwoKTtpZih0aGlzLmF4aXNZJiYwPHRoaXMuYXhpc1kubGVuZ3RoKWZvcihlPTA7ZTx0aGlzLmF4aXNZLmxlbmd0aDtlKyspdGhpcy5heGlzWVtlXS5jcm9zc2hhaXImJnRoaXMuYXhpc1lbZV0uY3Jvc3NoYWlyLmVuYWJsZWQmJnRoaXMuYXhpc1lbZV0uY3Jvc3NoYWlyLnJlbmRlckxhYmVsKCk7aWYodGhpcy5heGlzWTImJlxuMDx0aGlzLmF4aXNZMi5sZW5ndGgpZm9yKGU9MDtlPHRoaXMuYXhpc1kyLmxlbmd0aDtlKyspdGhpcy5heGlzWTJbZV0uY3Jvc3NoYWlyJiZ0aGlzLmF4aXNZMltlXS5jcm9zc2hhaXIuZW5hYmxlZCYmdGhpcy5heGlzWTJbZV0uY3Jvc3NoYWlyLnJlbmRlckxhYmVsKCl9fTtwLnByb3RvdHlwZS5fem9vbVBhblRvU2VsZWN0ZWRSZWdpb249ZnVuY3Rpb24oYSxkLGMsYixlKXthPXRoaXMudmFsaWRhdGVSZWdpb24oYSxkLGMsYixlKTtkPWEuYXhlc1dpdGhWYWxpZFJhbmdlO2M9YS5heGVzUmFuZ2VzO2lmKGEuaXNWYWxpZClmb3IoYj0wO2I8ZC5sZW5ndGg7YisrKWU9Y1tiXSxkW2JdLnNldFZpZXdQb3J0UmFuZ2UoZS52YWwxLGUudmFsMiksdGhpcy5zeW5jQ2hhcnRzJiZcInlcIiE9dGhpcy56b29tVHlwZSYmdGhpcy5zeW5jQ2hhcnRzKGUudmFsMSxlLnZhbDIpLHRoaXMuc3RvY2tDaGFydCYmKHRoaXMuc3RvY2tDaGFydC5fcmFuZ2VFdmVudFBhcmFtZXRlcj17c3RvY2tDaGFydDp0aGlzLnN0b2NrQ2hhcnQsXG5zb3VyY2U6XCJjaGFydFwiLGluZGV4OnRoaXMuc3RvY2tDaGFydC5jaGFydHMuaW5kZXhPZih0aGlzKSxtaW5pbXVtOmUudmFsMSxtYXhpbXVtOmUudmFsMn0pO3JldHVybiBhLmlzVmFsaWR9O3AucHJvdG90eXBlLnZhbGlkYXRlUmVnaW9uPWZ1bmN0aW9uKGEsZCxjLGIsZSl7ZT1lfHwhMTtmb3IodmFyIGY9MDw9dGhpcy56b29tVHlwZS5pbmRleE9mKFwieFwiKSxsPTA8PXRoaXMuem9vbVR5cGUuaW5kZXhPZihcInlcIiksdD0hMSxDPVtdLGs9W10sbT1bXSxuPTA7bjx0aGlzLl9heGVzLmxlbmd0aDtuKyspKFwiYXhpc1hcIj09PXRoaXMuX2F4ZXNbbl0udHlwZSYmZnx8XCJheGlzWVwiPT09dGhpcy5fYXhlc1tuXS50eXBlJiZsKSYmay5wdXNoKHRoaXMuX2F4ZXNbbl0pO2ZvcihsPTA7bDxrLmxlbmd0aDtsKyspe3ZhciBuPWtbbF0sZj0hMSxxPW4uY29udmVydFBpeGVsVG9WYWx1ZSh7eDphLHk6ZH0pLGc9bi5jb252ZXJ0UGl4ZWxUb1ZhbHVlKHt4OmMseTpifSk7aWYocT5nKXZhciBzPWcsZz1xLFxucT1zO2lmKG4uc2NhbGVCcmVha3MpZm9yKHM9MDshZiYmczxuLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aDtzKyspZj1uLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW3NdLnN0YXJ0VmFsdWU8PXEmJm4uc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3Nbc10uZW5kVmFsdWU+PWc7aWYoaXNGaW5pdGUobi5kYXRhSW5mby5taW5EaWZmKSlpZihzPW4uZ2V0QXBwYXJlbnREaWZmZXJlbmNlKHEsZyxudWxsLCEwKSwhKGZ8fCEodGhpcy5wYW5FbmFibGVkJiZuLnNjYWxlQnJlYWtzJiZuLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCkmJihuLmxvZ2FyaXRobWljJiZzPE1hdGgucG93KG4uZGF0YUluZm8ubWluRGlmZiwzKXx8IW4ubG9nYXJpdGhtaWMmJnM8MypNYXRoLmFicyhuLmRhdGFJbmZvLm1pbkRpZmYpKXx8cTxuLm1pbmltdW18fGc+bi5tYXhpbXVtKSlDLnB1c2gobiksbS5wdXNoKHt2YWwxOnEsdmFsMjpnfSksdD0hMDtlbHNlIGlmKCFlKXt0PSExO1xuYnJlYWt9fXJldHVybntpc1ZhbGlkOnQsYXhlc1dpdGhWYWxpZFJhbmdlOkMsYXhlc1JhbmdlczptfX07cC5wcm90b3R5cGUucHJlcGFyZVBsb3RBcmVhPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wbG90QXJlYTshdyYmKDA8YS54MXx8MDxhLnkxKSYmYS5jdHgudHJhbnNsYXRlKGEueDEsYS55MSk7aWYoKHRoaXMuYXhpc1hbMF18fHRoaXMuYXhpc1gyWzBdKSYmKHRoaXMuYXhpc1lbMF18fHRoaXMuYXhpc1kyWzBdKSl7dmFyIGQ9dGhpcy5heGlzWFswXT90aGlzLmF4aXNYWzBdLmxpbmVDb29yZGluYXRlczp0aGlzLmF4aXNYMlswXS5saW5lQ29vcmRpbmF0ZXM7aWYodGhpcy5heGlzWSYmMDx0aGlzLmF4aXNZLmxlbmd0aCYmdGhpcy5heGlzWVswXSl7dmFyIGM9dGhpcy5heGlzWVswXTthLngxPWQueDE8ZC54Mj9kLngxOmMubGluZUNvb3JkaW5hdGVzLngxO2EueTE9ZC55MTxjLmxpbmVDb29yZGluYXRlcy55MT9kLnkxOmMubGluZUNvb3JkaW5hdGVzLnkxO2EueDI9ZC54Mj5jLmxpbmVDb29yZGluYXRlcy54Mj9cbmQueDI6Yy5saW5lQ29vcmRpbmF0ZXMueDI7YS55Mj1kLnkyPmQueTE/ZC55MjpjLmxpbmVDb29yZGluYXRlcy55MjthLndpZHRoPWEueDItYS54MTthLmhlaWdodD1hLnkyLWEueTF9dGhpcy5heGlzWTImJjA8dGhpcy5heGlzWTIubGVuZ3RoJiZ0aGlzLmF4aXNZMlswXSYmKGM9dGhpcy5heGlzWTJbMF0sYS54MT1kLngxPGQueDI/ZC54MTpjLmxpbmVDb29yZGluYXRlcy54MSxhLnkxPWQueTE8Yy5saW5lQ29vcmRpbmF0ZXMueTE/ZC55MTpjLmxpbmVDb29yZGluYXRlcy55MSxhLngyPWQueDI+Yy5saW5lQ29vcmRpbmF0ZXMueDI/ZC54MjpjLmxpbmVDb29yZGluYXRlcy54MixhLnkyPWQueTI+ZC55MT9kLnkyOmMubGluZUNvb3JkaW5hdGVzLnkyLGEud2lkdGg9YS54Mi1hLngxLGEuaGVpZ2h0PWEueTItYS55MSl9ZWxzZSBkPXRoaXMubGF5b3V0TWFuYWdlci5nZXRGcmVlU3BhY2UoKSxhLngxPWQueDEsYS54Mj1kLngyLGEueTE9ZC55MSxhLnkyPWQueTIsYS53aWR0aD1kLndpZHRoLFxuYS5oZWlnaHQ9ZC5oZWlnaHQ7d3x8KGEuY2FudmFzLndpZHRoPWEud2lkdGgsYS5jYW52YXMuaGVpZ2h0PWEuaGVpZ2h0LGEuY2FudmFzLnN0eWxlLmxlZnQ9YS54MStcInB4XCIsYS5jYW52YXMuc3R5bGUudG9wPWEueTErXCJweFwiLCgwPGEueDF8fDA8YS55MSkmJmEuY3R4LnRyYW5zbGF0ZSgtYS54MSwtYS55MSkpO2EubGF5b3V0TWFuYWdlcj1uZXcgRmEoYS54MSxhLnkxLGEueDIsYS55MiwyKX07cC5wcm90b3R5cGUucmVuZGVySW5kZXhMYWJlbHM9ZnVuY3Rpb24oYSl7dmFyIGQ9YXx8dGhpcy5wbG90QXJlYS5jdHgsYz10aGlzLnBsb3RBcmVhLGI9MCxlPTAsZj0wLGw9Zj1lPTAsdD0wLEM9Yj0wLGs9MDtmb3IoYT0wO2E8dGhpcy5faW5kZXhMYWJlbHMubGVuZ3RoO2ErKyl7dmFyIG09dGhpcy5faW5kZXhMYWJlbHNbYV0sbj1tLmNoYXJ0VHlwZS50b0xvd2VyQ2FzZSgpLHEsZyxsPW1hKFwiaW5kZXhMYWJlbEZvbnRDb2xvclwiLG0uZGF0YVBvaW50LG0uZGF0YVNlcmllcykscz1tYShcImluZGV4TGFiZWxGb250U2l6ZVwiLFxubS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzKSx0PW1hKFwiaW5kZXhMYWJlbEZvbnRGYW1pbHlcIixtLmRhdGFQb2ludCxtLmRhdGFTZXJpZXMpLEM9bWEoXCJpbmRleExhYmVsRm9udFN0eWxlXCIsbS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzKSxrPW1hKFwiaW5kZXhMYWJlbEZvbnRXZWlnaHRcIixtLmRhdGFQb2ludCxtLmRhdGFTZXJpZXMpLGg9bWEoXCJpbmRleExhYmVsQmFja2dyb3VuZENvbG9yXCIsbS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzKTtxPW1hKFwiaW5kZXhMYWJlbE1heFdpZHRoXCIsbS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzKTtnPW1hKFwiaW5kZXhMYWJlbFdyYXBcIixtLmRhdGFQb2ludCxtLmRhdGFTZXJpZXMpO3ZhciBiYT1tYShcImluZGV4TGFiZWxMaW5lRGFzaFR5cGVcIixtLmRhdGFQb2ludCxtLmRhdGFTZXJpZXMpLHU9bWEoXCJpbmRleExhYmVsTGluZUNvbG9yXCIsbS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzKSxwPXIobS5kYXRhUG9pbnQuaW5kZXhMYWJlbExpbmVUaGlja25lc3MpP1xucihtLmRhdGFTZXJpZXMub3B0aW9ucy5pbmRleExhYmVsTGluZVRoaWNrbmVzcyk/MDptLmRhdGFTZXJpZXMub3B0aW9ucy5pbmRleExhYmVsTGluZVRoaWNrbmVzczptLmRhdGFQb2ludC5pbmRleExhYmVsTGluZVRoaWNrbmVzcyxiPTA8cD9NYXRoLm1pbigxMCwoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudD90aGlzLnBsb3RBcmVhLmhlaWdodDp0aGlzLnBsb3RBcmVhLndpZHRoKTw8MCk6MCx4PXtwZXJjZW50Om51bGwsdG90YWw6bnVsbH0sej1udWxsO2lmKDA8PW0uZGF0YVNlcmllcy50eXBlLmluZGV4T2YoXCJzdGFja2VkXCIpfHxcInBpZVwiPT09bS5kYXRhU2VyaWVzLnR5cGV8fFwiZG91Z2hudXRcIj09PW0uZGF0YVNlcmllcy50eXBlKXg9dGhpcy5nZXRQZXJjZW50QW5kVG90YWwobS5kYXRhU2VyaWVzLG0uZGF0YVBvaW50KTtpZihtLmRhdGFTZXJpZXMuaW5kZXhMYWJlbEZvcm1hdHRlcnx8bS5kYXRhUG9pbnQuaW5kZXhMYWJlbEZvcm1hdHRlcil6PXtjaGFydDp0aGlzLFxuZGF0YVNlcmllczptLmRhdGFTZXJpZXMsZGF0YVBvaW50Om0uZGF0YVBvaW50LGluZGV4Om0uaW5kZXhLZXl3b3JkLHRvdGFsOngudG90YWwscGVyY2VudDp4LnBlcmNlbnR9O3ZhciBIPW0uZGF0YVBvaW50LmluZGV4TGFiZWxGb3JtYXR0ZXI/bS5kYXRhUG9pbnQuaW5kZXhMYWJlbEZvcm1hdHRlcih6KTptLmRhdGFQb2ludC5pbmRleExhYmVsP3RoaXMucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKG0uZGF0YVBvaW50LmluZGV4TGFiZWwsbS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzLG51bGwsbS5pbmRleEtleXdvcmQpOm0uZGF0YVNlcmllcy5pbmRleExhYmVsRm9ybWF0dGVyP20uZGF0YVNlcmllcy5pbmRleExhYmVsRm9ybWF0dGVyKHopOm0uZGF0YVNlcmllcy5pbmRleExhYmVsP3RoaXMucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKG0uZGF0YVNlcmllcy5pbmRleExhYmVsLG0uZGF0YVBvaW50LG0uZGF0YVNlcmllcyxudWxsLG0uaW5kZXhLZXl3b3JkKTpudWxsO2lmKG51bGwhPT1cbkgmJlwiXCIhPT1IKXt2YXIgeD1tYShcImluZGV4TGFiZWxQbGFjZW1lbnRcIixtLmRhdGFQb2ludCxtLmRhdGFTZXJpZXMpLHo9bWEoXCJpbmRleExhYmVsT3JpZW50YXRpb25cIixtLmRhdGFQb2ludCxtLmRhdGFTZXJpZXMpLEQ9bWEoXCJpbmRleExhYmVsVGV4dEFsaWduXCIsbS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzKSx2PW0uZGlyZWN0aW9uLGU9bS5kYXRhU2VyaWVzLmF4aXNYLGY9bS5kYXRhU2VyaWVzLmF4aXNZLEE9ITEsaD1uZXcgamEoZCx7eDowLHk6MCxtYXhXaWR0aDpxP3E6MC41KnRoaXMud2lkdGgsbWF4SGVpZ2h0Omc/NSpzOjEuNSpzLGFuZ2xlOlwiaG9yaXpvbnRhbFwiPT09ej8wOi05MCx0ZXh0OkgscGFkZGluZzowLGJhY2tncm91bmRDb2xvcjpoLHRleHRBbGlnbjpELGZvbnRTaXplOnMsZm9udEZhbWlseTp0LGZvbnRXZWlnaHQ6ayxmb250Q29sb3I6bCxmb250U3R5bGU6Qyx0ZXh0QmFzZWxpbmU6XCJtaWRkbGVcIn0pO2gubWVhc3VyZVRleHQoKTttLmRhdGFTZXJpZXMuaW5kZXhMYWJlbE1heFdpZHRoPVxuaC5tYXhXaWR0aDtpZihcInN0YWNrZWRhcmVhMTAwXCI9PT1uKXtpZihtLnBvaW50Lng8Yy54MXx8bS5wb2ludC54PmMueDJ8fG0ucG9pbnQueTxjLnkxLTF8fG0ucG9pbnQueT5jLnkyKzEpY29udGludWV9ZWxzZSBpZihcInJhbmdlYXJlYVwiPT09bnx8XCJyYW5nZXNwbGluZWFyZWFcIj09PW4pe2lmKG0uZGF0YVBvaW50Lng8ZS52aWV3cG9ydE1pbmltdW18fG0uZGF0YVBvaW50Lng+ZS52aWV3cG9ydE1heGltdW18fE1hdGgubWF4LmFwcGx5KG51bGwsbS5kYXRhUG9pbnQueSk8Zi52aWV3cG9ydE1pbmltdW18fE1hdGgubWluLmFwcGx5KG51bGwsbS5kYXRhUG9pbnQueSk+Zi52aWV3cG9ydE1heGltdW0pY29udGludWV9ZWxzZSBpZigwPD1uLmluZGV4T2YoXCJsaW5lXCIpfHwwPD1uLmluZGV4T2YoXCJhcmVhXCIpfHwwPD1uLmluZGV4T2YoXCJidWJibGVcIil8fDA8PW4uaW5kZXhPZihcInNjYXR0ZXJcIikpe2lmKG0uZGF0YVBvaW50Lng8ZS52aWV3cG9ydE1pbmltdW18fG0uZGF0YVBvaW50Lng+ZS52aWV3cG9ydE1heGltdW18fFxubS5kYXRhUG9pbnQueTxmLnZpZXdwb3J0TWluaW11bXx8bS5kYXRhUG9pbnQueT5mLnZpZXdwb3J0TWF4aW11bSljb250aW51ZX1lbHNlIGlmKDA8PW4uaW5kZXhPZihcImNvbHVtblwiKXx8XCJ3YXRlcmZhbGxcIj09PW58fFwiZXJyb3JcIj09PW4mJiFtLmF4aXNTd2FwcGVkKXtpZihtLmRhdGFQb2ludC54PGUudmlld3BvcnRNaW5pbXVtfHxtLmRhdGFQb2ludC54PmUudmlld3BvcnRNYXhpbXVtfHxtLmJvdW5kcy55MT5jLnkyfHxtLmJvdW5kcy55MjxjLnkxKWNvbnRpbnVlfWVsc2UgaWYoMDw9bi5pbmRleE9mKFwiYmFyXCIpfHxcImVycm9yXCI9PT1uKXtpZihtLmRhdGFQb2ludC54PGUudmlld3BvcnRNaW5pbXVtfHxtLmRhdGFQb2ludC54PmUudmlld3BvcnRNYXhpbXVtfHxtLmJvdW5kcy54MT5jLngyfHxtLmJvdW5kcy54MjxjLngxKWNvbnRpbnVlfWVsc2UgaWYoXCJjYW5kbGVzdGlja1wiPT09bnx8XCJvaGxjXCI9PT1uKXtpZihtLmRhdGFQb2ludC54PGUudmlld3BvcnRNaW5pbXVtfHxtLmRhdGFQb2ludC54PlxuZS52aWV3cG9ydE1heGltdW18fE1hdGgubWF4LmFwcGx5KG51bGwsbS5kYXRhUG9pbnQueSk8Zi52aWV3cG9ydE1pbmltdW18fE1hdGgubWluLmFwcGx5KG51bGwsbS5kYXRhUG9pbnQueSk+Zi52aWV3cG9ydE1heGltdW0pY29udGludWV9ZWxzZSBpZihtLmRhdGFQb2ludC54PGUudmlld3BvcnRNaW5pbXVtfHxtLmRhdGFQb2ludC54PmUudmlld3BvcnRNYXhpbXVtKWNvbnRpbnVlO2w9dD0yO1wiaG9yaXpvbnRhbFwiPT09ej8oQz1oLndpZHRoLGs9aC5oZWlnaHQpOihrPWgud2lkdGgsQz1oLmhlaWdodCk7aWYoXCJub3JtYWxcIj09PXRoaXMucGxvdEluZm8uYXhpc1BsYWNlbWVudCl7aWYoMDw9bi5pbmRleE9mKFwibGluZVwiKXx8MDw9bi5pbmRleE9mKFwiYXJlYVwiKSl4PVwiYXV0b1wiLHQ9NDtlbHNlIGlmKDA8PW4uaW5kZXhPZihcInN0YWNrZWRcIikpXCJhdXRvXCI9PT14JiYoeD1cImluc2lkZVwiKTtlbHNlIGlmKFwiYnViYmxlXCI9PT1ufHxcInNjYXR0ZXJcIj09PW4peD1cImluc2lkZVwiO3E9bS5wb2ludC54LVxuKFwiaG9yaXpvbnRhbFwiPT09ej9DLzI6Qy8yLXMvMik7XCJpbnNpZGVcIiE9PXg/KGU9Yy55MSxmPWMueTIsMDx2PyhnPW0ucG9pbnQueSsoXCJob3Jpem9udGFsXCI9PT16P3MvMjowKS1rLXQtYixnPGUmJihnPVwiYXV0b1wiPT09eD9NYXRoLm1heChtLnBvaW50LnksZSkrcy8yK3Q6ZStzLzIrdCxBPWcraz5tLnBvaW50LnkpKTooZz1tLnBvaW50Lnkrcy8yK3QrYixnPmYtayYmKGc9XCJhdXRvXCI9PT14P01hdGgubWluKG0ucG9pbnQueSxmKStzLzItay10OmYrcy8yLWssQT1nPG0ucG9pbnQueSkpKTooZT1NYXRoLm1heChtLmJvdW5kcy55MSxjLnkxKSxmPU1hdGgubWluKG0uYm91bmRzLnkyLGMueTItaytzLzIpLGI9MDw9bi5pbmRleE9mKFwicmFuZ2VcIil8fFwiZXJyb3JcIj09PW4/MDx2P01hdGgubWF4KG0uYm91bmRzLnkxLGMueTEpK3MvMit0Ok1hdGgubWluKG0uYm91bmRzLnkyLGMueTIpK3MvMi1rK3Q6KE1hdGgubWF4KG0uYm91bmRzLnkxLGMueTEpK01hdGgubWluKG0uYm91bmRzLnkyLGMueTIpKS9cbjItay8yK3MvMisoXCJob3Jpem9udGFsXCI9PT16P3Q6MCksMDx2PyhnPU1hdGgubWF4KG0ucG9pbnQueSxiKSxnPGUmJihcImJ1YmJsZVwiPT09bnx8XCJzY2F0dGVyXCI9PT1uKSYmKGc9TWF0aC5tYXgobS5wb2ludC55LWstdCxjLnkxK3QpKSk6KGc9TWF0aC5taW4obS5wb2ludC55LGIpLGc+Zi1rLXQmJihcImJ1YmJsZVwiPT09bnx8XCJzY2F0dGVyXCI9PT1uKSYmKGc9TWF0aC5taW4obS5wb2ludC55K3QsYy55Mi1rLXQpKSksZz1NYXRoLm1pbihnLGYpKX1lbHNlIDA8PW4uaW5kZXhPZihcImxpbmVcIil8fDA8PW4uaW5kZXhPZihcImFyZWFcIil8fDA8PW4uaW5kZXhPZihcInNjYXR0ZXJcIik/KHg9XCJhdXRvXCIsbD00KTowPD1uLmluZGV4T2YoXCJzdGFja2VkXCIpP1wiYXV0b1wiPT09eCYmKHg9XCJpbnNpZGVcIik6XCJidWJibGVcIj09PW4mJih4PVwiaW5zaWRlXCIpLGc9bS5wb2ludC55K3MvMi1rLzIrdCxcImluc2lkZVwiIT09eD8oZT1jLngxLGY9Yy54MiwwPnY/KHE9bS5wb2ludC54LShcImhvcml6b250YWxcIj09PXo/XG5DOkMtcy8yKS1sLWIscTxlJiYocT1cImF1dG9cIj09PXg/TWF0aC5tYXgobS5wb2ludC54LGUpK2w6ZStsLEE9cStDPm0ucG9pbnQueCkpOihxPW0ucG9pbnQueCsoXCJob3Jpem9udGFsXCI9PT16PzA6cy8yKStsK2IscT5mLUMtbC1iJiYocT1cImF1dG9cIj09PXg/TWF0aC5taW4obS5wb2ludC54LGYpLShcImhvcml6b250YWxcIj09PXo/QzpDLzIpLWw6Zi1DLWwsQT1xPG0ucG9pbnQueCkpKTooZT1NYXRoLm1heChtLmJvdW5kcy54MSxjLngxKSxNYXRoLm1pbihtLmJvdW5kcy54MixjLngyKSxiPTA8PW4uaW5kZXhPZihcInJhbmdlXCIpfHxcImVycm9yXCI9PT1uPzA+dj9NYXRoLm1heChtLmJvdW5kcy54MSxjLngxKStzLzIrbDpNYXRoLm1pbihtLmJvdW5kcy54MixjLngyKS1DLzItbCsoXCJob3Jpem9udGFsXCI9PT16PzA6cy8yKTooTWF0aC5tYXgobS5ib3VuZHMueDEsYy54MSkrTWF0aC5taW4obS5ib3VuZHMueDIsYy54MikpLzIrKFwiaG9yaXpvbnRhbFwiPT09ej8wOnMvMikscT0wPnY/TWF0aC5tYXgobS5wb2ludC54LFxuYiktKFwiaG9yaXpvbnRhbFwiPT09ej9DLzI6MCk6TWF0aC5taW4obS5wb2ludC54LGIpLUMvMixxPU1hdGgubWF4KHEsZSkpO1widmVydGljYWxcIj09PXomJihnKz1rLXMvMik7aC54PXE7aC55PWc7aC5yZW5kZXIoITApO3AmJihcImluc2lkZVwiIT09eCYmKDA+bi5pbmRleE9mKFwiYmFyXCIpJiYoXCJlcnJvclwiIT09bnx8IW0uYXhpc1N3YXBwZWQpJiZtLnBvaW50Lng+Yy54MSYmbS5wb2ludC54PGMueDJ8fCFBKSYmKDA+bi5pbmRleE9mKFwiY29sdW1uXCIpJiYoXCJlcnJvclwiIT09bnx8bS5heGlzU3dhcHBlZCkmJm0ucG9pbnQueT5jLnkxJiZtLnBvaW50Lnk8Yy55Mnx8IUEpKSYmKGQubGluZVdpZHRoPXAsZC5zdHJva2VTdHlsZT11P3U6XCJncmF5XCIsZC5zZXRMaW5lRGFzaCYmZC5zZXRMaW5lRGFzaChKKGJhLHApKSxkLmJlZ2luUGF0aCgpLGQubW92ZVRvKG0ucG9pbnQueCxtLnBvaW50LnkpLDA8PW4uaW5kZXhPZihcImJhclwiKXx8XCJlcnJvclwiPT09biYmbS5heGlzU3dhcHBlZD9kLmxpbmVUbyhxK1xuKDA8bS5kaXJlY3Rpb24/LWw6QytsKSsoXCJ2ZXJ0aWNhbFwiPT09ej8tcy8yOjApLGcrKFwidmVydGljYWxcIj09PXo/LWsvMjprLzItcy8yKS10KTowPD1uLmluZGV4T2YoXCJjb2x1bW5cIil8fFwiZXJyb3JcIj09PW4mJiFtLmF4aXNTd2FwcGVkP2QubGluZVRvKHErQy8yLShcImhvcml6b250YWxcIj09PXo/MDpzLzIpLGcrKFwidmVydGljYWxcIj09PXo/KGctazxtLnBvaW50Lnk/MDotaykrdDooZy1zLzI8bS5wb2ludC55P2s6MCktcy8yKSk6MDw9bi5pbmRleE9mKFwid2F0ZXJmYWxsXCIpP2QubGluZVRvKHErQy8yLShcImhvcml6b250YWxcIj09PXo/MDpzLzIpLFwidmVydGljYWxcIj09PXo/MDx2JiZnPG0ucG9pbnQueT9nOjA+diYmZy1rPm0ucG9pbnQueT9nLWs6bS5wb2ludC55OjA8diYmZytrLXMvMjxtLnBvaW50Lnk/ZytrLXMvMjowPnYmJmctcy8yPm0ucG9pbnQueT9nLXMvMi0yOm0ucG9pbnQueSk6ZC5saW5lVG8ocStDLzItKFwiaG9yaXpvbnRhbFwiPT09ej8wOnMvMiksZysoXCJ2ZXJ0aWNhbFwiPT09XG56P2ctazxtLnBvaW50Lnk/MDotazooZytrPG0ucG9pbnQueT9rOjApLXMvMikpLGQuc3Ryb2tlKCkpfX1kPXtzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0uZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowLHN0YXJ0VGltZVBlcmNlbnQ6MC43fTtmb3IoYT0wO2E8dGhpcy5faW5kZXhMYWJlbHMubGVuZ3RoO2ErKyltPXRoaXMuX2luZGV4TGFiZWxzW2FdLGg9bWEoXCJpbmRleExhYmVsQmFja2dyb3VuZENvbG9yXCIsbS5kYXRhUG9pbnQsbS5kYXRhU2VyaWVzKSxtLmRhdGFTZXJpZXMuaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvcj1yKGgpP3c/XCJ0cmFuc3BhcmVudFwiOm51bGw6aDtyZXR1cm4gZH07cC5wcm90b3R5cGUucmVuZGVyTGluZT1mdW5jdGlvbihhKXt2YXIgZD1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz13P3RoaXMuX3ByZVJlbmRlckN0eDpcbmQ7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBiPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eDtjLnNhdmUoKTt2YXIgZT10aGlzLnBsb3RBcmVhO2MuYmVnaW5QYXRoKCk7Yy5yZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KTtjLmNsaXAoKTtmb3IodmFyIGY9W10sbCx0PTA7dDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt0Kyspe3ZhciBDPWEuZGF0YVNlcmllc0luZGV4ZXNbdF0saz10aGlzLmRhdGFbQ107Yy5saW5lV2lkdGg9ay5saW5lVGhpY2tuZXNzO3ZhciBtPWsuZGF0YVBvaW50cyxuPVwic29saWRcIjtpZihjLnNldExpbmVEYXNoKXt2YXIgcT1KKGsubnVsbERhdGFMaW5lRGFzaFR5cGUsay5saW5lVGhpY2tuZXNzKSxuPWsubGluZURhc2hUeXBlLGc9SihuLGsubGluZVRoaWNrbmVzcyk7Yy5zZXRMaW5lRGFzaChnKX12YXIgcz1rLmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbc109e29iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsXG5kYXRhU2VyaWVzSW5kZXg6Q307cz1YKHMpO2Iuc3Ryb2tlU3R5bGU9cztiLmxpbmVXaWR0aD0wPGsubGluZVRoaWNrbmVzcz9NYXRoLm1heChrLmxpbmVUaGlja25lc3MsNCk6MDt2YXIgcz1rLl9jb2xvclNldCxoPXM9ay5saW5lQ29sb3I9ay5vcHRpb25zLmxpbmVDb2xvcj9rLm9wdGlvbnMubGluZUNvbG9yOnNbMF07Yy5zdHJva2VTdHlsZT1zO3ZhciByPSEwLHU9MCxwLHg7Yy5iZWdpblBhdGgoKTtpZigwPG0ubGVuZ3RoKXtmb3IodmFyIHo9ITEsdT0wO3U8bS5sZW5ndGg7dSsrKWlmKHA9bVt1XS54LmdldFRpbWU/bVt1XS54LmdldFRpbWUoKTptW3VdLngsIShwPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fHA+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCYmKCFrLmNvbm5lY3ROdWxsRGF0YXx8IXopKSlpZihcIm51bWJlclwiIT09dHlwZW9mIG1bdV0ueSkwPHUmJiEoay5jb25uZWN0TnVsbERhdGF8fHp8fHIpJiYoYy5zdHJva2UoKSx3JiZiLnN0cm9rZSgpKSx6PVxuITA7ZWxzZXtwPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChwKTt4PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChtW3VdLnkpO3ZhciBIPWsuZGF0YVBvaW50SWRzW3VdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbSF09e2lkOkgsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpDLGRhdGFQb2ludEluZGV4OnUseDE6cCx5MTp4fTtyfHx6PyghciYmay5jb25uZWN0TnVsbERhdGE/KGMuc2V0TGluZURhc2gmJihrLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fG49PT1rLmxpbmVEYXNoVHlwZSYmay5saW5lRGFzaFR5cGUhPT1rLm51bGxEYXRhTGluZURhc2hUeXBlKSYmKGMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhsLngsbC55KSxuPWsubnVsbERhdGFMaW5lRGFzaFR5cGUsYy5zZXRMaW5lRGFzaChxKSksYy5saW5lVG8ocCx4KSx3JiZiLmxpbmVUbyhwLHgpKTooYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhwLHgpLHcmJihiLmJlZ2luUGF0aCgpLFxuYi5tb3ZlVG8ocCx4KSkpLHo9cj0hMSk6KGMubGluZVRvKHAseCksdyYmYi5saW5lVG8ocCx4KSwwPT11JTUwMCYmKGMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhwLHgpLHcmJihiLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8ocCx4KSkpKTtsPXt4OnAseTp4fTt1PG0ubGVuZ3RoLTEmJihoIT09KG1bdV0ubGluZUNvbG9yfHxzKXx8biE9PShtW3VdLmxpbmVEYXNoVHlwZXx8ay5saW5lRGFzaFR5cGUpKSYmKGMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhwLHgpLGg9bVt1XS5saW5lQ29sb3J8fHMsYy5zdHJva2VTdHlsZT1oLGMuc2V0TGluZURhc2gmJihtW3VdLmxpbmVEYXNoVHlwZT8obj1tW3VdLmxpbmVEYXNoVHlwZSxjLnNldExpbmVEYXNoKEoobixrLmxpbmVUaGlja25lc3MpKSk6KG49ay5saW5lRGFzaFR5cGUsYy5zZXRMaW5lRGFzaChnKSkpKTtpZigwIT09bVt1XS5tYXJrZXJTaXplJiYoMDxtW3VdLm1hcmtlclNpemV8fDA8ay5tYXJrZXJTaXplKSl7dmFyIEQ9XG5rLmdldE1hcmtlclByb3BlcnRpZXModSxwLHgsYyk7Zi5wdXNoKEQpO0g9WChIKTt3JiZmLnB1c2goe3g6cCx5OngsY3R4OmIsdHlwZTpELnR5cGUsc2l6ZTpELnNpemUsY29sb3I6SCxib3JkZXJDb2xvcjpILGJvcmRlclRoaWNrbmVzczpELmJvcmRlclRoaWNrbmVzc30pfShtW3VdLmluZGV4TGFiZWx8fGsuaW5kZXhMYWJlbHx8bVt1XS5pbmRleExhYmVsRm9ybWF0dGVyfHxrLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJsaW5lXCIsZGF0YVBvaW50Om1bdV0sZGF0YVNlcmllczprLHBvaW50Ont4OnAseTp4fSxkaXJlY3Rpb246MD5tW3VdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsY29sb3I6c30pfWMuc3Ryb2tlKCk7dyYmYi5zdHJva2UoKX19Vy5kcmF3TWFya2VycyhmKTt3JiYoZC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cblwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuY2xlYXJSZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KSxiLmJlZ2luUGF0aCgpKTtjLnJlc3RvcmUoKTtjLmJlZ2luUGF0aCgpO3JldHVybntzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0ueENsaXBBbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcubGluZWFyLGFuaW1hdGlvbkJhc2U6MH19fTtwLnByb3RvdHlwZS5yZW5kZXJTdGVwTGluZT1cbmZ1bmN0aW9uKGEpe3ZhciBkPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxjPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmQ7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBiPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eDtjLnNhdmUoKTt2YXIgZT10aGlzLnBsb3RBcmVhO2MuYmVnaW5QYXRoKCk7Yy5yZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KTtjLmNsaXAoKTtmb3IodmFyIGY9W10sbCx0PTA7dDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt0Kyspe3ZhciBDPWEuZGF0YVNlcmllc0luZGV4ZXNbdF0saz10aGlzLmRhdGFbQ107Yy5saW5lV2lkdGg9ay5saW5lVGhpY2tuZXNzO3ZhciBtPWsuZGF0YVBvaW50cyxuPVwic29saWRcIjtpZihjLnNldExpbmVEYXNoKXt2YXIgcT1KKGsubnVsbERhdGFMaW5lRGFzaFR5cGUsay5saW5lVGhpY2tuZXNzKSxuPWsubGluZURhc2hUeXBlLGc9SihuLGsubGluZVRoaWNrbmVzcyk7Yy5zZXRMaW5lRGFzaChnKX12YXIgcz1cbmsuaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtzXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6Q307cz1YKHMpO2Iuc3Ryb2tlU3R5bGU9cztiLmxpbmVXaWR0aD0wPGsubGluZVRoaWNrbmVzcz9NYXRoLm1heChrLmxpbmVUaGlja25lc3MsNCk6MDt2YXIgcz1rLl9jb2xvclNldCxoPXM9ay5saW5lQ29sb3I9ay5vcHRpb25zLmxpbmVDb2xvcj9rLm9wdGlvbnMubGluZUNvbG9yOnNbMF07Yy5zdHJva2VTdHlsZT1zO3ZhciByPSEwLHU9MCxwLHg7Yy5iZWdpblBhdGgoKTtpZigwPG0ubGVuZ3RoKXtmb3IodmFyIHo9ITEsdT0wO3U8bS5sZW5ndGg7dSsrKWlmKHA9bVt1XS5nZXRUaW1lP21bdV0ueC5nZXRUaW1lKCk6bVt1XS54LCEocDxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxwPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighay5jb25uZWN0TnVsbERhdGF8fCF6KSkpaWYoXCJudW1iZXJcIiE9PXR5cGVvZiBtW3VdLnkpMDxcbnUmJiEoay5jb25uZWN0TnVsbERhdGF8fHp8fHIpJiYoYy5zdHJva2UoKSx3JiZiLnN0cm9rZSgpKSx6PSEwO2Vsc2V7dmFyIEg9eDtwPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChwKTt4PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChtW3VdLnkpO3ZhciBEPWsuZGF0YVBvaW50SWRzW3VdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbRF09e2lkOkQsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpDLGRhdGFQb2ludEluZGV4OnUseDE6cCx5MTp4fTtyfHx6PyghciYmay5jb25uZWN0TnVsbERhdGE/KGMuc2V0TGluZURhc2gmJihrLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fG49PT1rLmxpbmVEYXNoVHlwZSYmay5saW5lRGFzaFR5cGUhPT1rLm51bGxEYXRhTGluZURhc2hUeXBlKSYmKGMuc3Ryb2tlKCksYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhsLngsbC55KSxuPWsubnVsbERhdGFMaW5lRGFzaFR5cGUsYy5zZXRMaW5lRGFzaChxKSksXG5jLmxpbmVUbyhwLEgpLGMubGluZVRvKHAseCksdyYmKGIubGluZVRvKHAsSCksYi5saW5lVG8ocCx4KSkpOihjLmJlZ2luUGF0aCgpLGMubW92ZVRvKHAseCksdyYmKGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8ocCx4KSkpLHo9cj0hMSk6KGMubGluZVRvKHAsSCksdyYmYi5saW5lVG8ocCxIKSxjLmxpbmVUbyhwLHgpLHcmJmIubGluZVRvKHAseCksMD09dSU1MDAmJihjLnN0cm9rZSgpLGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8ocCx4KSx3JiYoYi5zdHJva2UoKSxiLmJlZ2luUGF0aCgpLGIubW92ZVRvKHAseCkpKSk7bD17eDpwLHk6eH07dTxtLmxlbmd0aC0xJiYoaCE9PShtW3VdLmxpbmVDb2xvcnx8cyl8fG4hPT0obVt1XS5saW5lRGFzaFR5cGV8fGsubGluZURhc2hUeXBlKSkmJihjLnN0cm9rZSgpLGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8ocCx4KSxoPW1bdV0ubGluZUNvbG9yfHxzLGMuc3Ryb2tlU3R5bGU9aCxjLnNldExpbmVEYXNoJiYobVt1XS5saW5lRGFzaFR5cGU/KG49bVt1XS5saW5lRGFzaFR5cGUsXG5jLnNldExpbmVEYXNoKEoobixrLmxpbmVUaGlja25lc3MpKSk6KG49ay5saW5lRGFzaFR5cGUsYy5zZXRMaW5lRGFzaChnKSkpKTswIT09bVt1XS5tYXJrZXJTaXplJiYoMDxtW3VdLm1hcmtlclNpemV8fDA8ay5tYXJrZXJTaXplKSYmKEg9ay5nZXRNYXJrZXJQcm9wZXJ0aWVzKHUscCx4LGMpLGYucHVzaChIKSxEPVgoRCksdyYmZi5wdXNoKHt4OnAseTp4LGN0eDpiLHR5cGU6SC50eXBlLHNpemU6SC5zaXplLGNvbG9yOkQsYm9yZGVyQ29sb3I6RCxib3JkZXJUaGlja25lc3M6SC5ib3JkZXJUaGlja25lc3N9KSk7KG1bdV0uaW5kZXhMYWJlbHx8ay5pbmRleExhYmVsfHxtW3VdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGsuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInN0ZXBMaW5lXCIsZGF0YVBvaW50Om1bdV0sZGF0YVNlcmllczprLHBvaW50Ont4OnAseTp4fSxkaXJlY3Rpb246MD5tW3VdLnk9PT1hLmF4aXNZLnJldmVyc2VkP1xuMTotMSxjb2xvcjpzfSl9Yy5zdHJva2UoKTt3JiZiLnN0cm9rZSgpfX1XLmRyYXdNYXJrZXJzKGYpO3cmJihkLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuY2xlYXJSZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KSxiLmJlZ2luUGF0aCgpKTtjLnJlc3RvcmUoKTtjLmJlZ2luUGF0aCgpO1xucmV0dXJue3NvdXJjZTpkLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6TS54Q2xpcEFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpNLmVhc2luZy5saW5lYXIsYW5pbWF0aW9uQmFzZTowfX19O3AucHJvdG90eXBlLnJlbmRlclNwbGluZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBkKGEpe2E9dihhLDIpO2lmKDA8YS5sZW5ndGgpe2IuYmVnaW5QYXRoKCk7dyYmZS5iZWdpblBhdGgoKTtiLm1vdmVUbyhhWzBdLngsYVswXS55KTthWzBdLm5ld1N0cm9rZVN0eWxlJiYoYi5zdHJva2VTdHlsZT1hWzBdLm5ld1N0cm9rZVN0eWxlKTthWzBdLm5ld0xpbmVEYXNoQXJyYXkmJmIuc2V0TGluZURhc2goYVswXS5uZXdMaW5lRGFzaEFycmF5KTt3JiZlLm1vdmVUbyhhWzBdLngsYVswXS55KTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoLTM7Yys9MylpZihiLmJlemllckN1cnZlVG8oYVtjKzFdLngsYVtjKzFdLnksYVtjKzJdLngsYVtjKzJdLnksYVtjKzNdLngsYVtjKzNdLnkpLFxudyYmZS5iZXppZXJDdXJ2ZVRvKGFbYysxXS54LGFbYysxXS55LGFbYysyXS54LGFbYysyXS55LGFbYyszXS54LGFbYyszXS55KSwwPGMmJjA9PT1jJTNFM3x8YVtjKzNdLm5ld1N0cm9rZVN0eWxlfHxhW2MrM10ubmV3TGluZURhc2hBcnJheSliLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oYVtjKzNdLngsYVtjKzNdLnkpLGFbYyszXS5uZXdTdHJva2VTdHlsZSYmKGIuc3Ryb2tlU3R5bGU9YVtjKzNdLm5ld1N0cm9rZVN0eWxlKSxhW2MrM10ubmV3TGluZURhc2hBcnJheSYmYi5zZXRMaW5lRGFzaChhW2MrM10ubmV3TGluZURhc2hBcnJheSksdyYmKGUuc3Ryb2tlKCksZS5iZWdpblBhdGgoKSxlLm1vdmVUbyhhW2MrM10ueCxhW2MrM10ueSkpO2Iuc3Ryb2tlKCk7dyYmZS5zdHJva2UoKX19dmFyIGM9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGI9dz90aGlzLl9wcmVSZW5kZXJDdHg6YztpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGU9XG50aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHg7Yi5zYXZlKCk7dmFyIGY9dGhpcy5wbG90QXJlYTtiLmJlZ2luUGF0aCgpO2IucmVjdChmLngxLGYueTEsZi53aWR0aCxmLmhlaWdodCk7Yi5jbGlwKCk7Zm9yKHZhciBsPVtdLHQ9MDt0PGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO3QrKyl7dmFyIEM9YS5kYXRhU2VyaWVzSW5kZXhlc1t0XSxrPXRoaXMuZGF0YVtDXTtiLmxpbmVXaWR0aD1rLmxpbmVUaGlja25lc3M7dmFyIG09ay5kYXRhUG9pbnRzLG49XCJzb2xpZFwiO2lmKGIuc2V0TGluZURhc2gpe3ZhciBxPUooay5udWxsRGF0YUxpbmVEYXNoVHlwZSxrLmxpbmVUaGlja25lc3MpLG49ay5saW5lRGFzaFR5cGUsZz1KKG4say5saW5lVGhpY2tuZXNzKTtiLnNldExpbmVEYXNoKGcpfXZhciBzPWsuaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtzXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6Q307cz1YKHMpO2Uuc3Ryb2tlU3R5bGU9cztlLmxpbmVXaWR0aD1cbjA8ay5saW5lVGhpY2tuZXNzP01hdGgubWF4KGsubGluZVRoaWNrbmVzcyw0KTowO3ZhciBzPWsuX2NvbG9yU2V0LGg9cz1rLmxpbmVDb2xvcj1rLm9wdGlvbnMubGluZUNvbG9yP2sub3B0aW9ucy5saW5lQ29sb3I6c1swXTtiLnN0cm9rZVN0eWxlPXM7dmFyIHI9MCx1LHAseD1bXTtiLmJlZ2luUGF0aCgpO2lmKDA8bS5sZW5ndGgpZm9yKHA9ITEscj0wO3I8bS5sZW5ndGg7cisrKWlmKHU9bVtyXS5nZXRUaW1lP21bcl0ueC5nZXRUaW1lKCk6bVtyXS54LCEodTxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx1PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighay5jb25uZWN0TnVsbERhdGF8fCFwKSkpaWYoXCJudW1iZXJcIiE9PXR5cGVvZiBtW3JdLnkpMDxyJiYhcCYmKGsuY29ubmVjdE51bGxEYXRhP2Iuc2V0TGluZURhc2gmJigwPHgubGVuZ3RoJiYoay5vcHRpb25zLm51bGxEYXRhTGluZURhc2hUeXBlfHwhbVtyLTFdLmxpbmVEYXNoVHlwZSkpJiYoeFt4Lmxlbmd0aC1cbjFdLm5ld0xpbmVEYXNoQXJyYXk9cSxuPWsubnVsbERhdGFMaW5lRGFzaFR5cGUpOihkKHgpLHg9W10pKSxwPSEwO2Vsc2V7dT1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodSk7cD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVtyXS55KTt2YXIgej1rLmRhdGFQb2ludElkc1tyXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW3pdPXtpZDp6LG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6QyxkYXRhUG9pbnRJbmRleDpyLHgxOnUseTE6cH07eFt4Lmxlbmd0aF09e3g6dSx5OnB9O3I8bS5sZW5ndGgtMSYmKGghPT0obVtyXS5saW5lQ29sb3J8fHMpfHxuIT09KG1bcl0ubGluZURhc2hUeXBlfHxrLmxpbmVEYXNoVHlwZSkpJiYoaD1tW3JdLmxpbmVDb2xvcnx8cyx4W3gubGVuZ3RoLTFdLm5ld1N0cm9rZVN0eWxlPWgsYi5zZXRMaW5lRGFzaCYmKG1bcl0ubGluZURhc2hUeXBlPyhuPW1bcl0ubGluZURhc2hUeXBlLHhbeC5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1cbkoobixrLmxpbmVUaGlja25lc3MpKToobj1rLmxpbmVEYXNoVHlwZSx4W3gubGVuZ3RoLTFdLm5ld0xpbmVEYXNoQXJyYXk9ZykpKTtpZigwIT09bVtyXS5tYXJrZXJTaXplJiYoMDxtW3JdLm1hcmtlclNpemV8fDA8ay5tYXJrZXJTaXplKSl7dmFyIEg9ay5nZXRNYXJrZXJQcm9wZXJ0aWVzKHIsdSxwLGIpO2wucHVzaChIKTt6PVgoeik7dyYmbC5wdXNoKHt4OnUseTpwLGN0eDplLHR5cGU6SC50eXBlLHNpemU6SC5zaXplLGNvbG9yOnosYm9yZGVyQ29sb3I6eixib3JkZXJUaGlja25lc3M6SC5ib3JkZXJUaGlja25lc3N9KX0obVtyXS5pbmRleExhYmVsfHxrLmluZGV4TGFiZWx8fG1bcl0uaW5kZXhMYWJlbEZvcm1hdHRlcnx8ay5pbmRleExhYmVsRm9ybWF0dGVyKSYmdGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwic3BsaW5lXCIsZGF0YVBvaW50Om1bcl0sZGF0YVNlcmllczprLHBvaW50Ont4OnUseTpwfSxkaXJlY3Rpb246MD5tW3JdLnk9PT1hLmF4aXNZLnJldmVyc2VkP1xuMTotMSxjb2xvcjpzfSk7cD0hMX1kKHgpfVcuZHJhd01hcmtlcnMobCk7dyYmKGMuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QoZi54MSxmLnkxLGYud2lkdGgsZi5oZWlnaHQpLGUuYmVnaW5QYXRoKCkpO2IucmVzdG9yZSgpO2IuYmVnaW5QYXRoKCk7cmV0dXJue3NvdXJjZTpjLFxuZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLnhDbGlwQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmxpbmVhcixhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyQ29sdW1uPWZ1bmN0aW9uKGEpe3ZhciBkPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxjPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmQ7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBiPW51bGwsZT10aGlzLnBsb3RBcmVhLGY9MCxsLHQsQyxrPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGY9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MSxtPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNYXhXaWR0aD9cbnRoaXMuZGF0YVBvaW50TWF4V2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6TWF0aC5taW4oMC4xNSp0aGlzLndpZHRoLDAuOSoodGhpcy5wbG90QXJlYS53aWR0aC9hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcykpPDwwLG49YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKG4pfHwobj0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO249dGhpcy5kYXRhUG9pbnRXaWR0aD10aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjkqKGUud2lkdGgqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cobikvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMobikvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZmPm0mJihmPU1hdGgubWluKHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD9cbnRoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHksbSkpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmbTxmKSYmKG09TWF0aC5tYXgodGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6LUluZmluaXR5LGYpKTtuPGYmJihuPWYpO24+bSYmKG49bSk7Yy5zYXZlKCk7dyYmdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnNhdmUoKTtjLmJlZ2luUGF0aCgpO2MucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCk7Yy5jbGlwKCk7dyYmKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5iZWdpblBhdGgoKSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKG09MDttPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO20rKyl7dmFyIHE9YS5kYXRhU2VyaWVzSW5kZXhlc1ttXSxcbmc9dGhpcy5kYXRhW3FdLHM9Zy5kYXRhUG9pbnRzO2lmKDA8cy5sZW5ndGgpZm9yKHZhciBoPTU8biYmZy5iZXZlbEVuYWJsZWQ/ITA6ITEsZj0wO2Y8cy5sZW5ndGg7ZisrKWlmKHNbZl0uZ2V0VGltZT9DPXNbZl0ueC5nZXRUaW1lKCk6Qz1zW2ZdLngsIShDPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fEM+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlwibnVtYmVyXCI9PT10eXBlb2Ygc1tmXS55KXtsPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChDKTt0PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChzW2ZdLnkpO2w9YS5heGlzWC5yZXZlcnNlZD9sK2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKm4vMi0oYS5wcmV2aW91c0RhdGFTZXJpZXNDb3VudCttKSpuPDwwOmwtYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMqbi8yKyhhLnByZXZpb3VzRGF0YVNlcmllc0NvdW50K20pKm48PDA7dmFyIHI9YS5heGlzWC5yZXZlcnNlZD9sLW48PDA6bCtuPDwwLHU7XG4wPD1zW2ZdLnk/dT1rOih1PXQsdD1rKTt0PnUmJihiPXQsdD11LHU9Yik7Yj1zW2ZdLmNvbG9yP3NbZl0uY29sb3I6Zy5fY29sb3JTZXRbZiVnLl9jb2xvclNldC5sZW5ndGhdO1koYyxhLmF4aXNYLnJldmVyc2VkP3I6bCx0LGEuYXhpc1gucmV2ZXJzZWQ/bDpyLHUsYiwwLG51bGwsaCYmKGEuYXhpc1kucmV2ZXJzZWQ/MD5zW2ZdLnk6MDw9c1tmXS55KSwoYS5heGlzWS5yZXZlcnNlZD8wPD1zW2ZdLnk6MD5zW2ZdLnkpJiZoLCExLCExLGcuZmlsbE9wYWNpdHkpO2I9Zy5kYXRhUG9pbnRJZHNbZl07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtiXT17aWQ6YixvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OnEsZGF0YVBvaW50SW5kZXg6Zix4MTpsLHkxOnQseDI6cix5Mjp1fTtiPVgoYik7dyYmWSh0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsYS5heGlzWC5yZXZlcnNlZD9yOmwsdCxhLmF4aXNYLnJldmVyc2VkP2w6cix1LGIsMCxudWxsLCExLCExLFxuITEsITEpOyhzW2ZdLmluZGV4TGFiZWx8fGcuaW5kZXhMYWJlbHx8c1tmXS5pbmRleExhYmVsRm9ybWF0dGVyfHxnLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJjb2x1bW5cIixkYXRhUG9pbnQ6c1tmXSxkYXRhU2VyaWVzOmcscG9pbnQ6e3g6bCsoci1sKS8yLHk6MD5zW2ZdLnk9PT1hLmF4aXNZLnJldmVyc2VkP3Q6dX0sZGlyZWN0aW9uOjA+c1tmXS55PT09YS5heGlzWS5yZXZlcnNlZD8xOi0xLGJvdW5kczp7eDE6bCx5MTpNYXRoLm1pbih0LHUpLHgyOnIseTI6TWF0aC5tYXgodCx1KX0sY29sb3I6Yn0pfX13JiYoZC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLFxuYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuY2xlYXJSZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtjLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmQsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLnlTY2FsZUFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpNLmVhc2luZy5lYXNlT3V0UXVhcnQsYW5pbWF0aW9uQmFzZTprPGEuYXhpc1kuYm91bmRzLnkxP2EuYXhpc1kuYm91bmRzLnkxOms+YS5heGlzWS5ib3VuZHMueTI/YS5heGlzWS5ib3VuZHMueTI6a319fTtwLnByb3RvdHlwZS5yZW5kZXJTdGFja2VkQ29sdW1uPVxuZnVuY3Rpb24oYSl7dmFyIGQ9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGM9dz90aGlzLl9wcmVSZW5kZXJDdHg6ZDtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGI9bnVsbCxlPXRoaXMucGxvdEFyZWEsZj1bXSxsPVtdLHQ9W10sQz1bXSxrPTAsbSxuLHE9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGEuYXhpc1kubG9nYXJpdGhtaWM/YS5heGlzWS52aWV3cG9ydE1pbmltdW06MCksaz10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWluV2lkdGg/dGhpcy5kYXRhUG9pbnRNaW5XaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxLGc9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC4xNSp0aGlzLndpZHRoPDwwLHM9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO1xuaXNGaW5pdGUocyl8fChzPTAuMypNYXRoLmFicyhhLmF4aXNYLnJhbmdlKSk7cz10aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjkqKGUud2lkdGgqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocykvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocykvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmaz5nJiYoaz1NYXRoLm1pbih0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpJbmZpbml0eSxnKSk7IXRoaXMuZGF0YVBvaW50TWF4V2lkdGgmJih0aGlzLmRhdGFQb2ludE1pbldpZHRoJiZnPGspJiYoZz1NYXRoLm1heCh0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDotSW5maW5pdHksaykpO3M8ayYmKHM9ayk7cz5nJiYocz1nKTtjLnNhdmUoKTt3JiZ0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguc2F2ZSgpO1xuYy5iZWdpblBhdGgoKTtjLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2MuY2xpcCgpO3cmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2ZvcihnPTA7ZzxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtnKyspe3ZhciBoPWEuZGF0YVNlcmllc0luZGV4ZXNbZ10scj10aGlzLmRhdGFbaF0sdT1yLmRhdGFQb2ludHM7aWYoMDx1Lmxlbmd0aCl7dmFyIHA9NTxzJiZyLmJldmVsRW5hYmxlZD8hMDohMTtjLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIjtmb3Ioaz0wO2s8dS5sZW5ndGg7aysrKWlmKGI9dVtrXS54LmdldFRpbWU/dVtrXS54LmdldFRpbWUoKTp1W2tdLngsIShiPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fGI+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlxuXCJudW1iZXJcIj09PXR5cGVvZiB1W2tdLnkpe209YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGIpO209bS1hLnBsb3RUeXBlLnBsb3RVbml0cy5sZW5ndGgqcy8yK2EuaW5kZXgqczw8MDt2YXIgeD1tK3M8PDAsejtpZihhLmF4aXNZLmxvZ2FyaXRobWljfHxhLmF4aXNZLnNjYWxlQnJlYWtzJiYwPGEuYXhpc1kuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoJiYwPHVba10ueSl0W2JdPXVba10ueSsodFtiXT90W2JdOjApLDA8dFtiXSYmKG49YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHRbYl0pLHo9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBmW2JdP2ZbYl06cSxmW2JdPW4pO2Vsc2UgaWYoYS5heGlzWS5zY2FsZUJyZWFrcyYmMDxhLmF4aXNZLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCYmMD49dVtrXS55KUNbYl09dVtrXS55KyhDW2JdP0NbYl06MCksej1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoQ1tiXSksbj1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGxbYl0/XG5sW2JdOnEsbFtiXT16O2Vsc2UgaWYobj1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodVtrXS55KSwwPD11W2tdLnkpe3ZhciBIPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgZltiXT9mW2JdOjA7bi09SDt6PXEtSDtmW2JdPUgrKHotbil9ZWxzZSBIPWxbYl0/bFtiXTowLHo9bitILG49cStILGxbYl09SCsoei1uKTtiPXVba10uY29sb3I/dVtrXS5jb2xvcjpyLl9jb2xvclNldFtrJXIuX2NvbG9yU2V0Lmxlbmd0aF07WShjLG0sYS5heGlzWS5yZXZlcnNlZD96Om4seCxhLmF4aXNZLnJldmVyc2VkP246eixiLDAsbnVsbCxwJiYoYS5heGlzWS5yZXZlcnNlZD8wPnVba10ueTowPD11W2tdLnkpLChhLmF4aXNZLnJldmVyc2VkPzA8PXVba10ueTowPnVba10ueSkmJnAsITEsITEsci5maWxsT3BhY2l0eSk7Yj1yLmRhdGFQb2ludElkc1trXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2JdPXtpZDpiLG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6aCxkYXRhUG9pbnRJbmRleDprLFxueDE6bSx5MTpuLHgyOngseTI6en07Yj1YKGIpO3cmJlkodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LG0sbix4LHosYiwwLG51bGwsITEsITEsITEsITEpOyh1W2tdLmluZGV4TGFiZWx8fHIuaW5kZXhMYWJlbHx8dVtrXS5pbmRleExhYmVsRm9ybWF0dGVyfHxyLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzdGFja2VkQ29sdW1uXCIsZGF0YVBvaW50OnVba10sZGF0YVNlcmllczpyLHBvaW50Ont4Om0rKHgtbSkvMix5OjA8PXVba10ueT9uOnp9LGRpcmVjdGlvbjowPnVba10ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxib3VuZHM6e3gxOm0seTE6TWF0aC5taW4obix6KSx4Mjp4LHkyOk1hdGgubWF4KG4seil9LGNvbG9yOmJ9KX19fXcmJihkLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixcbmEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2MucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0ueVNjYWxlQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VPdXRRdWFydCxhbmltYXRpb25CYXNlOnE8YS5heGlzWS5ib3VuZHMueTE/YS5heGlzWS5ib3VuZHMueTE6XG5xPmEuYXhpc1kuYm91bmRzLnkyP2EuYXhpc1kuYm91bmRzLnkyOnF9fX07cC5wcm90b3R5cGUucmVuZGVyU3RhY2tlZENvbHVtbjEwMD1mdW5jdGlvbihhKXt2YXIgZD1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz13P3RoaXMuX3ByZVJlbmRlckN0eDpkO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYj1udWxsLGU9dGhpcy5wbG90QXJlYSxmPVtdLGw9W10sdD1bXSxDPVtdLGs9MCxtLG4scT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYS5heGlzWS5sb2dhcml0aG1pYz9hLmF4aXNZLnZpZXdwb3J0TWluaW11bTowKSxrPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjEsZz10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/XG50aGlzLmRhdGFQb2ludFdpZHRoOjAuMTUqdGhpcy53aWR0aDw8MCxzPWEuYXhpc1guZGF0YUluZm8ubWluRGlmZjtpc0Zpbml0ZShzKXx8KHM9MC4zKk1hdGguYWJzKGEuYXhpc1gucmFuZ2UpKTtzPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS53aWR0aCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhzKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhzKS9NYXRoLmFicyhhLmF4aXNYLnJhbmdlKSkvYS5wbG90VHlwZS5wbG90VW5pdHMubGVuZ3RoKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZrPmcmJihrPU1hdGgubWluKHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOkluZmluaXR5LGcpKTshdGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmKHRoaXMuZGF0YVBvaW50TWluV2lkdGgmJmc8aykmJihnPU1hdGgubWF4KHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOlxuLUluZmluaXR5LGspKTtzPGsmJihzPWspO3M+ZyYmKHM9Zyk7Yy5zYXZlKCk7dyYmdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnNhdmUoKTtjLmJlZ2luUGF0aCgpO2MucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCk7Yy5jbGlwKCk7dyYmKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5iZWdpblBhdGgoKSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKGc9MDtnPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2crKyl7dmFyIGg9YS5kYXRhU2VyaWVzSW5kZXhlc1tnXSxyPXRoaXMuZGF0YVtoXSx1PXIuZGF0YVBvaW50cztpZigwPHUubGVuZ3RoKWZvcih2YXIgcD01PHMmJnIuYmV2ZWxFbmFibGVkPyEwOiExLGs9MDtrPHUubGVuZ3RoO2srKylpZihiPXVba10ueC5nZXRUaW1lP3Vba10ueC5nZXRUaW1lKCk6dVtrXS54LCEoYjxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxcbmI+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlwibnVtYmVyXCI9PT10eXBlb2YgdVtrXS55KXttPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChiKTtuPTAhPT1hLmRhdGFQb2ludFlTdW1zW2JdPzEwMCoodVtrXS55L2EuZGF0YVBvaW50WVN1bXNbYl0pOjA7bT1tLWEucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCpzLzIrYS5pbmRleCpzPDwwO3ZhciB4PW0rczw8MCx6O2lmKGEuYXhpc1kubG9nYXJpdGhtaWN8fGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA8dVtrXS55KXt0W2JdPW4rKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgdFtiXT90W2JdOjApO2lmKDA+PXRbYl0pY29udGludWU7bj1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodFtiXSk7ej1mW2JdP2ZbYl06cTtmW2JdPW59ZWxzZSBpZihhLmF4aXNZLnNjYWxlQnJlYWtzJiYwPGEuYXhpc1kuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoJiZcbjA+PXVba10ueSlDW2JdPW4rKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgQ1tiXT9DW2JdOjApLHo9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKENbYl0pLG49bFtiXT9sW2JdOnEsbFtiXT16O2Vsc2UgaWYobj1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwobiksMDw9dVtrXS55KXt2YXIgSD1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGZbYl0/ZltiXTowO24tPUg7ej1xLUg7YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgtMT09PWcmJjE+PU1hdGguYWJzKGUueTEtbikmJihuPWUueTEpO2ZbYl09SCsoei1uKX1lbHNlIEg9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsW2JdP2xbYl06MCx6PW4rSCxuPXErSCxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aC0xPT09ZyYmMT49TWF0aC5hYnMoZS55Mi16KSYmKHo9ZS55MiksbFtiXT1IKyh6LW4pO2I9dVtrXS5jb2xvcj91W2tdLmNvbG9yOnIuX2NvbG9yU2V0W2slci5fY29sb3JTZXQubGVuZ3RoXTtZKGMsbSxhLmF4aXNZLnJldmVyc2VkP3o6bixcbngsYS5heGlzWS5yZXZlcnNlZD9uOnosYiwwLG51bGwscCYmKGEuYXhpc1kucmV2ZXJzZWQ/MD51W2tdLnk6MDw9dVtrXS55KSwoYS5heGlzWS5yZXZlcnNlZD8wPD11W2tdLnk6MD51W2tdLnkpJiZwLCExLCExLHIuZmlsbE9wYWNpdHkpO2I9ci5kYXRhUG9pbnRJZHNba107dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtiXT17aWQ6YixvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OmgsZGF0YVBvaW50SW5kZXg6ayx4MTptLHkxOm4seDI6eCx5Mjp6fTtiPVgoYik7dyYmWSh0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsbSxuLHgseixiLDAsbnVsbCwhMSwhMSwhMSwhMSk7KHVba10uaW5kZXhMYWJlbHx8ci5pbmRleExhYmVsfHx1W2tdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fHIuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInN0YWNrZWRDb2x1bW4xMDBcIixkYXRhUG9pbnQ6dVtrXSxkYXRhU2VyaWVzOnIsXG5wb2ludDp7eDptKyh4LW0pLzIseTowPD11W2tdLnk/bjp6fSxkaXJlY3Rpb246MD51W2tdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsYm91bmRzOnt4MTptLHkxOk1hdGgubWluKG4seikseDI6eCx5MjpNYXRoLm1heChuLHopfSxjb2xvcjpifSl9fXcmJihkLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLFxuYy5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2MucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0ueVNjYWxlQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VPdXRRdWFydCxhbmltYXRpb25CYXNlOnE8YS5heGlzWS5ib3VuZHMueTE/YS5heGlzWS5ib3VuZHMueTE6cT5hLmF4aXNZLmJvdW5kcy55Mj9hLmF4aXNZLmJvdW5kcy55MjpxfX19O3AucHJvdG90eXBlLnJlbmRlckJhcj1mdW5jdGlvbihhKXt2YXIgZD1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz13P3RoaXMuX3ByZVJlbmRlckN0eDpkO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYj1udWxsLGU9dGhpcy5wbG90QXJlYSxmPTAsbCx0LEMsaz1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYS5heGlzWS5sb2dhcml0aG1pYz9cbmEuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGY9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MSxtPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOk1hdGgubWluKDAuMTUqdGhpcy5oZWlnaHQsMC45Kih0aGlzLnBsb3RBcmVhLmhlaWdodC9hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcykpPDwwLG49YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKG4pfHwobj0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO249dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC45KihlLmhlaWdodCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhuKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpcbk1hdGguYWJzKG4pL01hdGguYWJzKGEuYXhpc1gucmFuZ2UpKS9hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcyk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmZj5tJiYoZj1NYXRoLm1pbih0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpJbmZpbml0eSxtKSk7IXRoaXMuZGF0YVBvaW50TWF4V2lkdGgmJih0aGlzLmRhdGFQb2ludE1pbldpZHRoJiZtPGYpJiYobT1NYXRoLm1heCh0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDotSW5maW5pdHksZikpO248ZiYmKG49Zik7bj5tJiYobj1tKTtjLnNhdmUoKTt3JiZ0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguc2F2ZSgpO2MuYmVnaW5QYXRoKCk7Yy5yZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KTtjLmNsaXAoKTt3JiYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmJlZ2luUGF0aCgpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZWN0KGUueDEsXG5lLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2ZvcihtPTA7bTxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDttKyspe3ZhciBxPWEuZGF0YVNlcmllc0luZGV4ZXNbbV0sZz10aGlzLmRhdGFbcV0scz1nLmRhdGFQb2ludHM7aWYoMDxzLmxlbmd0aCl7dmFyIGg9NTxuJiZnLmJldmVsRW5hYmxlZD8hMDohMTtjLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIjtmb3IoZj0wO2Y8cy5sZW5ndGg7ZisrKWlmKHNbZl0uZ2V0VGltZT9DPXNbZl0ueC5nZXRUaW1lKCk6Qz1zW2ZdLngsIShDPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fEM+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlwibnVtYmVyXCI9PT10eXBlb2Ygc1tmXS55KXt0PWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChDKTtsPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChzW2ZdLnkpO3Q9YS5heGlzWC5yZXZlcnNlZD90K2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKlxubi8yLShhLnByZXZpb3VzRGF0YVNlcmllc0NvdW50K20pKm48PDA6dC1hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcypuLzIrKGEucHJldmlvdXNEYXRhU2VyaWVzQ291bnQrbSkqbjw8MDt2YXIgcj1hLmF4aXNYLnJldmVyc2VkP3Qtbjw8MDp0K248PDAsdTswPD1zW2ZdLnk/dT1rOih1PWwsbD1rKTtiPXNbZl0uY29sb3I/c1tmXS5jb2xvcjpnLl9jb2xvclNldFtmJWcuX2NvbG9yU2V0Lmxlbmd0aF07WShjLGEuYXhpc1kucmV2ZXJzZWQ/bDp1LGEuYXhpc1gucmV2ZXJzZWQ/cjp0LGEuYXhpc1kucmV2ZXJzZWQ/dTpsLGEuYXhpc1gucmV2ZXJzZWQ/dDpyLGIsMCxudWxsLGgsITEsITEsITEsZy5maWxsT3BhY2l0eSk7Yj1nLmRhdGFQb2ludElkc1tmXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2JdPXtpZDpiLG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6cSxkYXRhUG9pbnRJbmRleDpmLHgxOnUseTE6dCx4MjpsLHkyOnJ9O2I9WChiKTt3JiZZKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCxcbnUsYS5heGlzWC5yZXZlcnNlZD9yOnQsbCxhLmF4aXNYLnJldmVyc2VkP3Q6cixiLDAsbnVsbCwhMSwhMSwhMSwhMSk7KHNbZl0uaW5kZXhMYWJlbHx8Zy5pbmRleExhYmVsfHxzW2ZdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGcuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcImJhclwiLGRhdGFQb2ludDpzW2ZdLGRhdGFTZXJpZXM6Zyxwb2ludDp7eDowPD1zW2ZdLnk/bDp1LHk6dCsoci10KS8yfSxkaXJlY3Rpb246MD5zW2ZdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsYm91bmRzOnt4MTpNYXRoLm1pbih1LGwpLHkxOnQseDI6TWF0aC5tYXgodSxsKSx5MjpyfSxjb2xvcjpifSl9fX13JiYoZC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsXG4wLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuY2xlYXJSZWN0KGUueDEsZS55MSxlLndpZHRoLGUuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtjLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmQsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLnhTY2FsZUFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpNLmVhc2luZy5lYXNlT3V0UXVhcnQsYW5pbWF0aW9uQmFzZTprPGEuYXhpc1kuYm91bmRzLngxP2EuYXhpc1kuYm91bmRzLngxOms+YS5heGlzWS5ib3VuZHMueDI/YS5heGlzWS5ib3VuZHMueDI6XG5rfX19O3AucHJvdG90eXBlLnJlbmRlclN0YWNrZWRCYXI9ZnVuY3Rpb24oYSl7dmFyIGQ9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGM9dz90aGlzLl9wcmVSZW5kZXJDdHg6ZDtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGI9bnVsbCxlPXRoaXMucGxvdEFyZWEsZj1bXSxsPVtdLHQ9W10sQz1bXSxrPTAsbSxuLHE9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGEuYXhpc1kubG9nYXJpdGhtaWM/YS5heGlzWS52aWV3cG9ydE1pbmltdW06MCksaz10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWluV2lkdGg/dGhpcy5kYXRhUG9pbnRNaW5XaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxLGc9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC4xNSp0aGlzLmhlaWdodDw8XG4wLHM9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHMpfHwocz0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO3M9dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC45KihlLmhlaWdodCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhzKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhzKS9NYXRoLmFicyhhLmF4aXNYLnJhbmdlKSkvYS5wbG90VHlwZS5wbG90VW5pdHMubGVuZ3RoKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZrPmcmJihrPU1hdGgubWluKHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOkluZmluaXR5LGcpKTshdGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmKHRoaXMuZGF0YVBvaW50TWluV2lkdGgmJmc8aykmJihnPU1hdGgubWF4KHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxrKSk7czxrJiZcbihzPWspO3M+ZyYmKHM9Zyk7Yy5zYXZlKCk7dyYmdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnNhdmUoKTtjLmJlZ2luUGF0aCgpO2MucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCk7Yy5jbGlwKCk7dyYmKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5iZWdpblBhdGgoKSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKGc9MDtnPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2crKyl7dmFyIGg9YS5kYXRhU2VyaWVzSW5kZXhlc1tnXSxyPXRoaXMuZGF0YVtoXSx1PXIuZGF0YVBvaW50cztpZigwPHUubGVuZ3RoKXt2YXIgcD01PHMmJnIuYmV2ZWxFbmFibGVkPyEwOiExO2Muc3Ryb2tlU3R5bGU9XCIjNDU3MkE3IFwiO2ZvcihrPTA7azx1Lmxlbmd0aDtrKyspaWYoYj11W2tdLnguZ2V0VGltZT91W2tdLnguZ2V0VGltZSgpOnVba10ueCxcbiEoYjxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxiPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiZcIm51bWJlclwiPT09dHlwZW9mIHVba10ueSl7bj1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYik7bj1uLWEucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCpzLzIrYS5pbmRleCpzPDwwO3ZhciB4PW4rczw8MCx6O2lmKGEuYXhpc1kubG9nYXJpdGhtaWN8fGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA8dVtrXS55KXRbYl09dVtrXS55Kyh0W2JdP3RbYl06MCksMDx0W2JdJiYoej1mW2JdP2ZbYl06cSxmW2JdPW09YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHRbYl0pKTtlbHNlIGlmKGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA+PXVba10ueSlDW2JdPXVba10ueSsoQ1tiXT9DW2JdOjApLG09bFtiXT9sW2JdOlxucSxsW2JdPXo9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKENbYl0pO2Vsc2UgaWYobT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodVtrXS55KSwwPD11W2tdLnkpe3ZhciBIPWZbYl0/ZltiXTowO3o9cStIO20rPUg7ZltiXT1IKyhtLXopfWVsc2UgSD1sW2JdP2xbYl06MCx6PW0tSCxtPXEtSCxsW2JdPUgrKG0teik7Yj11W2tdLmNvbG9yP3Vba10uY29sb3I6ci5fY29sb3JTZXRbayVyLl9jb2xvclNldC5sZW5ndGhdO1koYyxhLmF4aXNZLnJldmVyc2VkP206eixuLGEuYXhpc1kucmV2ZXJzZWQ/ejptLHgsYiwwLG51bGwscCwhMSwhMSwhMSxyLmZpbGxPcGFjaXR5KTtiPXIuZGF0YVBvaW50SWRzW2tdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbYl09e2lkOmIsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpoLGRhdGFQb2ludEluZGV4OmsseDE6eix5MTpuLHgyOm0seTI6eH07Yj1YKGIpO3cmJlkodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LFxueixuLG0seCxiLDAsbnVsbCwhMSwhMSwhMSwhMSk7KHVba10uaW5kZXhMYWJlbHx8ci5pbmRleExhYmVsfHx1W2tdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fHIuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInN0YWNrZWRCYXJcIixkYXRhUG9pbnQ6dVtrXSxkYXRhU2VyaWVzOnIscG9pbnQ6e3g6MDw9dVtrXS55P206eix5Om4rKHgtbikvMn0sZGlyZWN0aW9uOjA+dVtrXS55PT09YS5heGlzWS5yZXZlcnNlZD8xOi0xLGJvdW5kczp7eDE6TWF0aC5taW4oeixtKSx5MTpuLHgyOk1hdGgubWF4KHosbSkseTI6eH0sY29sb3I6Yn0pfX19dyYmKGQuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLFxudGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yy5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpkLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6TS54U2NhbGVBbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcuZWFzZU91dFF1YXJ0LGFuaW1hdGlvbkJhc2U6cTxhLmF4aXNZLmJvdW5kcy54MT9hLmF4aXNZLmJvdW5kcy54MTpxPmEuYXhpc1kuYm91bmRzLngyP2EuYXhpc1kuYm91bmRzLngyOnF9fX07cC5wcm90b3R5cGUucmVuZGVyU3RhY2tlZEJhcjEwMD1cbmZ1bmN0aW9uKGEpe3ZhciBkPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxjPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmQ7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBiPW51bGwsZT10aGlzLnBsb3RBcmVhLGY9W10sbD1bXSx0PVtdLEM9W10saz0wLG0sbixxPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGs9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MSxnPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuMTUqdGhpcy5oZWlnaHQ8PDAscz1hLmF4aXNYLmRhdGFJbmZvLm1pbkRpZmY7XG5pc0Zpbml0ZShzKXx8KHM9MC4zKk1hdGguYWJzKGEuYXhpc1gucmFuZ2UpKTtzPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS5oZWlnaHQqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocykvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocykvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUucGxvdFVuaXRzLmxlbmd0aCk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmaz5nJiYoaz1NYXRoLm1pbih0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpJbmZpbml0eSxnKSk7IXRoaXMuZGF0YVBvaW50TWF4V2lkdGgmJih0aGlzLmRhdGFQb2ludE1pbldpZHRoJiZnPGspJiYoZz1NYXRoLm1heCh0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDotSW5maW5pdHksaykpO3M8ayYmKHM9ayk7cz5nJiYocz1nKTtjLnNhdmUoKTt3JiZcbnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yy5iZWdpblBhdGgoKTtjLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2MuY2xpcCgpO3cmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2ZvcihnPTA7ZzxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtnKyspe3ZhciBoPWEuZGF0YVNlcmllc0luZGV4ZXNbZ10scj10aGlzLmRhdGFbaF0sdT1yLmRhdGFQb2ludHM7aWYoMDx1Lmxlbmd0aCl7dmFyIHA9NTxzJiZyLmJldmVsRW5hYmxlZD8hMDohMTtjLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIjtmb3Ioaz0wO2s8dS5sZW5ndGg7aysrKWlmKGI9dVtrXS54LmdldFRpbWU/dVtrXS54LmdldFRpbWUoKTp1W2tdLngsIShiPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fFxuYj5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4KSYmXCJudW1iZXJcIj09PXR5cGVvZiB1W2tdLnkpe249YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGIpO3ZhciB4O3g9MCE9PWEuZGF0YVBvaW50WVN1bXNbYl0/MTAwKih1W2tdLnkvYS5kYXRhUG9pbnRZU3Vtc1tiXSk6MDtuPW4tYS5wbG90VHlwZS5wbG90VW5pdHMubGVuZ3RoKnMvMithLmluZGV4KnM8PDA7dmFyIHo9bitzPDwwO2lmKGEuYXhpc1kubG9nYXJpdGhtaWN8fGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA8dVtrXS55KXt0W2JdPXgrKHRbYl0/dFtiXTowKTtpZigwPj10W2JdKWNvbnRpbnVlO3g9ZltiXT9mW2JdOnE7ZltiXT1tPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh0W2JdKX1lbHNlIGlmKGEuYXhpc1kuc2NhbGVCcmVha3MmJjA8YS5heGlzWS5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGgmJjA+PXVba10ueSlDW2JdPVxueCsoQ1tiXT9DW2JdOjApLG09bFtiXT9sW2JdOnEsbFtiXT14PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChDW2JdKTtlbHNlIGlmKG09YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHgpLDA8PXVba10ueSl7dmFyIEg9ZltiXT9mW2JdOjA7eD1xK0g7bSs9SDthLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aC0xPT09ZyYmMT49TWF0aC5hYnMoZS54Mi1tKSYmKG09ZS54Mik7ZltiXT1IKyhtLXgpfWVsc2UgSD1sW2JdP2xbYl06MCx4PW0tSCxtPXEtSCxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aC0xPT09ZyYmMT49TWF0aC5hYnMoZS54MS14KSYmKHg9ZS54MSksbFtiXT1IKyhtLXgpO2I9dVtrXS5jb2xvcj91W2tdLmNvbG9yOnIuX2NvbG9yU2V0W2slci5fY29sb3JTZXQubGVuZ3RoXTtZKGMsYS5heGlzWS5yZXZlcnNlZD9tOngsbixhLmF4aXNZLnJldmVyc2VkP3g6bSx6LGIsMCxudWxsLHAsITEsITEsITEsci5maWxsT3BhY2l0eSk7Yj1yLmRhdGFQb2ludElkc1trXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2JdPVxue2lkOmIsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpoLGRhdGFQb2ludEluZGV4OmsseDE6eCx5MTpuLHgyOm0seTI6en07Yj1YKGIpO3cmJlkodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LHgsbixtLHosYiwwLG51bGwsITEsITEsITEsITEpOyh1W2tdLmluZGV4TGFiZWx8fHIuaW5kZXhMYWJlbHx8dVtrXS5pbmRleExhYmVsRm9ybWF0dGVyfHxyLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzdGFja2VkQmFyMTAwXCIsZGF0YVBvaW50OnVba10sZGF0YVNlcmllczpyLHBvaW50Ont4OjA8PXVba10ueT9tOngseTpuKyh6LW4pLzJ9LGRpcmVjdGlvbjowPnVba10ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxib3VuZHM6e3gxOk1hdGgubWluKHgsbSkseTE6bix4MjpNYXRoLm1heCh4LG0pLHkyOnp9LGNvbG9yOmJ9KX19fXcmJihkLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLFxudGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2MucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0ueFNjYWxlQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VPdXRRdWFydCxcbmFuaW1hdGlvbkJhc2U6cTxhLmF4aXNZLmJvdW5kcy54MT9hLmF4aXNZLmJvdW5kcy54MTpxPmEuYXhpc1kuYm91bmRzLngyP2EuYXhpc1kuYm91bmRzLngyOnF9fX07cC5wcm90b3R5cGUucmVuZGVyQXJlYT1mdW5jdGlvbihhKXt2YXIgZCxjO2Z1bmN0aW9uIGIoKXtIJiYoMDxnLmxpbmVUaGlja25lc3MmJmYuc3Ryb2tlKCksYS5heGlzWS5sb2dhcml0aG1pY3x8MD49YS5heGlzWS52aWV3cG9ydE1pbmltdW0mJjA8PWEuYXhpc1kudmlld3BvcnRNYXhpbXVtP3o9eDowPmEuYXhpc1kudmlld3BvcnRNYXhpbXVtP3o9dC55MTowPGEuYXhpc1kudmlld3BvcnRNaW5pbXVtJiYoej14KSxmLmxpbmVUbyhyLHopLGYubGluZVRvKEgueCx6KSxmLmNsb3NlUGF0aCgpLGYuZ2xvYmFsQWxwaGE9Zy5maWxsT3BhY2l0eSxmLmZpbGwoKSxmLmdsb2JhbEFscGhhPTEsdyYmKGwubGluZVRvKHIseiksbC5saW5lVG8oSC54LHopLGwuY2xvc2VQYXRoKCksbC5maWxsKCkpLGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8ocixcbnUpLGwuYmVnaW5QYXRoKCksbC5tb3ZlVG8ocix1KSxIPXt4OnIseTp1fSl9dmFyIGU9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGY9dz90aGlzLl9wcmVSZW5kZXJDdHg6ZTtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGw9dGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LHQ9YS5heGlzWS5saW5lQ29vcmRpbmF0ZXMsQz1bXSxrPXRoaXMucGxvdEFyZWEsbTtmLnNhdmUoKTt3JiZsLnNhdmUoKTtmLmJlZ2luUGF0aCgpO2YucmVjdChrLngxLGsueTEsay53aWR0aCxrLmhlaWdodCk7Zi5jbGlwKCk7dyYmKGwuYmVnaW5QYXRoKCksbC5yZWN0KGsueDEsay55MSxrLndpZHRoLGsuaGVpZ2h0KSxsLmNsaXAoKSk7Zm9yKHZhciBuPTA7bjxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtuKyspe3ZhciBxPWEuZGF0YVNlcmllc0luZGV4ZXNbbl0sZz10aGlzLmRhdGFbcV0scz1nLmRhdGFQb2ludHMsQz1nLmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbQ109XG57b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6cX07Qz1YKEMpO2wuZmlsbFN0eWxlPUM7Qz1bXTtkPSEwO3ZhciBoPTAscix1LHAseD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoYS5heGlzWS5sb2dhcml0aG1pYz9hLmF4aXNZLnZpZXdwb3J0TWluaW11bTowKSx6LEg9bnVsbDtpZigwPHMubGVuZ3RoKXt2YXIgRD1nLl9jb2xvclNldFtoJWcuX2NvbG9yU2V0Lmxlbmd0aF0sdj1nLmxpbmVDb2xvcj1nLm9wdGlvbnMubGluZUNvbG9yfHxELEE9djtmLmZpbGxTdHlsZT1EO2Yuc3Ryb2tlU3R5bGU9djtmLmxpbmVXaWR0aD1nLmxpbmVUaGlja25lc3M7Yz1cInNvbGlkXCI7aWYoZi5zZXRMaW5lRGFzaCl7dmFyIEw9SihnLm51bGxEYXRhTGluZURhc2hUeXBlLGcubGluZVRoaWNrbmVzcyk7Yz1nLmxpbmVEYXNoVHlwZTt2YXIgUz1KKGMsZy5saW5lVGhpY2tuZXNzKTtmLnNldExpbmVEYXNoKFMpfWZvcih2YXIgZWE9ITA7aDxzLmxlbmd0aDtoKyspaWYocD1zW2hdLnguZ2V0VGltZT9cbnNbaF0ueC5nZXRUaW1lKCk6c1toXS54LCEocDxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxwPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighZy5jb25uZWN0TnVsbERhdGF8fCFlYSkpKWlmKFwibnVtYmVyXCIhPT10eXBlb2Ygc1toXS55KWcuY29ubmVjdE51bGxEYXRhfHwoZWF8fGQpfHxiKCksZWE9ITA7ZWxzZXtyPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChwKTt1PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChzW2hdLnkpO2R8fGVhPyghZCYmZy5jb25uZWN0TnVsbERhdGE/KGYuc2V0TGluZURhc2gmJihnLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fGM9PT1nLmxpbmVEYXNoVHlwZSYmZy5saW5lRGFzaFR5cGUhPT1nLm51bGxEYXRhTGluZURhc2hUeXBlKSYmKGQ9cixjPXUscj1tLngsdT1tLnksYigpLGYubW92ZVRvKG0ueCxtLnkpLHI9ZCx1PWMsSD1tLGM9Zy5udWxsRGF0YUxpbmVEYXNoVHlwZSxmLnNldExpbmVEYXNoKEwpKSxmLmxpbmVUbyhyLFxudSksdyYmbC5saW5lVG8ocix1KSk6KGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8ocix1KSx3JiYobC5iZWdpblBhdGgoKSxsLm1vdmVUbyhyLHUpKSxIPXt4OnIseTp1fSksZWE9ZD0hMSk6KGYubGluZVRvKHIsdSksdyYmbC5saW5lVG8ocix1KSwwPT1oJTI1MCYmYigpKTttPXt4OnIseTp1fTtoPHMubGVuZ3RoLTEmJihBIT09KHNbaF0ubGluZUNvbG9yfHx2KXx8YyE9PShzW2hdLmxpbmVEYXNoVHlwZXx8Zy5saW5lRGFzaFR5cGUpKSYmKGIoKSxBPXNbaF0ubGluZUNvbG9yfHx2LGYuc3Ryb2tlU3R5bGU9QSxmLnNldExpbmVEYXNoJiYoc1toXS5saW5lRGFzaFR5cGU/KGM9c1toXS5saW5lRGFzaFR5cGUsZi5zZXRMaW5lRGFzaChKKGMsZy5saW5lVGhpY2tuZXNzKSkpOihjPWcubGluZURhc2hUeXBlLGYuc2V0TGluZURhc2goUykpKSk7dmFyICQ9Zy5kYXRhUG9pbnRJZHNbaF07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFskXT17aWQ6JCxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsXG5kYXRhU2VyaWVzSW5kZXg6cSxkYXRhUG9pbnRJbmRleDpoLHgxOnIseTE6dX07MCE9PXNbaF0ubWFya2VyU2l6ZSYmKDA8c1toXS5tYXJrZXJTaXplfHwwPGcubWFya2VyU2l6ZSkmJihwPWcuZ2V0TWFya2VyUHJvcGVydGllcyhoLHIsdSxmKSxDLnB1c2gocCksJD1YKCQpLHcmJkMucHVzaCh7eDpyLHk6dSxjdHg6bCx0eXBlOnAudHlwZSxzaXplOnAuc2l6ZSxjb2xvcjokLGJvcmRlckNvbG9yOiQsYm9yZGVyVGhpY2tuZXNzOnAuYm9yZGVyVGhpY2tuZXNzfSkpOyhzW2hdLmluZGV4TGFiZWx8fGcuaW5kZXhMYWJlbHx8c1toXS5pbmRleExhYmVsRm9ybWF0dGVyfHxnLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJhcmVhXCIsZGF0YVBvaW50OnNbaF0sZGF0YVNlcmllczpnLHBvaW50Ont4OnIseTp1fSxkaXJlY3Rpb246MD5zW2hdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsY29sb3I6RH0pfWIoKTtXLmRyYXdNYXJrZXJzKEMpfX13JiZcbihlLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGYuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmYuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZmLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGYuY2xlYXJSZWN0KGsueDEsay55MSxrLndpZHRoLGsuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtmLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmUsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLnhDbGlwQW5pbWF0aW9uLFxuZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcubGluZWFyLGFuaW1hdGlvbkJhc2U6MH19fTtwLnByb3RvdHlwZS5yZW5kZXJTcGxpbmVBcmVhPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGQoKXt2YXIgYz12KHksMik7aWYoMDxjLmxlbmd0aCl7aWYoMDxtLmxpbmVUaGlja25lc3Mpe2IuYmVnaW5QYXRoKCk7Yi5tb3ZlVG8oY1swXS54LGNbMF0ueSk7Y1swXS5uZXdTdHJva2VTdHlsZSYmKGIuc3Ryb2tlU3R5bGU9Y1swXS5uZXdTdHJva2VTdHlsZSk7Y1swXS5uZXdMaW5lRGFzaEFycmF5JiZiLnNldExpbmVEYXNoKGNbMF0ubmV3TGluZURhc2hBcnJheSk7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aC0zO2QrPTMpaWYoYi5iZXppZXJDdXJ2ZVRvKGNbZCsxXS54LGNbZCsxXS55LGNbZCsyXS54LGNbZCsyXS55LGNbZCszXS54LGNbZCszXS55KSx3JiZlLmJlemllckN1cnZlVG8oY1tkKzFdLngsY1tkKzFdLnksY1tkKzJdLngsY1tkKzJdLnksY1tkKzNdLngsY1tkKzNdLnkpLGNbZCszXS5uZXdTdHJva2VTdHlsZXx8XG5jW2QrM10ubmV3TGluZURhc2hBcnJheSliLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oY1tkKzNdLngsY1tkKzNdLnkpLGNbZCszXS5uZXdTdHJva2VTdHlsZSYmKGIuc3Ryb2tlU3R5bGU9Y1tkKzNdLm5ld1N0cm9rZVN0eWxlKSxjW2QrM10ubmV3TGluZURhc2hBcnJheSYmYi5zZXRMaW5lRGFzaChjW2QrM10ubmV3TGluZURhc2hBcnJheSk7Yi5zdHJva2UoKX1iLmJlZ2luUGF0aCgpO2IubW92ZVRvKGNbMF0ueCxjWzBdLnkpO3cmJihlLmJlZ2luUGF0aCgpLGUubW92ZVRvKGNbMF0ueCxjWzBdLnkpKTtmb3IoZD0wO2Q8Yy5sZW5ndGgtMztkKz0zKWIuYmV6aWVyQ3VydmVUbyhjW2QrMV0ueCxjW2QrMV0ueSxjW2QrMl0ueCxjW2QrMl0ueSxjW2QrM10ueCxjW2QrM10ueSksdyYmZS5iZXppZXJDdXJ2ZVRvKGNbZCsxXS54LGNbZCsxXS55LGNbZCsyXS54LGNbZCsyXS55LGNbZCszXS54LGNbZCszXS55KTthLmF4aXNZLmxvZ2FyaXRobWljfHwwPj1hLmF4aXNZLnZpZXdwb3J0TWluaW11bSYmXG4wPD1hLmF4aXNZLnZpZXdwb3J0TWF4aW11bT9wPXI6MD5hLmF4aXNZLnZpZXdwb3J0TWF4aW11bT9wPWYueTE6MDxhLmF4aXNZLnZpZXdwb3J0TWluaW11bSYmKHA9cik7dT17eDpjWzBdLngseTpjWzBdLnl9O2IubGluZVRvKGNbYy5sZW5ndGgtMV0ueCxwKTtiLmxpbmVUbyh1LngscCk7Yi5jbG9zZVBhdGgoKTtiLmdsb2JhbEFscGhhPW0uZmlsbE9wYWNpdHk7Yi5maWxsKCk7Yi5nbG9iYWxBbHBoYT0xO3cmJihlLmxpbmVUbyhjW2MubGVuZ3RoLTFdLngscCksZS5saW5lVG8odS54LHApLGUuY2xvc2VQYXRoKCksZS5maWxsKCkpfX12YXIgYz1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj13P3RoaXMuX3ByZVJlbmRlckN0eDpjO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgZT10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZj1hLmF4aXNZLmxpbmVDb29yZGluYXRlcyxsPVtdLHQ9dGhpcy5wbG90QXJlYTtiLnNhdmUoKTt3JiZcbmUuc2F2ZSgpO2IuYmVnaW5QYXRoKCk7Yi5yZWN0KHQueDEsdC55MSx0LndpZHRoLHQuaGVpZ2h0KTtiLmNsaXAoKTt3JiYoZS5iZWdpblBhdGgoKSxlLnJlY3QodC54MSx0LnkxLHQud2lkdGgsdC5oZWlnaHQpLGUuY2xpcCgpKTtmb3IodmFyIGg9MDtoPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2grKyl7dmFyIGs9YS5kYXRhU2VyaWVzSW5kZXhlc1toXSxtPXRoaXMuZGF0YVtrXSxuPW0uZGF0YVBvaW50cyxsPW0uaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtsXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6a307bD1YKGwpO2UuZmlsbFN0eWxlPWw7dmFyIGw9W10scT0wLGcscyxyPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLHAsdT1udWxsLHk9W107aWYoMDxuLmxlbmd0aCl7dmFyIHg9bS5fY29sb3JTZXRbcSVtLl9jb2xvclNldC5sZW5ndGhdLFxuej1tLmxpbmVDb2xvcj1tLm9wdGlvbnMubGluZUNvbG9yfHx4LEg9ejtiLmZpbGxTdHlsZT14O2Iuc3Ryb2tlU3R5bGU9ejtiLmxpbmVXaWR0aD1tLmxpbmVUaGlja25lc3M7dmFyIEQ9XCJzb2xpZFwiO2lmKGIuc2V0TGluZURhc2gpe3ZhciBBPUoobS5udWxsRGF0YUxpbmVEYXNoVHlwZSxtLmxpbmVUaGlja25lc3MpLEQ9bS5saW5lRGFzaFR5cGUsQj1KKEQsbS5saW5lVGhpY2tuZXNzKTtiLnNldExpbmVEYXNoKEIpfWZvcihzPSExO3E8bi5sZW5ndGg7cSsrKWlmKGc9bltxXS54LmdldFRpbWU/bltxXS54LmdldFRpbWUoKTpuW3FdLngsIShnPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fGc+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCYmKCFtLmNvbm5lY3ROdWxsRGF0YXx8IXMpKSlpZihcIm51bWJlclwiIT09dHlwZW9mIG5bcV0ueSkwPHEmJiFzJiYobS5jb25uZWN0TnVsbERhdGE/Yi5zZXRMaW5lRGFzaCYmKDA8eS5sZW5ndGgmJihtLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fFxuIW5bcS0xXS5saW5lRGFzaFR5cGUpKSYmKHlbeS5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1BLEQ9bS5udWxsRGF0YUxpbmVEYXNoVHlwZSk6KGQoKSx5PVtdKSkscz0hMDtlbHNle2c9YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGcpO3M9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKG5bcV0ueSk7dmFyIEw9bS5kYXRhUG9pbnRJZHNbcV07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtMXT17aWQ6TCxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OmssZGF0YVBvaW50SW5kZXg6cSx4MTpnLHkxOnN9O3lbeS5sZW5ndGhdPXt4OmcseTpzfTtxPG4ubGVuZ3RoLTEmJihIIT09KG5bcV0ubGluZUNvbG9yfHx6KXx8RCE9PShuW3FdLmxpbmVEYXNoVHlwZXx8bS5saW5lRGFzaFR5cGUpKSYmKEg9bltxXS5saW5lQ29sb3J8fHoseVt5Lmxlbmd0aC0xXS5uZXdTdHJva2VTdHlsZT1ILGIuc2V0TGluZURhc2gmJihuW3FdLmxpbmVEYXNoVHlwZT8oRD1cbm5bcV0ubGluZURhc2hUeXBlLHlbeS5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1KKEQsbS5saW5lVGhpY2tuZXNzKSk6KEQ9bS5saW5lRGFzaFR5cGUseVt5Lmxlbmd0aC0xXS5uZXdMaW5lRGFzaEFycmF5PUIpKSk7aWYoMCE9PW5bcV0ubWFya2VyU2l6ZSYmKDA8bltxXS5tYXJrZXJTaXplfHwwPG0ubWFya2VyU2l6ZSkpe3ZhciBTPW0uZ2V0TWFya2VyUHJvcGVydGllcyhxLGcscyxiKTtsLnB1c2goUyk7TD1YKEwpO3cmJmwucHVzaCh7eDpnLHk6cyxjdHg6ZSx0eXBlOlMudHlwZSxzaXplOlMuc2l6ZSxjb2xvcjpMLGJvcmRlckNvbG9yOkwsYm9yZGVyVGhpY2tuZXNzOlMuYm9yZGVyVGhpY2tuZXNzfSl9KG5bcV0uaW5kZXhMYWJlbHx8bS5pbmRleExhYmVsfHxuW3FdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fG0uaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInNwbGluZUFyZWFcIixkYXRhUG9pbnQ6bltxXSxkYXRhU2VyaWVzOm0sXG5wb2ludDp7eDpnLHk6c30sZGlyZWN0aW9uOjA+bltxXS55PT09YS5heGlzWS5yZXZlcnNlZD8xOi0xLGNvbG9yOnh9KTtzPSExfWQoKTtXLmRyYXdNYXJrZXJzKGwpfX13JiYoYy5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmNsZWFyUmVjdCh0LngxLHQueTEsdC53aWR0aCx0LmhlaWdodCksXG50aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtiLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmMsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLnhDbGlwQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmxpbmVhcixhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyU3RlcEFyZWE9ZnVuY3Rpb24oYSl7dmFyIGQsYztmdW5jdGlvbiBiKCl7SCYmKDA8Zy5saW5lVGhpY2tuZXNzJiZmLnN0cm9rZSgpLGEuYXhpc1kubG9nYXJpdGhtaWN8fDA+PWEuYXhpc1kudmlld3BvcnRNaW5pbXVtJiYwPD1hLmF4aXNZLnZpZXdwb3J0TWF4aW11bT96PXg6MD5hLmF4aXNZLnZpZXdwb3J0TWF4aW11bT96PXQueTE6MDxhLmF4aXNZLnZpZXdwb3J0TWluaW11bSYmKHo9eCksZi5saW5lVG8ocCx6KSxmLmxpbmVUbyhILngseiksZi5jbG9zZVBhdGgoKSxmLmdsb2JhbEFscGhhPWcuZmlsbE9wYWNpdHksZi5maWxsKCksZi5nbG9iYWxBbHBoYT1cbjEsdyYmKGwubGluZVRvKHAseiksbC5saW5lVG8oSC54LHopLGwuY2xvc2VQYXRoKCksbC5maWxsKCkpLGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8ocCx1KSxsLmJlZ2luUGF0aCgpLGwubW92ZVRvKHAsdSksSD17eDpwLHk6dX0pfXZhciBlPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxmPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmU7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBsPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCx0PWEuYXhpc1kubGluZUNvb3JkaW5hdGVzLGg9W10saz10aGlzLnBsb3RBcmVhLG07Zi5zYXZlKCk7dyYmbC5zYXZlKCk7Zi5iZWdpblBhdGgoKTtmLnJlY3Qoay54MSxrLnkxLGsud2lkdGgsay5oZWlnaHQpO2YuY2xpcCgpO3cmJihsLmJlZ2luUGF0aCgpLGwucmVjdChrLngxLGsueTEsay53aWR0aCxrLmhlaWdodCksbC5jbGlwKCkpO2Zvcih2YXIgbj0wO248YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7bisrKXt2YXIgcT1cbmEuZGF0YVNlcmllc0luZGV4ZXNbbl0sZz10aGlzLmRhdGFbcV0scz1nLmRhdGFQb2ludHMsaD1nLmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbaF09e29iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsZGF0YVNlcmllc0luZGV4OnF9O2g9WChoKTtsLmZpbGxTdHlsZT1oO2g9W107ZD0hMDt2YXIgcj0wLHAsdSx5LHg9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGEuYXhpc1kubG9nYXJpdGhtaWM/YS5heGlzWS52aWV3cG9ydE1pbmltdW06MCkseixIPW51bGw7Yz0hMTtpZigwPHMubGVuZ3RoKXt2YXIgRD1nLl9jb2xvclNldFtyJWcuX2NvbG9yU2V0Lmxlbmd0aF0sdj1nLmxpbmVDb2xvcj1nLm9wdGlvbnMubGluZUNvbG9yfHxELEE9djtmLmZpbGxTdHlsZT1EO2Yuc3Ryb2tlU3R5bGU9djtmLmxpbmVXaWR0aD1nLmxpbmVUaGlja25lc3M7dmFyIEw9XCJzb2xpZFwiO2lmKGYuc2V0TGluZURhc2gpe3ZhciBTPUooZy5udWxsRGF0YUxpbmVEYXNoVHlwZSxnLmxpbmVUaGlja25lc3MpLFxuTD1nLmxpbmVEYXNoVHlwZSxCPUooTCxnLmxpbmVUaGlja25lc3MpO2Yuc2V0TGluZURhc2goQil9Zm9yKDtyPHMubGVuZ3RoO3IrKylpZih5PXNbcl0ueC5nZXRUaW1lP3Nbcl0ueC5nZXRUaW1lKCk6c1tyXS54LCEoeTxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx5PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighZy5jb25uZWN0TnVsbERhdGF8fCFjKSkpe3ZhciAkPXU7XCJudW1iZXJcIiE9PXR5cGVvZiBzW3JdLnk/KGcuY29ubmVjdE51bGxEYXRhfHwoY3x8ZCl8fGIoKSxjPSEwKToocD1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeSksdT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoc1tyXS55KSxkfHxjPyghZCYmZy5jb25uZWN0TnVsbERhdGE/KGYuc2V0TGluZURhc2gmJihnLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fEw9PT1nLmxpbmVEYXNoVHlwZSYmZy5saW5lRGFzaFR5cGUhPT1nLm51bGxEYXRhTGluZURhc2hUeXBlKSYmKGQ9cCxcbmM9dSxwPW0ueCx1PW0ueSxiKCksZi5tb3ZlVG8obS54LG0ueSkscD1kLHU9YyxIPW0sTD1nLm51bGxEYXRhTGluZURhc2hUeXBlLGYuc2V0TGluZURhc2goUykpLGYubGluZVRvKHAsJCksZi5saW5lVG8ocCx1KSx3JiYobC5saW5lVG8ocCwkKSxsLmxpbmVUbyhwLHUpKSk6KGYuYmVnaW5QYXRoKCksZi5tb3ZlVG8ocCx1KSx3JiYobC5iZWdpblBhdGgoKSxsLm1vdmVUbyhwLHUpKSxIPXt4OnAseTp1fSksYz1kPSExKTooZi5saW5lVG8ocCwkKSx3JiZsLmxpbmVUbyhwLCQpLGYubGluZVRvKHAsdSksdyYmbC5saW5lVG8ocCx1KSwwPT1yJTI1MCYmYigpKSxtPXt4OnAseTp1fSxyPHMubGVuZ3RoLTEmJihBIT09KHNbcl0ubGluZUNvbG9yfHx2KXx8TCE9PShzW3JdLmxpbmVEYXNoVHlwZXx8Zy5saW5lRGFzaFR5cGUpKSYmKGIoKSxBPXNbcl0ubGluZUNvbG9yfHx2LGYuc3Ryb2tlU3R5bGU9QSxmLnNldExpbmVEYXNoJiYoc1tyXS5saW5lRGFzaFR5cGU/KEw9c1tyXS5saW5lRGFzaFR5cGUsXG5mLnNldExpbmVEYXNoKEooTCxnLmxpbmVUaGlja25lc3MpKSk6KEw9Zy5saW5lRGFzaFR5cGUsZi5zZXRMaW5lRGFzaChCKSkpKSx5PWcuZGF0YVBvaW50SWRzW3JdLHRoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbeV09e2lkOnksb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpxLGRhdGFQb2ludEluZGV4OnIseDE6cCx5MTp1fSwwIT09c1tyXS5tYXJrZXJTaXplJiYoMDxzW3JdLm1hcmtlclNpemV8fDA8Zy5tYXJrZXJTaXplKSYmKCQ9Zy5nZXRNYXJrZXJQcm9wZXJ0aWVzKHIscCx1LGYpLGgucHVzaCgkKSx5PVgoeSksdyYmaC5wdXNoKHt4OnAseTp1LGN0eDpsLHR5cGU6JC50eXBlLHNpemU6JC5zaXplLGNvbG9yOnksYm9yZGVyQ29sb3I6eSxib3JkZXJUaGlja25lc3M6JC5ib3JkZXJUaGlja25lc3N9KSksKHNbcl0uaW5kZXhMYWJlbHx8Zy5pbmRleExhYmVsfHxzW3JdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGcuaW5kZXhMYWJlbEZvcm1hdHRlcikmJlxudGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwic3RlcEFyZWFcIixkYXRhUG9pbnQ6c1tyXSxkYXRhU2VyaWVzOmcscG9pbnQ6e3g6cCx5OnV9LGRpcmVjdGlvbjowPnNbcl0ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxjb2xvcjpEfSkpfWIoKTtXLmRyYXdNYXJrZXJzKGgpfX13JiYoZS5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxmLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZmLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmZi5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLFxuMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGYuY2xlYXJSZWN0KGsueDEsay55MSxrLndpZHRoLGsuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtmLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmUsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLnhDbGlwQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmxpbmVhcixhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyU3RhY2tlZEFyZWE9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZCgpe2lmKCEoMT5rLmxlbmd0aCkpe2ZvcigwPEQubGluZVRoaWNrbmVzcyYmYi5zdHJva2UoKTswPGsubGVuZ3RoOyl7dmFyIGE9ay5wb3AoKTtiLmxpbmVUbyhhLngsYS55KTt3JiZwLmxpbmVUbyhhLngsYS55KX1iLmNsb3NlUGF0aCgpO2IuZ2xvYmFsQWxwaGE9RC5maWxsT3BhY2l0eTtiLmZpbGwoKTtiLmdsb2JhbEFscGhhPTE7Yi5iZWdpblBhdGgoKTt3JiYocC5jbG9zZVBhdGgoKSxcbnAuZmlsbCgpLHAuYmVnaW5QYXRoKCkpO2s9W119fXZhciBjPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxiPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmM7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBlPW51bGwsZj1udWxsLGw9W10sdD10aGlzLnBsb3RBcmVhLGg9W10saz1bXSxtPVtdLG49W10scT0wLGcscyxyPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLHA9dGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LHUseSx4O3cmJnAuYmVnaW5QYXRoKCk7Yi5zYXZlKCk7dyYmcC5zYXZlKCk7Yi5iZWdpblBhdGgoKTtiLnJlY3QodC54MSx0LnkxLHQud2lkdGgsdC5oZWlnaHQpO2IuY2xpcCgpO3cmJihwLmJlZ2luUGF0aCgpLHAucmVjdCh0LngxLHQueTEsdC53aWR0aCx0LmhlaWdodCkscC5jbGlwKCkpO2Zvcih2YXIgZT1bXSx6PTA7ejxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt6Kyspe3ZhciBIPVxuYS5kYXRhU2VyaWVzSW5kZXhlc1t6XSxEPXRoaXMuZGF0YVtIXSx2PUQuZGF0YVBvaW50cztELmRhdGFQb2ludEluZGV4ZXM9W107Zm9yKHE9MDtxPHYubGVuZ3RoO3ErKylIPXZbcV0ueC5nZXRUaW1lP3ZbcV0ueC5nZXRUaW1lKCk6dltxXS54LEQuZGF0YVBvaW50SW5kZXhlc1tIXT1xLGVbSF18fChtLnB1c2goSCksZVtIXT0hMCk7bS5zb3J0KFJhKX1mb3Ioej0wO3o8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7eisrKXtIPWEuZGF0YVNlcmllc0luZGV4ZXNbel07RD10aGlzLmRhdGFbSF07dj1ELmRhdGFQb2ludHM7eT0hMDtrPVtdO3E9RC5pZDt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW3FdPXtvYmplY3RUeXBlOlwiZGF0YVNlcmllc1wiLGRhdGFTZXJpZXNJbmRleDpIfTtxPVgocSk7cC5maWxsU3R5bGU9cTtpZigwPG0ubGVuZ3RoKXt2YXIgZT1ELl9jb2xvclNldFswXSxBPUQubGluZUNvbG9yPUQub3B0aW9ucy5saW5lQ29sb3J8fGUsTD1BO2IuZmlsbFN0eWxlPWU7XG5iLnN0cm9rZVN0eWxlPUE7Yi5saW5lV2lkdGg9RC5saW5lVGhpY2tuZXNzO3g9XCJzb2xpZFwiO2lmKGIuc2V0TGluZURhc2gpe3ZhciBTPUooRC5udWxsRGF0YUxpbmVEYXNoVHlwZSxELmxpbmVUaGlja25lc3MpO3g9RC5saW5lRGFzaFR5cGU7dmFyIEI9Sih4LEQubGluZVRoaWNrbmVzcyk7Yi5zZXRMaW5lRGFzaChCKX1mb3IodmFyICQ9ITAscT0wO3E8bS5sZW5ndGg7cSsrKXt2YXIgZj1tW3FdLGdhPW51bGwsZ2E9MDw9RC5kYXRhUG9pbnRJbmRleGVzW2ZdP3ZbRC5kYXRhUG9pbnRJbmRleGVzW2ZdXTp7eDpmLHk6bnVsbH07aWYoIShmPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fGY+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCYmKCFELmNvbm5lY3ROdWxsRGF0YXx8ISQpKSlpZihcIm51bWJlclwiIT09dHlwZW9mIGdhLnkpRC5jb25uZWN0TnVsbERhdGF8fCgkfHx5KXx8ZCgpLCQ9ITA7ZWxzZXtnPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChmKTt2YXIgbmE9XG5oW2ZdP2hbZl06MDtpZihhLmF4aXNZLmxvZ2FyaXRobWljfHxhLmF4aXNZLnNjYWxlQnJlYWtzJiYwPGEuYXhpc1kuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoKXtuW2ZdPWdhLnkrKG5bZl0/bltmXTowKTtpZigwPj1uW2ZdJiZhLmF4aXNZLmxvZ2FyaXRobWljKWNvbnRpbnVlO3M9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKG5bZl0pfWVsc2Ugcz1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoZ2EueSkscy09bmE7ay5wdXNoKHt4OmcseTpyLW5hfSk7aFtmXT1yLXM7eXx8JD8oIXkmJkQuY29ubmVjdE51bGxEYXRhPyhiLnNldExpbmVEYXNoJiYoRC5vcHRpb25zLm51bGxEYXRhTGluZURhc2hUeXBlfHx4PT09RC5saW5lRGFzaFR5cGUmJkQubGluZURhc2hUeXBlIT09RC5udWxsRGF0YUxpbmVEYXNoVHlwZSkmJih5PWsucG9wKCkseD1rW2subGVuZ3RoLTFdLGQoKSxiLm1vdmVUbyh1LngsdS55KSxrLnB1c2goeCksay5wdXNoKHkpLHg9RC5udWxsRGF0YUxpbmVEYXNoVHlwZSxcbmIuc2V0TGluZURhc2goUykpLGIubGluZVRvKGcscyksdyYmcC5saW5lVG8oZyxzKSk6KGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oZyxzKSx3JiYocC5iZWdpblBhdGgoKSxwLm1vdmVUbyhnLHMpKSksJD15PSExKTooYi5saW5lVG8oZyxzKSx3JiZwLmxpbmVUbyhnLHMpLDA9PXElMjUwJiYoZCgpLGIubW92ZVRvKGcscyksdyYmcC5tb3ZlVG8oZyxzKSxrLnB1c2goe3g6Zyx5OnItbmF9KSkpO3U9e3g6Zyx5OnN9O3E8di5sZW5ndGgtMSYmKEwhPT0odltxXS5saW5lQ29sb3J8fEEpfHx4IT09KHZbcV0ubGluZURhc2hUeXBlfHxELmxpbmVEYXNoVHlwZSkpJiYoZCgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oZyxzKSxrLnB1c2goe3g6Zyx5OnItbmF9KSxMPXZbcV0ubGluZUNvbG9yfHxBLGIuc3Ryb2tlU3R5bGU9TCxiLnNldExpbmVEYXNoJiYodltxXS5saW5lRGFzaFR5cGU/KHg9dltxXS5saW5lRGFzaFR5cGUsYi5zZXRMaW5lRGFzaChKKHgsRC5saW5lVGhpY2tuZXNzKSkpOih4PVxuRC5saW5lRGFzaFR5cGUsYi5zZXRMaW5lRGFzaChCKSkpKTtpZigwPD1ELmRhdGFQb2ludEluZGV4ZXNbZl0pe3ZhciBrYT1ELmRhdGFQb2ludElkc1tELmRhdGFQb2ludEluZGV4ZXNbZl1dO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBba2FdPXtpZDprYSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OkgsZGF0YVBvaW50SW5kZXg6RC5kYXRhUG9pbnRJbmRleGVzW2ZdLHgxOmcseTE6c319MDw9RC5kYXRhUG9pbnRJbmRleGVzW2ZdJiYwIT09Z2EubWFya2VyU2l6ZSYmKDA8Z2EubWFya2VyU2l6ZXx8MDxELm1hcmtlclNpemUpJiYobmE9RC5nZXRNYXJrZXJQcm9wZXJ0aWVzKEQuZGF0YVBvaW50SW5kZXhlc1tmXSxnLHMsYiksbC5wdXNoKG5hKSxmPVgoa2EpLHcmJmwucHVzaCh7eDpnLHk6cyxjdHg6cCx0eXBlOm5hLnR5cGUsc2l6ZTpuYS5zaXplLGNvbG9yOmYsYm9yZGVyQ29sb3I6Zixib3JkZXJUaGlja25lc3M6bmEuYm9yZGVyVGhpY2tuZXNzfSkpO1xuKGdhLmluZGV4TGFiZWx8fEQuaW5kZXhMYWJlbHx8Z2EuaW5kZXhMYWJlbEZvcm1hdHRlcnx8RC5pbmRleExhYmVsRm9ybWF0dGVyKSYmdGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwic3RhY2tlZEFyZWFcIixkYXRhUG9pbnQ6Z2EsZGF0YVNlcmllczpELHBvaW50Ont4OmcseTpzfSxkaXJlY3Rpb246MD52W3FdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsY29sb3I6ZX0pfX1kKCk7Yi5tb3ZlVG8oZyxzKTt3JiZwLm1vdmVUbyhnLHMpfWRlbGV0ZSBELmRhdGFQb2ludEluZGV4ZXN9Vy5kcmF3TWFya2VycyhsKTt3JiYoYy5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxiLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cInNvdXJjZS1hdG9wXCIsYS5heGlzWC5tYXNrQ2FudmFzJiZiLmRyYXdJbWFnZShhLmF4aXNYLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmXG5iLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuY2xlYXJSZWN0KHQueDEsdC55MSx0LndpZHRoLHQuaGVpZ2h0KSxwLnJlc3RvcmUoKSk7Yi5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpjLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6TS54Q2xpcEFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpNLmVhc2luZy5saW5lYXIsYW5pbWF0aW9uQmFzZTowfX19O3AucHJvdG90eXBlLnJlbmRlclN0YWNrZWRBcmVhMTAwPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGQoKXtmb3IoMDxELmxpbmVUaGlja25lc3MmJmIuc3Ryb2tlKCk7MDxrLmxlbmd0aDspe3ZhciBhPWsucG9wKCk7Yi5saW5lVG8oYS54LGEueSk7dyYmeC5saW5lVG8oYS54LFxuYS55KX1iLmNsb3NlUGF0aCgpO2IuZ2xvYmFsQWxwaGE9RC5maWxsT3BhY2l0eTtiLmZpbGwoKTtiLmdsb2JhbEFscGhhPTE7Yi5iZWdpblBhdGgoKTt3JiYoeC5jbG9zZVBhdGgoKSx4LmZpbGwoKSx4LmJlZ2luUGF0aCgpKTtrPVtdfXZhciBjPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxiPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmM7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBlPW51bGwsZj1udWxsLGw9dGhpcy5wbG90QXJlYSx0PVtdLGg9W10saz1bXSxtPVtdLG49W10scT0wLGcscyxyLHAsdSx5PWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLHg9dGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4O2Iuc2F2ZSgpO3cmJnguc2F2ZSgpO2IuYmVnaW5QYXRoKCk7Yi5yZWN0KGwueDEsbC55MSxsLndpZHRoLGwuaGVpZ2h0KTtiLmNsaXAoKTt3JiYoeC5iZWdpblBhdGgoKSxcbngucmVjdChsLngxLGwueTEsbC53aWR0aCxsLmhlaWdodCkseC5jbGlwKCkpO2Zvcih2YXIgZT1bXSx6PTA7ejxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt6Kyspe3ZhciBIPWEuZGF0YVNlcmllc0luZGV4ZXNbel0sRD10aGlzLmRhdGFbSF0sdj1ELmRhdGFQb2ludHM7RC5kYXRhUG9pbnRJbmRleGVzPVtdO2ZvcihxPTA7cTx2Lmxlbmd0aDtxKyspSD12W3FdLnguZ2V0VGltZT92W3FdLnguZ2V0VGltZSgpOnZbcV0ueCxELmRhdGFQb2ludEluZGV4ZXNbSF09cSxlW0hdfHwobS5wdXNoKEgpLGVbSF09ITApO20uc29ydChSYSl9Zm9yKHo9MDt6PGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO3orKyl7SD1hLmRhdGFTZXJpZXNJbmRleGVzW3pdO0Q9dGhpcy5kYXRhW0hdO3Y9RC5kYXRhUG9pbnRzO3A9ITA7ZT1ELmlkO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbZV09e29iamVjdFR5cGU6XCJkYXRhU2VyaWVzXCIsZGF0YVNlcmllc0luZGV4Okh9O2U9WChlKTt4LmZpbGxTdHlsZT1cbmU7az1bXTtpZigwPG0ubGVuZ3RoKXt2YXIgZT1ELl9jb2xvclNldFtxJUQuX2NvbG9yU2V0Lmxlbmd0aF0sQT1ELmxpbmVDb2xvcj1ELm9wdGlvbnMubGluZUNvbG9yfHxlLEw9QTtiLmZpbGxTdHlsZT1lO2Iuc3Ryb2tlU3R5bGU9QTtiLmxpbmVXaWR0aD1ELmxpbmVUaGlja25lc3M7dT1cInNvbGlkXCI7aWYoYi5zZXRMaW5lRGFzaCl7dmFyIFM9SihELm51bGxEYXRhTGluZURhc2hUeXBlLEQubGluZVRoaWNrbmVzcyk7dT1ELmxpbmVEYXNoVHlwZTt2YXIgQj1KKHUsRC5saW5lVGhpY2tuZXNzKTtiLnNldExpbmVEYXNoKEIpfWZvcih2YXIgJD0hMCxxPTA7cTxtLmxlbmd0aDtxKyspe3ZhciBmPW1bcV0sZ2E9bnVsbCxnYT0wPD1ELmRhdGFQb2ludEluZGV4ZXNbZl0/dltELmRhdGFQb2ludEluZGV4ZXNbZl1dOnt4OmYseTpudWxsfTtpZighKGY8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8Zj5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4JiYoIUQuY29ubmVjdE51bGxEYXRhfHxcbiEkKSkpaWYoXCJudW1iZXJcIiE9PXR5cGVvZiBnYS55KUQuY29ubmVjdE51bGxEYXRhfHwoJHx8cCl8fGQoKSwkPSEwO2Vsc2V7dmFyIG5hO25hPTAhPT1hLmRhdGFQb2ludFlTdW1zW2ZdPzEwMCooZ2EueS9hLmRhdGFQb2ludFlTdW1zW2ZdKTowO2c9YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGYpO3ZhciBrYT1oW2ZdP2hbZl06MDtpZihhLmF4aXNZLmxvZ2FyaXRobWljfHxhLmF4aXNZLnNjYWxlQnJlYWtzJiYwPGEuYXhpc1kuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoKXtuW2ZdPW5hKyhuW2ZdP25bZl06MCk7aWYoMD49bltmXSYmYS5heGlzWS5sb2dhcml0aG1pYyljb250aW51ZTtzPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChuW2ZdKX1lbHNlIHM9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKG5hKSxzLT1rYTtrLnB1c2goe3g6Zyx5Onkta2F9KTtoW2ZdPXktcztwfHwkPyghcCYmRC5jb25uZWN0TnVsbERhdGE/KGIuc2V0TGluZURhc2gmJihELm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fFxudT09PUQubGluZURhc2hUeXBlJiZELmxpbmVEYXNoVHlwZSE9PUQubnVsbERhdGFMaW5lRGFzaFR5cGUpJiYocD1rLnBvcCgpLHU9a1trLmxlbmd0aC0xXSxkKCksYi5tb3ZlVG8oci54LHIueSksay5wdXNoKHUpLGsucHVzaChwKSx1PUQubnVsbERhdGFMaW5lRGFzaFR5cGUsYi5zZXRMaW5lRGFzaChTKSksYi5saW5lVG8oZyxzKSx3JiZ4LmxpbmVUbyhnLHMpKTooYi5iZWdpblBhdGgoKSxiLm1vdmVUbyhnLHMpLHcmJih4LmJlZ2luUGF0aCgpLHgubW92ZVRvKGcscykpKSwkPXA9ITEpOihiLmxpbmVUbyhnLHMpLHcmJngubGluZVRvKGcscyksMD09cSUyNTAmJihkKCksYi5tb3ZlVG8oZyxzKSx3JiZ4Lm1vdmVUbyhnLHMpLGsucHVzaCh7eDpnLHk6eS1rYX0pKSk7cj17eDpnLHk6c307cTx2Lmxlbmd0aC0xJiYoTCE9PSh2W3FdLmxpbmVDb2xvcnx8QSl8fHUhPT0odltxXS5saW5lRGFzaFR5cGV8fEQubGluZURhc2hUeXBlKSkmJihkKCksYi5iZWdpblBhdGgoKSxiLm1vdmVUbyhnLFxucyksay5wdXNoKHt4OmcseTp5LWthfSksTD12W3FdLmxpbmVDb2xvcnx8QSxiLnN0cm9rZVN0eWxlPUwsYi5zZXRMaW5lRGFzaCYmKHZbcV0ubGluZURhc2hUeXBlPyh1PXZbcV0ubGluZURhc2hUeXBlLGIuc2V0TGluZURhc2goSih1LEQubGluZVRoaWNrbmVzcykpKToodT1ELmxpbmVEYXNoVHlwZSxiLnNldExpbmVEYXNoKEIpKSkpO2lmKDA8PUQuZGF0YVBvaW50SW5kZXhlc1tmXSl7dmFyIEY9RC5kYXRhUG9pbnRJZHNbRC5kYXRhUG9pbnRJbmRleGVzW2ZdXTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW0ZdPXtpZDpGLG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6SCxkYXRhUG9pbnRJbmRleDpELmRhdGFQb2ludEluZGV4ZXNbZl0seDE6Zyx5MTpzfX0wPD1ELmRhdGFQb2ludEluZGV4ZXNbZl0mJjAhPT1nYS5tYXJrZXJTaXplJiYoMDxnYS5tYXJrZXJTaXplfHwwPEQubWFya2VyU2l6ZSkmJihrYT1ELmdldE1hcmtlclByb3BlcnRpZXMocSxnLHMsXG5iKSx0LnB1c2goa2EpLGY9WChGKSx3JiZ0LnB1c2goe3g6Zyx5OnMsY3R4OngsdHlwZTprYS50eXBlLHNpemU6a2Euc2l6ZSxjb2xvcjpmLGJvcmRlckNvbG9yOmYsYm9yZGVyVGhpY2tuZXNzOmthLmJvcmRlclRoaWNrbmVzc30pKTsoZ2EuaW5kZXhMYWJlbHx8RC5pbmRleExhYmVsfHxnYS5pbmRleExhYmVsRm9ybWF0dGVyfHxELmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZ0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJzdGFja2VkQXJlYTEwMFwiLGRhdGFQb2ludDpnYSxkYXRhU2VyaWVzOkQscG9pbnQ6e3g6Zyx5OnN9LGRpcmVjdGlvbjowPnZbcV0ueT09PWEuYXhpc1kucmV2ZXJzZWQ/MTotMSxjb2xvcjplfSl9fWQoKTtiLm1vdmVUbyhnLHMpO3cmJngubW92ZVRvKGcscyl9ZGVsZXRlIEQuZGF0YVBvaW50SW5kZXhlc31XLmRyYXdNYXJrZXJzKHQpO3cmJihjLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLFxuYi5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYi5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QobC54MSxsLnkxLGwud2lkdGgsbC5oZWlnaHQpLHgucmVzdG9yZSgpKTtiLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmMsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLnhDbGlwQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmxpbmVhcixhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyQnViYmxlPVxuZnVuY3Rpb24oYSl7dmFyIGQ9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGM9dz90aGlzLl9wcmVSZW5kZXJDdHg6ZDtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGI9dGhpcy5wbG90QXJlYSxlPTAsZixsO2Muc2F2ZSgpO3cmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yy5iZWdpblBhdGgoKTtjLnJlY3QoYi54MSxiLnkxLGIud2lkdGgsYi5oZWlnaHQpO2MuY2xpcCgpO3cmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoYi54MSxiLnkxLGIud2lkdGgsYi5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2Zvcih2YXIgdD0tSW5maW5pdHksaD1JbmZpbml0eSxrPTA7azxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtrKyspZm9yKHZhciBtPWEuZGF0YVNlcmllc0luZGV4ZXNba10sbj10aGlzLmRhdGFbbV0sXG5xPW4uZGF0YVBvaW50cyxnPTAsZT0wO2U8cS5sZW5ndGg7ZSsrKWY9cVtlXS5nZXRUaW1lP2Y9cVtlXS54LmdldFRpbWUoKTpmPXFbZV0ueCxmPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fGY+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBxW2VdLnp8fChnPXFbZV0ueixnPnQmJih0PWcpLGc8aCYmKGg9ZykpO2Zvcih2YXIgcz0yNSpNYXRoLlBJLHI9TWF0aC5tYXgoTWF0aC5wb3coMC4yNSpNYXRoLm1pbihiLmhlaWdodCxiLndpZHRoKS8yLDIpKk1hdGguUEkscyksaz0wO2s8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7aysrKWlmKG09YS5kYXRhU2VyaWVzSW5kZXhlc1trXSxuPXRoaXMuZGF0YVttXSxxPW4uZGF0YVBvaW50cywwPHEubGVuZ3RoKWZvcihjLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIixlPTA7ZTxxLmxlbmd0aDtlKyspaWYoZj1xW2VdLmdldFRpbWU/Zj1xW2VdLnguZ2V0VGltZSgpOmY9cVtlXS54LCEoZjxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxcbmY+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJlwibnVtYmVyXCI9PT10eXBlb2YgcVtlXS55KXtmPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChmKTtsPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChxW2VdLnkpO3ZhciBnPXFbZV0ueixwPTIqTWF0aC5tYXgoTWF0aC5zcXJ0KCh0PT09aD9yLzI6cysoci1zKS8odC1oKSooZy1oKSkvTWF0aC5QSSk8PDAsMSksZz1uLmdldE1hcmtlclByb3BlcnRpZXMoZSxjKTtnLnNpemU9cDtjLmdsb2JhbEFscGhhPW4uZmlsbE9wYWNpdHk7Vy5kcmF3TWFya2VyKGYsbCxjLGcudHlwZSxnLnNpemUsZy5jb2xvcixnLmJvcmRlckNvbG9yLGcuYm9yZGVyVGhpY2tuZXNzKTtjLmdsb2JhbEFscGhhPTE7dmFyIHU9bi5kYXRhUG9pbnRJZHNbZV07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFt1XT17aWQ6dSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4Om0sZGF0YVBvaW50SW5kZXg6ZSx4MTpmLHkxOmwsc2l6ZTpwfTtcbnA9WCh1KTt3JiZXLmRyYXdNYXJrZXIoZixsLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCxnLnR5cGUsZy5zaXplLHAscCxnLmJvcmRlclRoaWNrbmVzcyk7KHFbZV0uaW5kZXhMYWJlbHx8bi5pbmRleExhYmVsfHxxW2VdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fG4uaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcImJ1YmJsZVwiLGRhdGFQb2ludDpxW2VdLGRhdGFTZXJpZXM6bixwb2ludDp7eDpmLHk6bH0sZGlyZWN0aW9uOjEsYm91bmRzOnt4MTpmLWcuc2l6ZS8yLHkxOmwtZy5zaXplLzIseDI6ZitnLnNpemUvMix5MjpsK2cuc2l6ZS8yfSxjb2xvcjpudWxsfSl9dyYmKGQuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLFxuMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdChiLngxLGIueTEsYi53aWR0aCxiLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yy5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpkLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6TS5mYWRlSW5BbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcuZWFzZUluUXVhZCxhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyU2NhdHRlcj1mdW5jdGlvbihhKXt2YXIgZD1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsXG5jPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmQ7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBiPXRoaXMucGxvdEFyZWEsZT0wLGYsbDtjLnNhdmUoKTt3JiZ0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguc2F2ZSgpO2MuYmVnaW5QYXRoKCk7Yy5yZWN0KGIueDEsYi55MSxiLndpZHRoLGIuaGVpZ2h0KTtjLmNsaXAoKTt3JiYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmJlZ2luUGF0aCgpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZWN0KGIueDEsYi55MSxiLndpZHRoLGIuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguY2xpcCgpKTtmb3IodmFyIHQ9MDt0PGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO3QrKyl7dmFyIGg9YS5kYXRhU2VyaWVzSW5kZXhlc1t0XSxrPXRoaXMuZGF0YVtoXSxtPWsuZGF0YVBvaW50cztpZigwPG0ubGVuZ3RoKXtjLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIjtNYXRoLnBvdygwLjMqTWF0aC5taW4oYi5oZWlnaHQsXG5iLndpZHRoKS8yLDIpO2Zvcih2YXIgbj0wLHE9MCxlPTA7ZTxtLmxlbmd0aDtlKyspaWYoZj1tW2VdLmdldFRpbWU/Zj1tW2VdLnguZ2V0VGltZSgpOmY9bVtlXS54LCEoZjxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxmPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiZcIm51bWJlclwiPT09dHlwZW9mIG1bZV0ueSl7Zj1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoZik7bD1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVtlXS55KTt2YXIgZz1rLmdldE1hcmtlclByb3BlcnRpZXMoZSxmLGwsYyk7Yy5nbG9iYWxBbHBoYT1rLmZpbGxPcGFjaXR5O1cuZHJhd01hcmtlcihnLngsZy55LGcuY3R4LGcudHlwZSxnLnNpemUsZy5jb2xvcixnLmJvcmRlckNvbG9yLGcuYm9yZGVyVGhpY2tuZXNzKTtjLmdsb2JhbEFscGhhPTE7TWF0aC5zcXJ0KChuLWYpKihuLWYpKyhxLWwpKihxLWwpKTxNYXRoLm1pbihnLnNpemUsNSkmJm0ubGVuZ3RoPk1hdGgubWluKHRoaXMucGxvdEFyZWEud2lkdGgsXG50aGlzLnBsb3RBcmVhLmhlaWdodCl8fChuPWsuZGF0YVBvaW50SWRzW2VdLHRoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbbl09e2lkOm4sb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpoLGRhdGFQb2ludEluZGV4OmUseDE6Zix5MTpsfSxuPVgobiksdyYmVy5kcmF3TWFya2VyKGcueCxnLnksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LGcudHlwZSxnLnNpemUsbixuLGcuYm9yZGVyVGhpY2tuZXNzKSwobVtlXS5pbmRleExhYmVsfHxrLmluZGV4TGFiZWx8fG1bZV0uaW5kZXhMYWJlbEZvcm1hdHRlcnx8ay5pbmRleExhYmVsRm9ybWF0dGVyKSYmdGhpcy5faW5kZXhMYWJlbHMucHVzaCh7Y2hhcnRUeXBlOlwic2NhdHRlclwiLGRhdGFQb2ludDptW2VdLGRhdGFTZXJpZXM6ayxwb2ludDp7eDpmLHk6bH0sZGlyZWN0aW9uOjEsYm91bmRzOnt4MTpmLWcuc2l6ZS8yLHkxOmwtZy5zaXplLzIseDI6ZitnLnNpemUvMix5MjpsK2cuc2l6ZS8yfSxjb2xvcjpudWxsfSksXG5uPWYscT1sKX19fXcmJihkLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuY2xlYXJSZWN0KGIueDEsYi55MSxiLndpZHRoLGIuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVzdG9yZSgpKTtjLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmQsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxcbmFuaW1hdGlvbkNhbGxiYWNrOk0uZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19O3AucHJvdG90eXBlLnJlbmRlckNhbmRsZXN0aWNrPWZ1bmN0aW9uKGEpe3ZhciBkPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxjPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmQsYj10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHg7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBlPW51bGwsZj1udWxsLGw9dGhpcy5wbG90QXJlYSx0PTAsaCxrLG0sbixxLGcsZT10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWluV2lkdGg/dGhpcy5kYXRhUG9pbnRNaW5XaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxLGY9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP1xudGhpcy5kYXRhUG9pbnRXaWR0aDowLjAxNSp0aGlzLndpZHRoLHM9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHMpfHwocz0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO3M9dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC43Kmwud2lkdGgqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocykvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocykvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpPDwwO3RoaXMuZGF0YVBvaW50TWF4V2lkdGgmJmU+ZiYmKGU9TWF0aC5taW4odGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHksZikpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmZjxlKSYmKGY9TWF0aC5tYXgodGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6LUluZmluaXR5LGUpKTtzPFxuZSYmKHM9ZSk7cz5mJiYocz1mKTtjLnNhdmUoKTt3JiZiLnNhdmUoKTtjLmJlZ2luUGF0aCgpO2MucmVjdChsLngxLGwueTEsbC53aWR0aCxsLmhlaWdodCk7Yy5jbGlwKCk7dyYmKGIuYmVnaW5QYXRoKCksYi5yZWN0KGwueDEsbC55MSxsLndpZHRoLGwuaGVpZ2h0KSxiLmNsaXAoKSk7Zm9yKHZhciBwPTA7cDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtwKyspe3ZhciBiYT1hLmRhdGFTZXJpZXNJbmRleGVzW3BdLHU9dGhpcy5kYXRhW2JhXSx5PXUuZGF0YVBvaW50cztpZigwPHkubGVuZ3RoKWZvcih2YXIgeD01PHMmJnUuYmV2ZWxFbmFibGVkPyEwOiExLHQ9MDt0PHkubGVuZ3RoO3QrKylpZih5W3RdLmdldFRpbWU/Zz15W3RdLnguZ2V0VGltZSgpOmc9eVt0XS54LCEoZzxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxnPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiYhcih5W3RdLnkpJiZ5W3RdLnkubGVuZ3RoJiZcIm51bWJlclwiPT09dHlwZW9mIHlbdF0ueVswXSYmXG5cIm51bWJlclwiPT09dHlwZW9mIHlbdF0ueVsxXSYmXCJudW1iZXJcIj09PXR5cGVvZiB5W3RdLnlbMl0mJlwibnVtYmVyXCI9PT10eXBlb2YgeVt0XS55WzNdKXtoPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChnKTtrPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh5W3RdLnlbMF0pO209YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHlbdF0ueVsxXSk7bj1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeVt0XS55WzJdKTtxPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh5W3RdLnlbM10pO3ZhciB6PWgtcy8yPDwwLEg9eitzPDwwLGY9dS5vcHRpb25zLmZhbGxpbmdDb2xvcj91LmZhbGxpbmdDb2xvcjp1Ll9jb2xvclNldFswXSxlPXlbdF0uY29sb3I/eVt0XS5jb2xvcjp1Ll9jb2xvclNldFswXSxEPU1hdGgucm91bmQoTWF0aC5tYXgoMSwwLjE1KnMpKSx2PTA9PT1EJTI/MDowLjUsQT11LmRhdGFQb2ludElkc1t0XTt0aGlzLl9ldmVudE1hbmFnZXIub2JqZWN0TWFwW0FdPVxue2lkOkEsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpiYSxkYXRhUG9pbnRJbmRleDp0LHgxOnoseTE6ayx4MjpILHkyOm0seDM6aCx5MzpuLHg0OmgseTQ6cSxib3JkZXJUaGlja25lc3M6RCxjb2xvcjplfTtjLnN0cm9rZVN0eWxlPWU7Yy5iZWdpblBhdGgoKTtjLmxpbmVXaWR0aD1EO2IubGluZVdpZHRoPU1hdGgubWF4KEQsNCk7XCJjYW5kbGVzdGlja1wiPT09dS50eXBlPyhjLm1vdmVUbyhoLXYsbSksYy5saW5lVG8oaC12LE1hdGgubWluKGsscSkpLGMuc3Ryb2tlKCksYy5tb3ZlVG8oaC12LE1hdGgubWF4KGsscSkpLGMubGluZVRvKGgtdixuKSxjLnN0cm9rZSgpLFkoYyx6LE1hdGgubWluKGsscSksSCxNYXRoLm1heChrLHEpLHlbdF0ueVswXTw9eVt0XS55WzNdP3UucmlzaW5nQ29sb3I6ZixELGUseCx4LCExLCExLHUuZmlsbE9wYWNpdHkpLHcmJihlPVgoQSksYi5zdHJva2VTdHlsZT1lLGIubW92ZVRvKGgtdixtKSxiLmxpbmVUbyhoLXYsTWF0aC5taW4oayxcbnEpKSxiLnN0cm9rZSgpLGIubW92ZVRvKGgtdixNYXRoLm1heChrLHEpKSxiLmxpbmVUbyhoLXYsbiksYi5zdHJva2UoKSxZKGIseixNYXRoLm1pbihrLHEpLEgsTWF0aC5tYXgoayxxKSxlLDAsbnVsbCwhMSwhMSwhMSwhMSkpKTpcIm9obGNcIj09PXUudHlwZSYmKGMubW92ZVRvKGgtdixtKSxjLmxpbmVUbyhoLXYsbiksYy5zdHJva2UoKSxjLmJlZ2luUGF0aCgpLGMubW92ZVRvKGgsayksYy5saW5lVG8oeixrKSxjLnN0cm9rZSgpLGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8oaCxxKSxjLmxpbmVUbyhILHEpLGMuc3Ryb2tlKCksdyYmKGU9WChBKSxiLnN0cm9rZVN0eWxlPWUsYi5tb3ZlVG8oaC12LG0pLGIubGluZVRvKGgtdixuKSxiLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oaCxrKSxiLmxpbmVUbyh6LGspLGIuc3Ryb2tlKCksYi5iZWdpblBhdGgoKSxiLm1vdmVUbyhoLHEpLGIubGluZVRvKEgscSksYi5zdHJva2UoKSkpOyh5W3RdLmluZGV4TGFiZWx8fHUuaW5kZXhMYWJlbHx8XG55W3RdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fHUuaW5kZXhMYWJlbEZvcm1hdHRlcikmJnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTp1LnR5cGUsZGF0YVBvaW50OnlbdF0sZGF0YVNlcmllczp1LHBvaW50Ont4OnorKEgteikvMix5OmEuYXhpc1kucmV2ZXJzZWQ/bjptfSxkaXJlY3Rpb246MSxib3VuZHM6e3gxOnoseTE6TWF0aC5taW4obSxuKSx4MjpILHkyOk1hdGgubWF4KG0sbil9LGNvbG9yOmV9KX19dyYmKGQuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksXG50aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdChsLngxLGwueTEsbC53aWR0aCxsLmhlaWdodCksYi5yZXN0b3JlKCkpO2MucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0uZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19O3AucHJvdG90eXBlLnJlbmRlckJveEFuZFdoaXNrZXI9ZnVuY3Rpb24oYSl7dmFyIGQ9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGM9dz90aGlzLl9wcmVSZW5kZXJDdHg6ZCxiPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eDtpZighKDA+PWEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoKSl7dmFyIGU9bnVsbCxmPXRoaXMucGxvdEFyZWEsXG5sPTAsdCxoLGssbSxuLHEsZyxlPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjEsbD10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjAxNSp0aGlzLndpZHRoLHM9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHMpfHwocz0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO3M9dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC43KmYud2lkdGgqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocykvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocykvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpPDwwO3RoaXMuZGF0YVBvaW50TWF4V2lkdGgmJmU+XG5sJiYoZT1NYXRoLm1pbih0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpJbmZpbml0eSxsKSk7IXRoaXMuZGF0YVBvaW50TWF4V2lkdGgmJih0aGlzLmRhdGFQb2ludE1pbldpZHRoJiZsPGUpJiYobD1NYXRoLm1heCh0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDotSW5maW5pdHksZSkpO3M8ZSYmKHM9ZSk7cz5sJiYocz1sKTtjLnNhdmUoKTt3JiZiLnNhdmUoKTtjLmJlZ2luUGF0aCgpO2MucmVjdChmLngxLGYueTEsZi53aWR0aCxmLmhlaWdodCk7Yy5jbGlwKCk7dyYmKGIuYmVnaW5QYXRoKCksYi5yZWN0KGYueDEsZi55MSxmLndpZHRoLGYuaGVpZ2h0KSxiLmNsaXAoKSk7Zm9yKHZhciBwPSExLHA9ISFhLmF4aXNZLnJldmVyc2VkLGJhPTA7YmE8YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7YmErKyl7dmFyIHU9YS5kYXRhU2VyaWVzSW5kZXhlc1tiYV0seT10aGlzLmRhdGFbdV0seD15LmRhdGFQb2ludHM7XG5pZigwPHgubGVuZ3RoKWZvcih2YXIgej01PHMmJnkuYmV2ZWxFbmFibGVkPyEwOiExLGw9MDtsPHgubGVuZ3RoO2wrKylpZih4W2xdLmdldFRpbWU/Zz14W2xdLnguZ2V0VGltZSgpOmc9eFtsXS54LCEoZzxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHxnPmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgpJiYhcih4W2xdLnkpJiZ4W2xdLnkubGVuZ3RoJiZcIm51bWJlclwiPT09dHlwZW9mIHhbbF0ueVswXSYmXCJudW1iZXJcIj09PXR5cGVvZiB4W2xdLnlbMV0mJlwibnVtYmVyXCI9PT10eXBlb2YgeFtsXS55WzJdJiZcIm51bWJlclwiPT09dHlwZW9mIHhbbF0ueVszXSYmXCJudW1iZXJcIj09PXR5cGVvZiB4W2xdLnlbNF0mJjU9PT14W2xdLnkubGVuZ3RoKXt0PWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChnKTtoPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbCh4W2xdLnlbMF0pO2s9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHhbbF0ueVsxXSk7bT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeFtsXS55WzJdKTtcbm49YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHhbbF0ueVszXSk7cT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeFtsXS55WzRdKTt2YXIgdj10LXMvMjw8MCxEPXQrcy8yPDwwLGU9eFtsXS5jb2xvcj94W2xdLmNvbG9yOnkuX2NvbG9yU2V0WzBdLEE9TWF0aC5yb3VuZChNYXRoLm1heCgxLDAuMTUqcykpLEI9MD09PUElMj8wOjAuNSxMPXhbbF0ud2hpc2tlckNvbG9yP3hbbF0ud2hpc2tlckNvbG9yOnhbbF0uY29sb3I/eS53aGlza2VyQ29sb3I/eS53aGlza2VyQ29sb3I6eFtsXS5jb2xvcjp5LndoaXNrZXJDb2xvcj95LndoaXNrZXJDb2xvcjplLFM9XCJudW1iZXJcIj09PXR5cGVvZiB4W2xdLndoaXNrZXJUaGlja25lc3M/eFtsXS53aGlza2VyVGhpY2tuZXNzOlwibnVtYmVyXCI9PT10eXBlb2YgeS5vcHRpb25zLndoaXNrZXJUaGlja25lc3M/eS53aGlza2VyVGhpY2tuZXNzOkEsZWE9eFtsXS53aGlza2VyRGFzaFR5cGU/eFtsXS53aGlza2VyRGFzaFR5cGU6eS53aGlza2VyRGFzaFR5cGUsXG4kPXIoeFtsXS53aGlza2VyTGVuZ3RoKT9yKHkub3B0aW9ucy53aGlza2VyTGVuZ3RoKT9zOnkud2hpc2tlckxlbmd0aDp4W2xdLndoaXNrZXJMZW5ndGgsJD1cIm51bWJlclwiPT09dHlwZW9mICQ/MD49JD8wOiQ+PXM/czokOlwic3RyaW5nXCI9PT10eXBlb2YgJD9wYXJzZUludCgkKSpzLzEwMD5zP3M6cGFyc2VJbnQoJCkqcy8xMDA6cyxnYT0xPT09TWF0aC5yb3VuZChTKSUyPzAuNTowLG5hPXhbbF0uc3RlbUNvbG9yP3hbbF0uc3RlbUNvbG9yOnhbbF0uY29sb3I/eS5zdGVtQ29sb3I/eS5zdGVtQ29sb3I6eFtsXS5jb2xvcjp5LnN0ZW1Db2xvcj95LnN0ZW1Db2xvcjplLGthPVwibnVtYmVyXCI9PT10eXBlb2YgeFtsXS5zdGVtVGhpY2tuZXNzP3hbbF0uc3RlbVRoaWNrbmVzczpcIm51bWJlclwiPT09dHlwZW9mIHkub3B0aW9ucy5zdGVtVGhpY2tuZXNzP3kuc3RlbVRoaWNrbmVzczpBLEY9MT09PU1hdGgucm91bmQoa2EpJTI/MC41OjAsRT14W2xdLnN0ZW1EYXNoVHlwZT94W2xdLnN0ZW1EYXNoVHlwZTpcbnkuc3RlbURhc2hUeXBlLEs9eFtsXS5saW5lQ29sb3I/eFtsXS5saW5lQ29sb3I6eFtsXS5jb2xvcj95LmxpbmVDb2xvcj95LmxpbmVDb2xvcjp4W2xdLmNvbG9yOnkubGluZUNvbG9yP3kubGluZUNvbG9yOmUsRz1cIm51bWJlclwiPT09dHlwZW9mIHhbbF0ubGluZVRoaWNrbmVzcz94W2xdLmxpbmVUaGlja25lc3M6XCJudW1iZXJcIj09PXR5cGVvZiB5Lm9wdGlvbnMubGluZVRoaWNrbmVzcz95LmxpbmVUaGlja25lc3M6QSxOPXhbbF0ubGluZURhc2hUeXBlP3hbbF0ubGluZURhc2hUeXBlOnkubGluZURhc2hUeXBlLE89MT09PU1hdGgucm91bmQoRyklMj8wLjU6MCxQPXkudXBwZXJCb3hDb2xvcixRPXkubG93ZXJCb3hDb2xvcix0YT1yKHkub3B0aW9ucy5maWxsT3BhY2l0eSk/MTp5LmZpbGxPcGFjaXR5LFI9eS5kYXRhUG9pbnRJZHNbbF07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtSXT17aWQ6UixvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OnUsZGF0YVBvaW50SW5kZXg6bCxcbngxOnYseTE6aCx4MjpELHkyOmsseDM6dCx5MzptLHg0OnQseTQ6bix5NTpxLGJvcmRlclRoaWNrbmVzczpBLGNvbG9yOmUsc3RlbVRoaWNrbmVzczprYSxzdGVtQ29sb3I6bmEsd2hpc2tlclRoaWNrbmVzczpTLHdoaXNrZXJMZW5ndGg6JCx3aGlza2VyQ29sb3I6TCxsaW5lVGhpY2tuZXNzOkcsbGluZUNvbG9yOkt9O2Muc2F2ZSgpOzA8a2EmJihjLmJlZ2luUGF0aCgpLGMuc3Ryb2tlU3R5bGU9bmEsYy5saW5lV2lkdGg9a2EsYy5zZXRMaW5lRGFzaCYmYy5zZXRMaW5lRGFzaChKKEUsa2EpKSxjLm1vdmVUbyh0LUYsayksYy5saW5lVG8odC1GLGgpLGMuc3Ryb2tlKCksYy5tb3ZlVG8odC1GLG4pLGMubGluZVRvKHQtRixtKSxjLnN0cm9rZSgpKTtjLnJlc3RvcmUoKTtiLmxpbmVXaWR0aD1NYXRoLm1heChBLDQpO2MuYmVnaW5QYXRoKCk7WShjLHYsTWF0aC5taW4ocSxrKSxELE1hdGgubWF4KGsscSksUSwwLGUscD96OiExLHA/ITE6eiwhMSwhMSx0YSk7Yy5iZWdpblBhdGgoKTtZKGMsXG52LE1hdGgubWluKG0scSksRCxNYXRoLm1heChxLG0pLFAsMCxlLHA/ITE6eixwP3o6ITEsITEsITEsdGEpO2MuYmVnaW5QYXRoKCk7Yy5saW5lV2lkdGg9QTtjLnN0cm9rZVN0eWxlPWU7Yy5yZWN0KHYtQixNYXRoLm1pbihrLG0pLUIsRC12KzIqQixNYXRoLm1heChrLG0pLU1hdGgubWluKGssbSkrMipCKTtjLnN0cm9rZSgpO2Muc2F2ZSgpOzA8RyYmKGMuYmVnaW5QYXRoKCksYy5nbG9iYWxBbHBoYT0xLGMuc2V0TGluZURhc2gmJmMuc2V0TGluZURhc2goSihOLEcpKSxjLnN0cm9rZVN0eWxlPUssYy5saW5lV2lkdGg9RyxjLm1vdmVUbyh2LHEtTyksYy5saW5lVG8oRCxxLU8pLGMuc3Ryb2tlKCkpO2MucmVzdG9yZSgpO2Muc2F2ZSgpOzA8UyYmKGMuYmVnaW5QYXRoKCksYy5zZXRMaW5lRGFzaCYmYy5zZXRMaW5lRGFzaChKKGVhLFMpKSxjLnN0cm9rZVN0eWxlPUwsYy5saW5lV2lkdGg9UyxjLm1vdmVUbyh0LSQvMjw8MCxuLWdhKSxjLmxpbmVUbyh0KyQvMjw8MCxuLWdhKSxjLnN0cm9rZSgpLFxuYy5tb3ZlVG8odC0kLzI8PDAsaCtnYSksYy5saW5lVG8odCskLzI8PDAsaCtnYSksYy5zdHJva2UoKSk7Yy5yZXN0b3JlKCk7dyYmKGU9WChSKSxiLnN0cm9rZVN0eWxlPWUsYi5saW5lV2lkdGg9a2EsMDxrYSYmKGIubW92ZVRvKHQtQi1GLGspLGIubGluZVRvKHQtQi1GLE1hdGgubWF4KGgsbikpLGIuc3Ryb2tlKCksYi5tb3ZlVG8odC1CLUYsTWF0aC5taW4oaCxuKSksYi5saW5lVG8odC1CLUYsbSksYi5zdHJva2UoKSksWShiLHYsTWF0aC5tYXgoayxtKSxELE1hdGgubWluKGssbSksZSwwLG51bGwsITEsITEsITEsITEpLDA8UyYmKGIuYmVnaW5QYXRoKCksYi5saW5lV2lkdGg9UyxiLm1vdmVUbyh0KyQvMixuLWdhKSxiLmxpbmVUbyh0LSQvMixuLWdhKSxiLnN0cm9rZSgpLGIubW92ZVRvKHQrJC8yLGgrZ2EpLGIubGluZVRvKHQtJC8yLGgrZ2EpLGIuc3Ryb2tlKCkpKTsoeFtsXS5pbmRleExhYmVsfHx5LmluZGV4TGFiZWx8fHhbbF0uaW5kZXhMYWJlbEZvcm1hdHRlcnx8eS5pbmRleExhYmVsRm9ybWF0dGVyKSYmXG50aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6eS50eXBlLGRhdGFQb2ludDp4W2xdLGRhdGFTZXJpZXM6eSxwb2ludDp7eDp2KyhELXYpLzIseTphLmF4aXNZLnJldmVyc2VkP2g6bn0sZGlyZWN0aW9uOjEsYm91bmRzOnt4MTp2LHkxOk1hdGgubWluKGgsbikseDI6RCx5MjpNYXRoLm1heChoLG4pfSxjb2xvcjplfSl9fXcmJihkLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsXG4wLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5jbGVhclJlY3QoZi54MSxmLnkxLGYud2lkdGgsZi5oZWlnaHQpLGIucmVzdG9yZSgpKTtjLnJlc3RvcmUoKTtyZXR1cm57c291cmNlOmQsZGVzdDp0aGlzLnBsb3RBcmVhLmN0eCxhbmltYXRpb25DYWxsYmFjazpNLmZhZGVJbkFuaW1hdGlvbixlYXNpbmdGdW5jdGlvbjpNLmVhc2luZy5lYXNlSW5RdWFkLGFuaW1hdGlvbkJhc2U6MH19fTtwLnByb3RvdHlwZS5yZW5kZXJSYW5nZUNvbHVtbj1mdW5jdGlvbihhKXt2YXIgZD1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYz13P3RoaXMuX3ByZVJlbmRlckN0eDpkO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYj1udWxsLGU9dGhpcy5wbG90QXJlYSxmPTAsbCx0LGgsZj10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWluV2lkdGg/dGhpcy5kYXRhUG9pbnRNaW5XaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpcbjE7bD10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDowLjAzKnRoaXMud2lkdGg7dmFyIGs9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKGspfHwoaz0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO2s9dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MC45KihlLndpZHRoKihhLmF4aXNYLmxvZ2FyaXRobWljP01hdGgubG9nKGspL01hdGgubG9nKGEuYXhpc1gucmFuZ2UpOk1hdGguYWJzKGspL01hdGguYWJzKGEuYXhpc1gucmFuZ2UpKS9hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcyk8PDA7dGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmZj5sJiYoZj1NYXRoLm1pbih0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpJbmZpbml0eSxsKSk7IXRoaXMuZGF0YVBvaW50TWF4V2lkdGgmJlxuKHRoaXMuZGF0YVBvaW50TWluV2lkdGgmJmw8ZikmJihsPU1hdGgubWF4KHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxmKSk7azxmJiYoaz1mKTtrPmwmJihrPWwpO2Muc2F2ZSgpO3cmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yy5iZWdpblBhdGgoKTtjLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO2MuY2xpcCgpO3cmJih0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguYmVnaW5QYXRoKCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5jbGlwKCkpO2Zvcih2YXIgbT0wO208YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGg7bSsrKXt2YXIgbj1hLmRhdGFTZXJpZXNJbmRleGVzW21dLHE9dGhpcy5kYXRhW25dLGc9cS5kYXRhUG9pbnRzO2lmKDA8Zy5sZW5ndGgpZm9yKHZhciBzPVxuNTxrJiZxLmJldmVsRW5hYmxlZD8hMDohMSxmPTA7ZjxnLmxlbmd0aDtmKyspaWYoZ1tmXS5nZXRUaW1lP2g9Z1tmXS54LmdldFRpbWUoKTpoPWdbZl0ueCwhKGg8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8aD5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4KSYmIXIoZ1tmXS55KSYmZ1tmXS55Lmxlbmd0aCYmXCJudW1iZXJcIj09PXR5cGVvZiBnW2ZdLnlbMF0mJlwibnVtYmVyXCI9PT10eXBlb2YgZ1tmXS55WzFdKXtiPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChoKTtsPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChnW2ZdLnlbMF0pO3Q9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGdbZl0ueVsxXSk7dmFyIHA9YS5heGlzWC5yZXZlcnNlZD9iK2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKmsvMi0oYS5wcmV2aW91c0RhdGFTZXJpZXNDb3VudCttKSprPDwwOmItYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMqay8yKyhhLnByZXZpb3VzRGF0YVNlcmllc0NvdW50K1xubSkqazw8MCxiYT1hLmF4aXNYLnJldmVyc2VkP3Atazw8MDpwK2s8PDAsYj1nW2ZdLmNvbG9yP2dbZl0uY29sb3I6cS5fY29sb3JTZXRbZiVxLl9jb2xvclNldC5sZW5ndGhdO2lmKGw+dCl7dmFyIHU9bDtsPXQ7dD11fXU9cS5kYXRhUG9pbnRJZHNbZl07dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFt1XT17aWQ6dSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4Om4sZGF0YVBvaW50SW5kZXg6Zix4MTpwLHkxOmwseDI6YmEseTI6dH07WShjLGEuYXhpc1gucmV2ZXJzZWQ/YmE6cCxsLGEuYXhpc1gucmV2ZXJzZWQ/cDpiYSx0LGIsMCxiLHMscywhMSwhMSxxLmZpbGxPcGFjaXR5KTtiPVgodSk7dyYmWSh0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsYS5heGlzWC5yZXZlcnNlZD9iYTpwLGwsYS5heGlzWC5yZXZlcnNlZD9wOmJhLHQsYiwwLG51bGwsITEsITEsITEsITEpO2lmKGdbZl0uaW5kZXhMYWJlbHx8cS5pbmRleExhYmVsfHxnW2ZdLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fFxucS5pbmRleExhYmVsRm9ybWF0dGVyKXRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInJhbmdlQ29sdW1uXCIsZGF0YVBvaW50OmdbZl0sZGF0YVNlcmllczpxLGluZGV4S2V5d29yZDowLHBvaW50Ont4OnArKGJhLXApLzIseTpnW2ZdLnlbMV0+PWdbZl0ueVswXT90Omx9LGRpcmVjdGlvbjpnW2ZdLnlbMV0+PWdbZl0ueVswXT8tMToxLGJvdW5kczp7eDE6cCx5MTpNYXRoLm1pbihsLHQpLHgyOmJhLHkyOk1hdGgubWF4KGwsdCl9LGNvbG9yOmJ9KSx0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZUNvbHVtblwiLGRhdGFQb2ludDpnW2ZdLGRhdGFTZXJpZXM6cSxpbmRleEtleXdvcmQ6MSxwb2ludDp7eDpwKyhiYS1wKS8yLHk6Z1tmXS55WzFdPj1nW2ZdLnlbMF0/bDp0fSxkaXJlY3Rpb246Z1tmXS55WzFdPj1nW2ZdLnlbMF0/MTotMSxib3VuZHM6e3gxOnAseTE6TWF0aC5taW4obCx0KSx4MjpiYSx5MjpNYXRoLm1heChsLHQpfSxjb2xvcjpifSl9fXcmJlxuKGQuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5jbGVhclJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2MucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0uZmFkZUluQW5pbWF0aW9uLFxuZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcuZWFzZUluUXVhZCxhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyRXJyb3I9ZnVuY3Rpb24oYSl7dmFyIGQ9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LGM9dz90aGlzLl9wcmVSZW5kZXJDdHg6ZCxiPWEuYXhpc1kuX3Bvc2l0aW9uP1wibGVmdFwiPT09YS5heGlzWS5fcG9zaXRpb258fFwicmlnaHRcIj09PWEuYXhpc1kuX3Bvc2l0aW9uPyExOiEwOiExO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgZT1udWxsLGY9ITEsbD10aGlzLnBsb3RBcmVhLHQ9MCxoLGssbSxuLHEsZyxzLHA9YS5heGlzWC5kYXRhSW5mby5taW5EaWZmO2lzRmluaXRlKHApfHwocD0wLjMqTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpO2Muc2F2ZSgpO3cmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yy5iZWdpblBhdGgoKTtjLnJlY3QobC54MSxsLnkxLGwud2lkdGgsbC5oZWlnaHQpO2MuY2xpcCgpO1xudyYmKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5iZWdpblBhdGgoKSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVjdChsLngxLGwueTEsbC53aWR0aCxsLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKHZhciBiYT0wLHU9MDt1PHRoaXMuZGF0YS5sZW5ndGg7dSsrKSF0aGlzLmRhdGFbdV0udHlwZS5tYXRjaCgvKGJhcnxjb2x1bW4pL2lnKXx8IXRoaXMuZGF0YVt1XS52aXNpYmxlfHx0aGlzLmRhdGFbdV0udHlwZS5tYXRjaCgvKHN0YWNrZWQpL2lnKSYmYmF8fGJhKys7Zm9yKHZhciB5PTA7eTxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt5Kyspe3ZhciB4PWEuZGF0YVNlcmllc0luZGV4ZXNbeV0sej10aGlzLmRhdGFbeF0sdj16LmRhdGFQb2ludHMsRD1yKHouX2xpbmtlZFNlcmllcyk/ITE6ei5fbGlua2VkU2VyaWVzLnR5cGUubWF0Y2goLyhiYXJ8Y29sdW1uKS9pZykmJnouX2xpbmtlZFNlcmllcy52aXNpYmxlPyEwOiExLFxuQT0wO2lmKEQpZm9yKGU9ei5fbGlua2VkU2VyaWVzLmlkLHU9MDt1PGU7dSsrKSF0aGlzLmRhdGFbdV0udHlwZS5tYXRjaCgvKGJhcnxjb2x1bW4pL2lnKXx8IXRoaXMuZGF0YVt1XS52aXNpYmxlfHx0aGlzLmRhdGFbdV0udHlwZS5tYXRjaCgvKHN0YWNrZWQpL2lnKSYmQXx8KHRoaXMuZGF0YVt1XS50eXBlLm1hdGNoKC8ocmFuZ2UpL2lnKSYmKGY9ITApLEErKyk7ZT10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWluV2lkdGg/dGhpcy5kYXRhUG9pbnRNaW5XaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDoxO3Q9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1heFdpZHRoP3RoaXMuZGF0YVBvaW50TWF4V2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6Yj9NYXRoLm1pbigwLjE1KnRoaXMuaGVpZ2h0LDAuOSoodGhpcy5wbG90QXJlYS5oZWlnaHQvKEQ/YmE6MSkpKTw8MDowLjMqdGhpcy53aWR0aDtmJiZcbih0PXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOmI/TWF0aC5taW4oMC4xNSp0aGlzLmhlaWdodCwwLjkqKHRoaXMucGxvdEFyZWEuaGVpZ2h0LyhEP2JhOjEpKSk8PDA6MC4wMyp0aGlzLndpZHRoKTt1PXRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooKGI/bC5oZWlnaHQ6bC53aWR0aCkqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cocCkvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMocCkvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpLyhEP2JhOjEpKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZlPnQmJihlPU1hdGgubWluKHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOkluZmluaXR5LHQpKTshdGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmKHRoaXMuZGF0YVBvaW50TWluV2lkdGgmJlxudDxlKSYmKHQ9TWF0aC5tYXgodGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6LUluZmluaXR5LGUpKTt1PGUmJih1PWUpO3U+dCYmKHU9dCk7aWYoMDx2Lmxlbmd0aClmb3IodmFyIEU9ei5fY29sb3JTZXQsdD0wO3Q8di5sZW5ndGg7dCsrKXt2YXIgZT16LmxpbmVDb2xvcj16Lm9wdGlvbnMuY29sb3I/ei5vcHRpb25zLmNvbG9yOkVbMF0sTD17Y29sb3I6dlt0XS53aGlza2VyQ29sb3I/dlt0XS53aGlza2VyQ29sb3I6dlt0XS5jb2xvcj96LndoaXNrZXJDb2xvcj96LndoaXNrZXJDb2xvcjp2W3RdLmNvbG9yOnoud2hpc2tlckNvbG9yP3oud2hpc2tlckNvbG9yOmUsdGhpY2tuZXNzOnIodlt0XS53aGlza2VyVGhpY2tuZXNzKT96LndoaXNrZXJUaGlja25lc3M6dlt0XS53aGlza2VyVGhpY2tuZXNzLGRhc2hUeXBlOnZbdF0ud2hpc2tlckRhc2hUeXBlP3ZbdF0ud2hpc2tlckRhc2hUeXBlOnoud2hpc2tlckRhc2hUeXBlLGxlbmd0aDpyKHZbdF0ud2hpc2tlckxlbmd0aCk/XG5yKHoub3B0aW9ucy53aGlza2VyTGVuZ3RoKT91Onoub3B0aW9ucy53aGlza2VyTGVuZ3RoOnZbdF0ud2hpc2tlckxlbmd0aCx0cmltTGVuZ3RoOnIodlt0XS53aGlza2VyTGVuZ3RoKT9yKHoub3B0aW9ucy53aGlza2VyTGVuZ3RoKT81MDowOjB9O0wubGVuZ3RoPVwibnVtYmVyXCI9PT10eXBlb2YgTC5sZW5ndGg/MD49TC5sZW5ndGg/MDpMLmxlbmd0aD49dT91OkwubGVuZ3RoOlwic3RyaW5nXCI9PT10eXBlb2YgTC5sZW5ndGg/cGFyc2VJbnQoTC5sZW5ndGgpKnUvMTAwPnU/dTpwYXJzZUludChMLmxlbmd0aCkqdS8xMDA+dTp1O0wudGhpY2tuZXNzPVwibnVtYmVyXCI9PT10eXBlb2YgTC50aGlja25lc3M/MD5MLnRoaWNrbmVzcz8wOk1hdGgucm91bmQoTC50aGlja25lc3MpOjI7dmFyIFM9e2NvbG9yOnZbdF0uc3RlbUNvbG9yP3ZbdF0uc3RlbUNvbG9yOnZbdF0uY29sb3I/ei5zdGVtQ29sb3I/ei5zdGVtQ29sb3I6dlt0XS5jb2xvcjp6LnN0ZW1Db2xvcj96LnN0ZW1Db2xvcjplLHRoaWNrbmVzczp2W3RdLnN0ZW1UaGlja25lc3M/XG52W3RdLnN0ZW1UaGlja25lc3M6ei5zdGVtVGhpY2tuZXNzLGRhc2hUeXBlOnZbdF0uc3RlbURhc2hUeXBlP3ZbdF0uc3RlbURhc2hUeXBlOnouc3RlbURhc2hUeXBlfTtTLnRoaWNrbmVzcz1cIm51bWJlclwiPT09dHlwZW9mIFMudGhpY2tuZXNzPzA+Uy50aGlja25lc3M/MDpNYXRoLnJvdW5kKFMudGhpY2tuZXNzKToyO3ZbdF0uZ2V0VGltZT9zPXZbdF0ueC5nZXRUaW1lKCk6cz12W3RdLng7aWYoIShzPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fHM+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJiFyKHZbdF0ueSkmJnZbdF0ueS5sZW5ndGgmJlwibnVtYmVyXCI9PT10eXBlb2Ygdlt0XS55WzBdJiZcIm51bWJlclwiPT09dHlwZW9mIHZbdF0ueVsxXSl7dmFyIGVhPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChzKTtiP2s9ZWE6aD1lYTtlYT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodlt0XS55WzBdKTtiP209ZWE6cT1lYTtlYT1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwodlt0XS55WzFdKTtcbmI/bj1lYTpnPWVhO2I/KHE9YS5heGlzWC5yZXZlcnNlZD9rKyhEP2JhOjEpKnUvMi0oRD9BLTE6MCkqdTw8MDprLShEP2JhOjEpKnUvMisoRD9BLTE6MCkqdTw8MCxnPWEuYXhpc1gucmV2ZXJzZWQ/cS11PDwwOnErdTw8MCk6KG09YS5heGlzWC5yZXZlcnNlZD9oKyhEP2JhOjEpKnUvMi0oRD9BLTE6MCkqdTw8MDpoLShEP2JhOjEpKnUvMisoRD9BLTE6MCkqdTw8MCxuPWEuYXhpc1gucmV2ZXJzZWQ/bS11PDwwOm0rdTw8MCk7IWImJnE+ZyYmKGVhPXEscT1nLGc9ZWEpO2ImJm0+biYmKGVhPW0sbT1uLG49ZWEpO2VhPXouZGF0YVBvaW50SWRzW3RdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbZWFdPXtpZDplYSxvYmplY3RUeXBlOlwiZGF0YVBvaW50XCIsZGF0YVNlcmllc0luZGV4OngsZGF0YVBvaW50SW5kZXg6dCx4MTpNYXRoLm1pbihtLG4pLHkxOk1hdGgubWluKHEsZykseDI6TWF0aC5tYXgobixtKSx5MjpNYXRoLm1heChnLHEpLGlzWFlTd2FwcGVkOmIsc3RlbVByb3BlcnRpZXM6UyxcbndoaXNrZXJQcm9wZXJ0aWVzOkx9O0IoYyxNYXRoLm1pbihtLG4pLE1hdGgubWluKHEsZyksTWF0aC5tYXgobixtKSxNYXRoLm1heChnLHEpLGUsTCxTLGIpO3cmJkIodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LG0scSxuLGcsZSxMLFMsYik7aWYodlt0XS5pbmRleExhYmVsfHx6LmluZGV4TGFiZWx8fHZbdF0uaW5kZXhMYWJlbEZvcm1hdHRlcnx8ei5pbmRleExhYmVsRm9ybWF0dGVyKXRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcImVycm9yXCIsZGF0YVBvaW50OnZbdF0sZGF0YVNlcmllczp6LGluZGV4S2V5d29yZDowLHBvaW50Ont4OmI/dlt0XS55WzFdPj12W3RdLnlbMF0/bTpuOm0rKG4tbSkvMix5OmI/cSsoZy1xKS8yOnZbdF0ueVsxXT49dlt0XS55WzBdP2c6cX0sZGlyZWN0aW9uOnZbdF0ueVsxXT49dlt0XS55WzBdPy0xOjEsYm91bmRzOnt4MTpiP01hdGgubWluKG0sbik6bSx5MTpiP3E6TWF0aC5taW4ocSxnKSx4MjpiP01hdGgubWF4KG0sbik6bix5MjpiP1xuZzpNYXRoLm1heChxLGcpfSxjb2xvcjplLGF4aXNTd2FwcGVkOmJ9KSx0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJlcnJvclwiLGRhdGFQb2ludDp2W3RdLGRhdGFTZXJpZXM6eixpbmRleEtleXdvcmQ6MSxwb2ludDp7eDpiP3ZbdF0ueVsxXT49dlt0XS55WzBdP246bTptKyhuLW0pLzIseTpiP3ErKGctcSkvMjp2W3RdLnlbMV0+PXZbdF0ueVswXT9xOmd9LGRpcmVjdGlvbjp2W3RdLnlbMV0+PXZbdF0ueVswXT8xOi0xLGJvdW5kczp7eDE6Yj9NYXRoLm1pbihtLG4pOm0seTE6Yj9xOk1hdGgubWluKHEsZykseDI6Yj9NYXRoLm1heChtLG4pOm4seTI6Yj9nOk1hdGgubWF4KHEsZyl9LGNvbG9yOmUsYXhpc1N3YXBwZWQ6Yn0pfX19dyYmKGQuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLFxuMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGEuYXhpc1kubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWS5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdChsLngxLGwueTEsbC53aWR0aCxsLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yy5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpkLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6TS5mYWRlSW5BbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcuZWFzZUluUXVhZCxhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyUmFuZ2VCYXI9ZnVuY3Rpb24oYSl7dmFyIGQ9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LFxuYz13P3RoaXMuX3ByZVJlbmRlckN0eDpkO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYj1udWxsLGU9dGhpcy5wbG90QXJlYSxmPTAsbCx0LGgsayxmPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNaW5XaWR0aD90aGlzLmRhdGFQb2ludE1pbldpZHRoOnRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjE7bD10aGlzLm9wdGlvbnMuZGF0YVBvaW50TWF4V2lkdGg/dGhpcy5kYXRhUG9pbnRNYXhXaWR0aDp0aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/dGhpcy5kYXRhUG9pbnRXaWR0aDpNYXRoLm1pbigwLjE1KnRoaXMuaGVpZ2h0LDAuOSoodGhpcy5wbG90QXJlYS5oZWlnaHQvYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMpKTw8MDt2YXIgbT1hLmF4aXNYLmRhdGFJbmZvLm1pbkRpZmY7aXNGaW5pdGUobSl8fChtPTAuMypNYXRoLmFicyhhLmF4aXNYLnJhbmdlKSk7bT10aGlzLm9wdGlvbnMuZGF0YVBvaW50V2lkdGg/XG50aGlzLmRhdGFQb2ludFdpZHRoOjAuOSooZS5oZWlnaHQqKGEuYXhpc1gubG9nYXJpdGhtaWM/TWF0aC5sb2cobSkvTWF0aC5sb2coYS5heGlzWC5yYW5nZSk6TWF0aC5hYnMobSkvTWF0aC5hYnMoYS5heGlzWC5yYW5nZSkpL2EucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKTw8MDt0aGlzLmRhdGFQb2ludE1heFdpZHRoJiZmPmwmJihmPU1hdGgubWluKHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOkluZmluaXR5LGwpKTshdGhpcy5kYXRhUG9pbnRNYXhXaWR0aCYmKHRoaXMuZGF0YVBvaW50TWluV2lkdGgmJmw8ZikmJihsPU1hdGgubWF4KHRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOi1JbmZpbml0eSxmKSk7bTxmJiYobT1mKTttPmwmJihtPWwpO2Muc2F2ZSgpO3cmJnRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5zYXZlKCk7Yy5iZWdpblBhdGgoKTtjLnJlY3QoZS54MSxlLnkxLGUud2lkdGgsZS5oZWlnaHQpO1xuYy5jbGlwKCk7dyYmKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5iZWdpblBhdGgoKSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgucmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmNsaXAoKSk7Zm9yKHZhciBuPTA7bjxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDtuKyspe3ZhciBxPWEuZGF0YVNlcmllc0luZGV4ZXNbbl0sZz10aGlzLmRhdGFbcV0scz1nLmRhdGFQb2ludHM7aWYoMDxzLmxlbmd0aCl7dmFyIHA9NTxtJiZnLmJldmVsRW5hYmxlZD8hMDohMTtjLnN0cm9rZVN0eWxlPVwiIzQ1NzJBNyBcIjtmb3IoZj0wO2Y8cy5sZW5ndGg7ZisrKWlmKHNbZl0uZ2V0VGltZT9rPXNbZl0ueC5nZXRUaW1lKCk6az1zW2ZdLngsIShrPGEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNaW58fGs+YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1heCkmJiFyKHNbZl0ueSkmJnNbZl0ueS5sZW5ndGgmJlwibnVtYmVyXCI9PT10eXBlb2Ygc1tmXS55WzBdJiZcblwibnVtYmVyXCI9PT10eXBlb2Ygc1tmXS55WzFdKXtsPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChzW2ZdLnlbMF0pO3Q9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKHNbZl0ueVsxXSk7aD1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoayk7aD1hLmF4aXNYLnJldmVyc2VkP2grYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMqbS8yLShhLnByZXZpb3VzRGF0YVNlcmllc0NvdW50K24pKm08PDA6aC1hLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcyptLzIrKGEucHJldmlvdXNEYXRhU2VyaWVzQ291bnQrbikqbTw8MDt2YXIgdj1hLmF4aXNYLnJldmVyc2VkP2gtbTw8MDpoK208PDA7bD50JiYoYj1sLGw9dCx0PWIpO2I9c1tmXS5jb2xvcj9zW2ZdLmNvbG9yOmcuX2NvbG9yU2V0W2YlZy5fY29sb3JTZXQubGVuZ3RoXTtZKGMsbCxhLmF4aXNYLnJldmVyc2VkP3Y6aCx0LGEuYXhpc1gucmV2ZXJzZWQ/aDp2LGIsMCxudWxsLHAsITEsITEsITEsZy5maWxsT3BhY2l0eSk7Yj1nLmRhdGFQb2ludElkc1tmXTtcbnRoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbYl09e2lkOmIsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpxLGRhdGFQb2ludEluZGV4OmYseDE6bCx5MTpoLHgyOnQseTI6dn07Yj1YKGIpO3cmJlkodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LGwsYS5heGlzWC5yZXZlcnNlZD92OmgsdCxhLmF4aXNYLnJldmVyc2VkP2g6dixiLDAsbnVsbCwhMSwhMSwhMSwhMSk7aWYoc1tmXS5pbmRleExhYmVsfHxnLmluZGV4TGFiZWx8fHNbZl0uaW5kZXhMYWJlbEZvcm1hdHRlcnx8Zy5pbmRleExhYmVsRm9ybWF0dGVyKXRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInJhbmdlQmFyXCIsZGF0YVBvaW50OnNbZl0sZGF0YVNlcmllczpnLGluZGV4S2V5d29yZDowLHBvaW50Ont4OnNbZl0ueVsxXT49c1tmXS55WzBdP2w6dCx5OmgrKHYtaCkvMn0sZGlyZWN0aW9uOnNbZl0ueVsxXT49c1tmXS55WzBdPy0xOjEsYm91bmRzOnt4MTpNYXRoLm1pbihsLHQpLFxueTE6aCx4MjpNYXRoLm1heChsLHQpLHkyOnZ9LGNvbG9yOmJ9KSx0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZUJhclwiLGRhdGFQb2ludDpzW2ZdLGRhdGFTZXJpZXM6ZyxpbmRleEtleXdvcmQ6MSxwb2ludDp7eDpzW2ZdLnlbMV0+PXNbZl0ueVswXT90OmwseTpoKyh2LWgpLzJ9LGRpcmVjdGlvbjpzW2ZdLnlbMV0+PXNbZl0ueVswXT8xOi0xLGJvdW5kczp7eDE6TWF0aC5taW4obCx0KSx5MTpoLHgyOk1hdGgubWF4KGwsdCkseTI6dn0sY29sb3I6Yn0pfX19dyYmKGQuZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249XCJzb3VyY2UtYXRvcFwiLGEuYXhpc1gubWFza0NhbnZhcyYmYy5kcmF3SW1hZ2UoYS5heGlzWC5tYXNrQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcyxcbjAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLl9icmVha3NDYW52YXNDdHgmJnRoaXMuX2JyZWFrc0NhbnZhc0N0eC5kcmF3SW1hZ2UodGhpcy5fcHJlUmVuZGVyQ2FudmFzLDAsMCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxjLmNsZWFyUmVjdChlLngxLGUueTEsZS53aWR0aCxlLmhlaWdodCksdGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LnJlc3RvcmUoKSk7Yy5yZXN0b3JlKCk7cmV0dXJue3NvdXJjZTpkLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6TS5mYWRlSW5BbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcuZWFzZUluUXVhZCxhbmltYXRpb25CYXNlOjB9fX07cC5wcm90b3R5cGUucmVuZGVyUmFuZ2VBcmVhPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGQoKXtpZih5KXtmb3IodmFyIGE9bnVsbCxjPWgubGVuZ3RoLTE7MDw9YztjLS0pYT1oW2NdLGIubGluZVRvKGEueCxhLnkyKSxlLmxpbmVUbyhhLngsYS55Mik7Yi5jbG9zZVBhdGgoKTtcbmIuZ2xvYmFsQWxwaGE9bS5maWxsT3BhY2l0eTtiLmZpbGwoKTtiLmdsb2JhbEFscGhhPTE7ZS5maWxsKCk7aWYoMDxtLmxpbmVUaGlja25lc3Mpe2IuYmVnaW5QYXRoKCk7Yi5tb3ZlVG8oYS54LGEueTIpO2ZvcihjPTA7YzxoLmxlbmd0aDtjKyspYT1oW2NdLGIubGluZVRvKGEueCxhLnkyKTtiLm1vdmVUbyhoWzBdLngsaFswXS55MSk7Zm9yKGM9MDtjPGgubGVuZ3RoO2MrKylhPWhbY10sYi5saW5lVG8oYS54LGEueTEpO2Iuc3Ryb2tlKCl9Yi5iZWdpblBhdGgoKTtiLm1vdmVUbyhzLHIpO2UuYmVnaW5QYXRoKCk7ZS5tb3ZlVG8ocyxyKTt5PXt4OnMseTpyfTtoPVtdO2gucHVzaCh7eDpzLHkxOnIseTI6cH0pfX12YXIgYz1hLnRhcmdldENhbnZhc0N0eHx8dGhpcy5wbG90QXJlYS5jdHgsYj13P3RoaXMuX3ByZVJlbmRlckN0eDpjO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgZT10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZj1bXSxsPXRoaXMucGxvdEFyZWE7XG5iLnNhdmUoKTt3JiZlLnNhdmUoKTtiLmJlZ2luUGF0aCgpO2IucmVjdChsLngxLGwueTEsbC53aWR0aCxsLmhlaWdodCk7Yi5jbGlwKCk7dyYmKGUuYmVnaW5QYXRoKCksZS5yZWN0KGwueDEsbC55MSxsLndpZHRoLGwuaGVpZ2h0KSxlLmNsaXAoKSk7Zm9yKHZhciB0PTA7dDxhLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aDt0Kyspe3ZhciBoPVtdLGs9YS5kYXRhU2VyaWVzSW5kZXhlc1t0XSxtPXRoaXMuZGF0YVtrXSxuPW0uZGF0YVBvaW50cyxmPW0uaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtmXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6a307Zj1YKGYpO2UuZmlsbFN0eWxlPWY7dmFyIGY9W10scT0hMCxnPTAscyxyLHAsdSx5PW51bGw7aWYoMDxuLmxlbmd0aCl7dmFyIHg9bS5fY29sb3JTZXRbZyVtLl9jb2xvclNldC5sZW5ndGhdLHY9bS5saW5lQ29sb3I9bS5vcHRpb25zLmxpbmVDb2xvcnx8eCxBPXY7Yi5maWxsU3R5bGU9eDtiLnN0cm9rZVN0eWxlPVxudjtiLmxpbmVXaWR0aD1tLmxpbmVUaGlja25lc3M7dmFyIEQ9XCJzb2xpZFwiO2lmKGIuc2V0TGluZURhc2gpe3ZhciBCPUoobS5udWxsRGF0YUxpbmVEYXNoVHlwZSxtLmxpbmVUaGlja25lc3MpLEQ9bS5saW5lRGFzaFR5cGUsRT1KKEQsbS5saW5lVGhpY2tuZXNzKTtiLnNldExpbmVEYXNoKEUpfWZvcih2YXIgTD0hMDtnPG4ubGVuZ3RoO2crKylpZih1PW5bZ10ueC5nZXRUaW1lP25bZ10ueC5nZXRUaW1lKCk6bltnXS54LCEodTxhLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWlufHx1PmEuYXhpc1guZGF0YUluZm8udmlld1BvcnRNYXgmJighbS5jb25uZWN0TnVsbERhdGF8fCFMKSkpaWYobnVsbCE9PW5bZ10ueSYmbltnXS55Lmxlbmd0aCYmXCJudW1iZXJcIj09PXR5cGVvZiBuW2ddLnlbMF0mJlwibnVtYmVyXCI9PT10eXBlb2YgbltnXS55WzFdKXtzPWEuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbCh1KTtyPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChuW2ddLnlbMF0pO3A9YS5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKG5bZ10ueVsxXSk7XG5xfHxMPyhtLmNvbm5lY3ROdWxsRGF0YSYmIXE/KGIuc2V0TGluZURhc2gmJihtLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fEQ9PT1tLmxpbmVEYXNoVHlwZSYmbS5saW5lRGFzaFR5cGUhPT1tLm51bGxEYXRhTGluZURhc2hUeXBlKSYmKGhbaC5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1FLEQ9bS5udWxsRGF0YUxpbmVEYXNoVHlwZSxiLnNldExpbmVEYXNoKEIpKSxiLmxpbmVUbyhzLHIpLHcmJmUubGluZVRvKHMsciksaC5wdXNoKHt4OnMseTE6cix5MjpwfSkpOihiLmJlZ2luUGF0aCgpLGIubW92ZVRvKHMscikseT17eDpzLHk6cn0saD1bXSxoLnB1c2goe3g6cyx5MTpyLHkyOnB9KSx3JiYoZS5iZWdpblBhdGgoKSxlLm1vdmVUbyhzLHIpKSksTD1xPSExKTooYi5saW5lVG8ocyxyKSxoLnB1c2goe3g6cyx5MTpyLHkyOnB9KSx3JiZlLmxpbmVUbyhzLHIpLDA9PWclMjUwJiZkKCkpO3U9bS5kYXRhUG9pbnRJZHNbZ107dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFt1XT1cbntpZDp1LG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhU2VyaWVzSW5kZXg6ayxkYXRhUG9pbnRJbmRleDpnLHgxOnMseTE6cix5MjpwfTtnPG4ubGVuZ3RoLTEmJihBIT09KG5bZ10ubGluZUNvbG9yfHx2KXx8RCE9PShuW2ddLmxpbmVEYXNoVHlwZXx8bS5saW5lRGFzaFR5cGUpKSYmKGQoKSxBPW5bZ10ubGluZUNvbG9yfHx2LGhbaC5sZW5ndGgtMV0ubmV3U3Ryb2tlU3R5bGU9QSxiLnN0cm9rZVN0eWxlPUEsYi5zZXRMaW5lRGFzaCYmKG5bZ10ubGluZURhc2hUeXBlPyhEPW5bZ10ubGluZURhc2hUeXBlLGhbaC5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1KKEQsbS5saW5lVGhpY2tuZXNzKSxiLnNldExpbmVEYXNoKGhbaC5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheSkpOihEPW0ubGluZURhc2hUeXBlLGhbaC5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1FLGIuc2V0TGluZURhc2goRSkpKSk7aWYoMCE9PW5bZ10ubWFya2VyU2l6ZSYmKDA8bltnXS5tYXJrZXJTaXplfHxcbjA8bS5tYXJrZXJTaXplKSl7dmFyIFM9bS5nZXRNYXJrZXJQcm9wZXJ0aWVzKGcscyxwLGIpO2YucHVzaChTKTt2YXIgZWE9WCh1KTt3JiZmLnB1c2goe3g6cyx5OnAsY3R4OmUsdHlwZTpTLnR5cGUsc2l6ZTpTLnNpemUsY29sb3I6ZWEsYm9yZGVyQ29sb3I6ZWEsYm9yZGVyVGhpY2tuZXNzOlMuYm9yZGVyVGhpY2tuZXNzfSk7Uz1tLmdldE1hcmtlclByb3BlcnRpZXMoZyxzLHIsYik7Zi5wdXNoKFMpO2VhPVgodSk7dyYmZi5wdXNoKHt4OnMseTpyLGN0eDplLHR5cGU6Uy50eXBlLHNpemU6Uy5zaXplLGNvbG9yOmVhLGJvcmRlckNvbG9yOmVhLGJvcmRlclRoaWNrbmVzczpTLmJvcmRlclRoaWNrbmVzc30pfWlmKG5bZ10uaW5kZXhMYWJlbHx8bS5pbmRleExhYmVsfHxuW2ddLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fG0uaW5kZXhMYWJlbEZvcm1hdHRlcil0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZUFyZWFcIixkYXRhUG9pbnQ6bltnXSxkYXRhU2VyaWVzOm0sXG5pbmRleEtleXdvcmQ6MCxwb2ludDp7eDpzLHk6cn0sZGlyZWN0aW9uOm5bZ10ueVswXT5uW2ddLnlbMV09PT1hLmF4aXNZLnJldmVyc2VkPy0xOjEsY29sb3I6eH0pLHRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcInJhbmdlQXJlYVwiLGRhdGFQb2ludDpuW2ddLGRhdGFTZXJpZXM6bSxpbmRleEtleXdvcmQ6MSxwb2ludDp7eDpzLHk6cH0sZGlyZWN0aW9uOm5bZ10ueVswXT5uW2ddLnlbMV09PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsY29sb3I6eH0pfWVsc2UgTHx8cXx8ZCgpLEw9ITA7ZCgpO1cuZHJhd01hcmtlcnMoZil9fXcmJihjLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZcbmIuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QobC54MSxsLnkxLGwud2lkdGgsbC5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6YyxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0ueENsaXBBbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcubGluZWFyLGFuaW1hdGlvbkJhc2U6MH19fTtwLnByb3RvdHlwZS5yZW5kZXJSYW5nZVNwbGluZUFyZWE9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gZChhLGMpe3ZhciBkPXYocCwyKTtpZigwPGQubGVuZ3RoKXtpZigwPGsubGluZVRoaWNrbmVzcyl7Yi5zdHJva2VTdHlsZT1cbmM7Yi5zZXRMaW5lRGFzaCYmYi5zZXRMaW5lRGFzaChhKTtiLmJlZ2luUGF0aCgpO2IubW92ZVRvKGRbMF0ueCxkWzBdLnkpO2Zvcih2YXIgZj0wO2Y8ZC5sZW5ndGgtMztmKz0zKXtpZihkW2ZdLm5ld1N0cm9rZVN0eWxlfHxkW2ZdLm5ld0xpbmVEYXNoQXJyYXkpYi5zdHJva2UoKSxiLmJlZ2luUGF0aCgpLGIubW92ZVRvKGRbZl0ueCxkW2ZdLnkpLGRbZl0ubmV3U3Ryb2tlU3R5bGUmJihiLnN0cm9rZVN0eWxlPWRbZl0ubmV3U3Ryb2tlU3R5bGUpLGRbZl0ubmV3TGluZURhc2hBcnJheSYmYi5zZXRMaW5lRGFzaChkW2ZdLm5ld0xpbmVEYXNoQXJyYXkpO2IuYmV6aWVyQ3VydmVUbyhkW2YrMV0ueCxkW2YrMV0ueSxkW2YrMl0ueCxkW2YrMl0ueSxkW2YrM10ueCxkW2YrM10ueSl9fWIuYmVnaW5QYXRoKCk7Yi5tb3ZlVG8oZFswXS54LGRbMF0ueSk7dyYmKGUuYmVnaW5QYXRoKCksZS5tb3ZlVG8oZFswXS54LGRbMF0ueSkpO2ZvcihmPTA7ZjxkLmxlbmd0aC0zO2YrPTMpYi5iZXppZXJDdXJ2ZVRvKGRbZitcbjFdLngsZFtmKzFdLnksZFtmKzJdLngsZFtmKzJdLnksZFtmKzNdLngsZFtmKzNdLnkpLHcmJmUuYmV6aWVyQ3VydmVUbyhkW2YrMV0ueCxkW2YrMV0ueSxkW2YrMl0ueCxkW2YrMl0ueSxkW2YrM10ueCxkW2YrM10ueSk7ZD12KGJhLDIpO2IubGluZVRvKGJhW2JhLmxlbmd0aC0xXS54LGJhW2JhLmxlbmd0aC0xXS55KTtmb3IoZj1kLmxlbmd0aC0xOzI8ZjtmLT0zKWIuYmV6aWVyQ3VydmVUbyhkW2YtMV0ueCxkW2YtMV0ueSxkW2YtMl0ueCxkW2YtMl0ueSxkW2YtM10ueCxkW2YtM10ueSksdyYmZS5iZXppZXJDdXJ2ZVRvKGRbZi0xXS54LGRbZi0xXS55LGRbZi0yXS54LGRbZi0yXS55LGRbZi0zXS54LGRbZi0zXS55KTtiLmNsb3NlUGF0aCgpO2IuZ2xvYmFsQWxwaGE9ay5maWxsT3BhY2l0eTtiLmZpbGwoKTt3JiYoZS5jbG9zZVBhdGgoKSxlLmZpbGwoKSk7Yi5nbG9iYWxBbHBoYT0xO2lmKDA8ay5saW5lVGhpY2tuZXNzKXtiLnN0cm9rZVN0eWxlPWM7Yi5zZXRMaW5lRGFzaCYmYi5zZXRMaW5lRGFzaChhKTtcbmIuYmVnaW5QYXRoKCk7Yi5tb3ZlVG8oZFswXS54LGRbMF0ueSk7Zm9yKHZhciBnPWY9MDtmPGQubGVuZ3RoLTM7Zis9MyxnKyspe2lmKHBbZ10ubmV3U3Ryb2tlU3R5bGV8fHBbZ10ubmV3TGluZURhc2hBcnJheSliLnN0cm9rZSgpLGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oZFtmXS54LGRbZl0ueSkscFtnXS5uZXdTdHJva2VTdHlsZSYmKGIuc3Ryb2tlU3R5bGU9cFtnXS5uZXdTdHJva2VTdHlsZSkscFtnXS5uZXdMaW5lRGFzaEFycmF5JiZiLnNldExpbmVEYXNoKHBbZ10ubmV3TGluZURhc2hBcnJheSk7Yi5iZXppZXJDdXJ2ZVRvKGRbZisxXS54LGRbZisxXS55LGRbZisyXS54LGRbZisyXS55LGRbZiszXS54LGRbZiszXS55KX1kPXYocCwyKTtiLm1vdmVUbyhkWzBdLngsZFswXS55KTtmb3IoZz1mPTA7ZjxkLmxlbmd0aC0zO2YrPTMsZysrKXtpZihwW2ddLm5ld1N0cm9rZVN0eWxlfHxwW2ddLm5ld0xpbmVEYXNoQXJyYXkpYi5zdHJva2UoKSxiLmJlZ2luUGF0aCgpLGIubW92ZVRvKGRbZl0ueCxcbmRbZl0ueSkscFtnXS5uZXdTdHJva2VTdHlsZSYmKGIuc3Ryb2tlU3R5bGU9cFtnXS5uZXdTdHJva2VTdHlsZSkscFtnXS5uZXdMaW5lRGFzaEFycmF5JiZiLnNldExpbmVEYXNoKHBbZ10ubmV3TGluZURhc2hBcnJheSk7Yi5iZXppZXJDdXJ2ZVRvKGRbZisxXS54LGRbZisxXS55LGRbZisyXS54LGRbZisyXS55LGRbZiszXS54LGRbZiszXS55KX1iLnN0cm9rZSgpfWIuYmVnaW5QYXRoKCl9fXZhciBjPWEudGFyZ2V0Q2FudmFzQ3R4fHx0aGlzLnBsb3RBcmVhLmN0eCxiPXc/dGhpcy5fcHJlUmVuZGVyQ3R4OmM7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe3ZhciBlPXRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCxmPVtdLGw9dGhpcy5wbG90QXJlYTtiLnNhdmUoKTt3JiZlLnNhdmUoKTtiLmJlZ2luUGF0aCgpO2IucmVjdChsLngxLGwueTEsbC53aWR0aCxsLmhlaWdodCk7Yi5jbGlwKCk7dyYmKGUuYmVnaW5QYXRoKCksZS5yZWN0KGwueDEsbC55MSxsLndpZHRoLFxubC5oZWlnaHQpLGUuY2xpcCgpKTtmb3IodmFyIGg9MDtoPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2grKyl7dmFyIHI9YS5kYXRhU2VyaWVzSW5kZXhlc1toXSxrPXRoaXMuZGF0YVtyXSxtPWsuZGF0YVBvaW50cyxmPWsuaWQ7dGhpcy5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtmXT17b2JqZWN0VHlwZTpcImRhdGFTZXJpZXNcIixkYXRhU2VyaWVzSW5kZXg6cn07Zj1YKGYpO2UuZmlsbFN0eWxlPWY7dmFyIGY9W10sbj0wLHEsZyxzLHA9W10sYmE9W107aWYoMDxtLmxlbmd0aCl7dmFyIHU9ay5fY29sb3JTZXRbbiVrLl9jb2xvclNldC5sZW5ndGhdLHk9ay5saW5lQ29sb3I9ay5vcHRpb25zLmxpbmVDb2xvcnx8dSx4PXk7Yi5maWxsU3R5bGU9dTtiLmxpbmVXaWR0aD1rLmxpbmVUaGlja25lc3M7dmFyIHo9XCJzb2xpZFwiLEE7aWYoYi5zZXRMaW5lRGFzaCl7dmFyIEQ9SihrLm51bGxEYXRhTGluZURhc2hUeXBlLGsubGluZVRoaWNrbmVzcyksej1rLmxpbmVEYXNoVHlwZTtBPUooeixcbmsubGluZVRoaWNrbmVzcyl9Zm9yKGc9ITE7bjxtLmxlbmd0aDtuKyspaWYocT1tW25dLnguZ2V0VGltZT9tW25dLnguZ2V0VGltZSgpOm1bbl0ueCwhKHE8YS5heGlzWC5kYXRhSW5mby52aWV3UG9ydE1pbnx8cT5hLmF4aXNYLmRhdGFJbmZvLnZpZXdQb3J0TWF4JiYoIWsuY29ubmVjdE51bGxEYXRhfHwhZykpKWlmKG51bGwhPT1tW25dLnkmJm1bbl0ueS5sZW5ndGgmJlwibnVtYmVyXCI9PT10eXBlb2YgbVtuXS55WzBdJiZcIm51bWJlclwiPT09dHlwZW9mIG1bbl0ueVsxXSl7cT1hLmF4aXNYLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocSk7Zz1hLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVtuXS55WzBdKTtzPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChtW25dLnlbMV0pO3ZhciBCPWsuZGF0YVBvaW50SWRzW25dO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbQl09e2lkOkIsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpyLGRhdGFQb2ludEluZGV4Om4sXG54MTpxLHkxOmcseTI6c307cFtwLmxlbmd0aF09e3g6cSx5Omd9O2JhW2JhLmxlbmd0aF09e3g6cSx5OnN9O248bS5sZW5ndGgtMSYmKHghPT0obVtuXS5saW5lQ29sb3J8fHkpfHx6IT09KG1bbl0ubGluZURhc2hUeXBlfHxrLmxpbmVEYXNoVHlwZSkpJiYoeD1tW25dLmxpbmVDb2xvcnx8eSxwW3AubGVuZ3RoLTFdLm5ld1N0cm9rZVN0eWxlPXgsYi5zZXRMaW5lRGFzaCYmKG1bbl0ubGluZURhc2hUeXBlPyh6PW1bbl0ubGluZURhc2hUeXBlLHBbcC5sZW5ndGgtMV0ubmV3TGluZURhc2hBcnJheT1KKHosay5saW5lVGhpY2tuZXNzKSk6KHo9ay5saW5lRGFzaFR5cGUscFtwLmxlbmd0aC0xXS5uZXdMaW5lRGFzaEFycmF5PUEpKSk7aWYoMCE9PW1bbl0ubWFya2VyU2l6ZSYmKDA8bVtuXS5tYXJrZXJTaXplfHwwPGsubWFya2VyU2l6ZSkpe3ZhciBHPWsuZ2V0TWFya2VyUHJvcGVydGllcyhuLHEsZyxiKTtmLnB1c2goRyk7dmFyIEw9WChCKTt3JiZmLnB1c2goe3g6cSx5OmcsY3R4OmUsXG50eXBlOkcudHlwZSxzaXplOkcuc2l6ZSxjb2xvcjpMLGJvcmRlckNvbG9yOkwsYm9yZGVyVGhpY2tuZXNzOkcuYm9yZGVyVGhpY2tuZXNzfSk7Rz1rLmdldE1hcmtlclByb3BlcnRpZXMobixxLHMsYik7Zi5wdXNoKEcpO0w9WChCKTt3JiZmLnB1c2goe3g6cSx5OnMsY3R4OmUsdHlwZTpHLnR5cGUsc2l6ZTpHLnNpemUsY29sb3I6TCxib3JkZXJDb2xvcjpMLGJvcmRlclRoaWNrbmVzczpHLmJvcmRlclRoaWNrbmVzc30pfWlmKG1bbl0uaW5kZXhMYWJlbHx8ay5pbmRleExhYmVsfHxtW25dLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGsuaW5kZXhMYWJlbEZvcm1hdHRlcil0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZVNwbGluZUFyZWFcIixkYXRhUG9pbnQ6bVtuXSxkYXRhU2VyaWVzOmssaW5kZXhLZXl3b3JkOjAscG9pbnQ6e3g6cSx5Omd9LGRpcmVjdGlvbjptW25dLnlbMF08PW1bbl0ueVsxXT8tMToxLGNvbG9yOnV9KSx0aGlzLl9pbmRleExhYmVscy5wdXNoKHtjaGFydFR5cGU6XCJyYW5nZVNwbGluZUFyZWFcIixcbmRhdGFQb2ludDptW25dLGRhdGFTZXJpZXM6ayxpbmRleEtleXdvcmQ6MSxwb2ludDp7eDpxLHk6c30sZGlyZWN0aW9uOm1bbl0ueVswXTw9bVtuXS55WzFdPzE6LTEsY29sb3I6dX0pO2c9ITF9ZWxzZSAwPG4mJiFnJiYoay5jb25uZWN0TnVsbERhdGE/Yi5zZXRMaW5lRGFzaCYmKDA8cC5sZW5ndGgmJihrLm9wdGlvbnMubnVsbERhdGFMaW5lRGFzaFR5cGV8fCFtW24tMV0ubGluZURhc2hUeXBlKSkmJihwW3AubGVuZ3RoLTFdLm5ld0xpbmVEYXNoQXJyYXk9RCx6PWsubnVsbERhdGFMaW5lRGFzaFR5cGUpOihkKEEseSkscD1bXSxiYT1bXSkpLGc9ITA7ZChBLHkpO1cuZHJhd01hcmtlcnMoZil9fXcmJihjLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGIuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsXG50aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSxhLmF4aXNZLm1hc2tDYW52YXMmJmIuZHJhd0ltYWdlKGEuYXhpc1kubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5fYnJlYWtzQ2FudmFzQ3R4JiZ0aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYi5jbGVhclJlY3QobC54MSxsLnkxLGwud2lkdGgsbC5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2IucmVzdG9yZSgpO3JldHVybntzb3VyY2U6YyxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0ueENsaXBBbmltYXRpb24sZWFzaW5nRnVuY3Rpb246TS5lYXNpbmcubGluZWFyLGFuaW1hdGlvbkJhc2U6MH19fTtwLnByb3RvdHlwZS5yZW5kZXJXYXRlcmZhbGw9ZnVuY3Rpb24oYSl7dmFyIGQ9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4LFxuYz13P3RoaXMuX3ByZVJlbmRlckN0eDpkO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgYj10aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHgsZT1udWxsLGY9dGhpcy5wbG90QXJlYSxsPTAsaCxyLGssbSxuPWEuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChhLmF4aXNZLmxvZ2FyaXRobWljP2EuYXhpc1kudmlld3BvcnRNaW5pbXVtOjApLGw9dGhpcy5vcHRpb25zLmRhdGFQb2ludE1pbldpZHRoP3RoaXMuZGF0YVBvaW50TWluV2lkdGg6dGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6MTtyPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRNYXhXaWR0aD90aGlzLmRhdGFQb2ludE1heFdpZHRoOnRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOk1hdGgubWluKDAuMTUqdGhpcy53aWR0aCwwLjkqKHRoaXMucGxvdEFyZWEud2lkdGgvYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMpKTw8MDt2YXIgcT1cbmEuYXhpc1guZGF0YUluZm8ubWluRGlmZjtpc0Zpbml0ZShxKXx8KHE9MC4zKk1hdGguYWJzKGEuYXhpc1gucmFuZ2UpKTtxPXRoaXMub3B0aW9ucy5kYXRhUG9pbnRXaWR0aD90aGlzLmRhdGFQb2ludFdpZHRoOjAuNiooZi53aWR0aCooYS5heGlzWC5sb2dhcml0aG1pYz9NYXRoLmxvZyhxKS9NYXRoLmxvZyhhLmF4aXNYLnJhbmdlKTpNYXRoLmFicyhxKS9NYXRoLmFicyhhLmF4aXNYLnJhbmdlKSkvYS5wbG90VHlwZS50b3RhbERhdGFTZXJpZXMpPDwwO3RoaXMuZGF0YVBvaW50TWF4V2lkdGgmJmw+ciYmKGw9TWF0aC5taW4odGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6SW5maW5pdHkscikpOyF0aGlzLmRhdGFQb2ludE1heFdpZHRoJiYodGhpcy5kYXRhUG9pbnRNaW5XaWR0aCYmcjxsKSYmKHI9TWF0aC5tYXgodGhpcy5vcHRpb25zLmRhdGFQb2ludFdpZHRoP3RoaXMuZGF0YVBvaW50V2lkdGg6LUluZmluaXR5LGwpKTtxPGwmJihxPWwpO1xucT5yJiYocT1yKTtjLnNhdmUoKTt3JiZ0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguc2F2ZSgpO2MuYmVnaW5QYXRoKCk7Yy5yZWN0KGYueDEsZi55MSxmLndpZHRoLGYuaGVpZ2h0KTtjLmNsaXAoKTt3JiYodGhpcy5fZXZlbnRNYW5hZ2VyLmdob3N0Q3R4LmJlZ2luUGF0aCgpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZWN0KGYueDEsZi55MSxmLndpZHRoLGYuaGVpZ2h0KSx0aGlzLl9ldmVudE1hbmFnZXIuZ2hvc3RDdHguY2xpcCgpKTtmb3IodmFyIGc9MDtnPGEuZGF0YVNlcmllc0luZGV4ZXMubGVuZ3RoO2crKyl7dmFyIHM9YS5kYXRhU2VyaWVzSW5kZXhlc1tnXSxwPXRoaXMuZGF0YVtzXSx2PXAuZGF0YVBvaW50cyxlPXAuX2NvbG9yU2V0WzBdO3AucmlzaW5nQ29sb3I9cC5vcHRpb25zLnJpc2luZ0NvbG9yP3Aub3B0aW9ucy5yaXNpbmdDb2xvcjplO3AuZmFsbGluZ0NvbG9yPXAub3B0aW9ucy5mYWxsaW5nQ29sb3I/cC5vcHRpb25zLmZhbGxpbmdDb2xvcjpcIiNlNDBhMGFcIjtcbnZhciB1PVwibnVtYmVyXCI9PT10eXBlb2YgcC5vcHRpb25zLmxpbmVUaGlja25lc3M/TWF0aC5yb3VuZChwLmxpbmVUaGlja25lc3MpOjEseT0xPT09TWF0aC5yb3VuZCh1KSUyPy0wLjU6MDtpZigwPHYubGVuZ3RoKWZvcih2YXIgeD01PHEmJnAuYmV2ZWxFbmFibGVkPyEwOiExLHo9ITEsQT1udWxsLEQ9bnVsbCxsPTA7bDx2Lmxlbmd0aDtsKyspaWYodltsXS5nZXRUaW1lP209dltsXS54LmdldFRpbWUoKTptPXZbbF0ueCxcIm51bWJlclwiIT09dHlwZW9mIHZbbF0ueSl7aWYoMDxsJiYheiYmcC5jb25uZWN0TnVsbERhdGEpdmFyIEI9cC5vcHRpb25zLm51bGxEYXRhTGluZURhc2hUeXBlfHwhdltsLTFdLmxpbmVEYXNoVHlwZT9wLm51bGxEYXRhTGluZURhc2hUeXBlOnZbbC0xXS5saW5lRGFzaFR5cGU7ej0hMH1lbHNle2g9YS5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKG0pO3I9MD09PXAuZGF0YVBvaW50RU9zW2xdLmN1bXVsYXRpdmVTdW0/bjphLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocC5kYXRhUG9pbnRFT3NbbF0uY3VtdWxhdGl2ZVN1bSk7XG5rPTA9PT1wLmRhdGFQb2ludEVPc1tsXS5jdW11bGF0aXZlU3VtWVN0YXJ0VmFsdWU/bjphLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwocC5kYXRhUG9pbnRFT3NbbF0uY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlKTtoPWEuYXhpc1gucmV2ZXJzZWQ/aCthLnBsb3RUeXBlLnRvdGFsRGF0YVNlcmllcypxLzItKGEucHJldmlvdXNEYXRhU2VyaWVzQ291bnQrZykqcTw8MDpoLWEucGxvdFR5cGUudG90YWxEYXRhU2VyaWVzKnEvMisoYS5wcmV2aW91c0RhdGFTZXJpZXNDb3VudCtnKSpxPDwwO3ZhciBFPWEuYXhpc1gucmV2ZXJzZWQ/aC1xPDwwOmgrcTw8MDtyPmsmJihlPXIscj1rLGs9ZSk7YS5heGlzWS5yZXZlcnNlZCYmKGU9cixyPWssaz1lKTtlPXAuZGF0YVBvaW50SWRzW2xdO3RoaXMuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbZV09e2lkOmUsb2JqZWN0VHlwZTpcImRhdGFQb2ludFwiLGRhdGFTZXJpZXNJbmRleDpzLGRhdGFQb2ludEluZGV4OmwseDE6aCx5MTpyLHgyOkUseTI6a307XG52YXIgTD12W2xdLmNvbG9yP3ZbbF0uY29sb3I6MDx2W2xdLnk/cC5yaXNpbmdDb2xvcjpwLmZhbGxpbmdDb2xvcjtZKGMsYS5heGlzWC5yZXZlcnNlZD9FOmgsYS5heGlzWS5yZXZlcnNlZD9rOnIsYS5heGlzWC5yZXZlcnNlZD9oOkUsYS5heGlzWS5yZXZlcnNlZD9yOmssTCwwLEwseCx4LCExLCExLHAuZmlsbE9wYWNpdHkpO2U9WChlKTt3JiZZKHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eCxhLmF4aXNYLnJldmVyc2VkP0U6aCxyLGEuYXhpc1gucmV2ZXJzZWQ/aDpFLGssZSwwLG51bGwsITEsITEsITEsITEpO3ZhciBTLEw9aDtTPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgdltsXS5pc0ludGVybWVkaWF0ZVN1bSYmITA9PT12W2xdLmlzSW50ZXJtZWRpYXRlU3VtfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIHZbbF0uaXNDdW11bGF0aXZlU3VtJiYhMD09PXZbbF0uaXNDdW11bGF0aXZlU3VtPzA8dltsXS55P3I6azowPHZbbF0ueT9rOnI7MDxsJiZBJiYoIXp8fHAuY29ubmVjdE51bGxEYXRhKSYmXG4oeiYmYy5zZXRMaW5lRGFzaCYmYy5zZXRMaW5lRGFzaChKKEIsdSkpLGMuYmVnaW5QYXRoKCksYy5tb3ZlVG8oQSxELXkpLGMubGluZVRvKEwsUy15KSwwPHUmJmMuc3Ryb2tlKCksdyYmKGIuYmVnaW5QYXRoKCksYi5tb3ZlVG8oQSxELXkpLGIubGluZVRvKEwsUy15KSwwPHUmJmIuc3Ryb2tlKCkpKTt6PSExO0E9RTtEPTA8dltsXS55P3I6aztMPXZbbF0ubGluZURhc2hUeXBlP3ZbbF0ubGluZURhc2hUeXBlOnAub3B0aW9ucy5saW5lRGFzaFR5cGU/cC5vcHRpb25zLmxpbmVEYXNoVHlwZTpcInNob3J0RGFzaFwiO2Muc3Ryb2tlU3R5bGU9dltsXS5saW5lQ29sb3I/dltsXS5saW5lQ29sb3I6cC5vcHRpb25zLmxpbmVDb2xvcj9wLm9wdGlvbnMubGluZUNvbG9yOlwiIzllOWU5ZVwiO2MubGluZVdpZHRoPXU7Yy5zZXRMaW5lRGFzaCYmKEw9SihMLHUpLGMuc2V0TGluZURhc2goTCkpOyh2W2xdLmluZGV4TGFiZWx8fHAuaW5kZXhMYWJlbHx8dltsXS5pbmRleExhYmVsRm9ybWF0dGVyfHxwLmluZGV4TGFiZWxGb3JtYXR0ZXIpJiZcbnRoaXMuX2luZGV4TGFiZWxzLnB1c2goe2NoYXJ0VHlwZTpcIndhdGVyZmFsbFwiLGRhdGFQb2ludDp2W2xdLGRhdGFTZXJpZXM6cCxwb2ludDp7eDpoKyhFLWgpLzIseTowPD12W2xdLnk/cjprfSxkaXJlY3Rpb246MD52W2xdLnk9PT1hLmF4aXNZLnJldmVyc2VkPzE6LTEsYm91bmRzOnt4MTpoLHkxOk1hdGgubWluKHIsaykseDI6RSx5MjpNYXRoLm1heChyLGspfSxjb2xvcjplfSl9fXcmJihkLmRyYXdJbWFnZSh0aGlzLl9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLGMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uPVwic291cmNlLWF0b3BcIixhLmF4aXNYLm1hc2tDYW52YXMmJmMuZHJhd0ltYWdlKGEuYXhpc1gubWFza0NhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYS5heGlzWS5tYXNrQ2FudmFzJiZjLmRyYXdJbWFnZShhLmF4aXNZLm1hc2tDYW52YXMsMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLHRoaXMuX2JyZWFrc0NhbnZhc0N0eCYmXG50aGlzLl9icmVha3NDYW52YXNDdHguZHJhd0ltYWdlKHRoaXMuX3ByZVJlbmRlckNhbnZhcywwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksYy5jbGVhclJlY3QoZi54MSxmLnkxLGYud2lkdGgsZi5oZWlnaHQpLHRoaXMuX2V2ZW50TWFuYWdlci5naG9zdEN0eC5yZXN0b3JlKCkpO2MucmVzdG9yZSgpO3JldHVybntzb3VyY2U6ZCxkZXN0OnRoaXMucGxvdEFyZWEuY3R4LGFuaW1hdGlvbkNhbGxiYWNrOk0uZmFkZUluQW5pbWF0aW9uLGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19O3ZhciBwYT1mdW5jdGlvbihhLGQsYyxiLGUsZixsLGgscil7aWYoISgwPmMpKXtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGgmJihoPTEpO2lmKCF3KXt2YXIgaz1OdW1iZXIoKGwlKDIqTWF0aC5QSSkpLnRvRml4ZWQoOCkpO051bWJlcigoZiUoMipNYXRoLlBJKSkudG9GaXhlZCg4KSk9PT1rJiYobC09MUUtNCl9YS5zYXZlKCk7YS5nbG9iYWxBbHBoYT1oO1xuXCJwaWVcIj09PWU/KGEuYmVnaW5QYXRoKCksYS5tb3ZlVG8oZC54LGQueSksYS5hcmMoZC54LGQueSxjLGYsbCwhMSksYS5maWxsU3R5bGU9YixhLnN0cm9rZVN0eWxlPVwid2hpdGVcIixhLmxpbmVXaWR0aD0yLGEuY2xvc2VQYXRoKCksYS5maWxsKCkpOlwiZG91Z2hudXRcIj09PWUmJihhLmJlZ2luUGF0aCgpLGEuYXJjKGQueCxkLnksYyxmLGwsITEpLDA8PXImJmEuYXJjKGQueCxkLnkscipjLGwsZiwhMCksYS5jbG9zZVBhdGgoKSxhLmZpbGxTdHlsZT1iLGEuc3Ryb2tlU3R5bGU9XCJ3aGl0ZVwiLGEubGluZVdpZHRoPTIsYS5maWxsKCkpO2EuZ2xvYmFsQWxwaGE9MTthLnJlc3RvcmUoKX19O3AucHJvdG90eXBlLnJlbmRlclBpZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBkKCl7aWYoayYmbSl7Zm9yKHZhciBhPTAsYj0wLGM9MCxkPTAsZT0wO2U8bS5sZW5ndGg7ZSsrKXt2YXIgZj1tW2VdLGw9ay5kYXRhUG9pbnRJZHNbZV07Z1tlXS5pZD1sO2dbZV0ub2JqZWN0VHlwZT1cImRhdGFQb2ludFwiO1xuZ1tlXS5kYXRhUG9pbnRJbmRleD1lO2dbZV0uZGF0YVNlcmllc0luZGV4PTA7dmFyIG49Z1tlXSxoPXtwZXJjZW50Om51bGwsdG90YWw6bnVsbH0sdD1udWxsLGg9cC5nZXRQZXJjZW50QW5kVG90YWwoayxmKTtpZihrLmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGYuaW5kZXhMYWJlbEZvcm1hdHRlcil0PXtjaGFydDpwLm9wdGlvbnMsZGF0YVNlcmllczprLGRhdGFQb2ludDpmLHRvdGFsOmgudG90YWwscGVyY2VudDpoLnBlcmNlbnR9O2g9Zi5pbmRleExhYmVsRm9ybWF0dGVyP2YuaW5kZXhMYWJlbEZvcm1hdHRlcih0KTpmLmluZGV4TGFiZWw/cC5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWUoZi5pbmRleExhYmVsLGYsayxlKTprLmluZGV4TGFiZWxGb3JtYXR0ZXI/ay5pbmRleExhYmVsRm9ybWF0dGVyKHQpOmsuaW5kZXhMYWJlbD9wLnJlcGxhY2VLZXl3b3Jkc1dpdGhWYWx1ZShrLmluZGV4TGFiZWwsZixrLGUpOmYubGFiZWw/Zi5sYWJlbDpcIlwiO3AuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbbF09XG5uO24uY2VudGVyPXt4OngueCx5OngueX07bi55PWYueTtuLnJhZGl1cz1EO24ucGVyY2VudElubmVyUmFkaXVzPUU7bi5pbmRleExhYmVsVGV4dD1oO24uaW5kZXhMYWJlbFBsYWNlbWVudD1rLmluZGV4TGFiZWxQbGFjZW1lbnQ7bi5pbmRleExhYmVsTGluZUNvbG9yPWYuaW5kZXhMYWJlbExpbmVDb2xvcj9mLmluZGV4TGFiZWxMaW5lQ29sb3I6ay5vcHRpb25zLmluZGV4TGFiZWxMaW5lQ29sb3I/ay5vcHRpb25zLmluZGV4TGFiZWxMaW5lQ29sb3I6Zi5jb2xvcj9mLmNvbG9yOmsuX2NvbG9yU2V0W2Ulay5fY29sb3JTZXQubGVuZ3RoXTtuLmluZGV4TGFiZWxMaW5lVGhpY2tuZXNzPXIoZi5pbmRleExhYmVsTGluZVRoaWNrbmVzcyk/ay5pbmRleExhYmVsTGluZVRoaWNrbmVzczpmLmluZGV4TGFiZWxMaW5lVGhpY2tuZXNzO24uaW5kZXhMYWJlbExpbmVEYXNoVHlwZT1mLmluZGV4TGFiZWxMaW5lRGFzaFR5cGU/Zi5pbmRleExhYmVsTGluZURhc2hUeXBlOmsuaW5kZXhMYWJlbExpbmVEYXNoVHlwZTtcbm4uaW5kZXhMYWJlbEZvbnRDb2xvcj1mLmluZGV4TGFiZWxGb250Q29sb3I/Zi5pbmRleExhYmVsRm9udENvbG9yOmsuaW5kZXhMYWJlbEZvbnRDb2xvcjtuLmluZGV4TGFiZWxGb250U3R5bGU9Zi5pbmRleExhYmVsRm9udFN0eWxlP2YuaW5kZXhMYWJlbEZvbnRTdHlsZTprLmluZGV4TGFiZWxGb250U3R5bGU7bi5pbmRleExhYmVsRm9udFdlaWdodD1mLmluZGV4TGFiZWxGb250V2VpZ2h0P2YuaW5kZXhMYWJlbEZvbnRXZWlnaHQ6ay5pbmRleExhYmVsRm9udFdlaWdodDtuLmluZGV4TGFiZWxGb250U2l6ZT1yKGYuaW5kZXhMYWJlbEZvbnRTaXplKT9rLmluZGV4TGFiZWxGb250U2l6ZTpmLmluZGV4TGFiZWxGb250U2l6ZTtuLmluZGV4TGFiZWxGb250RmFtaWx5PWYuaW5kZXhMYWJlbEZvbnRGYW1pbHk/Zi5pbmRleExhYmVsRm9udEZhbWlseTprLmluZGV4TGFiZWxGb250RmFtaWx5O24uaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvcj1mLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3I/XG5mLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3I6ay5vcHRpb25zLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3I/ay5vcHRpb25zLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3I6ay5pbmRleExhYmVsQmFja2dyb3VuZENvbG9yO24uaW5kZXhMYWJlbE1heFdpZHRoPWYuaW5kZXhMYWJlbE1heFdpZHRoP2YuaW5kZXhMYWJlbE1heFdpZHRoOmsuaW5kZXhMYWJlbE1heFdpZHRoP2suaW5kZXhMYWJlbE1heFdpZHRoOjAuMzMqcS53aWR0aDtuLmluZGV4TGFiZWxXcmFwPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgZi5pbmRleExhYmVsV3JhcD9mLmluZGV4TGFiZWxXcmFwOmsuaW5kZXhMYWJlbFdyYXA7bi5pbmRleExhYmVsVGV4dEFsaWduPWYuaW5kZXhMYWJlbFRleHRBbGlnbj9mLmluZGV4TGFiZWxUZXh0QWxpZ246ay5pbmRleExhYmVsVGV4dEFsaWduP2suaW5kZXhMYWJlbFRleHRBbGlnbjpcImxlZnRcIjtuLnN0YXJ0QW5nbGU9MD09PWU/ay5zdGFydEFuZ2xlP2suc3RhcnRBbmdsZS8xODAqXG5NYXRoLlBJOjA6Z1tlLTFdLmVuZEFuZ2xlO24uc3RhcnRBbmdsZT0obi5zdGFydEFuZ2xlKzIqTWF0aC5QSSklKDIqTWF0aC5QSSk7bi5lbmRBbmdsZT1uLnN0YXJ0QW5nbGUrMipNYXRoLlBJL3oqTWF0aC5hYnMoZi55KTtmPShuLmVuZEFuZ2xlK24uc3RhcnRBbmdsZSkvMjtmPShmKzIqTWF0aC5QSSklKDIqTWF0aC5QSSk7bi5taWRBbmdsZT1mO2lmKG4ubWlkQW5nbGU+TWF0aC5QSS8yLXUmJm4ubWlkQW5nbGU8TWF0aC5QSS8yK3Upe2lmKDA9PT1hfHxnW2NdLm1pZEFuZ2xlPm4ubWlkQW5nbGUpYz1lO2ErK31lbHNlIGlmKG4ubWlkQW5nbGU+MypNYXRoLlBJLzItdSYmbi5taWRBbmdsZTwzKk1hdGguUEkvMit1KXtpZigwPT09Ynx8Z1tkXS5taWRBbmdsZT5uLm1pZEFuZ2xlKWQ9ZTtiKyt9bi5oZW1pc3BoZXJlPWY+TWF0aC5QSS8yJiZmPD0zKk1hdGguUEkvMj9cImxlZnRcIjpcInJpZ2h0XCI7bi5pbmRleExhYmVsVGV4dEJsb2NrPW5ldyBqYShwLnBsb3RBcmVhLmN0eCx7Zm9udFNpemU6bi5pbmRleExhYmVsRm9udFNpemUsXG5mb250RmFtaWx5Om4uaW5kZXhMYWJlbEZvbnRGYW1pbHksZm9udENvbG9yOm4uaW5kZXhMYWJlbEZvbnRDb2xvcixmb250U3R5bGU6bi5pbmRleExhYmVsRm9udFN0eWxlLGZvbnRXZWlnaHQ6bi5pbmRleExhYmVsRm9udFdlaWdodCx0ZXh0QWxpZ246bi5pbmRleExhYmVsVGV4dEFsaWduLGJhY2tncm91bmRDb2xvcjpuLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3IsbWF4V2lkdGg6bi5pbmRleExhYmVsTWF4V2lkdGgsbWF4SGVpZ2h0Om4uaW5kZXhMYWJlbFdyYXA/NSpuLmluZGV4TGFiZWxGb250U2l6ZToxLjUqbi5pbmRleExhYmVsRm9udFNpemUsdGV4dDpuLmluZGV4TGFiZWxUZXh0LHBhZGRpbmc6MCx0ZXh0QmFzZWxpbmU6XCJ0b3BcIn0pO24uaW5kZXhMYWJlbFRleHRCbG9jay5tZWFzdXJlVGV4dCgpfWw9Zj0wO2g9ITE7Zm9yKGU9MDtlPG0ubGVuZ3RoO2UrKyluPWdbKGMrZSklbS5sZW5ndGhdLDE8YSYmKG4ubWlkQW5nbGU+TWF0aC5QSS8yLXUmJm4ubWlkQW5nbGU8TWF0aC5QSS9cbjIrdSkmJihmPD1hLzImJiFoPyhuLmhlbWlzcGhlcmU9XCJyaWdodFwiLGYrKyk6KG4uaGVtaXNwaGVyZT1cImxlZnRcIixoPSEwKSk7aD0hMTtmb3IoZT0wO2U8bS5sZW5ndGg7ZSsrKW49Z1soZCtlKSVtLmxlbmd0aF0sMTxiJiYobi5taWRBbmdsZT4zKk1hdGguUEkvMi11JiZuLm1pZEFuZ2xlPDMqTWF0aC5QSS8yK3UpJiYobDw9Yi8yJiYhaD8obi5oZW1pc3BoZXJlPVwibGVmdFwiLGwrKyk6KG4uaGVtaXNwaGVyZT1cInJpZ2h0XCIsaD0hMCkpfX1mdW5jdGlvbiBjKGEpe3ZhciBiPXAucGxvdEFyZWEuY3R4O2IuY2xlYXJSZWN0KHEueDEscS55MSxxLndpZHRoLHEuaGVpZ2h0KTtiLmZpbGxTdHlsZT1wLmJhY2tncm91bmRDb2xvcjtiLmZpbGxSZWN0KHEueDEscS55MSxxLndpZHRoLHEuaGVpZ2h0KTtmb3IoYj0wO2I8bS5sZW5ndGg7YisrKXt2YXIgYz1nW2JdLnN0YXJ0QW5nbGUsZD1nW2JdLmVuZEFuZ2xlO2lmKGQ+Yyl7dmFyIGU9MC4wNypEKk1hdGguY29zKGdbYl0ubWlkQW5nbGUpLGY9XG4wLjA3KkQqTWF0aC5zaW4oZ1tiXS5taWRBbmdsZSksbD0hMTtpZihtW2JdLmV4cGxvZGVkKXtpZigxRS05PE1hdGguYWJzKGdbYl0uY2VudGVyLngtKHgueCtlKSl8fDFFLTk8TWF0aC5hYnMoZ1tiXS5jZW50ZXIueS0oeC55K2YpKSlnW2JdLmNlbnRlci54PXgueCtlKmEsZ1tiXS5jZW50ZXIueT14LnkrZiphLGw9ITB9ZWxzZSBpZigwPE1hdGguYWJzKGdbYl0uY2VudGVyLngteC54KXx8MDxNYXRoLmFicyhnW2JdLmNlbnRlci55LXgueSkpZ1tiXS5jZW50ZXIueD14LngrZSooMS1hKSxnW2JdLmNlbnRlci55PXgueStmKigxLWEpLGw9ITA7bCYmKGU9e30sZS5kYXRhU2VyaWVzPWssZS5kYXRhUG9pbnQ9ay5kYXRhUG9pbnRzW2JdLGUuaW5kZXg9YixwLnRvb2xUaXAuaGlnaGxpZ2h0T2JqZWN0cyhbZV0pKTtwYShwLnBsb3RBcmVhLmN0eCxnW2JdLmNlbnRlcixnW2JdLnJhZGl1cyxtW2JdLmNvbG9yP21bYl0uY29sb3I6ay5fY29sb3JTZXRbYiVrLl9jb2xvclNldC5sZW5ndGhdLGsudHlwZSxcbmMsZCxrLmZpbGxPcGFjaXR5LGdbYl0ucGVyY2VudElubmVyUmFkaXVzKX19YT1wLnBsb3RBcmVhLmN0eDthLnNhdmUoKTthLmZpbGxTdHlsZT1cImJsYWNrXCI7YS5zdHJva2VTdHlsZT1cImdyZXlcIjthLnRleHRCYXNlbGluZT1cIm1pZGRsZVwiO2EubGluZUpvaW49XCJyb3VuZFwiO2ZvcihiPWI9MDtiPG0ubGVuZ3RoO2IrKyljPWdbYl0sYy5pbmRleExhYmVsVGV4dCYmKGMuaW5kZXhMYWJlbFRleHRCbG9jay55LT1jLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIsZD0wLGQ9XCJsZWZ0XCI9PT1jLmhlbWlzcGhlcmU/XCJpbnNpZGVcIiE9PWsuaW5kZXhMYWJlbFBsYWNlbWVudD8tKGMuaW5kZXhMYWJlbFRleHRCbG9jay53aWR0aCtuKTotYy5pbmRleExhYmVsVGV4dEJsb2NrLndpZHRoLzI6XCJpbnNpZGVcIiE9PWsuaW5kZXhMYWJlbFBsYWNlbWVudD9uOi1jLmluZGV4TGFiZWxUZXh0QmxvY2sud2lkdGgvMixjLmluZGV4TGFiZWxUZXh0QmxvY2sueCs9ZCxjLmluZGV4TGFiZWxUZXh0QmxvY2sucmVuZGVyKCEwKSxcbmMuaW5kZXhMYWJlbFRleHRCbG9jay54LT1kLGMuaW5kZXhMYWJlbFRleHRCbG9jay55Kz1jLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIsXCJpbnNpZGVcIiE9PWMuaW5kZXhMYWJlbFBsYWNlbWVudCYmMDxjLmluZGV4TGFiZWxMaW5lVGhpY2tuZXNzJiYoZD1jLmNlbnRlci54K0QqTWF0aC5jb3MoYy5taWRBbmdsZSksZT1jLmNlbnRlci55K0QqTWF0aC5zaW4oYy5taWRBbmdsZSksYS5zdHJva2VTdHlsZT1jLmluZGV4TGFiZWxMaW5lQ29sb3IsYS5saW5lV2lkdGg9Yy5pbmRleExhYmVsTGluZVRoaWNrbmVzcyxhLnNldExpbmVEYXNoJiZhLnNldExpbmVEYXNoKEooYy5pbmRleExhYmVsTGluZURhc2hUeXBlLGMuaW5kZXhMYWJlbExpbmVUaGlja25lc3MpKSxhLmJlZ2luUGF0aCgpLGEubW92ZVRvKGQsZSksYS5saW5lVG8oYy5pbmRleExhYmVsVGV4dEJsb2NrLngsYy5pbmRleExhYmVsVGV4dEJsb2NrLnkpLGEubGluZVRvKGMuaW5kZXhMYWJlbFRleHRCbG9jay54KyhcImxlZnRcIj09PVxuYy5oZW1pc3BoZXJlPy1uOm4pLGMuaW5kZXhMYWJlbFRleHRCbG9jay55KSxhLnN0cm9rZSgpKSxhLmxpbmVKb2luPVwibWl0ZXJcIik7YS5zYXZlKCl9ZnVuY3Rpb24gYihhLGIpe3ZhciBjPTAsYz1hLmluZGV4TGFiZWxUZXh0QmxvY2sueS1hLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIsZD1hLmluZGV4TGFiZWxUZXh0QmxvY2sueSthLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIsZT1iLmluZGV4TGFiZWxUZXh0QmxvY2sueS1iLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIsZj1iLmluZGV4TGFiZWxUZXh0QmxvY2sueStiLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzI7cmV0dXJuIGM9Yi5pbmRleExhYmVsVGV4dEJsb2NrLnk+YS5pbmRleExhYmVsVGV4dEJsb2NrLnk/ZS1kOmMtZn1mdW5jdGlvbiBlKGEpe2Zvcih2YXIgYz1udWxsLGQ9MTtkPG0ubGVuZ3RoO2QrKylpZihjPShhK2QrZy5sZW5ndGgpJWcubGVuZ3RoLGdbY10uaGVtaXNwaGVyZSE9PWdbYV0uaGVtaXNwaGVyZSl7Yz1cbm51bGw7YnJlYWt9ZWxzZSBpZihnW2NdLmluZGV4TGFiZWxUZXh0JiZjIT09YSYmKDA+YihnW2NdLGdbYV0pfHwoXCJyaWdodFwiPT09Z1thXS5oZW1pc3BoZXJlP2dbY10uaW5kZXhMYWJlbFRleHRCbG9jay55Pj1nW2FdLmluZGV4TGFiZWxUZXh0QmxvY2sueTpnW2NdLmluZGV4TGFiZWxUZXh0QmxvY2sueTw9Z1thXS5pbmRleExhYmVsVGV4dEJsb2NrLnkpKSlicmVhaztlbHNlIGM9bnVsbDtyZXR1cm4gY31mdW5jdGlvbiBmKGEsYyxkKXtkPShkfHwwKSsxO2lmKDFFMzxkKXJldHVybiAwO2M9Y3x8MDt2YXIgbD0wLGs9eC55LTEqdyxuPXgueSsxKnc7aWYoMDw9YSYmYTxtLmxlbmd0aCl7dmFyIGg9Z1thXTtpZigwPmMmJmguaW5kZXhMYWJlbFRleHRCbG9jay55PGt8fDA8YyYmaC5pbmRleExhYmVsVGV4dEJsb2NrLnk+bilyZXR1cm4gMDt2YXIgcT0wLHQ9MCx0PXE9cT0wOzA+Yz9oLmluZGV4TGFiZWxUZXh0QmxvY2sueS1oLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzI+ayYmXG5oLmluZGV4TGFiZWxUZXh0QmxvY2sueS1oLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIrYzxrJiYoYz0tKGstKGguaW5kZXhMYWJlbFRleHRCbG9jay55LWguaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMitjKSkpOmguaW5kZXhMYWJlbFRleHRCbG9jay55K2guaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMjxrJiZoLmluZGV4TGFiZWxUZXh0QmxvY2sueStoLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIrYz5uJiYoYz1oLmluZGV4TGFiZWxUZXh0QmxvY2sueStoLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIrYy1uKTtjPWguaW5kZXhMYWJlbFRleHRCbG9jay55K2M7az0wO2s9XCJyaWdodFwiPT09aC5oZW1pc3BoZXJlP3gueCtNYXRoLnNxcnQoTWF0aC5wb3codywyKS1NYXRoLnBvdyhjLXgueSwyKSk6eC54LU1hdGguc3FydChNYXRoLnBvdyh3LDIpLU1hdGgucG93KGMteC55LDIpKTt0PXgueCtEKk1hdGguY29zKGgubWlkQW5nbGUpO3E9eC55K0QqTWF0aC5zaW4oaC5taWRBbmdsZSk7XG5xPU1hdGguc3FydChNYXRoLnBvdyhrLXQsMikrTWF0aC5wb3coYy1xLDIpKTt0PU1hdGguYWNvcyhEL3cpO3E9TWF0aC5hY29zKCh3KncrRCpELXEqcSkvKDIqRCp3KSk7Yz1xPHQ/Yy1oLmluZGV4TGFiZWxUZXh0QmxvY2sueTowO2s9bnVsbDtmb3Iobj0xO248bS5sZW5ndGg7bisrKWlmKGs9KGEtbitnLmxlbmd0aCklZy5sZW5ndGgsZ1trXS5oZW1pc3BoZXJlIT09Z1thXS5oZW1pc3BoZXJlKXtrPW51bGw7YnJlYWt9ZWxzZSBpZihnW2tdLmluZGV4TGFiZWxUZXh0JiZnW2tdLmhlbWlzcGhlcmU9PT1nW2FdLmhlbWlzcGhlcmUmJmshPT1hJiYoMD5iKGdba10sZ1thXSl8fChcInJpZ2h0XCI9PT1nW2FdLmhlbWlzcGhlcmU/Z1trXS5pbmRleExhYmVsVGV4dEJsb2NrLnk8PWdbYV0uaW5kZXhMYWJlbFRleHRCbG9jay55Omdba10uaW5kZXhMYWJlbFRleHRCbG9jay55Pj1nW2FdLmluZGV4TGFiZWxUZXh0QmxvY2sueSkpKWJyZWFrO2Vsc2Ugaz1udWxsO3Q9aztxPWUoYSk7bj1rPTA7MD5cbmM/KG49XCJyaWdodFwiPT09aC5oZW1pc3BoZXJlP3Q6cSxsPWMsbnVsbCE9PW4mJih0PS1jLGM9aC5pbmRleExhYmVsVGV4dEJsb2NrLnktaC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLShnW25dLmluZGV4TGFiZWxUZXh0QmxvY2sueStnW25dLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzIpLGMtdDxzJiYoaz0tdCxuPWYobixrLGQrMSksK24udG9GaXhlZCh5KT4ray50b0ZpeGVkKHkpJiYobD1jPnM/LShjLXMpOi0odC0obi1rKSkpKSkpOjA8YyYmKG49XCJyaWdodFwiPT09aC5oZW1pc3BoZXJlP3E6dCxsPWMsbnVsbCE9PW4mJih0PWMsYz1nW25dLmluZGV4TGFiZWxUZXh0QmxvY2sueS1nW25dLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzItKGguaW5kZXhMYWJlbFRleHRCbG9jay55K2guaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMiksYy10PHMmJihrPXQsbj1mKG4sayxkKzEpLCtuLnRvRml4ZWQoeSk8K2sudG9GaXhlZCh5KSYmKGw9Yz5zP2Mtczp0LShrLW4pKSkpKTtcbmwmJihkPWguaW5kZXhMYWJlbFRleHRCbG9jay55K2wsYz0wLGM9XCJyaWdodFwiPT09aC5oZW1pc3BoZXJlP3gueCtNYXRoLnNxcnQoTWF0aC5wb3codywyKS1NYXRoLnBvdyhkLXgueSwyKSk6eC54LU1hdGguc3FydChNYXRoLnBvdyh3LDIpLU1hdGgucG93KGQteC55LDIpKSxoLm1pZEFuZ2xlPk1hdGguUEkvMi11JiZoLm1pZEFuZ2xlPE1hdGguUEkvMit1PyhrPShhLTErZy5sZW5ndGgpJWcubGVuZ3RoLGs9Z1trXSxhPWdbKGErMStnLmxlbmd0aCklZy5sZW5ndGhdLFwibGVmdFwiPT09aC5oZW1pc3BoZXJlJiZcInJpZ2h0XCI9PT1rLmhlbWlzcGhlcmUmJmM+ay5pbmRleExhYmVsVGV4dEJsb2NrLng/Yz1rLmluZGV4TGFiZWxUZXh0QmxvY2sueC0xNTpcInJpZ2h0XCI9PT1oLmhlbWlzcGhlcmUmJihcImxlZnRcIj09PWEuaGVtaXNwaGVyZSYmYzxhLmluZGV4TGFiZWxUZXh0QmxvY2sueCkmJihjPWEuaW5kZXhMYWJlbFRleHRCbG9jay54KzE1KSk6aC5taWRBbmdsZT4zKk1hdGguUEkvMi11JiZcbmgubWlkQW5nbGU8MypNYXRoLlBJLzIrdSYmKGs9KGEtMStnLmxlbmd0aCklZy5sZW5ndGgsaz1nW2tdLGE9Z1soYSsxK2cubGVuZ3RoKSVnLmxlbmd0aF0sXCJyaWdodFwiPT09aC5oZW1pc3BoZXJlJiZcImxlZnRcIj09PWsuaGVtaXNwaGVyZSYmYzxrLmluZGV4TGFiZWxUZXh0QmxvY2sueD9jPWsuaW5kZXhMYWJlbFRleHRCbG9jay54KzE1OlwibGVmdFwiPT09aC5oZW1pc3BoZXJlJiYoXCJyaWdodFwiPT09YS5oZW1pc3BoZXJlJiZjPmEuaW5kZXhMYWJlbFRleHRCbG9jay54KSYmKGM9YS5pbmRleExhYmVsVGV4dEJsb2NrLngtMTUpKSxoLmluZGV4TGFiZWxUZXh0QmxvY2sueT1kLGguaW5kZXhMYWJlbFRleHRCbG9jay54PWMsaC5pbmRleExhYmVsQW5nbGU9TWF0aC5hdGFuMihoLmluZGV4TGFiZWxUZXh0QmxvY2sueS14LnksaC5pbmRleExhYmVsVGV4dEJsb2NrLngteC54KSl9cmV0dXJuIGx9ZnVuY3Rpb24gbCgpe3ZhciBhPXAucGxvdEFyZWEuY3R4O2EuZmlsbFN0eWxlPVwiZ3JleVwiO2Euc3Ryb2tlU3R5bGU9XG5cImdyZXlcIjthLmZvbnQ9XCIxNnB4IEFyaWFsXCI7YS50ZXh0QmFzZWxpbmU9XCJtaWRkbGVcIjtmb3IodmFyIGM9YT0wLGQ9MCxsPSEwLGM9MDsxMD5jJiYoMT5jfHwwPGQpO2MrKyl7aWYoay5yYWRpdXN8fCFrLnJhZGl1cyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBrLmlubmVyUmFkaXVzJiZudWxsIT09ay5pbm5lclJhZGl1cyYmRC1kPD1CKWw9ITE7bCYmKEQtPWQpO2Q9MDtpZihcImluc2lkZVwiIT09ay5pbmRleExhYmVsUGxhY2VtZW50KXt3PUQqdjtmb3IoYT0wO2E8bS5sZW5ndGg7YSsrKXt2YXIgaD1nW2FdO2guaW5kZXhMYWJlbFRleHRCbG9jay54PXgueCt3Kk1hdGguY29zKGgubWlkQW5nbGUpO2guaW5kZXhMYWJlbFRleHRCbG9jay55PXgueSt3Kk1hdGguc2luKGgubWlkQW5nbGUpO2guaW5kZXhMYWJlbEFuZ2xlPWgubWlkQW5nbGU7aC5yYWRpdXM9RDtoLnBlcmNlbnRJbm5lclJhZGl1cz1FfWZvcih2YXIgdCxyLGE9MDthPG0ubGVuZ3RoO2ErKyl7dmFyIGg9Z1thXSx1PWUoYSk7XG5pZihudWxsIT09dSl7dD1nW2FdO3I9Z1t1XTt2YXIgej0wLHo9Yih0LHIpLXM7aWYoMD56KXtmb3IodmFyIEE9cj0wLEg9MDtIPG0ubGVuZ3RoO0grKylIIT09YSYmZ1tIXS5oZW1pc3BoZXJlPT09aC5oZW1pc3BoZXJlJiYoZ1tIXS5pbmRleExhYmVsVGV4dEJsb2NrLnk8aC5pbmRleExhYmVsVGV4dEJsb2NrLnk/cisrOkErKyk7cj16LyhyK0F8fDEpKkE7dmFyIEE9LTEqKHotciksSj1IPTA7XCJyaWdodFwiPT09aC5oZW1pc3BoZXJlPyhIPWYoYSxyKSxBPS0xKih6LUgpLEo9Zih1LEEpLCtKLnRvRml4ZWQoeSk8K0EudG9GaXhlZCh5KSYmK0gudG9GaXhlZCh5KTw9K3IudG9GaXhlZCh5KSYmZihhLC0oQS1KKSkpOihIPWYodSxyKSxBPS0xKih6LUgpLEo9ZihhLEEpLCtKLnRvRml4ZWQoeSk8K0EudG9GaXhlZCh5KSYmK0gudG9GaXhlZCh5KTw9K3IudG9GaXhlZCh5KSYmZih1LC0oQS1KKSkpfX19fWVsc2UgZm9yKGE9MDthPG0ubGVuZ3RoO2ErKyloPWdbYV0sdz1cInBpZVwiPT09ay50eXBlP1xuMC43KkQ6MC44NSpELHU9eC54K3cqTWF0aC5jb3MoaC5taWRBbmdsZSkscj14LnkrdypNYXRoLnNpbihoLm1pZEFuZ2xlKSxoLmluZGV4TGFiZWxUZXh0QmxvY2sueD11LGguaW5kZXhMYWJlbFRleHRCbG9jay55PXI7Zm9yKGE9MDthPG0ubGVuZ3RoO2ErKylpZihoPWdbYV0sdT1oLmluZGV4TGFiZWxUZXh0QmxvY2subWVhc3VyZVRleHQoKSwwIT09dS5oZWlnaHQmJjAhPT11LndpZHRoKXU9dT0wLFwicmlnaHRcIj09PWguaGVtaXNwaGVyZT8odT1xLngyLShoLmluZGV4TGFiZWxUZXh0QmxvY2sueCtoLmluZGV4TGFiZWxUZXh0QmxvY2sud2lkdGgrbiksdSo9LTEpOnU9cS54MS0oaC5pbmRleExhYmVsVGV4dEJsb2NrLngtaC5pbmRleExhYmVsVGV4dEJsb2NrLndpZHRoLW4pLDA8dSYmKCFsJiZoLmluZGV4TGFiZWxUZXh0JiYocj1cInJpZ2h0XCI9PT1oLmhlbWlzcGhlcmU/cS54Mi1oLmluZGV4TGFiZWxUZXh0QmxvY2sueDpoLmluZGV4TGFiZWxUZXh0QmxvY2sueC1xLngxLDAuMypoLmluZGV4TGFiZWxUZXh0QmxvY2subWF4V2lkdGg+XG5yP2guaW5kZXhMYWJlbFRleHQ9XCJcIjpoLmluZGV4TGFiZWxUZXh0QmxvY2subWF4V2lkdGg9MC44NSpyLDAuMypoLmluZGV4TGFiZWxUZXh0QmxvY2subWF4V2lkdGg8ciYmKGguaW5kZXhMYWJlbFRleHRCbG9jay54LT1cInJpZ2h0XCI9PT1oLmhlbWlzcGhlcmU/MjotMikpLE1hdGguYWJzKGguaW5kZXhMYWJlbFRleHRCbG9jay55LWguaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMi14LnkpPER8fE1hdGguYWJzKGguaW5kZXhMYWJlbFRleHRCbG9jay55K2guaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQvMi14LnkpPEQpJiYodS89TWF0aC5hYnMoTWF0aC5jb3MoaC5pbmRleExhYmVsQW5nbGUpKSw5PHUmJih1Kj0wLjMpLHU+ZCYmKGQ9dSkpLHU9dT0wLDA8aC5pbmRleExhYmVsQW5nbGUmJmguaW5kZXhMYWJlbEFuZ2xlPE1hdGguUEk/KHU9cS55Mi0oaC5pbmRleExhYmVsVGV4dEJsb2NrLnkraC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yKzUpLHUqPS0xKTp1PXEueTEtXG4oaC5pbmRleExhYmVsVGV4dEJsb2NrLnktaC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLTUpLDA8dSYmKCFsJiZoLmluZGV4TGFiZWxUZXh0JiYocj0wPGguaW5kZXhMYWJlbEFuZ2xlJiZoLmluZGV4TGFiZWxBbmdsZTxNYXRoLlBJPy0xOjEsMD09PWYoYSx1KnIpJiZmKGEsMipyKSksTWF0aC5hYnMoaC5pbmRleExhYmVsVGV4dEJsb2NrLngteC54KTxEJiYodS89TWF0aC5hYnMoTWF0aC5zaW4oaC5pbmRleExhYmVsQW5nbGUpKSw5PHUmJih1Kj0wLjMpLHU+ZCYmKGQ9dSkpKTt2YXIgRz1mdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPVtdLGU9MDtkLnB1c2goZ1tiXSksYiE9PWM7Yj0oYisxK20ubGVuZ3RoKSVtLmxlbmd0aCk7ZC5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEueS1iLnl9KTtmb3IoYj0wO2I8ZC5sZW5ndGg7YisrKWlmKGM9ZFtiXSxlPDAuNyphKWUrPWMuaW5kZXhMYWJlbFRleHRCbG9jay5oZWlnaHQsYy5pbmRleExhYmVsVGV4dEJsb2NrLnRleHQ9XCJcIixcbmMuaW5kZXhMYWJlbFRleHQ9XCJcIixjLmluZGV4TGFiZWxUZXh0QmxvY2subWVhc3VyZVRleHQoKTtlbHNlIGJyZWFrfTsoZnVuY3Rpb24oKXtmb3IodmFyIGE9LTEsYz0tMSxkPTAsZj0hMSxsPTA7bDxtLmxlbmd0aDtsKyspaWYoZj0hMSx0PWdbbF0sdC5pbmRleExhYmVsVGV4dCl7dmFyIGs9ZShsKTtpZihudWxsIT09ayl7dmFyIGg9Z1trXTt6PTA7ej1iKHQsaCk7dmFyIHE7aWYocT0wPnope3E9dC5pbmRleExhYmVsVGV4dEJsb2NrLng7dmFyIHM9dC5pbmRleExhYmVsVGV4dEJsb2NrLnktdC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLHA9dC5pbmRleExhYmVsVGV4dEJsb2NrLnkrdC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLHI9aC5pbmRleExhYmVsVGV4dEJsb2NrLnktaC5pbmRleExhYmVsVGV4dEJsb2NrLmhlaWdodC8yLHU9aC5pbmRleExhYmVsVGV4dEJsb2NrLngraC5pbmRleExhYmVsVGV4dEJsb2NrLndpZHRoLEM9aC5pbmRleExhYmVsVGV4dEJsb2NrLnkrXG5oLmluZGV4TGFiZWxUZXh0QmxvY2suaGVpZ2h0LzI7cT10LmluZGV4TGFiZWxUZXh0QmxvY2sueCt0LmluZGV4TGFiZWxUZXh0QmxvY2sud2lkdGg8aC5pbmRleExhYmVsVGV4dEJsb2NrLngtbnx8cT51K258fHM+QytufHxwPHItbj8hMTohMH1xPygwPmEmJihhPWwpLGshPT1hJiYoYz1rLGQrPS16KSwwPT09bCVNYXRoLm1heChtLmxlbmd0aC8xMCwzKSYmKGY9ITApKTpmPSEwO2YmJigwPGQmJjA8PWEmJjA8PWMpJiYoRyhkLGEsYyksYz1hPS0xLGQ9MCl9fTA8ZCYmRyhkLGEsYyl9KSgpfX1mdW5jdGlvbiBoKCl7cC5wbG90QXJlYS5sYXlvdXRNYW5hZ2VyLnJlc2V0KCk7cC50aXRsZSYmKHAudGl0bGUuZG9ja0luc2lkZVBsb3RBcmVhfHxcImNlbnRlclwiPT09cC50aXRsZS5ob3Jpem9udGFsQWxpZ24mJlwiY2VudGVyXCI9PT1wLnRpdGxlLnZlcnRpY2FsQWxpZ24pJiZwLnRpdGxlLnJlbmRlcigpO2lmKHAuc3VidGl0bGVzKWZvcih2YXIgYT0wO2E8cC5zdWJ0aXRsZXMubGVuZ3RoO2ErKyl7dmFyIGI9XG5wLnN1YnRpdGxlc1thXTsoYi5kb2NrSW5zaWRlUGxvdEFyZWF8fFwiY2VudGVyXCI9PT1iLmhvcml6b250YWxBbGlnbiYmXCJjZW50ZXJcIj09PWIudmVydGljYWxBbGlnbikmJmIucmVuZGVyKCl9cC5sZWdlbmQmJihwLmxlZ2VuZC5kb2NrSW5zaWRlUGxvdEFyZWF8fFwiY2VudGVyXCI9PT1wLmxlZ2VuZC5ob3Jpem9udGFsQWxpZ24mJlwiY2VudGVyXCI9PT1wLmxlZ2VuZC52ZXJ0aWNhbEFsaWduKSYmKHAubGVnZW5kLnNldExheW91dCgpLHAubGVnZW5kLnJlbmRlcigpKX12YXIgcD10aGlzO2lmKCEoMD49YS5kYXRhU2VyaWVzSW5kZXhlcy5sZW5ndGgpKXt2YXIgaz10aGlzLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1swXV0sbT1rLmRhdGFQb2ludHMsbj0xMCxxPXRoaXMucGxvdEFyZWEsZz1rLmRhdGFQb2ludEVPcyxzPTIsdyx2PTEuMyx1PTIwLzE4MCpNYXRoLlBJLHk9Nix4PXt4OihxLngyK3EueDEpLzIseToocS55MitxLnkxKS8yfSx6PTA7YT0hMTtmb3IodmFyIEE9MDtBPG0ubGVuZ3RoO0ErKyl6Kz1cbk1hdGguYWJzKG1bQV0ueSksIWEmJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1bQV0uaW5kZXhMYWJlbCYmbnVsbCE9PW1bQV0uaW5kZXhMYWJlbCYmMDxtW0FdLmluZGV4TGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiYoYT0hMCksIWEmJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIG1bQV0ubGFiZWwmJm51bGwhPT1tW0FdLmxhYmVsJiYwPG1bQV0ubGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiYoYT0hMCk7aWYoMCE9PXope2E9YXx8XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBrLmluZGV4TGFiZWwmJm51bGwhPT1rLmluZGV4TGFiZWwmJjA8ay5pbmRleExhYmVsLnRvU3RyaW5nKCkubGVuZ3RoO3ZhciBEPVwiaW5zaWRlXCIhPT1rLmluZGV4TGFiZWxQbGFjZW1lbnQmJmE/MC43NSpNYXRoLm1pbihxLndpZHRoLHEuaGVpZ2h0KS8yOjAuOTIqTWF0aC5taW4ocS53aWR0aCxxLmhlaWdodCkvMjtrLnJhZGl1cyYmKEQ9VGEoay5yYWRpdXMsRCkpO3ZhciBCPVwidW5kZWZpbmVkXCIhPT10eXBlb2Ygay5pbm5lclJhZGl1cyYmXG5udWxsIT09ay5pbm5lclJhZGl1cz9UYShrLmlubmVyUmFkaXVzLEQpOjAuNypEO2sucmFkaXVzPUQ7XCJkb3VnaG51dFwiPT09ay50eXBlJiYoay5pbm5lclJhZGl1cz1CKTt2YXIgRT1NYXRoLm1pbihCL0QsKEQtMSkvRCk7dGhpcy5waWVEb3VnaG51dENsaWNrSGFuZGxlcj1mdW5jdGlvbihhKXtwLmlzQW5pbWF0aW5nfHwhcihhLmRhdGFTZXJpZXMuZXhwbG9kZU9uQ2xpY2spJiYhYS5kYXRhU2VyaWVzLmV4cGxvZGVPbkNsaWNrfHwoYT1hLmRhdGFQb2ludCxhLmV4cGxvZGVkPWEuZXhwbG9kZWQ/ITE6ITAsMTx0aGlzLmRhdGFQb2ludHMubGVuZ3RoJiZwLl9hbmltYXRvci5hbmltYXRlKDAsNTAwLGZ1bmN0aW9uKGEpe2MoYSk7aCgpO3AuZGlzcGF0Y2hFdmVudChcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIix7Y2hhcnQ6cH0pO3AuZGlzcGF0Y2hFdmVudChcImRhdGFBbmltYXRpb25FbmRcIix7Y2hhcnQ6cH0pfSkpfTtkKCk7bCgpO2woKTtsKCk7bCgpO3RoaXMuZGlzYWJsZVRvb2xUaXA9XG4hMDt0aGlzLl9hbmltYXRvci5hbmltYXRlKDAsdGhpcy5hbmltYXRlZFJlbmRlcj90aGlzLmFuaW1hdGlvbkR1cmF0aW9uOjAsZnVuY3Rpb24oYSl7dmFyIGI9cC5wbG90QXJlYS5jdHg7Yi5jbGVhclJlY3QocS54MSxxLnkxLHEud2lkdGgscS5oZWlnaHQpO2IuZmlsbFN0eWxlPXAuYmFja2dyb3VuZENvbG9yO2IuZmlsbFJlY3QocS54MSxxLnkxLHEud2lkdGgscS5oZWlnaHQpO2Zvcih2YXIgYj1nWzBdLnN0YXJ0QW5nbGUrMipNYXRoLlBJKmEsYz0wO2M8bS5sZW5ndGg7YysrKXt2YXIgZD0wPT09Yz9nW2NdLnN0YXJ0QW5nbGU6ZSxlPWQrKGdbY10uZW5kQW5nbGUtZ1tjXS5zdGFydEFuZ2xlKSxmPSExO2U+YiYmKGU9YixmPSEwKTt2YXIgbD1tW2NdLmNvbG9yP21bY10uY29sb3I6ay5fY29sb3JTZXRbYyVrLl9jb2xvclNldC5sZW5ndGhdO2U+ZCYmcGEocC5wbG90QXJlYS5jdHgsZ1tjXS5jZW50ZXIsZ1tjXS5yYWRpdXMsbCxrLnR5cGUsZCxlLGsuZmlsbE9wYWNpdHksZ1tjXS5wZXJjZW50SW5uZXJSYWRpdXMpO1xuaWYoZilicmVha31oKCk7cC5kaXNwYXRjaEV2ZW50KFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLHtjaGFydDpwfSk7MTw9YSYmcC5kaXNwYXRjaEV2ZW50KFwiZGF0YUFuaW1hdGlvbkVuZFwiLHtjaGFydDpwfSl9LGZ1bmN0aW9uKCl7cC5kaXNhYmxlVG9vbFRpcD0hMTtwLl9hbmltYXRvci5hbmltYXRlKDAscC5hbmltYXRlZFJlbmRlcj81MDA6MCxmdW5jdGlvbihhKXtjKGEpO2goKTtwLmRpc3BhdGNoRXZlbnQoXCJkYXRhQW5pbWF0aW9uSXRlcmF0aW9uRW5kXCIse2NoYXJ0OnB9KX0pO3AuZGlzcGF0Y2hFdmVudChcImRhdGFBbmltYXRpb25FbmRcIix7Y2hhcnQ6cH0pfSl9fX07dmFyIHJhPWZ1bmN0aW9uKGEsZCxjLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYyYmKGM9MSk7MD49TWF0aC5yb3VuZChkLnk0LWQueTEpfHwoYS5zYXZlKCksYS5nbG9iYWxBbHBoYT1jLGEuYmVnaW5QYXRoKCksYS5tb3ZlVG8oTWF0aC5yb3VuZChkLngxKSxNYXRoLnJvdW5kKGQueTEpKSxhLmxpbmVUbyhNYXRoLnJvdW5kKGQueDIpLFxuTWF0aC5yb3VuZChkLnkyKSksYS5saW5lVG8oTWF0aC5yb3VuZChkLngzKSxNYXRoLnJvdW5kKGQueTMpKSxhLmxpbmVUbyhNYXRoLnJvdW5kKGQueDQpLE1hdGgucm91bmQoZC55NCkpLFwidW5kZWZpbmVkXCIhPT1kLng1JiYoYS5saW5lVG8oTWF0aC5yb3VuZChkLng1KSxNYXRoLnJvdW5kKGQueTUpKSxhLmxpbmVUbyhNYXRoLnJvdW5kKGQueDYpLE1hdGgucm91bmQoZC55NikpKSxhLmNsb3NlUGF0aCgpLGEuZmlsbFN0eWxlPWI/YjpkLmNvbG9yLGEuZmlsbCgpLGEuZ2xvYmFsQXBsaGE9MSxhLnJlc3RvcmUoKSl9O3AucHJvdG90eXBlLnJlbmRlckZ1bm5lbD1mdW5jdGlvbihhKXtmdW5jdGlvbiBkKCl7Zm9yKHZhciBhPTAsYj1bXSxjPTA7Yzx5Lmxlbmd0aDtjKyspe2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgeVtjXS55KXJldHVybi0xO3lbY10ueT1cIm51bWJlclwiPT09dHlwZW9mIHlbY10ueT95W2NdLnk6MDthKz1NYXRoLmFicyh5W2NdLnkpfWlmKDA9PT1hKXJldHVybi0xO2ZvcihjPVxuYlswXT0wO2M8eS5sZW5ndGg7YysrKWIucHVzaChNYXRoLmFicyh5W2NdLnkpKkUvYSk7cmV0dXJuIGJ9ZnVuY3Rpb24gYygpe3ZhciBhPVQsYj1WLGM9TyxkPVcsZSxmO2U9JDtmPU4tUTtkPU1hdGguYWJzKChmLWUpKihiLWErKGQtYykpLzIpO2M9Vy1PO2U9Zi1lO2Y9YyooZi1OKTtmPU1hdGguYWJzKGYpO2Y9ZCtmO2Zvcih2YXIgZD1bXSxnPTAsbD0wO2w8eS5sZW5ndGg7bCsrKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHlbbF0ueSlyZXR1cm4tMTt5W2xdLnk9XCJudW1iZXJcIj09PXR5cGVvZiB5W2xdLnk/eVtsXS55OjA7Zys9TWF0aC5hYnMoeVtsXS55KX1pZigwPT09ZylyZXR1cm4tMTtmb3IodmFyIGs9ZFswXT0wLG09MCxoLG4sYj1iLWEsaz0hMSxsPTA7bDx5Lmxlbmd0aDtsKyspYT1NYXRoLmFicyh5W2xdLnkpKmYvZyxrP2g9MD09TnVtYmVyKGMudG9GaXhlZCgzKSk/MDphL2M6KG49YWEqYWEqYipiLTQqTWF0aC5hYnMoYWEpKmEsMD5uPyhuPWMsaz0oYituKSooZS1tKS9cbjIsYS09ayxoPWUtbSxtKz1lLW0saCs9MD09bj8wOmEvbixtKz1hL24saz0hMCk6KGg9KE1hdGguYWJzKGFhKSpiLU1hdGguc3FydChuKSkvMixuPWItMipoL01hdGguYWJzKGFhKSxtKz1oLG0+ZSYmKG0tPWgsbj1jLGs9KGIrbikqKGUtbSkvMixhLT1rLGg9ZS1tLG0rPWUtbSxoKz1hL24sbSs9YS9uLGs9ITApLGI9bikpLGQucHVzaChoKTtyZXR1cm4gZH1mdW5jdGlvbiBiKCl7aWYodSYmeSl7Zm9yKHZhciBhLGIsYyxkLGUsZixsLGssbSxoLG4scSx0LHAscyxDPVtdLHg9W10sdj17cGVyY2VudDpudWxsLHRvdGFsOm51bGx9LHo9bnVsbCxEPTA7RDx5Lmxlbmd0aDtEKyspcz1SW0RdLHM9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBzLng1PyhzLnkyK3MueTQpLzI6KHMueTIrcy55MykvMixzPWcocykueDIrMSxDW0RdPUstcy1YO3M9MC41Klg7Zm9yKHZhciBEPTAsQj15Lmxlbmd0aC0xO0Q8eS5sZW5ndGh8fDA8PUI7RCsrLEItLSl7Yj11LnJldmVyc2VkP3lbQl06eVtEXTthPWIuY29sb3I/XG5iLmNvbG9yOnUucmV2ZXJzZWQ/dS5fY29sb3JTZXRbKHkubGVuZ3RoLTEtRCkldS5fY29sb3JTZXQubGVuZ3RoXTp1Ll9jb2xvclNldFtEJXUuX2NvbG9yU2V0Lmxlbmd0aF07Yz1iLmluZGV4TGFiZWxQbGFjZW1lbnR8fHUuaW5kZXhMYWJlbFBsYWNlbWVudHx8XCJvdXRzaWRlXCI7cD1iLmluZGV4TGFiZWxUZXh0QWxpZ258fHUuaW5kZXhMYWJlbFRleHRBbGlnbnx8XCJsZWZ0XCI7ZD1iLmluZGV4TGFiZWxCYWNrZ3JvdW5kQ29sb3J8fHUuaW5kZXhMYWJlbEJhY2tncm91bmRDb2xvcnx8KHc/XCJ0cmFuc3BhcmVudFwiOm51bGwpO2U9Yi5pbmRleExhYmVsRm9udENvbG9yfHx1LmluZGV4TGFiZWxGb250Q29sb3J8fFwiIzk3OTc5N1wiO2Y9cihiLmluZGV4TGFiZWxGb250U2l6ZSk/dS5pbmRleExhYmVsRm9udFNpemU6Yi5pbmRleExhYmVsRm9udFNpemU7bD1iLmluZGV4TGFiZWxGb250U3R5bGV8fHUuaW5kZXhMYWJlbEZvbnRTdHlsZXx8XCJub3JtYWxcIjtrPWIuaW5kZXhMYWJlbEZvbnRGYW1pbHl8fFxudS5pbmRleExhYmVsRm9udEZhbWlseXx8XCJhcmlhbFwiO209Yi5pbmRleExhYmVsRm9udFdlaWdodHx8dS5pbmRleExhYmVsRm9udFdlaWdodHx8XCJub3JtYWxcIjthPWIuaW5kZXhMYWJlbExpbmVDb2xvcnx8dS5vcHRpb25zLmluZGV4TGFiZWxMaW5lQ29sb3J8fGE7aD1cIm51bWJlclwiPT09dHlwZW9mIGIuaW5kZXhMYWJlbExpbmVUaGlja25lc3M/Yi5pbmRleExhYmVsTGluZVRoaWNrbmVzczpcIm51bWJlclwiPT09dHlwZW9mIHUuaW5kZXhMYWJlbExpbmVUaGlja25lc3M/dS5pbmRleExhYmVsTGluZVRoaWNrbmVzczoyO249Yi5pbmRleExhYmVsTGluZURhc2hUeXBlfHx1LmluZGV4TGFiZWxMaW5lRGFzaFR5cGV8fFwic29saWRcIjtxPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgYi5pbmRleExhYmVsV3JhcD9iLmluZGV4TGFiZWxXcmFwOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgdS5pbmRleExhYmVsV3JhcD91LmluZGV4TGFiZWxXcmFwOiEwO3Q9dS5kYXRhUG9pbnRJZHNbRF07QS5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFt0XT1cbntpZDp0LG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhUG9pbnRJbmRleDpELGRhdGFTZXJpZXNJbmRleDowLGZ1bm5lbFNlY3Rpb246Ult1LnJldmVyc2VkP3kubGVuZ3RoLTEtRDpEXX07XCJpbnNpZGVcIj09PXUuaW5kZXhMYWJlbFBsYWNlbWVudCYmKENbRF09RCE9PWNhP3UucmV2ZXJzZWQ/UltEXS54Mi1SW0RdLngxOlJbRF0ueDMtUltEXS54NDpSW0RdLngzLVJbRF0ueDYsMjA+Q1tEXSYmKENbRF09RCE9PWNhP3UucmV2ZXJzZWQ/UltEXS54My1SW0RdLng0OlJbRF0ueDItUltEXS54MTpSW0RdLngyLVJbRF0ueDEsQ1tEXS89MikpO3Q9Yi5pbmRleExhYmVsTWF4V2lkdGg/Yi5pbmRleExhYmVsTWF4V2lkdGg6dS5vcHRpb25zLmluZGV4TGFiZWxNYXhXaWR0aD91LmluZGV4TGFiZWxNYXhXaWR0aDpDW0RdO2lmKHQ+Q1tEXXx8MD50KXQ9Q1tEXTt4W0RdPVwiaW5zaWRlXCI9PT11LmluZGV4TGFiZWxQbGFjZW1lbnQ/cT9NYXRoLm1heChSW0RdLmhlaWdodCxmKToxLjUqZjohMTt2PVxuQS5nZXRQZXJjZW50QW5kVG90YWwodSxiKTtpZih1LmluZGV4TGFiZWxGb3JtYXR0ZXJ8fGIuaW5kZXhMYWJlbEZvcm1hdHRlcil6PXtjaGFydDpBLm9wdGlvbnMsZGF0YVNlcmllczp1LGRhdGFQb2ludDpiLHRvdGFsOnYudG90YWwscGVyY2VudDp2LnBlcmNlbnR9O2I9Yi5pbmRleExhYmVsRm9ybWF0dGVyP2IuaW5kZXhMYWJlbEZvcm1hdHRlcih6KTpiLmluZGV4TGFiZWw/QS5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWUoYi5pbmRleExhYmVsLGIsdSxEKTp1LmluZGV4TGFiZWxGb3JtYXR0ZXI/dS5pbmRleExhYmVsRm9ybWF0dGVyKHopOnUuaW5kZXhMYWJlbD9BLnJlcGxhY2VLZXl3b3Jkc1dpdGhWYWx1ZSh1LmluZGV4TGFiZWwsYix1LEQpOmIubGFiZWw/Yi5sYWJlbDpcIlwiOzA+PWgmJihoPTApOzFFMz50JiYxRTMtdDxzJiYodCs9MUUzLXQpO1Aucm91bmRSZWN0fHxEYShQKTtjPW5ldyBqYShQLHtmb250U2l6ZTpmLGZvbnRGYW1pbHk6ayxmb250Q29sb3I6ZSxmb250U3R5bGU6bCxcbmZvbnRXZWlnaHQ6bSxob3Jpem9udGFsQWxpZ246Yyx0ZXh0QWxpZ246cCxiYWNrZ3JvdW5kQ29sb3I6ZCxtYXhXaWR0aDp0LG1heEhlaWdodDohMT09PXhbRF0/cT80LjI4NTcxNDI5KmY6MS41KmY6eFtEXSx0ZXh0OmIscGFkZGluZzpkYX0pO2MubWVhc3VyZVRleHQoKTtJLnB1c2goe3RleHRCbG9jazpjLGlkOnUucmV2ZXJzZWQ/QjpELGlzRGlydHk6ITEsbGluZUNvbG9yOmEsbGluZVRoaWNrbmVzczpoLGxpbmVEYXNoVHlwZTpuLGhlaWdodDpjLmhlaWdodDxjLm1heEhlaWdodD9jLmhlaWdodDpjLm1heEhlaWdodCx3aWR0aDpjLndpZHRoPGMubWF4V2lkdGg/Yy53aWR0aDpjLm1heFdpZHRofSl9fX1mdW5jdGlvbiBlKCl7dmFyIGEsYixjLGQsZSxmPVtdO2U9ITE7Yz0wO2Zvcih2YXIgZyxsPUstVi1YLzIsbD11Lm9wdGlvbnMuaW5kZXhMYWJlbE1heFdpZHRoP3UuaW5kZXhMYWJlbE1heFdpZHRoPmw/bDp1LmluZGV4TGFiZWxNYXhXaWR0aDpsLGs9SS5sZW5ndGgtMTswPD1rO2stLSl7Zz1cbnlbSVtrXS5pZF07Yz1JW2tdO2Q9Yy50ZXh0QmxvY2s7Yj0oYT1xKGspPFIubGVuZ3RoP0lbcShrKV06bnVsbCk/YS50ZXh0QmxvY2s6bnVsbDtjPWMuaGVpZ2h0O2EmJmQueStjK2RhPmIueSYmKGU9ITApO2M9Zy5pbmRleExhYmVsTWF4V2lkdGh8fGw7aWYoYz5sfHwwPmMpYz1sO2YucHVzaChjKX1pZihlKWZvcihrPUkubGVuZ3RoLTE7MDw9aztrLS0pYT1SW2tdLElba10udGV4dEJsb2NrLm1heFdpZHRoPWZbZi5sZW5ndGgtKGsrMSldLElba10udGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksSVtrXS50ZXh0QmxvY2sueD1LLWwsYz1JW2tdLnRleHRCbG9jay5oZWlnaHQ8SVtrXS50ZXh0QmxvY2subWF4SGVpZ2h0P0lba10udGV4dEJsb2NrLmhlaWdodDpJW2tdLnRleHRCbG9jay5tYXhIZWlnaHQsZT1JW2tdLnRleHRCbG9jay53aWR0aDxJW2tdLnRleHRCbG9jay5tYXhXaWR0aD9JW2tdLnRleHRCbG9jay53aWR0aDpJW2tdLnRleHRCbG9jay5tYXhXaWR0aCxJW2tdLmhlaWdodD1jLFxuSVtrXS53aWR0aD1lLGM9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhLng1PyhhLnkyK2EueTQpLzI6KGEueTIrYS55MykvMixJW2tdLnRleHRCbG9jay55PWMtSVtrXS5oZWlnaHQvMix1LnJldmVyc2VkPyhJW2tdLnRleHRCbG9jay55K0lba10uaGVpZ2h0PlUreiYmKElba10udGV4dEJsb2NrLnk9VSt6LUlba10uaGVpZ2h0KSxJW2tdLnRleHRCbG9jay55PHRhLXomJihJW2tdLnRleHRCbG9jay55PXRhLXopKTooSVtrXS50ZXh0QmxvY2sueTxVLXomJihJW2tdLnRleHRCbG9jay55PVUteiksSVtrXS50ZXh0QmxvY2sueStJW2tdLmhlaWdodD50YSt6JiYoSVtrXS50ZXh0QmxvY2sueT10YSt6LUlba10uaGVpZ2h0KSl9ZnVuY3Rpb24gZigpe3ZhciBhLGIsYyxkO2lmKFwiaW5zaWRlXCIhPT11LmluZGV4TGFiZWxQbGFjZW1lbnQpZm9yKHZhciBlPTA7ZTxSLmxlbmd0aDtlKyspMD09SVtlXS50ZXh0QmxvY2sudGV4dC5sZW5ndGg/SVtlXS5pc0RpcnR5PSEwOihhPVJbZV0sYz1cInVuZGVmaW5lZFwiIT09XG50eXBlb2YgYS54NT8oYS55MithLnk0KS8yOihhLnkyK2EueTMpLzIsYj11LnJldmVyc2VkP1widW5kZWZpbmVkXCIhPT10eXBlb2YgYS54NT9jPkNhP2coYykueDIrMTooYS54MithLngzKS8yKzE6KGEueDIrYS54MykvMisxOlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYS54NT9jPENhP2coYykueDIrMTooYS54NCthLngzKS8yKzE6KGEueDIrYS54MykvMisxLElbZV0udGV4dEJsb2NrLng9YitYLElbZV0udGV4dEJsb2NrLnk9Yy1JW2VdLmhlaWdodC8yLHUucmV2ZXJzZWQ/KElbZV0udGV4dEJsb2NrLnkrSVtlXS5oZWlnaHQ+VSt6JiYoSVtlXS50ZXh0QmxvY2sueT1VK3otSVtlXS5oZWlnaHQpLElbZV0udGV4dEJsb2NrLnk8dGEteiYmKElbZV0udGV4dEJsb2NrLnk9dGEteikpOihJW2VdLnRleHRCbG9jay55PFUteiYmKElbZV0udGV4dEJsb2NrLnk9VS16KSxJW2VdLnRleHRCbG9jay55K0lbZV0uaGVpZ2h0PnRhK3omJihJW2VdLnRleHRCbG9jay55PXRhK3otSVtlXS5oZWlnaHQpKSk7XG5lbHNlIGZvcihlPTA7ZTxSLmxlbmd0aDtlKyspMD09SVtlXS50ZXh0QmxvY2sudGV4dC5sZW5ndGg/SVtlXS5pc0RpcnR5PSEwOihhPVJbZV0sYj1hLmhlaWdodCxjPUlbZV0uaGVpZ2h0LGQ9SVtlXS53aWR0aCxiPj1jPyhiPWUhPWNhPyhhLng0K2EueDMpLzItZC8yOihhLng1K2EueDQpLzItZC8yLGM9ZSE9Y2E/KGEueTErYS55MykvMi1jLzI6KGEueTErYS55NCkvMi1jLzIsSVtlXS50ZXh0QmxvY2sueD1iLElbZV0udGV4dEJsb2NrLnk9Yyk6SVtlXS5pc0RpcnR5PSEwKX1mdW5jdGlvbiBsKCl7ZnVuY3Rpb24gYShiLGMpe3ZhciBkO2lmKDA+Ynx8Yj49SS5sZW5ndGgpcmV0dXJuIDA7dmFyIGUsZj1JW2JdLnRleHRCbG9jaztpZigwPmMpe2MqPS0xO2U9bihiKTtkPWgoZSxiKTtpZihkPj1jKXJldHVybiBmLnktPWMsYztpZigwPT1iKXJldHVybiAwPGQmJihmLnktPWQpLGQ7ZCs9YShlLC0oYy1kKSk7MDxkJiYoZi55LT1kKTtyZXR1cm4gZH1lPXEoYik7ZD1oKGIsZSk7aWYoZD49XG5jKXJldHVybiBmLnkrPWMsYztpZihiPT1SLmxlbmd0aC0xKXJldHVybiAwPGQmJihmLnkrPWQpLGQ7ZCs9YShlLGMtZCk7MDxkJiYoZi55Kz1kKTtyZXR1cm4gZH1mdW5jdGlvbiBiKCl7dmFyIGEsZCxlLGYsZz0wLGs7Zj0oTi0kKzIqeikvbTtrPW07Zm9yKHZhciBsLGg9MTtoPGs7aCsrKXtlPWgqZjtmb3IodmFyIHQ9SS5sZW5ndGgtMTswPD10O3QtLSkhSVt0XS5pc0RpcnR5JiYoSVt0XS50ZXh0QmxvY2sueTxlJiZJW3RdLnRleHRCbG9jay55K0lbdF0uaGVpZ2h0PmUpJiYobD1xKHQpLCEobD49SS5sZW5ndGgtMSkmJklbdF0udGV4dEJsb2NrLnkrSVt0XS5oZWlnaHQrZGE+SVtsXS50ZXh0QmxvY2sueSYmKElbdF0udGV4dEJsb2NrLnk9SVt0XS50ZXh0QmxvY2sueStJW3RdLmhlaWdodC1lPmUtSVt0XS50ZXh0QmxvY2sueT9lKzE6ZS1JW3RdLmhlaWdodC0xKSl9Zm9yKGw9Ui5sZW5ndGgtMTswPGw7bC0tKWlmKCFJW2xdLmlzRGlydHkpe2U9bihsKTtpZigwPmUmJihlPTAsSVtlXS5pc0RpcnR5KSlicmVhaztcbmlmKElbbF0udGV4dEJsb2NrLnk8SVtlXS50ZXh0QmxvY2sueStJW2VdLmhlaWdodCl7ZD1kfHxsO2Y9bDtmb3Ioaz0wO0lbZl0udGV4dEJsb2NrLnk8SVtlXS50ZXh0QmxvY2sueStJW2VdLmhlaWdodCtkYTspe2E9YXx8SVtmXS50ZXh0QmxvY2sueStJW2ZdLmhlaWdodDtrKz1JW2ZdLmhlaWdodDtrKz1kYTtmPWU7aWYoMD49Zil7Zj0wO2srPUlbZl0uaGVpZ2h0O2JyZWFrfWU9bihmKTtpZigwPmUpe2Y9MDtrKz1JW2ZdLmhlaWdodDticmVha319aWYoZiE9bCl7Zz1JW2ZdLnRleHRCbG9jay55O2EtPWc7YT1rLWE7Zz1jKGEsZCxmKTticmVha319fXJldHVybiBnfWZ1bmN0aW9uIGMoYSxiLGQpe3ZhciBlPVtdLGY9MCxnPTA7Zm9yKGE9TWF0aC5hYnMoYSk7ZDw9YjtkKyspZS5wdXNoKFJbZF0pO2Uuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLmhlaWdodC1iLmhlaWdodH0pO2ZvcihkPTA7ZDxlLmxlbmd0aDtkKyspaWYoYj1lW2RdLGY8YSlnKyssZis9SVtiLmlkXS5oZWlnaHQrXG5kYSxJW2IuaWRdLnRleHRCbG9jay50ZXh0PVwiXCIsSVtiLmlkXS5pbmRleExhYmVsVGV4dD1cIlwiLElbYi5pZF0uaXNEaXJ0eT0hMCxJW2IuaWRdLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpO2Vsc2UgYnJlYWs7cmV0dXJuIGd9Zm9yKHZhciBkLGUsZixnLGssbCxtPTEscz0wO3M8MiptO3MrKyl7Zm9yKHZhciBwPUkubGVuZ3RoLTE7MDw9cCYmISgwPD1uKHApJiZuKHApLGY9SVtwXSxnPWYudGV4dEJsb2NrLGw9KGs9cShwKTxSLmxlbmd0aD9JW3EocCldOm51bGwpP2sudGV4dEJsb2NrOm51bGwsZD0rZi5oZWlnaHQudG9GaXhlZCg2KSxlPStnLnkudG9GaXhlZCg2KSwhZi5pc0RpcnR5JiYoayYmZStkK2RhPitsLnkudG9GaXhlZCg2KSkmJihkPWcueStkK2RhLWwueSxlPWEocCwtZCksZTxkJiYoMDxlJiYoZC09ZSksZT1hKHEocCksZCksZSE9ZCkpKTtwLS0pO2IoKX19ZnVuY3Rpb24gaChhLGIpe3JldHVybihiPFIubGVuZ3RoP0lbYl0udGV4dEJsb2NrLnk6dS5yZXZlcnNlZD9VK3o6XG50YSt6KS0oMD5hP3UucmV2ZXJzZWQ/dGEtejpVLXo6SVthXS50ZXh0QmxvY2sueStJW2FdLmhlaWdodCtkYSl9ZnVuY3Rpb24gcChhLGIsYyl7dmFyIGQsZSxnLGw9W10saD16LG49W107LTEhPT1iJiYoMDw9Wi5pbmRleE9mKGIpPyhlPVouaW5kZXhPZihiKSxaLnNwbGljZShlLDEpKTooWi5wdXNoKGIpLFo9Wi5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEtYn0pKSk7aWYoMD09PVoubGVuZ3RoKWw9aWE7ZWxzZXtlPXoqKDEhPVoubGVuZ3RofHwwIT1aWzBdJiZaWzBdIT1SLmxlbmd0aC0xPzI6MSkvaygpO2Zvcih2YXIgcT0wO3E8Ui5sZW5ndGg7cSsrKXtpZigxPT1aLmxlbmd0aCYmMD09WlswXSl7aWYoMD09PXEpe2wucHVzaChpYVtxXSk7ZD1oO2NvbnRpbnVlfX1lbHNlIDA9PT1xJiYoZD0tMSpoKTtsLnB1c2goaWFbcV0rZCk7aWYoMDw9Wi5pbmRleE9mKHEpfHxxPFIubGVuZ3RoJiYwPD1aLmluZGV4T2YocSsxKSlkKz1lfX1nPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVtdLGI9XG4wO2I8Ui5sZW5ndGg7YisrKWEucHVzaChsW2JdLVJbYl0ueTEpO3JldHVybiBhfSgpO3ZhciB0PXtzdGFydFRpbWU6KG5ldyBEYXRlKS5nZXRUaW1lKCksZHVyYXRpb246Y3x8NTAwLGVhc2luZ0Z1bmN0aW9uOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiBNLmVhc2luZy5lYXNlT3V0UXVhcnQoYSxiLGMsZCl9LGNoYW5nZVNlY3Rpb246ZnVuY3Rpb24oYSl7Zm9yKHZhciBiLGMsZD0wO2Q8Ui5sZW5ndGg7ZCsrKWI9Z1tkXSxjPVJbZF0sYio9YSxcInVuZGVmaW5lZFwiPT09dHlwZW9mIG5bZF0mJihuW2RdPTApLDA+biYmKG4qPS0xKSxjLnkxKz1iLW5bZF0sYy55Mis9Yi1uW2RdLGMueTMrPWItbltkXSxjLnk0Kz1iLW5bZF0sYy55NSYmKGMueTUrPWItbltkXSxjLnk2Kz1iLW5bZF0pLG5bZF09Yn19O2EuX2FuaW1hdG9yLmFuaW1hdGUoMCxjLGZ1bmN0aW9uKGMpe3ZhciBkPWEucGxvdEFyZWEuY3R4fHxhLmN0eDtoYT0hMDtkLmNsZWFyUmVjdCh4LngxLHgueTEseC54Mi14LngxLHgueTItXG54LnkxKTtkLmZpbGxTdHlsZT1hLmJhY2tncm91bmRDb2xvcjtkLmZpbGxSZWN0KHgueDEseC55MSx4LndpZHRoLHguaGVpZ2h0KTt0LmNoYW5nZVNlY3Rpb24oYyxiKTt2YXIgZT17fTtlLmRhdGFTZXJpZXM9dTtlLmRhdGFQb2ludD11LnJldmVyc2VkP3UuZGF0YVBvaW50c1t5Lmxlbmd0aC0xLWJdOnUuZGF0YVBvaW50c1tiXTtlLmluZGV4PXUucmV2ZXJzZWQ/eS5sZW5ndGgtMS1iOmI7YS50b29sVGlwLmhpZ2hsaWdodE9iamVjdHMoW2VdKTtmb3IoZT0wO2U8Ui5sZW5ndGg7ZSsrKXJhKGQsUltlXSx1LmZpbGxPcGFjaXR5KTt2KGQpO0wmJihcImluc2lkZVwiIT09dS5pbmRleExhYmVsUGxhY2VtZW50P20oZCk6ZigpLHMoZCkpOzE8PWMmJihoYT0hMSl9LG51bGwsTS5lYXNpbmcuZWFzZU91dFF1YXJ0KX1mdW5jdGlvbiBrKCl7Zm9yKHZhciBhPTAsYj0wO2I8Ui5sZW5ndGgtMTtiKyspKDA8PVouaW5kZXhPZihiKXx8MDw9Wi5pbmRleE9mKGIrMSkpJiZhKys7cmV0dXJuIGF9ZnVuY3Rpb24gbShhKXtmb3IodmFyIGIsXG5jLGQsZSxmPTA7ZjxSLmxlbmd0aDtmKyspZT0xPT09SVtmXS5saW5lVGhpY2tuZXNzJTI/MC41OjAsYz0oKFJbZl0ueTIrUltmXS55NCkvMjw8MCkrZSxiPWcoYykueDItMSxkPUlbZl0udGV4dEJsb2NrLngsZT0oSVtmXS50ZXh0QmxvY2sueStJW2ZdLmhlaWdodC8yPDwwKStlLElbZl0uaXNEaXJ0eXx8MD09SVtmXS5saW5lVGhpY2tuZXNzfHwoYS5zdHJva2VTdHlsZT1JW2ZdLmxpbmVDb2xvcixhLmxpbmVXaWR0aD1JW2ZdLmxpbmVUaGlja25lc3MsYS5zZXRMaW5lRGFzaCYmYS5zZXRMaW5lRGFzaChKKElbZl0ubGluZURhc2hUeXBlLElbZl0ubGluZVRoaWNrbmVzcykpLGEuYmVnaW5QYXRoKCksYS5tb3ZlVG8oYixjKSxhLmxpbmVUbyhkLGUpLGEuc3Ryb2tlKCkpfWZ1bmN0aW9uIG4oYSl7Zm9yKGEtPTE7LTE8PWEmJi0xIT1hJiZJW2FdLmlzRGlydHk7YS0tKTtyZXR1cm4gYX1mdW5jdGlvbiBxKGEpe2ZvcihhKz0xO2E8PVIubGVuZ3RoJiZhIT1SLmxlbmd0aCYmSVthXS5pc0RpcnR5O2ErKyk7XG5yZXR1cm4gYX1mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYixjPTA7Yzx5Lmxlbmd0aDtjKyspaWYoUltjXS55MTxhJiZSW2NdLnk0PmEpe2I9UltjXTticmVha31yZXR1cm4gYj8oYT1iLnk2P2E+Yi55Nj9iLngzKyhiLng0LWIueDMpLyhiLnk0LWIueTMpKihhLWIueTMpOmIueDIrKGIueDMtYi54MikvKGIueTMtYi55MikqKGEtYi55Mik6Yi54MisoYi54My1iLngyKS8oYi55My1iLnkyKSooYS1iLnkyKSx7eDE6YSx4MjphfSk6LTF9ZnVuY3Rpb24gcyhhKXtmb3IodmFyIGI9MDtiPFIubGVuZ3RoO2IrKylJW2JdLmlzRGlydHl8fChhJiYoSVtiXS50ZXh0QmxvY2suY3R4PWEpLElbYl0udGV4dEJsb2NrLnJlbmRlcighMCkpfWZ1bmN0aW9uIHYoYSl7QS5wbG90QXJlYS5sYXlvdXRNYW5hZ2VyLnJlc2V0KCk7YS5yb3VuZFJlY3R8fERhKGEpO0EudGl0bGUmJihBLnRpdGxlLmRvY2tJbnNpZGVQbG90QXJlYXx8XCJjZW50ZXJcIj09PUEudGl0bGUuaG9yaXpvbnRhbEFsaWduJiZcImNlbnRlclwiPT09XG5BLnRpdGxlLnZlcnRpY2FsQWxpZ24pJiYoQS50aXRsZS5jdHg9YSxBLnRpdGxlLnJlbmRlcigpKTtpZihBLnN1YnRpdGxlcylmb3IodmFyIGI9MDtiPEEuc3VidGl0bGVzLmxlbmd0aDtiKyspe3ZhciBjPUEuc3VidGl0bGVzW2JdO2lmKGMuZG9ja0luc2lkZVBsb3RBcmVhfHxcImNlbnRlclwiPT09Yy5ob3Jpem9udGFsQWxpZ24mJlwiY2VudGVyXCI9PT1jLnZlcnRpY2FsQWxpZ24pQS5zdWJ0aXRsZXMuY3R4PWEsYy5yZW5kZXIoKX1BLmxlZ2VuZCYmKEEubGVnZW5kLmRvY2tJbnNpZGVQbG90QXJlYXx8XCJjZW50ZXJcIj09PUEubGVnZW5kLmhvcml6b250YWxBbGlnbiYmXCJjZW50ZXJcIj09PUEubGVnZW5kLnZlcnRpY2FsQWxpZ24pJiYoQS5sZWdlbmQuY3R4PWEsQS5sZWdlbmQuc2V0TGF5b3V0KCksQS5sZWdlbmQucmVuZGVyKCkpO3ZhLmZOZyYmdmEuZk5nKEEpfXZhciBBPXRoaXM7aWYoISgwPj1hLmRhdGFTZXJpZXNJbmRleGVzLmxlbmd0aCkpe2Zvcih2YXIgdT10aGlzLmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhlc1swXV0sXG55PXUuZGF0YVBvaW50cyx4PXRoaXMucGxvdEFyZWEsej0wLjAyNSp4LndpZHRoLEI9MC4wMSp4LndpZHRoLEQ9MCxFPXguaGVpZ2h0LTIqeixHPU1hdGgubWluKHgud2lkdGgtMipCLDIuOCp4LmhlaWdodCksTD0hMSxTPTA7Uzx5Lmxlbmd0aDtTKyspaWYoIUwmJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHlbU10uaW5kZXhMYWJlbCYmbnVsbCE9PXlbU10uaW5kZXhMYWJlbCYmMDx5W1NdLmluZGV4TGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiYoTD0hMCksIUwmJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHlbU10ubGFiZWwmJm51bGwhPT15W1NdLmxhYmVsJiYwPHlbU10ubGFiZWwudG9TdHJpbmcoKS5sZW5ndGgpJiYoTD0hMCksIUwmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiB1LmluZGV4TGFiZWxGb3JtYXR0ZXJ8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiB5W1NdLmluZGV4TGFiZWxGb3JtYXR0ZXIpTD0hMDtMPUx8fFwidW5kZWZpbmVkXCIhPT10eXBlb2YgdS5pbmRleExhYmVsJiZudWxsIT09dS5pbmRleExhYmVsJiZcbjA8dS5pbmRleExhYmVsLnRvU3RyaW5nKCkubGVuZ3RoO1wiaW5zaWRlXCIhPT11LmluZGV4TGFiZWxQbGFjZW1lbnQmJkx8fChCPSh4LndpZHRoLTAuNzUqRykvMik7dmFyIFM9eC54MStCLEs9eC54Mi1CLCQ9eC55MSt6LE49eC55Mi16LFA9YS50YXJnZXRDYW52YXNDdHh8fHRoaXMucGxvdEFyZWEuY3R4fHx0aGlzLmN0eDtpZigwIT11Lmxlbmd0aCYmKHUuZGF0YVBvaW50cyYmdS52aXNpYmxlKSYmMCE9PXkubGVuZ3RoKXt2YXIgUSxGO2E9NzUqRy8xMDA7dmFyIFg9MzAqKEstYSkvMTAwO1wiZnVubmVsXCI9PT11LnR5cGU/KFE9cih1Lm9wdGlvbnMubmVja0hlaWdodCk/MC4zNSpFOnUubmVja0hlaWdodCxGPXIodS5vcHRpb25zLm5lY2tXaWR0aCk/MC4yNSphOnUubmVja1dpZHRoLFwic3RyaW5nXCI9PT10eXBlb2YgUSYmUS5tYXRjaCgvJSQvKT8oUT1wYXJzZUludChRKSxRPVEqRS8xMDApOlE9cGFyc2VJbnQoUSksXCJzdHJpbmdcIj09PXR5cGVvZiBGJiZGLm1hdGNoKC8lJC8pPyhGPXBhcnNlSW50KEYpLFxuRj1GKmEvMTAwKTpGPXBhcnNlSW50KEYpLFE+RT9RPUU6MD49USYmKFE9MCksRj5hP0Y9YS0wLjU6MD49RiYmKEY9MCkpOlwicHlyYW1pZFwiPT09dS50eXBlJiYoRj1RPTAsdS5yZXZlcnNlZD11LnJldmVyc2VkPyExOiEwKTt2YXIgQj1TK2EvMixUPVMsVj1TK2EsVT11LnJldmVyc2VkP046JCxPPUItRi8yLFc9QitGLzIsQ2E9dS5yZXZlcnNlZD8kK1E6Ti1RLHRhPXUucmV2ZXJzZWQ/JDpOO2E9W107dmFyIEI9W10sUj1bXSxHPVtdLFk9JCxjYSxhYT0oQ2EtVSkvKE8tVCksZmE9LWFhLFM9XCJhcmVhXCI9PT0odS52YWx1ZVJlcHJlc2VudHM/dS52YWx1ZVJlcHJlc2VudHM6XCJoZWlnaHRcIik/YygpOmQoKTtpZigtMSE9PVMpe2lmKHUucmV2ZXJzZWQpZm9yKEcucHVzaChZKSxGPVMubGVuZ3RoLTE7MDxGO0YtLSlZKz1TW0ZdLEcucHVzaChZKTtlbHNlIGZvcihGPTA7RjxTLmxlbmd0aDtGKyspWSs9U1tGXSxHLnB1c2goWSk7aWYodS5yZXZlcnNlZClmb3IoRj0wO0Y8Uy5sZW5ndGg7RisrKUdbRl08XG5DYT8oYS5wdXNoKE8pLEIucHVzaChXKSxjYT1GKTooYS5wdXNoKChHW0ZdLVUrYWEqVCkvYWEpLEIucHVzaCgoR1tGXS1VK2ZhKlYpL2ZhKSk7ZWxzZSBmb3IoRj0wO0Y8Uy5sZW5ndGg7RisrKUdbRl08Q2E/KGEucHVzaCgoR1tGXS1VK2FhKlQpL2FhKSxCLnB1c2goKEdbRl0tVStmYSpWKS9mYSksY2E9Rik6KGEucHVzaChPKSxCLnB1c2goVykpO2ZvcihGPTA7RjxTLmxlbmd0aC0xO0YrKylZPXUucmV2ZXJzZWQ/eVt5Lmxlbmd0aC0xLUZdLmNvbG9yP3lbeS5sZW5ndGgtMS1GXS5jb2xvcjp1Ll9jb2xvclNldFsoeS5sZW5ndGgtMS1GKSV1Ll9jb2xvclNldC5sZW5ndGhdOnlbRl0uY29sb3I/eVtGXS5jb2xvcjp1Ll9jb2xvclNldFtGJXUuX2NvbG9yU2V0Lmxlbmd0aF0sRj09PWNhP1IucHVzaCh7eDE6YVtGXSx5MTpHW0ZdLHgyOkJbRl0seTI6R1tGXSx4MzpXLHkzOkNhLHg0OkJbRisxXSx5NDpHW0YrMV0seDU6YVtGKzFdLHk1OkdbRisxXSx4NjpPLHk2OkNhLGlkOkYsaGVpZ2h0OkdbRitcbjFdLUdbRl0sY29sb3I6WX0pOlIucHVzaCh7eDE6YVtGXSx5MTpHW0ZdLHgyOkJbRl0seTI6R1tGXSx4MzpCW0YrMV0seTM6R1tGKzFdLHg0OmFbRisxXSx5NDpHW0YrMV0saWQ6RixoZWlnaHQ6R1tGKzFdLUdbRl0sY29sb3I6WX0pO3ZhciBkYT0yLEk9W10saGE9ITEsWj1bXSxpYT1bXSxTPSExO2E9YT0wO0VhKFopO2ZvcihGPTA7Rjx5Lmxlbmd0aDtGKyspeVtGXS5leHBsb2RlZCYmKFM9ITAsdS5yZXZlcnNlZD9aLnB1c2goeS5sZW5ndGgtMS1GKTpaLnB1c2goRikpO1AuY2xlYXJSZWN0KHgueDEseC55MSx4LndpZHRoLHguaGVpZ2h0KTtQLmZpbGxTdHlsZT1BLmJhY2tncm91bmRDb2xvcjtQLmZpbGxSZWN0KHgueDEseC55MSx4LndpZHRoLHguaGVpZ2h0KTtpZihMJiZ1LnZpc2libGUmJihiKCksZigpLGUoKSxcImluc2lkZVwiIT09dS5pbmRleExhYmVsUGxhY2VtZW50KSl7bCgpO2ZvcihGPTA7Rjx5Lmxlbmd0aDtGKyspSVtGXS5pc0RpcnR5fHwoYT1JW0ZdLnRleHRCbG9jay54K1xuSVtGXS53aWR0aCxhPShLLWEpLzIsMD09RiYmKEQ9YSksRD5hJiYoRD1hKSk7Zm9yKEY9MDtGPFIubGVuZ3RoO0YrKylSW0ZdLngxKz1ELFJbRl0ueDIrPUQsUltGXS54Mys9RCxSW0ZdLng0Kz1ELFJbRl0ueDUmJihSW0ZdLng1Kz1ELFJbRl0ueDYrPUQpLElbRl0udGV4dEJsb2NrLngrPUR9Zm9yKEY9MDtGPFIubGVuZ3RoO0YrKylEPVJbRl0scmEoUCxELHUuZmlsbE9wYWNpdHkpLGlhLnB1c2goRC55MSk7dihQKTtMJiZ1LnZpc2libGUmJihcImluc2lkZVwiPT09dS5pbmRleExhYmVsUGxhY2VtZW50fHxBLmFuaW1hdGlvbkVuYWJsZWR8fG0oUCksQS5hbmltYXRpb25FbmFibGVkfHxzKCkpO2lmKCFMKWZvcihGPTA7Rjx5Lmxlbmd0aDtGKyspRD11LmRhdGFQb2ludElkc1tGXSxhPXtpZDpELG9iamVjdFR5cGU6XCJkYXRhUG9pbnRcIixkYXRhUG9pbnRJbmRleDpGLGRhdGFTZXJpZXNJbmRleDowLGZ1bm5lbFNlY3Rpb246Ult1LnJldmVyc2VkP3kubGVuZ3RoLTEtRjpGXX0sQS5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtEXT1cbmE7IUEuYW5pbWF0aW9uRW5hYmxlZCYmUz9wKEEsLTEsMCk6QS5hbmltYXRpb25FbmFibGVkJiYhQS5hbmltYXRlZFJlbmRlciYmcChBLC0xLDApO3RoaXMuZnVubmVsUHlyYW1pZENsaWNrSGFuZGxlcj1mdW5jdGlvbihhKXt2YXIgYj0tMTtpZighaGEmJiFBLmlzQW5pbWF0aW5nJiYocihhLmRhdGFTZXJpZXMuZXhwbG9kZU9uQ2xpY2spfHxhLmRhdGFTZXJpZXMuZXhwbG9kZU9uQ2xpY2spJiYoYj11LnJldmVyc2VkP3kubGVuZ3RoLTEtYS5kYXRhUG9pbnRJbmRleDphLmRhdGFQb2ludEluZGV4LDA8PWIpKXthPWI7aWYoXCJmdW5uZWxcIj09PXUudHlwZXx8XCJweXJhbWlkXCI9PT11LnR5cGUpdS5yZXZlcnNlZD95W3kubGVuZ3RoLTEtYV0uZXhwbG9kZWQ9eVt5Lmxlbmd0aC0xLWFdLmV4cGxvZGVkPyExOiEwOnlbYV0uZXhwbG9kZWQ9eVthXS5leHBsb2RlZD8hMTohMDtwKEEsYiw1MDApfX07cmV0dXJue3NvdXJjZTpQLGRlc3Q6dGhpcy5wbG90QXJlYS5jdHgsYW5pbWF0aW9uQ2FsbGJhY2s6ZnVuY3Rpb24oYSxcbmIpe00uZmFkZUluQW5pbWF0aW9uKGEsYik7MTw9YSYmKHAoQSwtMSw1MDApLHYoQS5wbG90QXJlYS5jdHh8fEEuY3R4KSl9LGVhc2luZ0Z1bmN0aW9uOk0uZWFzaW5nLmVhc2VJblF1YWQsYW5pbWF0aW9uQmFzZTowfX19fX07cC5wcm90b3R5cGUucmVxdWVzdEFuaW1GcmFtZT1mdW5jdGlvbigpe3JldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihhKXt3aW5kb3cuc2V0VGltZW91dChhLDFFMy82MCl9fSgpO3AucHJvdG90eXBlLmNhbmNlbFJlcXVlc3RBbmltRnJhbWU9d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96Q2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxcbndpbmRvdy5vQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGNsZWFyVGltZW91dDtwLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oYSxkLGMpe2M9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjPyEwOmM7XCJvcHRpb25zXCI9PT1hPyh0aGlzLm9wdGlvbnM9ZCxjJiZ0aGlzLnJlbmRlcigpKTpwLmJhc2Uuc2V0LmNhbGwodGhpcyxhLGQsYyl9O3AucHJvdG90eXBlLmV4cG9ydENoYXJ0PWZ1bmN0aW9uKGEpe2E9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP3t9OmE7dmFyIGQ9YS5mb3JtYXQ/YS5mb3JtYXQ6XCJwbmdcIixjPWEuZmlsZU5hbWU/YS5maWxlTmFtZTp0aGlzLmV4cG9ydEZpbGVOYW1lO2lmKGEudG9EYXRhVVJMKXJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9cIitkKTt2YXIgYj10aGlzLmNhbnZhcztpZihiJiZkJiZjKXtjPWMrXCIuXCIrZDthPVwiaW1hZ2UvXCIrZDt2YXIgYj1iLnRvRGF0YVVSTChhKSxlPSExLFxuZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtmLmRvd25sb2FkPWM7Zi5ocmVmPWI7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBCbG9iJiZuZXcgQmxvYil7Zm9yKHZhciBsPWIucmVwbGFjZSgvXmRhdGE6W2EtelxcL10qO2Jhc2U2NCwvLFwiXCIpLGw9YXRvYihsKSxoPW5ldyBBcnJheUJ1ZmZlcihsLmxlbmd0aCksaD1uZXcgVWludDhBcnJheShoKSxwPTA7cDxsLmxlbmd0aDtwKyspaFtwXT1sLmNoYXJDb2RlQXQocCk7ZD1uZXcgQmxvYihbaC5idWZmZXJdLHt0eXBlOlwiaW1hZ2UvXCIrZH0pO3RyeXt3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoZCxjKSxlPSEwfWNhdGNoKGspe2YuZGF0YXNldC5kb3dubG9hZHVybD1bYSxmLmRvd25sb2FkLGYuaHJlZl0uam9pbihcIjpcIiksZi5ocmVmPXdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGQpfX1pZighZSl0cnl7ZXZlbnQ9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50c1wiKSxldmVudC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsXG4hMCwhMSx3aW5kb3csMCwwLDAsMCwwLCExLCExLCExLCExLDAsbnVsbCksZi5kaXNwYXRjaEV2ZW50P2YuZGlzcGF0Y2hFdmVudChldmVudCk6Zi5maXJlRXZlbnQmJmYuZmlyZUV2ZW50KFwib25jbGlja1wiKX1jYXRjaChtKXtkPXdpbmRvdy5vcGVuKCksZC5kb2N1bWVudC53cml0ZShcIjxpbWcgc3JjPSdcIitiK1wiJz48L2ltZz48ZGl2PlBsZWFzZSByaWdodCBjbGljayBvbiB0aGUgaW1hZ2UgYW5kIHNhdmUgaXQgdG8geW91ciBkZXZpY2U8L2Rpdj5cIiksZC5kb2N1bWVudC5jbG9zZSgpfX19O3AucHJvdG90eXBlLnByaW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5leHBvcnRDaGFydCh7dG9EYXRhVVJMOiEwfSksZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2Quc2V0QXR0cmlidXRlKFwiY2xhc3NcIixcImNhbnZhc2pzLWNoYXJ0LXByaW50LWZyYW1lXCIpO1YoZCx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHdpZHRoOlwiMTAwJVwiLGJvcmRlcjpcIjBweFwiLG1hcmdpbjpcIjBweCAwcHggMHB4IDBweFwiLFxucGFkZGluZzpcIjBweCAwcHggMHB4IDBweFwifSk7ZC5zdHlsZS5oZWlnaHQ9dGhpcy5oZWlnaHQrXCJweFwiO3RoaXMuX2NhbnZhc0pTQ29udGFpbmVyLmFwcGVuZENoaWxkKGQpO3ZhciBjPXRoaXMsYj1kLmNvbnRlbnRXaW5kb3d8fGQuY29udGVudERvY3VtZW50LmRvY3VtZW50fHxkLmNvbnRlbnREb2N1bWVudDtiLmRvY3VtZW50Lm9wZW4oKTtiLmRvY3VtZW50LndyaXRlKCc8IURPQ1RZUEUgSFRNTD5cXG48aHRtbD48Ym9keT48aW1nIHNyYz1cIicrYSsnXCIvPjxib2R5Lz48L2h0bWw+Jyk7Yi5kb2N1bWVudC5ib2R5JiZiLmRvY3VtZW50LmJvZHkuc3R5bGUmJihiLmRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luPVwiMHB4IDBweCAwcHggMHB4XCIsYi5kb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmc9XCIwcHggMHB4IDBweCAwcHhcIik7Yi5kb2N1bWVudC5jbG9zZSgpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtiLmZvY3VzKCk7Yi5wcmludCgpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjLl9jYW52YXNKU0NvbnRhaW5lci5yZW1vdmVDaGlsZChkKX0sXG4xRTMpfSw1MDApfTtwLnByb3RvdHlwZS5nZXRQZXJjZW50QW5kVG90YWw9ZnVuY3Rpb24oYSxkKXt2YXIgYz1udWxsLGI9bnVsbCxlPWM9bnVsbDtpZigwPD1hLnR5cGUuaW5kZXhPZihcInN0YWNrZWRcIikpYj0wLGM9ZC54LmdldFRpbWU/ZC54LmdldFRpbWUoKTpkLngsYyBpbiBhLnBsb3RVbml0LnlUb3RhbHMmJihiPWEucGxvdFVuaXQueVRvdGFsc1tjXSxjPWEucGxvdFVuaXQueUFic1RvdGFsc1tjXSxlPWlzTmFOKGQueSk/MDowPT09Yz8wOjEwMCooZC55L2MpKTtlbHNlIGlmKFwicGllXCI9PT1hLnR5cGV8fFwiZG91Z2hudXRcIj09PWEudHlwZXx8XCJmdW5uZWxcIj09PWEudHlwZXx8XCJweXJhbWlkXCI9PT1hLnR5cGUpe2ZvcihjPWI9MDtjPGEuZGF0YVBvaW50cy5sZW5ndGg7YysrKWlzTmFOKGEuZGF0YVBvaW50c1tjXS55KXx8KGIrPWEuZGF0YVBvaW50c1tjXS55KTtlPWlzTmFOKGQueSk/MDoxMDAqKGQueS9iKX1yZXR1cm57cGVyY2VudDplLHRvdGFsOmJ9fTtwLnByb3RvdHlwZS5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWU9XG5mdW5jdGlvbihhLGQsYyxiLGUpe3ZhciBmPXRoaXM7ZT1cInVuZGVmaW5lZFwiPT09dHlwZW9mIGU/MDplO2lmKCgwPD1jLnR5cGUuaW5kZXhPZihcInN0YWNrZWRcIil8fFwicGllXCI9PT1jLnR5cGV8fFwiZG91Z2hudXRcIj09PWMudHlwZXx8XCJmdW5uZWxcIj09PWMudHlwZXx8XCJweXJhbWlkXCI9PT1jLnR5cGUpJiYoMDw9YS5pbmRleE9mKFwiI3BlcmNlbnRcIil8fDA8PWEuaW5kZXhPZihcIiN0b3RhbFwiKSkpe3ZhciBsPVwiI3BlcmNlbnRcIixoPVwiI3RvdGFsXCIscD10aGlzLmdldFBlcmNlbnRBbmRUb3RhbChjLGQpLGg9aXNOYU4ocC50b3RhbCk/aDpwLnRvdGFsLGw9aXNOYU4ocC5wZXJjZW50KT9sOnAucGVyY2VudDtkb3twPVwiXCI7aWYoYy5wZXJjZW50Rm9ybWF0U3RyaW5nKXA9Yy5wZXJjZW50Rm9ybWF0U3RyaW5nO2Vsc2V7dmFyIHA9XCIjLCMjMC5cIixrPU1hdGgubWF4KE1hdGguY2VpbChNYXRoLmxvZygxL01hdGguYWJzKGwpKS9NYXRoLkxOMTApLDIpO2lmKGlzTmFOKGspfHwhaXNGaW5pdGUoaykpaz1cbjI7Zm9yKHZhciBtPTA7bTxrO20rKylwKz1cIiNcIjtjLnBlcmNlbnRGb3JtYXRTdHJpbmc9cH1hPWEucmVwbGFjZShcIiNwZXJjZW50XCIsZGEobCxwLGYuX2N1bHR1cmVJbmZvKSk7YT1hLnJlcGxhY2UoXCIjdG90YWxcIixkYShoLGMueVZhbHVlRm9ybWF0U3RyaW5nP2MueVZhbHVlRm9ybWF0U3RyaW5nOlwiIywjIzAuIyMjIyMjIyNcIixmLl9jdWx0dXJlSW5mbykpfXdoaWxlKDA8PWEuaW5kZXhPZihcIiNwZXJjZW50XCIpfHwwPD1hLmluZGV4T2YoXCIjdG90YWxcIikpfXJldHVybiBhLnJlcGxhY2UoL1xcey4qP1xcfXxcIlteXCJdKlwifCdbXiddKicvZyxmdW5jdGlvbihhKXtpZignXCInPT09YVswXSYmJ1wiJz09PWFbYS5sZW5ndGgtMV18fFwiJ1wiPT09YVswXSYmXCInXCI9PT1hW2EubGVuZ3RoLTFdKXJldHVybiBhLnNsaWNlKDEsYS5sZW5ndGgtMSk7YT1IYShhLnNsaWNlKDEsYS5sZW5ndGgtMSkpO2E9YS5yZXBsYWNlKFwiI2luZGV4XCIsZSk7dmFyIGs9bnVsbDt0cnl7dmFyIGc9YS5tYXRjaCgvKC4qPylcXHMqXFxbXFxzKiguKj8pXFxzKlxcXS8pO1xuZyYmMDxnLmxlbmd0aCYmKGs9SGEoZ1syXSksYT1IYShnWzFdKSl9Y2F0Y2gobCl7fWc9bnVsbDtpZihcImNvbG9yXCI9PT1hKXJldHVyblwid2F0ZXJmYWxsXCI9PT1jLnR5cGU/ZC5jb2xvcj9kLmNvbG9yOjA8ZC55P2MucmlzaW5nQ29sb3I6Yy5mYWxsaW5nQ29sb3I6XCJlcnJvclwiPT09Yy50eXBlP2MuY29sb3I/Yy5jb2xvcjpjLl9jb2xvclNldFtrJWMuX2NvbG9yU2V0Lmxlbmd0aF06ZC5jb2xvcj9kLmNvbG9yOmMuY29sb3I/Yy5jb2xvcjpjLl9jb2xvclNldFtiJWMuX2NvbG9yU2V0Lmxlbmd0aF07aWYoZC5oYXNPd25Qcm9wZXJ0eShhKSlnPWQ7ZWxzZSBpZihjLmhhc093blByb3BlcnR5KGEpKWc9YztlbHNlIHJldHVyblwiXCI7Zz1nW2FdO251bGwhPT1rJiYoZz1nW2tdKTtyZXR1cm5cInhcIj09PWE/KGMuYXhpc1gmJlwiZGF0ZVRpbWVcIj09PWMuYXhpc1gudmFsdWVUeXBlfHxcImRhdGVUaW1lXCI9PT1jLnhWYWx1ZVR5cGV8fGQueCYmZC54LmdldFRpbWUpJiYhYy5heGlzWC5sb2dhcml0aG1pYz9cbkJhKGcsZC54VmFsdWVGb3JtYXRTdHJpbmc/ZC54VmFsdWVGb3JtYXRTdHJpbmc6Yy54VmFsdWVGb3JtYXRTdHJpbmc/Yy54VmFsdWVGb3JtYXRTdHJpbmc6Yy54VmFsdWVGb3JtYXRTdHJpbmc9Zi5heGlzWCYmZi5heGlzWC5hdXRvVmFsdWVGb3JtYXRTdHJpbmc/Zi5heGlzWC5hdXRvVmFsdWVGb3JtYXRTdHJpbmc6XCJERCBNTU0gWVlcIixmLl9jdWx0dXJlSW5mbyk6ZGEoZyxkLnhWYWx1ZUZvcm1hdFN0cmluZz9kLnhWYWx1ZUZvcm1hdFN0cmluZzpjLnhWYWx1ZUZvcm1hdFN0cmluZz9jLnhWYWx1ZUZvcm1hdFN0cmluZzpjLnhWYWx1ZUZvcm1hdFN0cmluZz1cIiMsIyMwLiMjIyMjIyMjXCIsZi5fY3VsdHVyZUluZm8pOlwieVwiPT09YT9kYShnLGQueVZhbHVlRm9ybWF0U3RyaW5nP2QueVZhbHVlRm9ybWF0U3RyaW5nOmMueVZhbHVlRm9ybWF0U3RyaW5nP2MueVZhbHVlRm9ybWF0U3RyaW5nOmMueVZhbHVlRm9ybWF0U3RyaW5nPVwiIywjIzAuIyMjIyMjIyNcIixmLl9jdWx0dXJlSW5mbyk6XG5cInpcIj09PWE/ZGEoZyxkLnpWYWx1ZUZvcm1hdFN0cmluZz9kLnpWYWx1ZUZvcm1hdFN0cmluZzpjLnpWYWx1ZUZvcm1hdFN0cmluZz9jLnpWYWx1ZUZvcm1hdFN0cmluZzpjLnpWYWx1ZUZvcm1hdFN0cmluZz1cIiMsIyMwLiMjIyMjIyMjXCIsZi5fY3VsdHVyZUluZm8pOmd9KX07b2EoSyxHKTtLLnByb3RvdHlwZS5zZXRMYXlvdXQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmRvY2tJbnNpZGVQbG90QXJlYT90aGlzLmNoYXJ0LnBsb3RBcmVhOnRoaXMuY2hhcnQsZD1hLmxheW91dE1hbmFnZXIuZ2V0RnJlZVNwYWNlKCksYz1udWxsLGI9MCxlPTAsZj0wLGw9MCxoPXRoaXMubWFya2VyTWFyZ2luPXRoaXMuY2hhcnQub3B0aW9ucy5sZWdlbmQmJiFyKHRoaXMuY2hhcnQub3B0aW9ucy5sZWdlbmQubWFya2VyTWFyZ2luKT90aGlzLmNoYXJ0Lm9wdGlvbnMubGVnZW5kLm1hcmtlck1hcmdpbjowLjMqdGhpcy5mb250U2l6ZTt0aGlzLmhlaWdodD0wO3ZhciBwPVtdLGs9W107aWYoXCJ0b3BcIj09PXRoaXMudmVydGljYWxBbGlnbnx8XG5cImJvdHRvbVwiPT09dGhpcy52ZXJ0aWNhbEFsaWduKXRoaXMub3JpZW50YXRpb249XCJob3Jpem9udGFsXCIsYz10aGlzLnZlcnRpY2FsQWxpZ24sZj10aGlzLm1heFdpZHRoPW51bGwhPT10aGlzLm1heFdpZHRoP3RoaXMubWF4V2lkdGg6ZC53aWR0aCxsPXRoaXMubWF4SGVpZ2h0PW51bGwhPT10aGlzLm1heEhlaWdodD90aGlzLm1heEhlaWdodDowLjUqZC5oZWlnaHQ7ZWxzZSBpZihcImNlbnRlclwiPT09dGhpcy52ZXJ0aWNhbEFsaWduKXt0aGlzLm9yaWVudGF0aW9uPVwidmVydGljYWxcIjtpZihcImxlZnRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWdufHxcImNlbnRlclwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ258fFwicmlnaHRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduKWM9dGhpcy5ob3Jpem9udGFsQWxpZ247Zj10aGlzLm1heFdpZHRoPW51bGwhPT10aGlzLm1heFdpZHRoP3RoaXMubWF4V2lkdGg6MC41KmQud2lkdGg7bD10aGlzLm1heEhlaWdodD1udWxsIT09dGhpcy5tYXhIZWlnaHQ/dGhpcy5tYXhIZWlnaHQ6XG5kLmhlaWdodH10aGlzLmVycm9yTWFya2VyQ29sb3I9W107Zm9yKHZhciBtPTA7bTx0aGlzLmRhdGFTZXJpZXMubGVuZ3RoO20rKyl7dmFyIG49dGhpcy5kYXRhU2VyaWVzW21dO2lmKG4uZGF0YVBvaW50cyYmbi5kYXRhUG9pbnRzLmxlbmd0aClpZihcInBpZVwiIT09bi50eXBlJiZcImRvdWdobnV0XCIhPT1uLnR5cGUmJlwiZnVubmVsXCIhPT1uLnR5cGUmJlwicHlyYW1pZFwiIT09bi50eXBlKXt2YXIgcT1uLmxlZ2VuZE1hcmtlclR5cGU9bi5sZWdlbmRNYXJrZXJUeXBlP24ubGVnZW5kTWFya2VyVHlwZTpcImxpbmVcIiE9PW4udHlwZSYmXCJzdGVwTGluZVwiIT09bi50eXBlJiZcInNwbGluZVwiIT09bi50eXBlJiZcInNjYXR0ZXJcIiE9PW4udHlwZSYmXCJidWJibGVcIiE9PW4udHlwZXx8IW4ubWFya2VyVHlwZT9cImVycm9yXCI9PT1uLnR5cGUmJm4uX2xpbmtlZFNlcmllcz9uLl9saW5rZWRTZXJpZXMubGVnZW5kTWFya2VyVHlwZT9uLl9saW5rZWRTZXJpZXMubGVnZW5kTWFya2VyVHlwZTpRLmdldERlZmF1bHRMZWdlbmRNYXJrZXIobi5fbGlua2VkU2VyaWVzLnR5cGUpOlxuUS5nZXREZWZhdWx0TGVnZW5kTWFya2VyKG4udHlwZSk6bi5tYXJrZXJUeXBlLGc9bi5sZWdlbmRUZXh0P24ubGVnZW5kVGV4dDp0aGlzLml0ZW1UZXh0Rm9ybWF0dGVyP3RoaXMuaXRlbVRleHRGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsbGVnZW5kOnRoaXMub3B0aW9ucyxkYXRhU2VyaWVzOm4sZGF0YVBvaW50Om51bGx9KTpuLm5hbWUscz1uLmxlZ2VuZE1hcmtlckNvbG9yPW4ubGVnZW5kTWFya2VyQ29sb3I/bi5sZWdlbmRNYXJrZXJDb2xvcjpuLm1hcmtlckNvbG9yP24ubWFya2VyQ29sb3I6XCJlcnJvclwiPT09bi50eXBlP3Iobi53aGlza2VyQ29sb3IpP24uX2NvbG9yU2V0WzBdOm4ud2hpc2tlckNvbG9yOm4uX2NvbG9yU2V0WzBdLHc9bi5tYXJrZXJTaXplfHxcImxpbmVcIiE9PW4udHlwZSYmXCJzdGVwTGluZVwiIT09bi50eXBlJiZcInNwbGluZVwiIT09bi50eXBlPzAuNzUqdGhpcy5saW5lSGVpZ2h0OjAsdj1uLmxlZ2VuZE1hcmtlckJvcmRlckNvbG9yP24ubGVnZW5kTWFya2VyQm9yZGVyQ29sb3I6XG5uLm1hcmtlckJvcmRlckNvbG9yLHU9bi5sZWdlbmRNYXJrZXJCb3JkZXJUaGlja25lc3M/bi5sZWdlbmRNYXJrZXJCb3JkZXJUaGlja25lc3M6bi5tYXJrZXJCb3JkZXJUaGlja25lc3M/TWF0aC5tYXgoMSxNYXRoLnJvdW5kKDAuMip3KSk6MDtcImVycm9yXCI9PT1uLnR5cGUmJnRoaXMuZXJyb3JNYXJrZXJDb2xvci5wdXNoKHMpO2c9dGhpcy5jaGFydC5yZXBsYWNlS2V5d29yZHNXaXRoVmFsdWUoZyxuLmRhdGFQb2ludHNbMF0sbixtKTtxPXttYXJrZXJUeXBlOnEsbWFya2VyQ29sb3I6cyx0ZXh0OmcsdGV4dEJsb2NrOm51bGwsY2hhcnRUeXBlOm4udHlwZSxtYXJrZXJTaXplOncsbGluZUNvbG9yOm4uX2NvbG9yU2V0WzBdLGRhdGFTZXJpZXNJbmRleDpuLmluZGV4LGRhdGFQb2ludEluZGV4Om51bGwsbWFya2VyQm9yZGVyQ29sb3I6dixtYXJrZXJCb3JkZXJUaGlja25lc3M6dX07cC5wdXNoKHEpfWVsc2UgZm9yKHZhciB5PTA7eTxuLmRhdGFQb2ludHMubGVuZ3RoO3krKyl7dmFyIHg9XG5uLmRhdGFQb2ludHNbeV0scT14LmxlZ2VuZE1hcmtlclR5cGU/eC5sZWdlbmRNYXJrZXJUeXBlOm4ubGVnZW5kTWFya2VyVHlwZT9uLmxlZ2VuZE1hcmtlclR5cGU6US5nZXREZWZhdWx0TGVnZW5kTWFya2VyKG4udHlwZSksZz14LmxlZ2VuZFRleHQ/eC5sZWdlbmRUZXh0Om4ubGVnZW5kVGV4dD9uLmxlZ2VuZFRleHQ6dGhpcy5pdGVtVGV4dEZvcm1hdHRlcj90aGlzLml0ZW1UZXh0Rm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGxlZ2VuZDp0aGlzLm9wdGlvbnMsZGF0YVNlcmllczpuLGRhdGFQb2ludDp4fSk6eC5uYW1lP3gubmFtZTpcIkRhdGFQb2ludDogXCIrKHkrMSkscz14LmxlZ2VuZE1hcmtlckNvbG9yP3gubGVnZW5kTWFya2VyQ29sb3I6bi5sZWdlbmRNYXJrZXJDb2xvcj9uLmxlZ2VuZE1hcmtlckNvbG9yOnguY29sb3I/eC5jb2xvcjpuLmNvbG9yP24uY29sb3I6bi5fY29sb3JTZXRbeSVuLl9jb2xvclNldC5sZW5ndGhdLHc9MC43NSp0aGlzLmxpbmVIZWlnaHQsdj14LmxlZ2VuZE1hcmtlckJvcmRlckNvbG9yP1xueC5sZWdlbmRNYXJrZXJCb3JkZXJDb2xvcjpuLmxlZ2VuZE1hcmtlckJvcmRlckNvbG9yP24ubGVnZW5kTWFya2VyQm9yZGVyQ29sb3I6eC5tYXJrZXJCb3JkZXJDb2xvcj94Lm1hcmtlckJvcmRlckNvbG9yOm4ubWFya2VyQm9yZGVyQ29sb3IsdT14LmxlZ2VuZE1hcmtlckJvcmRlclRoaWNrbmVzcz94LmxlZ2VuZE1hcmtlckJvcmRlclRoaWNrbmVzczpuLmxlZ2VuZE1hcmtlckJvcmRlclRoaWNrbmVzcz9uLmxlZ2VuZE1hcmtlckJvcmRlclRoaWNrbmVzczp4Lm1hcmtlckJvcmRlclRoaWNrbmVzc3x8bi5tYXJrZXJCb3JkZXJUaGlja25lc3M/TWF0aC5tYXgoMSxNYXRoLnJvdW5kKDAuMip3KSk6MCxnPXRoaXMuY2hhcnQucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKGcseCxuLHkpLHE9e21hcmtlclR5cGU6cSxtYXJrZXJDb2xvcjpzLHRleHQ6Zyx0ZXh0QmxvY2s6bnVsbCxjaGFydFR5cGU6bi50eXBlLG1hcmtlclNpemU6dyxkYXRhU2VyaWVzSW5kZXg6bSxkYXRhUG9pbnRJbmRleDp5LFxubWFya2VyQm9yZGVyQ29sb3I6dixtYXJrZXJCb3JkZXJUaGlja25lc3M6dX07KHguc2hvd0luTGVnZW5kfHxuLnNob3dJbkxlZ2VuZCYmITEhPT14LnNob3dJbkxlZ2VuZCkmJnAucHVzaChxKX19ITA9PT10aGlzLnJldmVyc2VkJiZwLnJldmVyc2UoKTtpZigwPHAubGVuZ3RoKXtuPW51bGw7Zz14PXk9MDt4PW51bGwhPT10aGlzLml0ZW1XaWR0aD9udWxsIT09dGhpcy5pdGVtTWF4V2lkdGg/TWF0aC5taW4odGhpcy5pdGVtV2lkdGgsdGhpcy5pdGVtTWF4V2lkdGgsZik6dGhpcy5pdGVtTWF4V2lkdGg9TWF0aC5taW4odGhpcy5pdGVtV2lkdGgsZik6bnVsbCE9PXRoaXMuaXRlbU1heFdpZHRoP01hdGgubWluKHRoaXMuaXRlbU1heFdpZHRoLGYpOnRoaXMuaXRlbU1heFdpZHRoPWY7dz0wPT09dz8wLjc1KnRoaXMubGluZUhlaWdodDp3O3g9KHRoaXMuaXRlbU1heFdpZHRoP3RoaXMuaXRlbU1heFdpZHRoOngpLSh3K2gpO2ZvcihtPTA7bTxwLmxlbmd0aDttKyspe3E9cFttXTtzPXg7XG5pZihcImxpbmVcIj09PXEuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09cS5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PXEuY2hhcnRUeXBlKXMtPTIqMC4xKnRoaXMubGluZUhlaWdodDtpZighKDA+PWx8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgbHx8MD49c3x8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBzKSlpZihcImhvcml6b250YWxcIj09PXRoaXMub3JpZW50YXRpb24pe3EudGV4dEJsb2NrPW5ldyBqYSh0aGlzLmN0eCx7eDowLHk6MCxtYXhXaWR0aDpzLG1heEhlaWdodDp0aGlzLml0ZW1XcmFwP2w6dGhpcy5saW5lSGVpZ2h0LGFuZ2xlOjAsdGV4dDpxLnRleHQsaG9yaXpvbnRhbEFsaWduOlwibGVmdFwiLGZvbnRTaXplOnRoaXMuZm9udFNpemUsZm9udEZhbWlseTp0aGlzLmZvbnRGYW1pbHksZm9udFdlaWdodDp0aGlzLmZvbnRXZWlnaHQsZm9udENvbG9yOnRoaXMuZm9udENvbG9yLGZvbnRTdHlsZTp0aGlzLmZvbnRTdHlsZSx0ZXh0QmFzZWxpbmU6XCJtaWRkbGVcIn0pO3EudGV4dEJsb2NrLm1lYXN1cmVUZXh0KCk7XG5udWxsIT09dGhpcy5pdGVtV2lkdGgmJihxLnRleHRCbG9jay53aWR0aD10aGlzLml0ZW1XaWR0aC0odytoKyhcImxpbmVcIj09PXEuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09cS5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PXEuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSkpO2lmKCFufHxuLndpZHRoK01hdGgucm91bmQocS50ZXh0QmxvY2sud2lkdGgrdytoKygwPT09bi53aWR0aD8wOnRoaXMuaG9yaXpvbnRhbFNwYWNpbmcpKyhcImxpbmVcIj09PXEuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09cS5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PXEuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSk+ZiluPXtpdGVtczpbXSx3aWR0aDowfSxrLnB1c2gobiksdGhpcy5oZWlnaHQrPWcsZz0wO2c9TWF0aC5tYXgoZyxxLnRleHRCbG9jay5oZWlnaHQ/cS50ZXh0QmxvY2suaGVpZ2h0OnRoaXMubGluZUhlaWdodCk7cS50ZXh0QmxvY2sueD1uLndpZHRoO3EudGV4dEJsb2NrLnk9XG4wO24ud2lkdGgrPU1hdGgucm91bmQocS50ZXh0QmxvY2sud2lkdGgrdytoKygwPT09bi53aWR0aD8wOnRoaXMuaG9yaXpvbnRhbFNwYWNpbmcpKyhcImxpbmVcIj09PXEuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09cS5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PXEuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSk7bi5pdGVtcy5wdXNoKHEpO3RoaXMud2lkdGg9TWF0aC5tYXgobi53aWR0aCx0aGlzLndpZHRoKX1lbHNlIHEudGV4dEJsb2NrPW5ldyBqYSh0aGlzLmN0eCx7eDowLHk6MCxtYXhXaWR0aDp4LG1heEhlaWdodDohMD09PXRoaXMuaXRlbVdyYXA/bDoxLjUqdGhpcy5mb250U2l6ZSxhbmdsZTowLHRleHQ6cS50ZXh0LGhvcml6b250YWxBbGlnbjpcImxlZnRcIixmb250U2l6ZTp0aGlzLmZvbnRTaXplLGZvbnRGYW1pbHk6dGhpcy5mb250RmFtaWx5LGZvbnRXZWlnaHQ6dGhpcy5mb250V2VpZ2h0LGZvbnRDb2xvcjp0aGlzLmZvbnRDb2xvcixmb250U3R5bGU6dGhpcy5mb250U3R5bGUsXG50ZXh0QmFzZWxpbmU6XCJtaWRkbGVcIn0pLHEudGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksbnVsbCE9PXRoaXMuaXRlbVdpZHRoJiYocS50ZXh0QmxvY2sud2lkdGg9dGhpcy5pdGVtV2lkdGgtKHcraCsoXCJsaW5lXCI9PT1xLmNoYXJ0VHlwZXx8XCJzcGxpbmVcIj09PXEuY2hhcnRUeXBlfHxcInN0ZXBMaW5lXCI9PT1xLmNoYXJ0VHlwZT8yKjAuMSp0aGlzLmxpbmVIZWlnaHQ6MCkpKSx0aGlzLmhlaWdodDxsLXRoaXMubGluZUhlaWdodD8obj17aXRlbXM6W10sd2lkdGg6MH0say5wdXNoKG4pKToobj1rW3ldLHk9KHkrMSklay5sZW5ndGgpLG4mJih0aGlzLmhlaWdodCs9cS50ZXh0QmxvY2suaGVpZ2h0P3EudGV4dEJsb2NrLmhlaWdodDp0aGlzLmxpbmVIZWlnaHQscS50ZXh0QmxvY2sueD1uLndpZHRoLHEudGV4dEJsb2NrLnk9MCxuLndpZHRoKz1NYXRoLnJvdW5kKHEudGV4dEJsb2NrLndpZHRoK3craCsoMD09PW4ud2lkdGg/MDp0aGlzLmhvcml6b250YWxTcGFjaW5nKSsoXCJsaW5lXCI9PT1xLmNoYXJ0VHlwZXx8XG5cInNwbGluZVwiPT09cS5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PXEuY2hhcnRUeXBlPzIqMC4xKnRoaXMubGluZUhlaWdodDowKSksbi5pdGVtcy5wdXNoKHEpLHRoaXMud2lkdGg9TWF0aC5tYXgobi53aWR0aCx0aGlzLndpZHRoKSl9dGhpcy5oZWlnaHQ9ITE9PT10aGlzLml0ZW1XcmFwP2subGVuZ3RoKnRoaXMubGluZUhlaWdodDp0aGlzLmhlaWdodCtnO3RoaXMuaGVpZ2h0PU1hdGgubWluKGwsdGhpcy5oZWlnaHQpO3RoaXMud2lkdGg9TWF0aC5taW4oZix0aGlzLndpZHRoKX1cInRvcFwiPT09dGhpcy52ZXJ0aWNhbEFsaWduPyhlPVwibGVmdFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24/ZC54MTpcInJpZ2h0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj9kLngyLXRoaXMud2lkdGg6ZC54MStkLndpZHRoLzItdGhpcy53aWR0aC8yLGI9ZC55MSk6XCJjZW50ZXJcIj09PXRoaXMudmVydGljYWxBbGlnbj8oZT1cImxlZnRcIj09PXRoaXMuaG9yaXpvbnRhbEFsaWduP2QueDE6XCJyaWdodFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24/XG5kLngyLXRoaXMud2lkdGg6ZC54MStkLndpZHRoLzItdGhpcy53aWR0aC8yLGI9ZC55MStkLmhlaWdodC8yLXRoaXMuaGVpZ2h0LzIpOlwiYm90dG9tXCI9PT10aGlzLnZlcnRpY2FsQWxpZ24mJihlPVwibGVmdFwiPT09dGhpcy5ob3Jpem9udGFsQWxpZ24/ZC54MTpcInJpZ2h0XCI9PT10aGlzLmhvcml6b250YWxBbGlnbj9kLngyLXRoaXMud2lkdGg6ZC54MStkLndpZHRoLzItdGhpcy53aWR0aC8yLGI9ZC55Mi10aGlzLmhlaWdodCk7dGhpcy5pdGVtcz1wO2ZvcihtPTA7bTx0aGlzLml0ZW1zLmxlbmd0aDttKyspcT1wW21dLHEuaWQ9Kyt0aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIubGFzdE9iamVjdElkLHRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbcS5pZF09e2lkOnEuaWQsb2JqZWN0VHlwZTpcImxlZ2VuZEl0ZW1cIixsZWdlbmRJdGVtSW5kZXg6bSxkYXRhU2VyaWVzSW5kZXg6cS5kYXRhU2VyaWVzSW5kZXgsZGF0YVBvaW50SW5kZXg6cS5kYXRhUG9pbnRJbmRleH07dGhpcy5tYXJrZXJTaXplPVxudzt0aGlzLnJvd3M9azswPHAubGVuZ3RoJiZhLmxheW91dE1hbmFnZXIucmVnaXN0ZXJTcGFjZShjLHt3aWR0aDp0aGlzLndpZHRoKzIrMixoZWlnaHQ6dGhpcy5oZWlnaHQrNSs1fSk7dGhpcy5ib3VuZHM9e3gxOmUseTE6Yix4MjplK3RoaXMud2lkdGgseTI6Yit0aGlzLmhlaWdodH19O0sucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYm91bmRzLngxLGQ9dGhpcy5ib3VuZHMueTEsYz10aGlzLm1hcmtlck1hcmdpbixiPXRoaXMubWF4V2lkdGgsZT10aGlzLm1heEhlaWdodCxmPXRoaXMubWFya2VyU2l6ZSxsPXRoaXMucm93czsoMDx0aGlzLmJvcmRlclRoaWNrbmVzcyYmdGhpcy5ib3JkZXJDb2xvcnx8dGhpcy5iYWNrZ3JvdW5kQ29sb3IpJiZ0aGlzLmN0eC5yb3VuZFJlY3QoYSxkLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsdGhpcy5jb3JuZXJSYWRpdXMsdGhpcy5ib3JkZXJUaGlja25lc3MsdGhpcy5iYWNrZ3JvdW5kQ29sb3IsdGhpcy5ib3JkZXJDb2xvcik7XG5mb3IodmFyIGg9MCxwPTA7cDxsLmxlbmd0aDtwKyspe2Zvcih2YXIgaz1sW3BdLG09MCxuPTA7bjxrLml0ZW1zLmxlbmd0aDtuKyspe3ZhciBxPWsuaXRlbXNbbl0sZz1xLnRleHRCbG9jay54K2ErKDA9PT1uPzAuMipmOnRoaXMuaG9yaXpvbnRhbFNwYWNpbmcpLHM9ZCtoLHI9Zzt0aGlzLmNoYXJ0LmRhdGFbcS5kYXRhU2VyaWVzSW5kZXhdLnZpc2libGV8fCh0aGlzLmN0eC5nbG9iYWxBbHBoYT0wLjUpO3RoaXMuY3R4LnNhdmUoKTt0aGlzLmN0eC5iZWdpblBhdGgoKTt0aGlzLmN0eC5yZWN0KGEsZCxiLE1hdGgubWF4KGUtZSV0aGlzLmxpbmVIZWlnaHQsMCkpO3RoaXMuY3R4LmNsaXAoKTtpZihcImxpbmVcIj09PXEuY2hhcnRUeXBlfHxcInN0ZXBMaW5lXCI9PT1xLmNoYXJ0VHlwZXx8XCJzcGxpbmVcIj09PXEuY2hhcnRUeXBlKXRoaXMuY3R4LnN0cm9rZVN0eWxlPXEubGluZUNvbG9yLHRoaXMuY3R4LmxpbmVXaWR0aD1NYXRoLmNlaWwodGhpcy5saW5lSGVpZ2h0LzgpLHRoaXMuY3R4LmJlZ2luUGF0aCgpLFxudGhpcy5jdHgubW92ZVRvKGctMC4xKnRoaXMubGluZUhlaWdodCxzK3RoaXMubGluZUhlaWdodC8yKSx0aGlzLmN0eC5saW5lVG8oZyswLjg1KnRoaXMubGluZUhlaWdodCxzK3RoaXMubGluZUhlaWdodC8yKSx0aGlzLmN0eC5zdHJva2UoKSxyLT0wLjEqdGhpcy5saW5lSGVpZ2h0O2lmKFwiZXJyb3JcIj09PXEuY2hhcnRUeXBlKXt0aGlzLmN0eC5zdHJva2VTdHlsZT10aGlzLmVycm9yTWFya2VyQ29sb3JbMF07dGhpcy5jdHgubGluZVdpZHRoPWYvODt0aGlzLmN0eC5iZWdpblBhdGgoKTt2YXIgdz1nLTAuMDgqdGhpcy5saW5lSGVpZ2h0KzAuMSp0aGlzLmxpbmVIZWlnaHQsdT1zKzAuMTUqdGhpcy5saW5lSGVpZ2h0LHk9MC43KnRoaXMubGluZUhlaWdodCx4PXkrMC4wMip0aGlzLmxpbmVIZWlnaHQ7dGhpcy5jdHgubW92ZVRvKHcsdSk7dGhpcy5jdHgubGluZVRvKHcreSx1KTt0aGlzLmN0eC5zdHJva2UoKTt0aGlzLmN0eC5iZWdpblBhdGgoKTt0aGlzLmN0eC5tb3ZlVG8odyt5LzIsXG51KTt0aGlzLmN0eC5saW5lVG8odyt5LzIsdSt4KTt0aGlzLmN0eC5zdHJva2UoKTt0aGlzLmN0eC5iZWdpblBhdGgoKTt0aGlzLmN0eC5tb3ZlVG8odyx1K3gpO3RoaXMuY3R4LmxpbmVUbyh3K3ksdSt4KTt0aGlzLmN0eC5zdHJva2UoKTt0aGlzLmVycm9yTWFya2VyQ29sb3Iuc2hpZnQoKX1XLmRyYXdNYXJrZXIoZytmLzIscyt0aGlzLmxpbmVIZWlnaHQvMix0aGlzLmN0eCxxLm1hcmtlclR5cGUsXCJlcnJvclwiPT09cS5jaGFydFR5cGV8fFwibGluZVwiPT09cS5jaGFydFR5cGV8fFwic3BsaW5lXCI9PT1xLmNoYXJ0VHlwZT9xLm1hcmtlclNpemUvMjpxLm1hcmtlclNpemUscS5tYXJrZXJDb2xvcixxLm1hcmtlckJvcmRlckNvbG9yLHEubWFya2VyQm9yZGVyVGhpY2tuZXNzKTtxLnRleHRCbG9jay54PWcrYytmO2lmKFwibGluZVwiPT09cS5jaGFydFR5cGV8fFwic3RlcExpbmVcIj09PXEuY2hhcnRUeXBlfHxcInNwbGluZVwiPT09cS5jaGFydFR5cGUpcS50ZXh0QmxvY2sueCs9MC4xKnRoaXMubGluZUhlaWdodDtcbnEudGV4dEJsb2NrLnk9TWF0aC5yb3VuZChzK3RoaXMubGluZUhlaWdodC8yKTtxLnRleHRCbG9jay5yZW5kZXIoITApO3RoaXMuY3R4LnJlc3RvcmUoKTttPTA8bj9NYXRoLm1heChtLHEudGV4dEJsb2NrLmhlaWdodD9xLnRleHRCbG9jay5oZWlnaHQ6dGhpcy5saW5lSGVpZ2h0KTpxLnRleHRCbG9jay5oZWlnaHQ/cS50ZXh0QmxvY2suaGVpZ2h0OnRoaXMubGluZUhlaWdodDt0aGlzLmNoYXJ0LmRhdGFbcS5kYXRhU2VyaWVzSW5kZXhdLnZpc2libGV8fCh0aGlzLmN0eC5nbG9iYWxBbHBoYT0xKTtnPVgocS5pZCk7dGhpcy5naG9zdEN0eC5maWxsU3R5bGU9Zzt0aGlzLmdob3N0Q3R4LmJlZ2luUGF0aCgpO3RoaXMuZ2hvc3RDdHguZmlsbFJlY3QocixxLnRleHRCbG9jay55LXRoaXMubGluZUhlaWdodC8yLHEudGV4dEJsb2NrLngrcS50ZXh0QmxvY2sud2lkdGgtcixxLnRleHRCbG9jay5oZWlnaHQ/cS50ZXh0QmxvY2suaGVpZ2h0OnRoaXMubGluZUhlaWdodCk7cS54MT10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW3EuaWRdLngxPVxucjtxLnkxPXRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbcS5pZF0ueTE9cS50ZXh0QmxvY2sueS10aGlzLmxpbmVIZWlnaHQvMjtxLngyPXRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbcS5pZF0ueDI9cS50ZXh0QmxvY2sueCtxLnRleHRCbG9jay53aWR0aDtxLnkyPXRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbcS5pZF0ueTI9cS50ZXh0QmxvY2sueSsocS50ZXh0QmxvY2suaGVpZ2h0P3EudGV4dEJsb2NrLmhlaWdodDp0aGlzLmxpbmVIZWlnaHQpLXRoaXMubGluZUhlaWdodC8yfWgrPW19fTtvYShRLEcpO1EucHJvdG90eXBlLmdldERlZmF1bHRBeGlzUGxhY2VtZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50eXBlO2lmKFwiY29sdW1uXCI9PT1hfHxcImxpbmVcIj09PWF8fFwic3RlcExpbmVcIj09PWF8fFwic3BsaW5lXCI9PT1hfHxcImFyZWFcIj09PWF8fFwic3RlcEFyZWFcIj09PWF8fFwic3BsaW5lQXJlYVwiPT09YXx8XCJzdGFja2VkQ29sdW1uXCI9PT1cbmF8fFwic3RhY2tlZExpbmVcIj09PWF8fFwiYnViYmxlXCI9PT1hfHxcInNjYXR0ZXJcIj09PWF8fFwic3RhY2tlZEFyZWFcIj09PWF8fFwic3RhY2tlZENvbHVtbjEwMFwiPT09YXx8XCJzdGFja2VkTGluZTEwMFwiPT09YXx8XCJzdGFja2VkQXJlYTEwMFwiPT09YXx8XCJjYW5kbGVzdGlja1wiPT09YXx8XCJvaGxjXCI9PT1hfHxcInJhbmdlQ29sdW1uXCI9PT1hfHxcInJhbmdlQXJlYVwiPT09YXx8XCJyYW5nZVNwbGluZUFyZWFcIj09PWF8fFwiYm94QW5kV2hpc2tlclwiPT09YXx8XCJ3YXRlcmZhbGxcIj09PWEpcmV0dXJuXCJub3JtYWxcIjtpZihcImJhclwiPT09YXx8XCJzdGFja2VkQmFyXCI9PT1hfHxcInN0YWNrZWRCYXIxMDBcIj09PWF8fFwicmFuZ2VCYXJcIj09PWEpcmV0dXJuXCJ4eVN3YXBwZWRcIjtpZihcInBpZVwiPT09YXx8XCJkb3VnaG51dFwiPT09YXx8XCJmdW5uZWxcIj09PWF8fFwicHlyYW1pZFwiPT09YSlyZXR1cm5cIm5vbmVcIjtcImVycm9yXCIhPT1hJiZ3aW5kb3cuY29uc29sZS5sb2coXCJVbmtub3duIENoYXJ0IFR5cGU6IFwiK2EpO3JldHVybiBudWxsfTtcblEuZ2V0RGVmYXVsdExlZ2VuZE1hcmtlcj1mdW5jdGlvbihhKXtpZihcImNvbHVtblwiPT09YXx8XCJzdGFja2VkQ29sdW1uXCI9PT1hfHxcInN0YWNrZWRMaW5lXCI9PT1hfHxcImJhclwiPT09YXx8XCJzdGFja2VkQmFyXCI9PT1hfHxcInN0YWNrZWRCYXIxMDBcIj09PWF8fFwiYnViYmxlXCI9PT1hfHxcInNjYXR0ZXJcIj09PWF8fFwic3RhY2tlZENvbHVtbjEwMFwiPT09YXx8XCJzdGFja2VkTGluZTEwMFwiPT09YXx8XCJzdGVwQXJlYVwiPT09YXx8XCJjYW5kbGVzdGlja1wiPT09YXx8XCJvaGxjXCI9PT1hfHxcInJhbmdlQ29sdW1uXCI9PT1hfHxcInJhbmdlQmFyXCI9PT1hfHxcInJhbmdlQXJlYVwiPT09YXx8XCJyYW5nZVNwbGluZUFyZWFcIj09PWF8fFwiYm94QW5kV2hpc2tlclwiPT09YXx8XCJ3YXRlcmZhbGxcIj09PWEpcmV0dXJuXCJzcXVhcmVcIjtpZihcImxpbmVcIj09PWF8fFwic3RlcExpbmVcIj09PWF8fFwic3BsaW5lXCI9PT1hfHxcInBpZVwiPT09YXx8XCJkb3VnaG51dFwiPT09YSlyZXR1cm5cImNpcmNsZVwiO2lmKFwiYXJlYVwiPT09YXx8XCJzcGxpbmVBcmVhXCI9PT1cbmF8fFwic3RhY2tlZEFyZWFcIj09PWF8fFwic3RhY2tlZEFyZWExMDBcIj09PWF8fFwiZnVubmVsXCI9PT1hfHxcInB5cmFtaWRcIj09PWEpcmV0dXJuXCJ0cmlhbmdsZVwiO2lmKFwiZXJyb3JcIj09PWEpcmV0dXJuXCJub25lXCI7d2luZG93LmNvbnNvbGUubG9nKFwiVW5rbm93biBDaGFydCBUeXBlOiBcIithKTtyZXR1cm4gbnVsbH07US5wcm90b3R5cGUuZ2V0RGF0YVBvaW50QXRYPWZ1bmN0aW9uKGEsZCl7aWYoIXRoaXMuZGF0YVBvaW50c3x8MD09PXRoaXMuZGF0YVBvaW50cy5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIGM9e2RhdGFQb2ludDpudWxsLGRpc3RhbmNlOkluZmluaXR5LGluZGV4Ok5hTn0sYj1udWxsLGU9MCxmPTAsbD0xLGg9SW5maW5pdHkscD0wLGs9MCxtPTA7XCJub25lXCIhPT10aGlzLmNoYXJ0LnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQmJih0aGlzLmF4aXNYLmxvZ2FyaXRobWljPyhtPU1hdGgubG9nKHRoaXMuZGF0YVBvaW50c1t0aGlzLmRhdGFQb2ludHMubGVuZ3RoLTFdLngvdGhpcy5kYXRhUG9pbnRzWzBdLngpLFxubT0xPG0/TWF0aC5taW4oTWF0aC5tYXgoKHRoaXMuZGF0YVBvaW50cy5sZW5ndGgtMSkvbSpNYXRoLmxvZyhhL3RoaXMuZGF0YVBvaW50c1swXS54KT4+MCwwKSx0aGlzLmRhdGFQb2ludHMubGVuZ3RoKTowKToobT10aGlzLmRhdGFQb2ludHNbdGhpcy5kYXRhUG9pbnRzLmxlbmd0aC0xXS54LXRoaXMuZGF0YVBvaW50c1swXS54LG09MDxtP01hdGgubWluKE1hdGgubWF4KCh0aGlzLmRhdGFQb2ludHMubGVuZ3RoLTEpL20qKGEtdGhpcy5kYXRhUG9pbnRzWzBdLngpPj4wLDApLHRoaXMuZGF0YVBvaW50cy5sZW5ndGgpOjApKTtmb3IoOzspe2Y9MDxsP20rZTptLWU7aWYoMDw9ZiYmZjx0aGlzLmRhdGFQb2ludHMubGVuZ3RoKXt2YXIgYj10aGlzLmRhdGFQb2ludHNbZl0sbj10aGlzLmF4aXNYLmxvZ2FyaXRobWljP2IueD5hP2IueC9hOmEvYi54Ok1hdGguYWJzKGIueC1hKTtuPGMuZGlzdGFuY2UmJihjLmRhdGFQb2ludD1iLGMuZGlzdGFuY2U9bixjLmluZGV4PWYpO2I9bjtiPD1oP1xuaD1iOjA8bD9wKys6aysrO2lmKDFFMzxwJiYxRTM8aylicmVha31lbHNlIGlmKDA+bS1lJiZtK2U+PXRoaXMuZGF0YVBvaW50cy5sZW5ndGgpYnJlYWs7LTE9PT1sPyhlKyssbD0xKTpsPS0xfXJldHVybiBkfHwoYy5kYXRhUG9pbnQueC5nZXRUaW1lP2MuZGF0YVBvaW50LnguZ2V0VGltZSgpOmMuZGF0YVBvaW50LngpIT09KGEuZ2V0VGltZT9hLmdldFRpbWUoKTphKT9kJiZudWxsIT09Yy5kYXRhUG9pbnQ/YzpudWxsOmN9O1EucHJvdG90eXBlLmdldERhdGFQb2ludEF0WFk9ZnVuY3Rpb24oYSxkLGMpe2lmKCF0aGlzLmRhdGFQb2ludHN8fDA9PT10aGlzLmRhdGFQb2ludHMubGVuZ3RofHxhPHRoaXMuY2hhcnQucGxvdEFyZWEueDF8fGE+dGhpcy5jaGFydC5wbG90QXJlYS54Mnx8ZDx0aGlzLmNoYXJ0LnBsb3RBcmVhLnkxfHxkPnRoaXMuY2hhcnQucGxvdEFyZWEueTIpcmV0dXJuIG51bGw7Yz1jfHwhMTt2YXIgYj1bXSxlPTAsZj0wLGw9MSxoPSExLHA9SW5maW5pdHksaz0wLG09XG4wLG49MDtpZihcIm5vbmVcIiE9PXRoaXMuY2hhcnQucGxvdEluZm8uYXhpc1BsYWNlbWVudClpZihuPSh0aGlzLmNoYXJ0LmF4aXNYWzBdP3RoaXMuY2hhcnQuYXhpc1hbMF06dGhpcy5jaGFydC5heGlzWDJbMF0pLmdldFhWYWx1ZUF0KHt4OmEseTpkfSksdGhpcy5heGlzWC5sb2dhcml0aG1pYyl2YXIgcT1NYXRoLmxvZyh0aGlzLmRhdGFQb2ludHNbdGhpcy5kYXRhUG9pbnRzLmxlbmd0aC0xXS54L3RoaXMuZGF0YVBvaW50c1swXS54KSxuPTE8cT9NYXRoLm1pbihNYXRoLm1heCgodGhpcy5kYXRhUG9pbnRzLmxlbmd0aC0xKS9xKk1hdGgubG9nKG4vdGhpcy5kYXRhUG9pbnRzWzBdLngpPj4wLDApLHRoaXMuZGF0YVBvaW50cy5sZW5ndGgpOjA7ZWxzZSBxPXRoaXMuZGF0YVBvaW50c1t0aGlzLmRhdGFQb2ludHMubGVuZ3RoLTFdLngtdGhpcy5kYXRhUG9pbnRzWzBdLngsbj0wPHE/TWF0aC5taW4oTWF0aC5tYXgoKHRoaXMuZGF0YVBvaW50cy5sZW5ndGgtMSkvcSoobi10aGlzLmRhdGFQb2ludHNbMF0ueCk+PlxuMCwwKSx0aGlzLmRhdGFQb2ludHMubGVuZ3RoKTowO2Zvcig7Oyl7Zj0wPGw/bitlOm4tZTtpZigwPD1mJiZmPHRoaXMuZGF0YVBvaW50cy5sZW5ndGgpe3ZhciBxPXRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5vYmplY3RNYXBbdGhpcy5kYXRhUG9pbnRJZHNbZl1dLGc9dGhpcy5kYXRhUG9pbnRzW2ZdLHM9bnVsbDtpZihxKXtzd2l0Y2godGhpcy50eXBlKXtjYXNlIFwiY29sdW1uXCI6Y2FzZSBcInN0YWNrZWRDb2x1bW5cIjpjYXNlIFwic3RhY2tlZENvbHVtbjEwMFwiOmNhc2UgXCJiYXJcIjpjYXNlIFwic3RhY2tlZEJhclwiOmNhc2UgXCJzdGFja2VkQmFyMTAwXCI6Y2FzZSBcInJhbmdlQ29sdW1uXCI6Y2FzZSBcInJhbmdlQmFyXCI6Y2FzZSBcIndhdGVyZmFsbFwiOmNhc2UgXCJlcnJvclwiOmE+PXEueDEmJihhPD1xLngyJiZkPj1xLnkxJiZkPD1xLnkyKSYmKGIucHVzaCh7ZGF0YVBvaW50OmcsZGF0YVBvaW50SW5kZXg6ZixkYXRhU2VyaWVzOnRoaXMsZGlzdGFuY2U6TWF0aC5taW4oTWF0aC5hYnMocS54MS1cbmEpLE1hdGguYWJzKHEueDItYSksTWF0aC5hYnMocS55MS1kKSxNYXRoLmFicyhxLnkyLWQpKX0pLGg9ITApO2JyZWFrO2Nhc2UgXCJsaW5lXCI6Y2FzZSBcInN0ZXBMaW5lXCI6Y2FzZSBcInNwbGluZVwiOmNhc2UgXCJhcmVhXCI6Y2FzZSBcInN0ZXBBcmVhXCI6Y2FzZSBcInN0YWNrZWRBcmVhXCI6Y2FzZSBcInN0YWNrZWRBcmVhMTAwXCI6Y2FzZSBcInNwbGluZUFyZWFcIjpjYXNlIFwic2NhdHRlclwiOnZhciB3PW1hKFwibWFya2VyU2l6ZVwiLGcsdGhpcyl8fDQsdj1jPzIwOncscz1NYXRoLnNxcnQoTWF0aC5wb3cocS54MS1hLDIpK01hdGgucG93KHEueTEtZCwyKSk7czw9diYmYi5wdXNoKHtkYXRhUG9pbnQ6ZyxkYXRhUG9pbnRJbmRleDpmLGRhdGFTZXJpZXM6dGhpcyxkaXN0YW5jZTpzfSk7cT1NYXRoLmFicyhxLngxLWEpO3E8PXA/cD1xOjA8bD9rKys6bSsrO3M8PXcvMiYmKGg9ITApO2JyZWFrO2Nhc2UgXCJyYW5nZUFyZWFcIjpjYXNlIFwicmFuZ2VTcGxpbmVBcmVhXCI6dz1tYShcIm1hcmtlclNpemVcIixnLHRoaXMpfHxcbjQ7dj1jPzIwOnc7cz1NYXRoLm1pbihNYXRoLnNxcnQoTWF0aC5wb3cocS54MS1hLDIpK01hdGgucG93KHEueTEtZCwyKSksTWF0aC5zcXJ0KE1hdGgucG93KHEueDEtYSwyKStNYXRoLnBvdyhxLnkyLWQsMikpKTtzPD12JiZiLnB1c2goe2RhdGFQb2ludDpnLGRhdGFQb2ludEluZGV4OmYsZGF0YVNlcmllczp0aGlzLGRpc3RhbmNlOnN9KTtxPU1hdGguYWJzKHEueDEtYSk7cTw9cD9wPXE6MDxsP2srKzptKys7czw9dy8yJiYoaD0hMCk7YnJlYWs7Y2FzZSBcImJ1YmJsZVwiOnc9cS5zaXplO3M9TWF0aC5zcXJ0KE1hdGgucG93KHEueDEtYSwyKStNYXRoLnBvdyhxLnkxLWQsMikpO3M8PXcvMiYmKGIucHVzaCh7ZGF0YVBvaW50OmcsZGF0YVBvaW50SW5kZXg6ZixkYXRhU2VyaWVzOnRoaXMsZGlzdGFuY2U6c30pLGg9ITApO2JyZWFrO2Nhc2UgXCJwaWVcIjpjYXNlIFwiZG91Z2hudXRcIjp3PXEuY2VudGVyO3Y9XCJkb3VnaG51dFwiPT09dGhpcy50eXBlP3EucGVyY2VudElubmVyUmFkaXVzKnEucmFkaXVzOlxuMDtzPU1hdGguc3FydChNYXRoLnBvdyh3LngtYSwyKStNYXRoLnBvdyh3LnktZCwyKSk7czxxLnJhZGl1cyYmcz52JiYocz1NYXRoLmF0YW4yKGQtdy55LGEtdy54KSwwPnMmJihzKz0yKk1hdGguUEkpLHM9TnVtYmVyKCgoMTgwKihzL01hdGguUEkpJTM2MCszNjApJTM2MCkudG9GaXhlZCgxMikpLHc9TnVtYmVyKCgoMTgwKihxLnN0YXJ0QW5nbGUvTWF0aC5QSSklMzYwKzM2MCklMzYwKS50b0ZpeGVkKDEyKSksdj1OdW1iZXIoKCgxODAqKHEuZW5kQW5nbGUvTWF0aC5QSSklMzYwKzM2MCklMzYwKS50b0ZpeGVkKDEyKSksMD09PXYmJjE8cS5lbmRBbmdsZSYmKHY9MzYwKSx3Pj12JiYoMCE9PWcueSYmIXIoZy55KSkmJih2Kz0zNjAsczx3JiYocys9MzYwKSkscz53JiZzPHYmJihiLnB1c2goe2RhdGFQb2ludDpnLGRhdGFQb2ludEluZGV4OmYsZGF0YVNlcmllczp0aGlzLGRpc3RhbmNlOjB9KSxoPSEwKSk7YnJlYWs7Y2FzZSBcImZ1bm5lbFwiOmNhc2UgXCJweXJhbWlkXCI6cz1xLmZ1bm5lbFNlY3Rpb247XG5kPnMueTEmJmQ8cy55NCYmKHMueTY/ZD5zLnk2PyhmPXMueDYrKHMueDUtcy54NikvKHMueTUtcy55NikqKGQtcy55Nikscz1zLngzKyhzLng0LXMueDMpLyhzLnk0LXMueTMpKihkLXMueTMpKTooZj1zLngxKyhzLng2LXMueDEpLyhzLnk2LXMueTEpKihkLXMueTEpLHM9cy54Misocy54My1zLngyKS8ocy55My1zLnkyKSooZC1zLnkyKSk6KGY9cy54MSsocy54NC1zLngxKS8ocy55NC1zLnkxKSooZC1zLnkxKSxzPXMueDIrKHMueDMtcy54MikvKHMueTMtcy55MikqKGQtcy55MikpLGE+ZiYmYTxzJiYoYi5wdXNoKHtkYXRhUG9pbnQ6ZyxkYXRhUG9pbnRJbmRleDpxLmRhdGFQb2ludEluZGV4LGRhdGFTZXJpZXM6dGhpcyxkaXN0YW5jZTowfSksaD0hMCkpO2JyZWFrO2Nhc2UgXCJib3hBbmRXaGlza2VyXCI6aWYoYT49cS54MS1xLmJvcmRlclRoaWNrbmVzcy8yJiZhPD1xLngyK3EuYm9yZGVyVGhpY2tuZXNzLzImJmQ+PXEueTQtcS5ib3JkZXJUaGlja25lc3MvMiYmZDw9cS55MStxLmJvcmRlclRoaWNrbmVzcy9cbjJ8fE1hdGguYWJzKHEueDItYStxLngxLWEpPHEuYm9yZGVyVGhpY2tuZXNzJiZkPj1xLnkxJiZkPD1xLnk0KWIucHVzaCh7ZGF0YVBvaW50OmcsZGF0YVBvaW50SW5kZXg6ZixkYXRhU2VyaWVzOnRoaXMsZGlzdGFuY2U6TWF0aC5taW4oTWF0aC5hYnMocS54MS1hKSxNYXRoLmFicyhxLngyLWEpLE1hdGguYWJzKHEueTItZCksTWF0aC5hYnMocS55My1kKSl9KSxoPSEwO2JyZWFrO2Nhc2UgXCJjYW5kbGVzdGlja1wiOmlmKGE+PXEueDEtcS5ib3JkZXJUaGlja25lc3MvMiYmYTw9cS54MitxLmJvcmRlclRoaWNrbmVzcy8yJiZkPj1xLnkyLXEuYm9yZGVyVGhpY2tuZXNzLzImJmQ8PXEueTMrcS5ib3JkZXJUaGlja25lc3MvMnx8TWF0aC5hYnMocS54Mi1hK3EueDEtYSk8cS5ib3JkZXJUaGlja25lc3MmJmQ+PXEueTEmJmQ8PXEueTQpYi5wdXNoKHtkYXRhUG9pbnQ6ZyxkYXRhUG9pbnRJbmRleDpmLGRhdGFTZXJpZXM6dGhpcyxkaXN0YW5jZTpNYXRoLm1pbihNYXRoLmFicyhxLngxLWEpLFxuTWF0aC5hYnMocS54Mi1hKSxNYXRoLmFicyhxLnkyLWQpLE1hdGguYWJzKHEueTMtZCkpfSksaD0hMDticmVhaztjYXNlIFwib2hsY1wiOmlmKE1hdGguYWJzKHEueDItYStxLngxLWEpPHEuYm9yZGVyVGhpY2tuZXNzJiZkPj1xLnkyJiZkPD1xLnkzfHxhPj1xLngxJiZhPD0ocS54MitxLngxKS8yJiZkPj1xLnkxLXEuYm9yZGVyVGhpY2tuZXNzLzImJmQ8PXEueTErcS5ib3JkZXJUaGlja25lc3MvMnx8YT49KHEueDErcS54MikvMiYmYTw9cS54MiYmZD49cS55NC1xLmJvcmRlclRoaWNrbmVzcy8yJiZkPD1xLnk0K3EuYm9yZGVyVGhpY2tuZXNzLzIpYi5wdXNoKHtkYXRhUG9pbnQ6ZyxkYXRhUG9pbnRJbmRleDpmLGRhdGFTZXJpZXM6dGhpcyxkaXN0YW5jZTpNYXRoLm1pbihNYXRoLmFicyhxLngxLWEpLE1hdGguYWJzKHEueDItYSksTWF0aC5hYnMocS55Mi1kKSxNYXRoLmFicyhxLnkzLWQpKX0pLGg9ITB9aWYoaHx8MUUzPGsmJjFFMzxtKWJyZWFrfX1lbHNlIGlmKDA+bi1lJiZuK2U+PVxudGhpcy5kYXRhUG9pbnRzLmxlbmd0aClicmVhazstMT09PWw/KGUrKyxsPTEpOmw9LTF9YT1udWxsO2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspYT9iW2RdLmRpc3RhbmNlPD1hLmRpc3RhbmNlJiYoYT1iW2RdKTphPWJbZF07cmV0dXJuIGF9O1EucHJvdG90eXBlLmdldE1hcmtlclByb3BlcnRpZXM9ZnVuY3Rpb24oYSxkLGMsYil7dmFyIGU9dGhpcy5kYXRhUG9pbnRzLGY9ZVthXS5tYXJrZXJDb2xvcj9lW2FdLm1hcmtlckNvbG9yOnRoaXMubWFya2VyQ29sb3I/dGhpcy5tYXJrZXJDb2xvcjplW2FdLmNvbG9yP2VbYV0uY29sb3I6dGhpcy5jb2xvcj90aGlzLmNvbG9yOnRoaXMuX2NvbG9yU2V0W2EldGhpcy5fY29sb3JTZXQubGVuZ3RoXSxsPWVbYV0ubWFya2VyQm9yZGVyQ29sb3I/ZVthXS5tYXJrZXJCb3JkZXJDb2xvcjp0aGlzLm1hcmtlckJvcmRlckNvbG9yP3RoaXMubWFya2VyQm9yZGVyQ29sb3I6bnVsbCxoPXIoZVthXS5tYXJrZXJCb3JkZXJUaGlja25lc3MpP3RoaXMubWFya2VyQm9yZGVyVGhpY2tuZXNzP1xudGhpcy5tYXJrZXJCb3JkZXJUaGlja25lc3M6bnVsbDplW2FdLm1hcmtlckJvcmRlclRoaWNrbmVzcyxwPWVbYV0ubWFya2VyVHlwZT9lW2FdLm1hcmtlclR5cGU6dGhpcy5tYXJrZXJUeXBlO2E9cihlW2FdLm1hcmtlclNpemUpP3RoaXMubWFya2VyU2l6ZTplW2FdLm1hcmtlclNpemU7cmV0dXJue3g6ZCx5OmMsY3R4OmIsdHlwZTpwLHNpemU6YSxjb2xvcjpmLGJvcmRlckNvbG9yOmwsYm9yZGVyVGhpY2tuZXNzOmh9fTtvYShBLEcpO0EucHJvdG90eXBlLmNyZWF0ZUV4dHJhTGFiZWxzRm9yTG9nPWZ1bmN0aW9uKGEpe2E9KGF8fDApKzE7aWYoISg1PGEpKXt2YXIgZD10aGlzLmxvZ0xhYmVsVmFsdWVzWzBdfHx0aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbjtpZihNYXRoLmxvZyh0aGlzLnJhbmdlKS9NYXRoLmxvZyhkL3RoaXMudmlld3BvcnRNaW5pbXVtKTx0aGlzLm5vVGlja3MtMSl7Zm9yKHZhciBjPUEuZ2V0TmljZU51bWJlcigoZC10aGlzLnZpZXdwb3J0TWluaW11bSkvTWF0aC5taW4oTWF0aC5tYXgoMixcbnRoaXMubm9UaWNrcy10aGlzLmxvZ0xhYmVsVmFsdWVzLmxlbmd0aCksMyksITApLGI9TWF0aC5jZWlsKHRoaXMudmlld3BvcnRNaW5pbXVtL2MpKmM7YjxkO2IrPWMpYjx0aGlzLnZpZXdwb3J0TWluaW11bXx8dGhpcy5sb2dMYWJlbFZhbHVlcy5wdXNoKGIpO3RoaXMubG9nTGFiZWxWYWx1ZXMuc29ydChSYSk7dGhpcy5jcmVhdGVFeHRyYUxhYmVsc0ZvckxvZyhhKX19fTtBLnByb3RvdHlwZS5jcmVhdGVMYWJlbHM9ZnVuY3Rpb24oKXt2YXIgYSxkLGM9MCxiPTAsZSxmPTAsbD0wLGI9MCxiPXRoaXMuaW50ZXJ2YWwsaD0wLHAsaz0wLjYqdGhpcy5jaGFydC5oZWlnaHQsbTthPSExO3ZhciBuPXRoaXMuc2NhbGVCcmVha3M/dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrczpbXSxxPW4ubGVuZ3RoP3IodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXgpPzA6dGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXg6MDtpZihcImF4aXNYXCIhPT10aGlzLnR5cGV8fFwiZGF0ZVRpbWVcIiE9PVxudGhpcy52YWx1ZVR5cGV8fHRoaXMubG9nYXJpdGhtaWMpe2U9dGhpcy52aWV3cG9ydE1heGltdW07aWYodGhpcy5sYWJlbHMpe2E9TWF0aC5jZWlsKGIpO2Zvcih2YXIgYj1NYXRoLmNlaWwodGhpcy5pbnRlcnZhbFN0YXJ0UG9zaXRpb24pLGc9ITEsYz1iO2M8dGhpcy52aWV3cG9ydE1heGltdW07Yys9YSlpZih0aGlzLmxhYmVsc1tjXSlnPSEwO2Vsc2V7Zz0hMTticmVha31nJiYodGhpcy5pbnRlcnZhbD1hLHRoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uPWIpfWlmKHRoaXMubG9nYXJpdGhtaWMmJiF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwpZm9yKHRoaXMubG9nTGFiZWxWYWx1ZXN8fCh0aGlzLmxvZ0xhYmVsVmFsdWVzPVtdLHRoaXMuY3JlYXRlRXh0cmFMYWJlbHNGb3JMb2coKSksYj0wLGc9cTtiPHRoaXMubG9nTGFiZWxWYWx1ZXMubGVuZ3RoO2IrKylpZihjPXRoaXMubG9nTGFiZWxWYWx1ZXNbYl0sYzx0aGlzLnZpZXdwb3J0TWluaW11bSliKys7ZWxzZXtmb3IoO2c8bi5sZW5ndGgmJlxuYz5uW2ddLmVuZFZhbHVlO2crKyk7YT1nPG4ubGVuZ3RoJiZjPj1uW2ddLnN0YXJ0VmFsdWUmJmM8PW5bZ10uZW5kVmFsdWU7bT1jO2F8fChhPXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMub3B0aW9ucyx2YWx1ZTptLGxhYmVsOnRoaXMubGFiZWxzW21dP3RoaXMubGFiZWxzW21dOm51bGx9KTpcImF4aXNYXCI9PT10aGlzLnR5cGUmJnRoaXMubGFiZWxzW21dP3RoaXMubGFiZWxzW21dOmRhKG0sdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyksYT1uZXcgamEodGhpcy5jdHgse3g6MCx5OjAsbWF4V2lkdGg6ZixtYXhIZWlnaHQ6bCxhbmdsZTp0aGlzLmxhYmVsQW5nbGUsdGV4dDp0aGlzLnByZWZpeCthK3RoaXMuc3VmZml4LGJhY2tncm91bmRDb2xvcjp0aGlzLmxhYmVsQmFja2dyb3VuZENvbG9yLGJvcmRlckNvbG9yOnRoaXMubGFiZWxCb3JkZXJDb2xvcixjb3JuZXJSYWRpdXM6dGhpcy5sYWJlbENvcm5lclJhZGl1cyxcbnRleHRBbGlnbjp0aGlzLmxhYmVsVGV4dEFsaWduLGZvbnRTaXplOnRoaXMubGFiZWxGb250U2l6ZSxmb250RmFtaWx5OnRoaXMubGFiZWxGb250RmFtaWx5LGZvbnRXZWlnaHQ6dGhpcy5sYWJlbEZvbnRXZWlnaHQsZm9udENvbG9yOnRoaXMubGFiZWxGb250Q29sb3IsZm9udFN0eWxlOnRoaXMubGFiZWxGb250U3R5bGUsdGV4dEJhc2VsaW5lOlwibWlkZGxlXCIsYm9yZGVyVGhpY2tuZXNzOjB9KSx0aGlzLl9sYWJlbHMucHVzaCh7cG9zaXRpb246bSx0ZXh0QmxvY2s6YSxlZmZlY3RpdmVIZWlnaHQ6bnVsbH0pKX1nPXE7Zm9yKGM9dGhpcy5pbnRlcnZhbFN0YXJ0UG9zaXRpb247Yzw9ZTtjPXBhcnNlRmxvYXQoMUUtMTI+dGhpcy5pbnRlcnZhbD90aGlzLmxvZ2FyaXRobWljJiZ0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWw/YypNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsdGhpcy5pbnRlcnZhbCk6Yyt0aGlzLmludGVydmFsOih0aGlzLmxvZ2FyaXRobWljJiZ0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWw/XG5jKk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSx0aGlzLmludGVydmFsKTpjK3RoaXMuaW50ZXJ2YWwpLnRvRml4ZWQoMTIpKSl7Zm9yKDtnPG4ubGVuZ3RoJiZjPm5bZ10uZW5kVmFsdWU7ZysrKTthPWc8bi5sZW5ndGgmJmM+PW5bZ10uc3RhcnRWYWx1ZSYmYzw9bltnXS5lbmRWYWx1ZTttPWM7YXx8KGE9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5vcHRpb25zLHZhbHVlOm0sbGFiZWw6dGhpcy5sYWJlbHNbbV0/dGhpcy5sYWJlbHNbbV06bnVsbH0pOlwiYXhpc1hcIj09PXRoaXMudHlwZSYmdGhpcy5sYWJlbHNbbV0/dGhpcy5sYWJlbHNbbV06ZGEobSx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKSxhPW5ldyBqYSh0aGlzLmN0eCx7eDowLHk6MCxtYXhXaWR0aDpmLG1heEhlaWdodDpsLGFuZ2xlOnRoaXMubGFiZWxBbmdsZSx0ZXh0OnRoaXMucHJlZml4K2ErdGhpcy5zdWZmaXgsXG50ZXh0QWxpZ246dGhpcy5sYWJlbFRleHRBbGlnbixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5sYWJlbEJhY2tncm91bmRDb2xvcixib3JkZXJDb2xvcjp0aGlzLmxhYmVsQm9yZGVyQ29sb3IsYm9yZGVyVGhpY2tuZXNzOnRoaXMubGFiZWxCb3JkZXJUaGlja25lc3MsY29ybmVyUmFkaXVzOnRoaXMubGFiZWxDb3JuZXJSYWRpdXMsZm9udFNpemU6dGhpcy5sYWJlbEZvbnRTaXplLGZvbnRGYW1pbHk6dGhpcy5sYWJlbEZvbnRGYW1pbHksZm9udFdlaWdodDp0aGlzLmxhYmVsRm9udFdlaWdodCxmb250Q29sb3I6dGhpcy5sYWJlbEZvbnRDb2xvcixmb250U3R5bGU6dGhpcy5sYWJlbEZvbnRTdHlsZSx0ZXh0QmFzZWxpbmU6XCJtaWRkbGVcIn0pLHRoaXMuX2xhYmVscy5wdXNoKHtwb3NpdGlvbjptLHRleHRCbG9jazphLGVmZmVjdGl2ZUhlaWdodDpudWxsfSkpfX1lbHNlIGZvcih0aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbj10aGlzLmdldExhYmVsU3RhcnRQb2ludChuZXcgRGF0ZSh0aGlzLnZpZXdwb3J0TWluaW11bSksXG50aGlzLmludGVydmFsVHlwZSx0aGlzLmludGVydmFsKSxlPVhhKG5ldyBEYXRlKHRoaXMudmlld3BvcnRNYXhpbXVtKSx0aGlzLmludGVydmFsLHRoaXMuaW50ZXJ2YWxUeXBlKSxnPXEsYz10aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbjtjPGU7WGEoYyxiLHRoaXMuaW50ZXJ2YWxUeXBlKSl7Zm9yKGE9Yy5nZXRUaW1lKCk7ZzxuLmxlbmd0aCYmYT5uW2ddLmVuZFZhbHVlO2crKyk7bT1hO2E9ZzxuLmxlbmd0aCYmYT49bltnXS5zdGFydFZhbHVlJiZhPD1uW2ddLmVuZFZhbHVlO2F8fChhPXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMub3B0aW9ucyx2YWx1ZTpuZXcgRGF0ZShtKSxsYWJlbDp0aGlzLmxhYmVsc1ttXT90aGlzLmxhYmVsc1ttXTpudWxsfSk6XCJheGlzWFwiPT09dGhpcy50eXBlJiZ0aGlzLmxhYmVsc1ttXT90aGlzLmxhYmVsc1ttXTpCYShtLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pLFxuYT1uZXcgamEodGhpcy5jdHgse3g6MCx5OjAsbWF4V2lkdGg6ZixiYWNrZ3JvdW5kQ29sb3I6dGhpcy5sYWJlbEJhY2tncm91bmRDb2xvcixib3JkZXJDb2xvcjp0aGlzLmxhYmVsQm9yZGVyQ29sb3IsYm9yZGVyVGhpY2tuZXNzOnRoaXMubGFiZWxCb3JkZXJUaGlja25lc3MsY29ybmVyUmFkaXVzOnRoaXMubGFiZWxDb3JuZXJSYWRpdXMsbWF4SGVpZ2h0OmwsYW5nbGU6dGhpcy5sYWJlbEFuZ2xlLHRleHQ6dGhpcy5wcmVmaXgrYSt0aGlzLnN1ZmZpeCx0ZXh0QWxpZ246dGhpcy5sYWJlbFRleHRBbGlnbixmb250U2l6ZTp0aGlzLmxhYmVsRm9udFNpemUsZm9udEZhbWlseTp0aGlzLmxhYmVsRm9udEZhbWlseSxmb250V2VpZ2h0OnRoaXMubGFiZWxGb250V2VpZ2h0LGZvbnRDb2xvcjp0aGlzLmxhYmVsRm9udENvbG9yLGZvbnRTdHlsZTp0aGlzLmxhYmVsRm9udFN0eWxlLHRleHRCYXNlbGluZTpcIm1pZGRsZVwifSksdGhpcy5fbGFiZWxzLnB1c2goe3Bvc2l0aW9uOm0sdGV4dEJsb2NrOmEsXG5lZmZlY3RpdmVIZWlnaHQ6bnVsbCxicmVha3NMYWJlbFR5cGU6dm9pZCAwfSkpfWlmKFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKWg9dGhpcy5sb2dhcml0aG1pYyYmIXRoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbCYmMjw9dGhpcy5fbGFiZWxzLmxlbmd0aD90aGlzLmxpbmVDb29yZGluYXRlcy53aWR0aCpNYXRoLmxvZyhNYXRoLm1pbih0aGlzLl9sYWJlbHNbdGhpcy5fbGFiZWxzLmxlbmd0aC0xXS5wb3NpdGlvbi90aGlzLl9sYWJlbHNbdGhpcy5fbGFiZWxzLmxlbmd0aC0yXS5wb3NpdGlvbix0aGlzLl9sYWJlbHNbMV0ucG9zaXRpb24vdGhpcy5fbGFiZWxzWzBdLnBvc2l0aW9uKSkvTWF0aC5sb2codGhpcy5yYW5nZSk6dGhpcy5saW5lQ29vcmRpbmF0ZXMud2lkdGgvKHRoaXMubG9nYXJpdGhtaWMmJnRoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbD9NYXRoLmxvZyh0aGlzLnJhbmdlKS9NYXRoLmxvZyh0aGlzLmxvZ2FyaXRobUJhc2UpOk1hdGguYWJzKHRoaXMucmFuZ2UpKSpcblRbdGhpcy5pbnRlcnZhbFR5cGUrXCJEdXJhdGlvblwiXSp0aGlzLmludGVydmFsLGY9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aD8wLjUqdGhpcy5jaGFydC53aWR0aD4+MDp0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCx0aGlzLmNoYXJ0LnBhbkVuYWJsZWR8fChsPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmxhYmVsV3JhcHx8dGhpcy5sYWJlbFdyYXA/MC44KnRoaXMuY2hhcnQuaGVpZ2h0Pj4wOjEuNSp0aGlzLmxhYmVsRm9udFNpemUpO2Vsc2UgaWYoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24paD10aGlzLmxvZ2FyaXRobWljJiYhdGhpcy5lcXVpZGlzdGFudEludGVydmFsJiYyPD10aGlzLl9sYWJlbHMubGVuZ3RoP3RoaXMubGluZUNvb3JkaW5hdGVzLmhlaWdodCpNYXRoLmxvZyhNYXRoLm1pbih0aGlzLl9sYWJlbHNbdGhpcy5fbGFiZWxzLmxlbmd0aC0xXS5wb3NpdGlvbi9cbnRoaXMuX2xhYmVsc1t0aGlzLl9sYWJlbHMubGVuZ3RoLTJdLnBvc2l0aW9uLHRoaXMuX2xhYmVsc1sxXS5wb3NpdGlvbi90aGlzLl9sYWJlbHNbMF0ucG9zaXRpb24pKS9NYXRoLmxvZyh0aGlzLnJhbmdlKTp0aGlzLmxpbmVDb29yZGluYXRlcy5oZWlnaHQvKHRoaXMubG9nYXJpdGhtaWMmJnRoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbD9NYXRoLmxvZyh0aGlzLnJhbmdlKS9NYXRoLmxvZyh0aGlzLmxvZ2FyaXRobUJhc2UpOk1hdGguYWJzKHRoaXMucmFuZ2UpKSpUW3RoaXMuaW50ZXJ2YWxUeXBlK1wiRHVyYXRpb25cIl0qdGhpcy5pbnRlcnZhbCx0aGlzLmNoYXJ0LnBhbkVuYWJsZWR8fChmPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/MC4zKnRoaXMuY2hhcnQud2lkdGg+PjA6dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpLGw9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWxXcmFwfHx0aGlzLmxhYmVsV3JhcD8wLjMqdGhpcy5jaGFydC5oZWlnaHQ+PlxuMDoxLjUqdGhpcy5sYWJlbEZvbnRTaXplO2ZvcihiPTA7Yjx0aGlzLl9sYWJlbHMubGVuZ3RoO2IrKyl7YT10aGlzLl9sYWJlbHNbYl0udGV4dEJsb2NrO2EubWF4V2lkdGg9ZjthLm1heEhlaWdodD1sO3ZhciBzPWEubWVhc3VyZVRleHQoKTtwPXMuaGVpZ2h0fWU9W107cT1uPTA7aWYodGhpcy5sYWJlbEF1dG9GaXR8fHRoaXMub3B0aW9ucy5sYWJlbEF1dG9GaXQpaWYocih0aGlzLmxhYmVsQW5nbGUpfHwodGhpcy5sYWJlbEFuZ2xlPSh0aGlzLmxhYmVsQW5nbGUlMzYwKzM2MCklMzYwLDkwPHRoaXMubGFiZWxBbmdsZSYmMjcwPnRoaXMubGFiZWxBbmdsZT90aGlzLmxhYmVsQW5nbGUtPTE4MDoyNzA8PXRoaXMubGFiZWxBbmdsZSYmMzYwPj10aGlzLmxhYmVsQW5nbGUmJih0aGlzLmxhYmVsQW5nbGUtPTM2MCkpLFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKWlmKGY9MC45Kmg+PjAscT0wLCF0aGlzLmNoYXJ0LnBhbkVuYWJsZWQmJjE8PVxudGhpcy5fbGFiZWxzLmxlbmd0aCl7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplO3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPWY7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWw7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlO3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXA7Zm9yKGM9MDtjPHRoaXMuX2xhYmVscy5sZW5ndGg7YysrKWlmKCF0aGlzLl9sYWJlbHNbY10uYnJlYWtzTGFiZWxUeXBlKXthPXRoaXMuX2xhYmVsc1tjXS50ZXh0QmxvY2s7Zm9yKHZhciB2LGc9YS50ZXh0LnNwbGl0KFwiIFwiKSxiPTA7YjxnLmxlbmd0aDtiKyspbT1nW2JdLHRoaXMuY3R4LmZvbnQ9YS5mb250U3R5bGUrXCIgXCIrYS5mb250V2VpZ2h0K1wiIFwiK2EuZm9udFNpemUrXCJweCBcIithLmZvbnRGYW1pbHksbT10aGlzLmN0eC5tZWFzdXJlVGV4dChtKSxcbm0ud2lkdGg+cSYmKHY9YyxxPW0ud2lkdGgpfWM9MDtmb3IoYz10aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbjx0aGlzLnZpZXdwb3J0TWluaW11bT8xOjA7Yzx0aGlzLl9sYWJlbHMubGVuZ3RoO2MrKylpZighdGhpcy5fbGFiZWxzW2NdLmJyZWFrc0xhYmVsVHlwZSl7YT10aGlzLl9sYWJlbHNbY10udGV4dEJsb2NrO3M9YS5tZWFzdXJlVGV4dCgpO2ZvcihnPWMrMTtnPHRoaXMuX2xhYmVscy5sZW5ndGg7ZysrKWlmKCF0aGlzLl9sYWJlbHNbZ10uYnJlYWtzTGFiZWxUeXBlKXtkPXRoaXMuX2xhYmVsc1tnXS50ZXh0QmxvY2s7ZD1kLm1lYXN1cmVUZXh0KCk7YnJlYWt9ZS5wdXNoKGEuaGVpZ2h0KTt0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9TWF0aC5tYXguYXBwbHkoTWF0aCxlKTtNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTtNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTtiPWYqTWF0aC5zaW4oTWF0aC5QSS9cbjE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSsobC1hLmZvbnRTaXplLzIpKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpO2lmKHIodGhpcy5vcHRpb25zLmxhYmVsQW5nbGUpJiZpc05hTih0aGlzLm9wdGlvbnMubGFiZWxBbmdsZSkmJjAhPT10aGlzLm9wdGlvbnMubGFiZWxBbmdsZSlpZih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9MD09PXRoaXMubGFiZWxBbmdsZT9sOk1hdGgubWluKChiLWYqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSkpL01hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpLGIpLG09KGstKHArYS5mb250U2l6ZS8yKSpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicygtMjUpKSkvTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnMoLTI1KSksIXIodGhpcy5vcHRpb25zLmxhYmVsV3JhcCkpdGhpcy5sYWJlbFdyYXA/cih0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCk/XG4odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9TWF0aC5taW4oTWF0aC5tYXgoZixxKSxtKSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwLGQmJnMud2lkdGgrZC53aWR0aD4+MD4yKmYmJih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT0tMjUpKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD5mPy0yNTp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk6cih0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCk/KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PVxubCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1mLGQmJnMud2lkdGgrZC53aWR0aD4+MD4yKmYmJih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT0tMjUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9bSkpOih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD5mPy0yNTp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwKTtlbHNle2lmKHIodGhpcy5vcHRpb25zLmxhYmVsV3JhcCkpaWYoIXIodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpKXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoPGY/XG4odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWIpOih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT0tMjUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWwpO2Vsc2UgaWYoIXIoZCkpaWYoYj1zLndpZHRoK2Qud2lkdGg+PjAsZz10aGlzLmxhYmVsRm9udFNpemUscTxmKWItMipmPm4mJihuPWItMipmLGI+PTIqZiYmYjwyLjIqZj8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9ZixyKHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKSYmMTI8ZyYmKGc9TWF0aC5mbG9vcigxMi8xMypnKSxhLm1lYXN1cmVUZXh0KCkpLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplPXIodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpP1xuZzp0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT10aGlzLmxhYmVsQW5nbGUpOmI+PTIuMipmJiZiPDIuOCpmPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT0tMjUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9bSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT1nKTpiPj0yLjgqZiYmYjwzLjIqZj8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9TWF0aC5tYXgoZixxKSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPSEwLHIodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpJiYxMjx0aGlzLmxhYmVsRm9udFNpemUmJih0aGlzLmxhYmVsRm9udFNpemU9TWF0aC5mbG9vcigxMi8xMyp0aGlzLmxhYmVsRm9udFNpemUpLGEubWVhc3VyZVRleHQoKSksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9cih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/XG5nOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPXRoaXMubGFiZWxBbmdsZSk6Yj49My4yKmYmJmI8My42KmY/KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPS0yNSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPSEwLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPW0sdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplKTpiPjMuNipmJiZiPDUqZj8ocih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSkmJjEyPGcmJihnPU1hdGguZmxvb3IoMTIvMTMqZyksYS5tZWFzdXJlVGV4dCgpKSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT1yKHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKT9nOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9ITAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9XG4tMjUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9bSk6Yj41KmYmJih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPSEwLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPWYsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9Zyx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT10aGlzLmxhYmVsQW5nbGUpKTtlbHNlIGlmKHY9PT1jJiYoMD09PXYmJnErdGhpcy5fbGFiZWxzW3YrMV0udGV4dEJsb2NrLm1lYXN1cmVUZXh0KCkud2lkdGgtMipmPm58fHY9PT10aGlzLl9sYWJlbHMubGVuZ3RoLTEmJnErdGhpcy5fbGFiZWxzW3YtMV0udGV4dEJsb2NrLm1lYXN1cmVUZXh0KCkud2lkdGgtMipmPm58fDA8diYmdjx0aGlzLl9sYWJlbHMubGVuZ3RoLTEmJnErdGhpcy5fbGFiZWxzW3YrMV0udGV4dEJsb2NrLm1lYXN1cmVUZXh0KCkud2lkdGgtMipmPm4mJlxucSt0aGlzLl9sYWJlbHNbdi0xXS50ZXh0QmxvY2subWVhc3VyZVRleHQoKS53aWR0aC0yKmY+bikpbj0wPT09dj9xK3RoaXMuX2xhYmVsc1t2KzFdLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLndpZHRoLTIqZjpxK3RoaXMuX2xhYmVsc1t2LTFdLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLndpZHRoLTIqZix0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT1yKHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKT9nOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9ITAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9LTI1LHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPW07ZWxzZSBpZigwPT09bilmb3IodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9cih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/Zzp0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPVxuITAsYj0wO2I8dGhpcy5fbGFiZWxzLmxlbmd0aDtiKyspYT10aGlzLl9sYWJlbHNbYl0udGV4dEJsb2NrLGEubWF4V2lkdGg9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9TWF0aC5taW4oTWF0aC5tYXgoZixxKSxtKSxzPWEubWVhc3VyZVRleHQoKSxiPHRoaXMuX2xhYmVscy5sZW5ndGgtMSYmKGc9YisxLGQ9dGhpcy5fbGFiZWxzW2ddLnRleHRCbG9jayxkLm1heFdpZHRoPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPU1hdGgubWluKE1hdGgubWF4KGYscSksbSksZD1kLm1lYXN1cmVUZXh0KCkscy53aWR0aCtkLndpZHRoPj4wPjIqZiYmKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPS0yNSkpfWVsc2UodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD0wPT09dGhpcy5sYWJlbEFuZ2xlP2w6TWF0aC5taW4oKGItZipNYXRoLmNvcyhNYXRoLlBJL1xuMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKS9NYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSxiKSxtPTAhPXRoaXMubGFiZWxBbmdsZT8oay0ocCthLmZvbnRTaXplLzIpKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKS9NYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTpmLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD10aGlzLmxhYmVsV3JhcD8oay1tKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKS9NYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKToxLjUqdGhpcy5sYWJlbEZvbnRTaXplLHIodGhpcy5vcHRpb25zLmxhYmVsV3JhcCkpP3IodGhpcy5vcHRpb25zLmxhYmVsV3JhcCkmJih0aGlzLmxhYmVsV3JhcCYmIXIodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpP1xuKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6bSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bCk6KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlPXRoaXMubGFiZWxBbmdsZSx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD1tLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1iPDAuOSpoPzAuOSpoOmIsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcCkpOih0aGlzLm9wdGlvbnMubGFiZWxXcmFwPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoP1xudGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6bSk6KHIodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPXRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoOm0sdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcCksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWwpfWZvcihiPTA7Yjx0aGlzLl9sYWJlbHMubGVuZ3RoO2IrKylhPXRoaXMuX2xhYmVsc1tiXS50ZXh0QmxvY2ssYS5tYXhXaWR0aD10aGlzLmxhYmVsTWF4V2lkdGg9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGgsYS5mb250U2l6ZT10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZSxhLmFuZ2xlPXRoaXMubGFiZWxBbmdsZT10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSxhLndyYXA9dGhpcy5sYWJlbFdyYXA9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcCxcbmEubWF4SGVpZ2h0PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodCxhLm1lYXN1cmVUZXh0KCl9ZWxzZSBmb3IoYz0wO2M8dGhpcy5fbGFiZWxzLmxlbmd0aDtjKyspYT10aGlzLl9sYWJlbHNbY10udGV4dEJsb2NrLGEubWF4V2lkdGg9dGhpcy5sYWJlbE1heFdpZHRoPXIodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpP3IodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGgpP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPWY6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg6dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgsYS5mb250U2l6ZT10aGlzLmxhYmVsRm9udFNpemU9cih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/cih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZSk/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplOlxudGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUsYS5hbmdsZT10aGlzLmxhYmVsQW5nbGU9cih0aGlzLm9wdGlvbnMubGFiZWxBbmdsZSk/cih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlOnRoaXMubGFiZWxBbmdsZSxhLndyYXA9dGhpcy5sYWJlbFdyYXA9cih0aGlzLm9wdGlvbnMubGFiZWxXcmFwKT9yKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXApP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXA6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcDp0aGlzLm9wdGlvbnMubGFiZWxXcmFwLGEubWF4SGVpZ2h0PXIodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0KT90aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQsXG5hLm1lYXN1cmVUZXh0KCk7ZWxzZSBpZihcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLl9wb3NpdGlvbilpZihmPXIodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpPzAuMyp0aGlzLmNoYXJ0LndpZHRoPj4wOnRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoLGw9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMubGFiZWxXcmFwfHx0aGlzLmxhYmVsV3JhcD8wLjMqdGhpcy5jaGFydC5oZWlnaHQ+PjA6MS41KnRoaXMubGFiZWxGb250U2l6ZSwhdGhpcy5jaGFydC5wYW5FbmFibGVkJiYxPD10aGlzLl9sYWJlbHMubGVuZ3RoKXt0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZT10aGlzLmxhYmVsRm9udFNpemU7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9Zjt0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bDt0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT1yKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlKT9cbjA6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcDtmb3IoYz0wO2M8dGhpcy5fbGFiZWxzLmxlbmd0aDtjKyspaWYoIXRoaXMuX2xhYmVsc1tjXS5icmVha3NMYWJlbFR5cGUpe2E9dGhpcy5fbGFiZWxzW2NdLnRleHRCbG9jaztzPWEubWVhc3VyZVRleHQoKTtmb3IoZz1jKzE7Zzx0aGlzLl9sYWJlbHMubGVuZ3RoO2crKylpZighdGhpcy5fbGFiZWxzW2ddLmJyZWFrc0xhYmVsVHlwZSl7ZD10aGlzLl9sYWJlbHNbZ10udGV4dEJsb2NrO2Q9ZC5tZWFzdXJlVGV4dCgpO2JyZWFrfWUucHVzaChhLmhlaWdodCk7dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PU1hdGgubWF4LmFwcGx5KE1hdGgsZSk7Yj1mKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKyhsLWEuZm9udFNpemUvMikqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSk7XG5NYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTtNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTtyKHRoaXMub3B0aW9ucy5sYWJlbEFuZ2xlKSYmaXNOYU4odGhpcy5vcHRpb25zLmxhYmVsQW5nbGUpJiYwIT09dGhpcy5vcHRpb25zLmxhYmVsQW5nbGU/cih0aGlzLm9wdGlvbnMubGFiZWxXcmFwKT9yKHRoaXMub3B0aW9ucy5sYWJlbFdyYXApJiYocih0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCk/cihkKXx8KGg9cy5oZWlnaHQrZC5oZWlnaHQ+PjAsaC0yKmw+cSYmKHE9aC0yKmwsaD49MipsJiZoPDIuNCpsPyhyKHRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKSYmMTI8dGhpcy5sYWJlbEZvbnRTaXplJiYodGhpcy5sYWJlbEZvbnRTaXplPU1hdGguZmxvb3IoMTIvMTMqdGhpcy5sYWJlbEZvbnRTaXplKSxhLm1lYXN1cmVUZXh0KCkpLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1sLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEZvbnRTaXplPVxucih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/dGhpcy5sYWJlbEZvbnRTaXplOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplKTpoPj0yLjQqbCYmaDwyLjgqbD8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWIsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9ITApOmg+PTIuOCpsJiZoPDMuMipsPyh0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPSEwLHIodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpJiYxMjx0aGlzLmxhYmVsRm9udFNpemUmJih0aGlzLmxhYmVsRm9udFNpemU9TWF0aC5mbG9vcigxMi8xMyp0aGlzLmxhYmVsRm9udFNpemUpLGEubWVhc3VyZVRleHQoKSksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9cih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/XG50aGlzLmxhYmVsRm9udFNpemU6dGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9cih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk/MDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk6aD49My4yKmwmJmg8My42Kmw/KHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1iLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9ITAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9dGhpcy5sYWJlbEZvbnRTaXplKTpoPjMuNipsJiZoPDEwKmw/KHIodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpJiYxMjx0aGlzLmxhYmVsRm9udFNpemUmJih0aGlzLmxhYmVsRm9udFNpemU9TWF0aC5mbG9vcigxMi8xMyp0aGlzLmxhYmVsRm9udFNpemUpLGEubWVhc3VyZVRleHQoKSksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9cih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/XG50aGlzLmxhYmVsRm9udFNpemU6dGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9Zix0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT1yKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlKT8wOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlKTpoPjEwKmwmJmg8NTAqbCYmKHIodGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUpJiYxMjx0aGlzLmxhYmVsRm9udFNpemUmJih0aGlzLmxhYmVsRm9udFNpemU9TWF0aC5mbG9vcigxMi8xMyp0aGlzLmxhYmVsRm9udFNpemUpLGEubWVhc3VyZVRleHQoKSksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9cih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/dGhpcy5sYWJlbEZvbnRTaXplOnRoaXMub3B0aW9ucy5sYWJlbEZvbnRTaXplLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1cbmwsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9Zix0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT1yKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlKT8wOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlKSkpOih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9bCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aCkpOih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aD10aGlzLmxhYmVsV3JhcD90aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aD90aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aDp0aGlzLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/XG50aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aDpmLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1sKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPTA9PT10aGlzLmxhYmVsQW5nbGU/ZjpNYXRoLm1pbigoYi1sKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKS9NYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSxsKSxyKHRoaXMub3B0aW9ucy5sYWJlbFdyYXApKT9yKHRoaXMub3B0aW9ucy5sYWJlbFdyYXApJiYodGhpcy5sYWJlbFdyYXAmJiFyKHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKT8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6XG50aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aCx0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwPXRoaXMubGFiZWxXcmFwLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1iKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6Zix0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhIZWlnaHQ9MD09PXRoaXMubGFiZWxBbmdsZT9sOmIscih0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCkmJih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZT10aGlzLmxhYmVsQW5nbGUpKSk6dGhpcy5vcHRpb25zLmxhYmVsV3JhcD8odGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PTA9PT10aGlzLmxhYmVsQW5nbGU/bDpiLHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXAsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9XG5mKToodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0PWwscih0aGlzLm9wdGlvbnMubGFiZWxNYXhXaWR0aCksdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg9dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGg6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGgsdGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcD10aGlzLmxhYmVsV3JhcCl9Zm9yKGI9MDtiPHRoaXMuX2xhYmVscy5sZW5ndGg7YisrKWE9dGhpcy5fbGFiZWxzW2JdLnRleHRCbG9jayxhLm1heFdpZHRoPXRoaXMubGFiZWxNYXhXaWR0aD10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxNYXhXaWR0aCxhLmZvbnRTaXplPXRoaXMubGFiZWxGb250U2l6ZT10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZSxhLmFuZ2xlPXRoaXMubGFiZWxBbmdsZT10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSxhLndyYXA9XG50aGlzLmxhYmVsV3JhcD10aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxXcmFwLGEubWF4SGVpZ2h0PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodCxhLm1lYXN1cmVUZXh0KCl9ZWxzZSBmb3IoYz0wO2M8dGhpcy5fbGFiZWxzLmxlbmd0aDtjKyspYT10aGlzLl9sYWJlbHNbY10udGV4dEJsb2NrLGEubWF4V2lkdGg9dGhpcy5sYWJlbE1heFdpZHRoPXIodGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgpP3IodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGgpP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heFdpZHRoPWY6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg6dGhpcy5vcHRpb25zLmxhYmVsTWF4V2lkdGgsYS5mb250U2l6ZT10aGlzLmxhYmVsRm9udFNpemU9cih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/cih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxGb250U2l6ZSk/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU9XG50aGlzLmxhYmVsRm9udFNpemU6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsRm9udFNpemU6dGhpcy5vcHRpb25zLmxhYmVsRm9udFNpemUsYS5hbmdsZT10aGlzLmxhYmVsQW5nbGU9cih0aGlzLm9wdGlvbnMubGFiZWxBbmdsZSk/cih0aGlzLnNlc3Npb25WYXJpYWJsZXMubGFiZWxBbmdsZSk/dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsQW5nbGU9dGhpcy5sYWJlbEFuZ2xlOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbEFuZ2xlOnRoaXMubGFiZWxBbmdsZSxhLndyYXA9dGhpcy5sYWJlbFdyYXA9cih0aGlzLm9wdGlvbnMubGFiZWxXcmFwKT9yKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXApP3RoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbFdyYXA9dGhpcy5sYWJlbFdyYXA6dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsV3JhcDp0aGlzLm9wdGlvbnMubGFiZWxXcmFwLGEubWF4SGVpZ2h0PXIodGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4SGVpZ2h0KT9cbnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodD1sOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5sYWJlbE1heEhlaWdodCxhLm1lYXN1cmVUZXh0KCk7Zm9yKGM9MDtjPHRoaXMuc3RyaXBMaW5lcy5sZW5ndGg7YysrKXt2YXIgZj10aGlzLnN0cmlwTGluZXNbY10sQTtpZihcIm91dHNpZGVcIj09PWYubGFiZWxQbGFjZW1lbnQpe2w9dGhpcy5zZXNzaW9uVmFyaWFibGVzLmxhYmVsTWF4V2lkdGg7aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24pcihmLm9wdGlvbnMubGFiZWxXcmFwKSYmIXIodGhpcy5zZXNzaW9uVmFyaWFibGVzLnN0cmlwTGluZUxhYmVsTWF4SGVpZ2h0KT9BPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5zdHJpcExpbmVMYWJlbE1heEhlaWdodDp0aGlzLnNlc3Npb25WYXJpYWJsZXMuc3RyaXBMaW5lTGFiZWxNYXhIZWlnaHQ9QT1mLmxhYmVsV3JhcD8wLjgqdGhpcy5jaGFydC5oZWlnaHQ+PjA6MS41KnRoaXMubGFiZWxGb250U2l6ZTtcbmlmKFwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uKXIoZi5vcHRpb25zLmxhYmVsV3JhcCkmJiFyKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5zdHJpcExpbmVMYWJlbE1heEhlaWdodCk/QT10aGlzLnNlc3Npb25WYXJpYWJsZXMuc3RyaXBMaW5lTGFiZWxNYXhIZWlnaHQ6dGhpcy5zZXNzaW9uVmFyaWFibGVzLnN0cmlwTGluZUxhYmVsTWF4SGVpZ2h0PUE9Zi5sYWJlbFdyYXA/MC44KnRoaXMuY2hhcnQud2lkdGg+PjA6MS41KnRoaXMubGFiZWxGb250U2l6ZTtyKGYubGFiZWxCYWNrZ3JvdW5kQ29sb3IpJiYoZi5sYWJlbEJhY2tncm91bmRDb2xvcj1cIiNFRUVFRUVcIil9ZWxzZSBsPVwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPzAuOSp0aGlzLmNoYXJ0LndpZHRoPj4wOjAuOSp0aGlzLmNoYXJ0LmhlaWdodD4+MCxBPXIoZi5vcHRpb25zLmxhYmVsV3JhcCl8fGYubGFiZWxXcmFwP1wiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XG5cInRvcFwiPT09dGhpcy5fcG9zaXRpb24/MC44KnRoaXMuY2hhcnQud2lkdGg+PjA6MC44KnRoaXMuY2hhcnQuaGVpZ2h0Pj4wOjEuNSp0aGlzLmxhYmVsRm9udFNpemUscihmLmxhYmVsQmFja2dyb3VuZENvbG9yKSYmKHIoZi5zdGFydFZhbHVlKSYmMCE9PWYuc3RhcnRWYWx1ZT9mLmxhYmVsQmFja2dyb3VuZENvbG9yPXc/XCJ0cmFuc3BhcmVudFwiOm51bGw6Zi5sYWJlbEJhY2tncm91bmRDb2xvcj1cIiNFRUVFRUVcIik7YT1uZXcgamEodGhpcy5jdHgse3g6MCx5OjAsYmFja2dyb3VuZENvbG9yOmYubGFiZWxCYWNrZ3JvdW5kQ29sb3IsYm9yZGVyQ29sb3I6Zi5sYWJlbEJvcmRlckNvbG9yLGJvcmRlclRoaWNrbmVzczpmLmxhYmVsQm9yZGVyVGhpY2tuZXNzLGNvcm5lclJhZGl1czpmLmxhYmVsQ29ybmVyUmFkaXVzLG1heFdpZHRoOmYub3B0aW9ucy5sYWJlbE1heFdpZHRoP2Yub3B0aW9ucy5sYWJlbE1heFdpZHRoOmwsbWF4SGVpZ2h0OkEsYW5nbGU6dGhpcy5sYWJlbEFuZ2xlLHRleHQ6Zi5sYWJlbEZvcm1hdHRlcj9cbmYubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLHN0cmlwTGluZTpmfSk6Zi5sYWJlbCx0ZXh0QWxpZ246dGhpcy5sYWJlbFRleHRBbGlnbixmb250U2l6ZTpcIm91dHNpZGVcIj09PWYubGFiZWxQbGFjZW1lbnQ/Zi5vcHRpb25zLmxhYmVsRm9udFNpemU/Zi5sYWJlbEZvbnRTaXplOnRoaXMubGFiZWxGb250U2l6ZTpmLmxhYmVsRm9udFNpemUsZm9udEZhbWlseTpcIm91dHNpZGVcIj09PWYubGFiZWxQbGFjZW1lbnQ/Zi5vcHRpb25zLmxhYmVsRm9udEZhbWlseT9mLmxhYmVsRm9udEZhbWlseTp0aGlzLmxhYmVsRm9udEZhbWlseTpmLmxhYmVsRm9udEZhbWlseSxmb250V2VpZ2h0Olwib3V0c2lkZVwiPT09Zi5sYWJlbFBsYWNlbWVudD9mLm9wdGlvbnMubGFiZWxGb250V2VpZ2h0P2YubGFiZWxGb250V2VpZ2h0OnRoaXMubGFiZWxGb250V2VpZ2h0OmYubGFiZWxGb250V2VpZ2h0LGZvbnRDb2xvcjpmLmxhYmVsRm9udENvbG9yfHxmLmNvbG9yLGZvbnRTdHlsZTpcIm91dHNpZGVcIj09PVxuZi5sYWJlbFBsYWNlbWVudD9mLm9wdGlvbnMubGFiZWxGb250U3R5bGU/Zi5sYWJlbEZvbnRTdHlsZTp0aGlzLmZvbnRXZWlnaHQ6Zi5sYWJlbEZvbnRTdHlsZSx0ZXh0QmFzZWxpbmU6XCJtaWRkbGVcIn0pO3RoaXMuX3N0cmlwTGluZUxhYmVscy5wdXNoKHtwb3NpdGlvbjpmLnZhbHVlLHRleHRCbG9jazphLGVmZmVjdGl2ZUhlaWdodDpudWxsLHN0cmlwTGluZTpmfSl9fTtBLnByb3RvdHlwZS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aD1mdW5jdGlvbigpe3ZhciBhPTAsZD0wO3RoaXMuX2xhYmVscz1bXTt0aGlzLl9zdHJpcExpbmVMYWJlbHM9W107dmFyIGM9dGhpcy5jaGFydC5pc05hdmlnYXRvcj8wOjU7aWYoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pe3RoaXMuY3JlYXRlTGFiZWxzKCk7aWYoXCJpbnNpZGVcIiE9dGhpcy5sYWJlbFBsYWNlbWVudHx8XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQmJjA8dGhpcy5faW5kZXgpZm9yKGQ9XG4wO2Q8dGhpcy5fbGFiZWxzLmxlbmd0aDtkKyspe3ZhciBiPXRoaXMuX2xhYmVsc1tkXS50ZXh0QmxvY2ssZT1iLm1lYXN1cmVUZXh0KCksZj0wLGY9MD09PXRoaXMubGFiZWxBbmdsZT9lLndpZHRoOmUud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSkrKGUuaGVpZ2h0LWIuZm9udFNpemUvMikqTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSk7YTxmJiYodGhpcy5sYWJlbEVmZmVjdGl2ZVdpZHRoPWE9Zik7dGhpcy5fbGFiZWxzW2RdLmVmZmVjdGl2ZVdpZHRoPWZ9Zm9yKGQ9MDtkPHRoaXMuX3N0cmlwTGluZUxhYmVscy5sZW5ndGg7ZCsrKVwib3V0c2lkZVwiPT09dGhpcy5fc3RyaXBMaW5lTGFiZWxzW2RdLnN0cmlwTGluZS5sYWJlbFBsYWNlbWVudCYmKHRoaXMuX3N0cmlwTGluZUxhYmVsc1tkXS5zdHJpcExpbmUudmFsdWU+PXRoaXMudmlld3BvcnRNaW5pbXVtJiZ0aGlzLl9zdHJpcExpbmVMYWJlbHNbZF0uc3RyaXBMaW5lLnZhbHVlPD1cbnRoaXMudmlld3BvcnRNYXhpbXVtKSYmKGI9dGhpcy5fc3RyaXBMaW5lTGFiZWxzW2RdLnRleHRCbG9jayxlPWIubWVhc3VyZVRleHQoKSxmPTA9PT10aGlzLmxhYmVsQW5nbGU/ZS53aWR0aDplLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpKyhlLmhlaWdodC1iLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKHRoaXMubGFiZWxBbmdsZSkpLFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQmJihmKz10aGlzLnRpY2tMZW5ndGgpLFwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50JiYoYSs9MDx0aGlzLl9pbmRleD9mOjApLGE8ZiYmKGE9ZiksdGhpcy5zdHJpcExpbmVMYWJlbEVmZmVjdGl2ZVdpZHRoPXRoaXMuX3N0cmlwTGluZUxhYmVsc1tkXS5lZmZlY3RpdmVXaWR0aD1mKX1yZXR1cm4odGhpcy50aXRsZT90aGlzLl90aXRsZVRleHRCbG9jay5tZWFzdXJlVGV4dCgpLmhlaWdodCsyOjApK2ErKFwiaW5zaWRlXCI9PT1cbnRoaXMudGlja1BsYWNlbWVudD8wPHRoaXMuX2luZGV4P3RoaXMudGlja0xlbmd0aDowOnRoaXMudGlja0xlbmd0aCkrY307QS5wcm90b3R5cGUuY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlSGVpZ2h0PWZ1bmN0aW9uKCl7dmFyIGE9MDt0aGlzLl9sYWJlbHM9W107dGhpcy5fc3RyaXBMaW5lTGFiZWxzPVtdO3ZhciBkLGM9MCxiPXRoaXMuY2hhcnQuaXNOYXZpZ2F0b3I/MDo1O2lmKFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKXt0aGlzLmNyZWF0ZUxhYmVscygpO2lmKFwiaW5zaWRlXCIhPXRoaXMubGFiZWxQbGFjZW1lbnR8fFwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50JiYwPHRoaXMuX2luZGV4KWZvcihjPTA7Yzx0aGlzLl9sYWJlbHMubGVuZ3RoO2MrKyl7ZD10aGlzLl9sYWJlbHNbY10udGV4dEJsb2NrO3ZhciBlPWQubWVhc3VyZVRleHQoKSxmPTAsZj0wPT09dGhpcy5sYWJlbEFuZ2xlP2UuaGVpZ2h0OmUud2lkdGgqTWF0aC5zaW4oTWF0aC5QSS9cbjE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKSsoZS5oZWlnaHQtZC5mb250U2l6ZS8yKSpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyh0aGlzLmxhYmVsQW5nbGUpKTthPGYmJih0aGlzLmxhYmVsRWZmZWN0aXZlSGVpZ2h0PWE9Zik7dGhpcy5fbGFiZWxzW2NdLmVmZmVjdGl2ZUhlaWdodD1mfWZvcihjPTA7Yzx0aGlzLl9zdHJpcExpbmVMYWJlbHMubGVuZ3RoO2MrKylcIm91dHNpZGVcIj09PXRoaXMuX3N0cmlwTGluZUxhYmVsc1tjXS5zdHJpcExpbmUubGFiZWxQbGFjZW1lbnQmJih0aGlzLl9zdHJpcExpbmVMYWJlbHNbY10uc3RyaXBMaW5lLnZhbHVlPj10aGlzLnZpZXdwb3J0TWluaW11bSYmdGhpcy5fc3RyaXBMaW5lTGFiZWxzW2NdLnN0cmlwTGluZS52YWx1ZTw9dGhpcy52aWV3cG9ydE1heGltdW0pJiYoZD10aGlzLl9zdHJpcExpbmVMYWJlbHNbY10udGV4dEJsb2NrLGU9ZC5tZWFzdXJlVGV4dCgpLGY9MD09PXRoaXMubGFiZWxBbmdsZT9lLmhlaWdodDplLndpZHRoKlxuTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSkrKGUuaGVpZ2h0LWQuZm9udFNpemUvMikqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnModGhpcy5sYWJlbEFuZ2xlKSksXCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudCYmKGYrPXRoaXMudGlja0xlbmd0aCksXCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQmJihhKz0wPHRoaXMuX2luZGV4P2Y6MCksYTxmJiYoYT1mKSx0aGlzLnN0cmlwTGluZUxhYmVsRWZmZWN0aXZlSGVpZ2h0PXRoaXMuX3N0cmlwTGluZUxhYmVsc1tjXS5lZmZlY3RpdmVIZWlnaHQ9Zil9cmV0dXJuKHRoaXMudGl0bGU/dGhpcy5fdGl0bGVUZXh0QmxvY2subWVhc3VyZVRleHQoKS5oZWlnaHQrMjowKSthKyhcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50PzA8dGhpcy5faW5kZXg/dGhpcy50aWNrTGVuZ3RoOjA6dGhpcy50aWNrTGVuZ3RoKStifTtBLnNldExheW91dD1mdW5jdGlvbihhLGQsYyxiLGUsZil7dmFyIGwsXG5oLHAsayxtPWFbMF0/YVswXS5jaGFydDpkWzBdLmNoYXJ0LG49bS5pc05hdmlnYXRvcj8wOjEwLHE9bS5fYXhlcztpZihhJiYwPGEubGVuZ3RoKWZvcih2YXIgZz0wO2c8YS5sZW5ndGg7ZysrKWFbZ10mJmFbZ10uY2FsY3VsYXRlQXhpc1BhcmFtZXRlcnMoKTtpZihkJiYwPGQubGVuZ3RoKWZvcihnPTA7ZzxkLmxlbmd0aDtnKyspZFtnXS5jYWxjdWxhdGVBeGlzUGFyYW1ldGVycygpO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKGc9MDtnPGMubGVuZ3RoO2crKyljW2ddLmNhbGN1bGF0ZUF4aXNQYXJhbWV0ZXJzKCk7aWYoYiYmMDxiLmxlbmd0aClmb3IoZz0wO2c8Yi5sZW5ndGg7ZysrKWJbZ10uY2FsY3VsYXRlQXhpc1BhcmFtZXRlcnMoKTtmb3IoZz0wO2c8cS5sZW5ndGg7ZysrKWlmKHFbZ10mJnFbZ10uc2NhbGVCcmVha3MmJnFbZ10uc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoKWZvcih2YXIgcz1xW2ddLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLHc9MDt3PHMubGVuZ3RoJiZcbiEoc1t3XS5zdGFydFZhbHVlPnFbZ10udmlld3BvcnRNYXhpbXVtKTt3Kyspc1t3XS5lbmRWYWx1ZTxxW2ddLnZpZXdwb3J0TWluaW11bXx8KHIocVtnXS5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXgpJiYocVtnXS5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXg9dyksc1t3XS5zdGFydFZhbHVlPj1xW2ddLnZpZXdQb3J0TWluaW11bSYmKHFbZ10uc2NhbGVCcmVha3MubGFzdEJyZWFrSW5kZXg9dykpO2Zvcih2YXIgdj13PTAsdT0wLHk9MCx4PTAsej0wLEE9MCxELEIsRT1oPTAsRyxKLEsscz1HPUo9Sz0hMSxnPTA7ZzxxLmxlbmd0aDtnKyspcVtnXSYmcVtnXS50aXRsZSYmKHFbZ10uX3RpdGxlVGV4dEJsb2NrPW5ldyBqYShxW2ddLmN0eCx7dGV4dDpxW2ddLnRpdGxlLGhvcml6b250YWxBbGlnbjpcImNlbnRlclwiLGZvbnRTaXplOnFbZ10udGl0bGVGb250U2l6ZSxmb250RmFtaWx5OnFbZ10udGl0bGVGb250RmFtaWx5LGZvbnRXZWlnaHQ6cVtnXS50aXRsZUZvbnRXZWlnaHQsXG5mb250Q29sb3I6cVtnXS50aXRsZUZvbnRDb2xvcixmb250U3R5bGU6cVtnXS50aXRsZUZvbnRTdHlsZSxib3JkZXJDb2xvcjpxW2ddLnRpdGxlQm9yZGVyQ29sb3IsYm9yZGVyVGhpY2tuZXNzOnFbZ10udGl0bGVCb3JkZXJUaGlja25lc3MsYmFja2dyb3VuZENvbG9yOnFbZ10udGl0bGVCYWNrZ3JvdW5kQ29sb3IsY29ybmVyUmFkaXVzOnFbZ10udGl0bGVDb3JuZXJSYWRpdXMsdGV4dEJhc2VsaW5lOlwidG9wXCJ9KSk7Zm9yKGc9MDtnPHEubGVuZ3RoO2crKylpZihxW2ddLnRpdGxlKXN3aXRjaChxW2ddLl9wb3NpdGlvbil7Y2FzZSBcImxlZnRcIjpxW2ddLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD1xW2ddLnRpdGxlTWF4V2lkdGh8fGYuaGVpZ2h0O3FbZ10uX3RpdGxlVGV4dEJsb2NrLm1heEhlaWdodD1xW2ddLnRpdGxlV3JhcD8wLjgqZi53aWR0aDoxLjUqcVtnXS50aXRsZUZvbnRTaXplO3FbZ10uX3RpdGxlVGV4dEJsb2NrLmFuZ2xlPS05MDticmVhaztjYXNlIFwicmlnaHRcIjpxW2ddLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD1cbnFbZ10udGl0bGVNYXhXaWR0aHx8Zi5oZWlnaHQ7cVtnXS5fdGl0bGVUZXh0QmxvY2subWF4SGVpZ2h0PXFbZ10udGl0bGVXcmFwPzAuOCpmLndpZHRoOjEuNSpxW2ddLnRpdGxlRm9udFNpemU7cVtnXS5fdGl0bGVUZXh0QmxvY2suYW5nbGU9OTA7YnJlYWs7ZGVmYXVsdDpxW2ddLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD1xW2ddLnRpdGxlTWF4V2lkdGh8fGYud2lkdGgscVtnXS5fdGl0bGVUZXh0QmxvY2subWF4SGVpZ2h0PXFbZ10udGl0bGVXcmFwPzAuOCpmLmhlaWdodDoxLjUqcVtnXS50aXRsZUZvbnRTaXplLHFbZ10uX3RpdGxlVGV4dEJsb2NrLmFuZ2xlPTB9aWYoXCJub3JtYWxcIj09PWUpe2Zvcih2YXIgeT1bXSx4PVtdLHo9W10sQT1bXSxNPVtdLFE9W10sTj1bXSxQPVtdOzQ+dzspe3ZhciBGPTAsWD0wLFQ9MCxVPTAsVj1lPTAsTz0wLFo9MCxXPTAsWT0wLFI9MCxhYT0wO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKHo9W10sZz1SPTA7ZzxjLmxlbmd0aDtnKyspei5wdXNoKE1hdGguY2VpbChjW2ddP1xuY1tnXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aCgpOjApKSxSKz16W2ddLE8rPWNbZ10mJiFtLmlzTmF2aWdhdG9yP2NbZ10ubWFyZ2luOjA7ZWxzZSB6LnB1c2goTWF0aC5jZWlsKGNbMF0/Y1swXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aCgpOjApKTtOLnB1c2goeik7aWYoYiYmMDxiLmxlbmd0aClmb3IoQT1bXSxnPWFhPTA7ZzxiLmxlbmd0aDtnKyspQS5wdXNoKE1hdGguY2VpbChiW2ddP2JbZ10uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTowKSksYWErPUFbZ10sWis9YltnXT9iW2ddLm1hcmdpbjowO2Vsc2UgQS5wdXNoKE1hdGguY2VpbChiWzBdP2JbMF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTowKSk7UC5wdXNoKEEpO2w9TWF0aC5yb3VuZChmLngxK1IrTyk7cD1NYXRoLnJvdW5kKGYueDItYWEtWj5tLndpZHRoLW4/bS53aWR0aC1uOmYueDItYWEtWik7aWYoYSYmMDxhLmxlbmd0aClmb3IoeT1bXSxnPVc9MDtnPGEubGVuZ3RoO2crKylhW2ddJiZcbihhW2ddLmxpbmVDb29yZGluYXRlcz17fSksYVtnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg9TWF0aC5hYnMocC1sKSxhW2ddLnRpdGxlJiYoYVtnXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxhW2ddLnRpdGxlTWF4V2lkdGgmJmFbZ10udGl0bGVNYXhXaWR0aDxhW2ddLmxpbmVDb29yZGluYXRlcy53aWR0aD9hW2ddLnRpdGxlTWF4V2lkdGg6YVtnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGgpLHkucHVzaChNYXRoLmNlaWwoYVtnXT9hW2ddLmNyZWF0ZUxhYmVsc0FuZENhbGN1bGF0ZUhlaWdodCgpOjApKSxXKz15W2ddLGUrPWFbZ10mJiFtLmlzTmF2aWdhdG9yP2FbZ10ubWFyZ2luOjA7ZWxzZSB5LnB1c2goTWF0aC5jZWlsKGFbMF0/YVswXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVIZWlnaHQoKTowKSk7TS5wdXNoKHkpO2lmKGQmJjA8ZC5sZW5ndGgpZm9yKHg9W10sZz1ZPTA7ZzxkLmxlbmd0aDtnKyspZFtnXSYmKGRbZ10ubGluZUNvb3JkaW5hdGVzPXt9KSxkW2ddLmxpbmVDb29yZGluYXRlcy53aWR0aD1cbk1hdGguYWJzKHAtbCksZFtnXS50aXRsZSYmKGRbZ10uX3RpdGxlVGV4dEJsb2NrLm1heFdpZHRoPTA8ZFtnXS50aXRsZU1heFdpZHRoJiZkW2ddLnRpdGxlTWF4V2lkdGg8ZFtnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg/ZFtnXS50aXRsZU1heFdpZHRoOmRbZ10ubGluZUNvb3JkaW5hdGVzLndpZHRoKSx4LnB1c2goTWF0aC5jZWlsKGRbZ10/ZFtnXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVIZWlnaHQoKTowKSksWSs9eFtnXSxWKz1kW2ddJiYhbS5pc05hdmlnYXRvcj9kW2ddLm1hcmdpbjowO2Vsc2UgeC5wdXNoKE1hdGguY2VpbChkWzBdP2RbMF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlSGVpZ2h0KCk6MCkpO1EucHVzaCh4KTtpZihhJiYwPGEubGVuZ3RoKWZvcihnPTA7ZzxhLmxlbmd0aDtnKyspYVtnXSYmKGFbZ10ubGluZUNvb3JkaW5hdGVzLngxPWwscD1NYXRoLnJvdW5kKGYueDItYWEtWj5tLndpZHRoLW4/bS53aWR0aC1uOmYueDItYWEtWiksYVtnXS5fbGFiZWxzJiZcbjE8YVtnXS5fbGFiZWxzLmxlbmd0aCYmKGg9az0wLGs9YVtnXS5fbGFiZWxzWzFdLGg9XCJkYXRlVGltZVwiPT09YVtnXS52YWx1ZVR5cGU/YVtnXS5fbGFiZWxzW2FbZ10uX2xhYmVscy5sZW5ndGgtMl06YVtnXS5fbGFiZWxzW2FbZ10uX2xhYmVscy5sZW5ndGgtMV0sdj1rLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyhrLnRleHRCbG9jay5hbmdsZSkpKyhrLnRleHRCbG9jay5oZWlnaHQtaC50ZXh0QmxvY2suZm9udFNpemUvMikqTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnMoay50ZXh0QmxvY2suYW5nbGUpKSx1PWgudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKGgudGV4dEJsb2NrLmFuZ2xlKSkrKGgudGV4dEJsb2NrLmhlaWdodC1oLnRleHRCbG9jay5mb250U2l6ZS8yKSpNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyhoLnRleHRCbG9jay5hbmdsZSkpKSwhYVtnXXx8KCFhW2ddLmxhYmVsQXV0b0ZpdHx8XG5yKEQpfHxyKEIpfHxtLmlzTmF2aWdhdG9yfHxtLnN0b2NrQ2hhcnQpfHwoaD0wLDA8YVtnXS5sYWJlbEFuZ2xlP0IrdT5wJiYoaCs9MDxhW2ddLmxhYmVsQW5nbGU/Qit1LXAtYWE6MCk6MD5hW2ddLmxhYmVsQW5nbGU/RC12PGwmJkQtdjxhW2ddLnZpZXdwb3J0TWluaW11bSYmKEU9bC0oTythW2ddLnRpY2tMZW5ndGgreitELXYrYVtnXS5sYWJlbEZvbnRTaXplLzIpKTowPT09YVtnXS5sYWJlbEFuZ2xlJiYoQit1PnAmJihoPUIrdS8yLXAtYWEpLEQtdjxsJiZELXY8YVtnXS52aWV3cG9ydE1pbmltdW0mJihFPWwtTy1hW2ddLnRpY2tMZW5ndGgtei1EK3YvMikpLGFbZ10udmlld3BvcnRNYXhpbXVtPT09YVtnXS5tYXhpbXVtJiZhW2ddLnZpZXdwb3J0TWluaW11bT09PWFbZ10ubWluaW11bSYmMDxhW2ddLmxhYmVsQW5nbGUmJjA8aD9wLT1oOmFbZ10udmlld3BvcnRNYXhpbXVtPT09YVtnXS5tYXhpbXVtJiZhW2ddLnZpZXdwb3J0TWluaW11bT09PWFbZ10ubWluaW11bSYmMD5hW2ddLmxhYmVsQW5nbGUmJlxuMDxFP2wrPUU6YVtnXS52aWV3cG9ydE1heGltdW09PT1hW2ddLm1heGltdW0mJmFbZ10udmlld3BvcnRNaW5pbXVtPT09YVtnXS5taW5pbXVtJiYwPT09YVtnXS5sYWJlbEFuZ2xlJiYoMDxFJiYobCs9RSksMDxoJiYocC09aCkpKSxtLnBhbkVuYWJsZWQ/Vz1yKG0uc2Vzc2lvblZhcmlhYmxlcy5heGlzWC5oZWlnaHQpP20uc2Vzc2lvblZhcmlhYmxlcy5heGlzWC5oZWlnaHQ9VzptLnNlc3Npb25WYXJpYWJsZXMuYXhpc1guaGVpZ2h0Om0uc2Vzc2lvblZhcmlhYmxlcy5heGlzWC5oZWlnaHQ9VyxoPU1hdGgucm91bmQoZi55Mi1XLWUrRiksaz1NYXRoLnJvdW5kKGYueTIpLGFbZ10ubGluZUNvb3JkaW5hdGVzLngyPXAsYVtnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg9cC1sLGFbZ10ubGluZUNvb3JkaW5hdGVzLnkxPWgsYVtnXS5saW5lQ29vcmRpbmF0ZXMueTI9aCthW2ddLmxpbmVUaGlja25lc3MvMixcImluc2lkZVwiPT09YVtnXS5sYWJlbFBsYWNlbWVudCYmMDxnJiYoYVtnXS5saW5lQ29vcmRpbmF0ZXMueTE9XG5hW2ctMV0ubGluZUNvb3JkaW5hdGVzLnkyK0YrKGFbZ10ubGFiZWxFZmZlY3RpdmVIZWlnaHR8fDApLGFbZ10ubGluZUNvb3JkaW5hdGVzLnkyPWFbZ10ubGluZUNvb3JkaW5hdGVzLnkxK2FbZ10ubGluZVRoaWNrbmVzcy8yKSxcImluc2lkZVwiPT09YVtnXS50aWNrUGxhY2VtZW50JiYwPGcmJihhW2ddLmxpbmVDb29yZGluYXRlcy55MSs9YVtnXS50aWNrTGVuZ3RoLGFbZ10ubGluZUNvb3JkaW5hdGVzLnkyPWFbZ10ubGluZUNvb3JkaW5hdGVzLnkxK2FbZ10ubGluZVRoaWNrbmVzcy8yKSxhW2ddLmJvdW5kcz17eDE6bCx5MTpoLHgyOnAseTI6ay0oVytlLXlbZ10tRiksd2lkdGg6cC1sfSxhW2ddLmJvdW5kcy5oZWlnaHQ9YVtnXS5ib3VuZHMueTItYVtnXS5ib3VuZHMueTEpLEYrPXlbZ10rYVtnXS5tYXJnaW47aWYoZCYmMDxkLmxlbmd0aClmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKWRbZ10ubGluZUNvb3JkaW5hdGVzLngxPU1hdGgucm91bmQoZi54MStSK08pLGRbZ10ubGluZUNvb3JkaW5hdGVzLngyPVxuTWF0aC5yb3VuZChmLngyLWFhLVo+bS53aWR0aC1uP20ud2lkdGgtbjpmLngyLWFhLVopLGRbZ10ubGluZUNvb3JkaW5hdGVzLndpZHRoPU1hdGguYWJzKHAtbCksZFtnXS5fbGFiZWxzJiYxPGRbZ10uX2xhYmVscy5sZW5ndGgmJihrPWRbZ10uX2xhYmVsc1sxXSxoPVwiZGF0ZVRpbWVcIj09PWRbZ10udmFsdWVUeXBlP2RbZ10uX2xhYmVsc1tkW2ddLl9sYWJlbHMubGVuZ3RoLTJdOmRbZ10uX2xhYmVsc1tkW2ddLl9sYWJlbHMubGVuZ3RoLTFdLHY9ay50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnMoay50ZXh0QmxvY2suYW5nbGUpKSsoay50ZXh0QmxvY2suaGVpZ2h0LWgudGV4dEJsb2NrLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKGsudGV4dEJsb2NrLmFuZ2xlKSksdT1oLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyhoLnRleHRCbG9jay5hbmdsZSkpKyhoLnRleHRCbG9jay5oZWlnaHQtXG5oLnRleHRCbG9jay5mb250U2l6ZS8yKSpNYXRoLnNpbihNYXRoLlBJLzE4MCpNYXRoLmFicyhoLnRleHRCbG9jay5hbmdsZSkpKSxtLnBhbkVuYWJsZWQ/WT1yKG0uc2Vzc2lvblZhcmlhYmxlcy5heGlzWDIuaGVpZ2h0KT9tLnNlc3Npb25WYXJpYWJsZXMuYXhpc1gyLmhlaWdodD1ZOm0uc2Vzc2lvblZhcmlhYmxlcy5heGlzWDIuaGVpZ2h0Om0uc2Vzc2lvblZhcmlhYmxlcy5heGlzWDIuaGVpZ2h0PVksaD1NYXRoLnJvdW5kKGYueTEpLGs9ZFtnXS5saW5lQ29vcmRpbmF0ZXMueTE9aCtZK1YtWCxkW2ddLmxpbmVDb29yZGluYXRlcy55Mj1oLFwiaW5zaWRlXCI9PT1kW2ddLmxhYmVsUGxhY2VtZW50JiYwPGcmJihkW2ddLmxpbmVDb29yZGluYXRlcy55MT1kW2ctMV0ubGluZUNvb3JkaW5hdGVzLnkxLVgtKGRbZ10ubGFiZWxFZmZlY3RpdmVIZWlnaHR8fDApKSxcImluc2lkZVwiPT09ZFtnXS50aWNrUGxhY2VtZW50JiYwPGcmJihkW2ddLmxpbmVDb29yZGluYXRlcy55MS09ZFtnXS50aWNrTGVuZ3RoKSxcbmRbZ10uYm91bmRzPXt4MTpsLHkxOmgrKFkrVi14W2ddLVgpLHgyOnAseTI6ayx3aWR0aDpwLWx9LGRbZ10uYm91bmRzLmhlaWdodD1kW2ddLmJvdW5kcy55Mi1kW2ddLmJvdW5kcy55MSxYKz14W2ddK2RbZ10ubWFyZ2luO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKGc9MDtnPGMubGVuZ3RoO2crKylPPW0uaXNOYXZpZ2F0b3I/MDoxMCxjW2ddJiYobD1NYXRoLnJvdW5kKGFbMF0/YVswXS5saW5lQ29vcmRpbmF0ZXMueDE6ZFswXS5saW5lQ29vcmRpbmF0ZXMueDEpLE89Y1tnXS5fbGFiZWxzJiYwPGNbZ10uX2xhYmVscy5sZW5ndGg/Y1tnXS5fbGFiZWxzW2NbZ10uX2xhYmVscy5sZW5ndGgtMV0udGV4dEJsb2NrLmhlaWdodC8yOm4saD1NYXRoLnJvdW5kKGYueTErWStWPE1hdGgubWF4KE8sbik/TWF0aC5tYXgoTyxuKTpmLnkxK1krVikscD1NYXRoLnJvdW5kKGFbMF0/YVswXS5saW5lQ29vcmRpbmF0ZXMueDE6ZFswXS5saW5lQ29vcmRpbmF0ZXMueDEpLE89MDxhLmxlbmd0aD8wOmNbZ10uX2xhYmVscyYmXG4wPGNbZ10uX2xhYmVscy5sZW5ndGg/Y1tnXS5fbGFiZWxzWzBdLnRleHRCbG9jay5oZWlnaHQvMjpuLGs9TWF0aC5yb3VuZChmLnkyLVctZS1PKSxjW2ddLmxpbmVDb29yZGluYXRlcz17eDE6bC1ULHkxOmgseDI6cC1ULHkyOmssaGVpZ2h0Ok1hdGguYWJzKGstaCl9LFwiaW5zaWRlXCI9PT1jW2ddLmxhYmVsUGxhY2VtZW50JiYwPGcmJihjW2ddLmxpbmVDb29yZGluYXRlcy54MT1jW2ctMV0ubGluZUNvb3JkaW5hdGVzLngxLVQtKGNbZ10ubGFiZWxFZmZlY3RpdmVXaWR0aHx8MCksY1tnXS5saW5lQ29vcmRpbmF0ZXMueDI9Y1tnXS5saW5lQ29vcmRpbmF0ZXMueDErY1tnXS5saW5lVGhpY2tuZXNzLzIpLFwiaW5zaWRlXCI9PT1jW2ddLnRpY2tQbGFjZW1lbnQmJjA8ZyYmKGNbZ10ubGluZUNvb3JkaW5hdGVzLngxLT1jW2ddLnRpY2tMZW5ndGgsY1tnXS5saW5lQ29vcmRpbmF0ZXMueDI9Y1tnXS5saW5lQ29vcmRpbmF0ZXMueDErY1tnXS5saW5lVGhpY2tuZXNzLzIpLGNbZ10uYm91bmRzPVxue3gxOmwtKHpbZ10rVCkseTE6aCx4MjpwLVQseTI6ayxoZWlnaHQ6ay1ofSxjW2ddLmJvdW5kcy53aWR0aD1jW2ddLmJvdW5kcy54Mi1jW2ddLmJvdW5kcy54MSxjW2ddLnRpdGxlJiYoY1tnXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxjW2ddLnRpdGxlTWF4V2lkdGgmJmNbZ10udGl0bGVNYXhXaWR0aDxjW2ddLmxpbmVDb29yZGluYXRlcy5oZWlnaHQ/Y1tnXS50aXRsZU1heFdpZHRoOmNbZ10ubGluZUNvb3JkaW5hdGVzLmhlaWdodCksVCs9eltnXStjW2ddLm1hcmdpbik7aWYoYiYmMDxiLmxlbmd0aClmb3IoZz0wO2c8Yi5sZW5ndGg7ZysrKWJbZ10mJihsPU1hdGgucm91bmQoYVswXT9hWzBdLmxpbmVDb29yZGluYXRlcy54MjpkWzBdLmxpbmVDb29yZGluYXRlcy54MikscD1NYXRoLnJvdW5kKGwpLE89YltnXS5fbGFiZWxzJiYwPGJbZ10uX2xhYmVscy5sZW5ndGg/YltnXS5fbGFiZWxzW2JbZ10uX2xhYmVscy5sZW5ndGgtMV0udGV4dEJsb2NrLmhlaWdodC8yOjAsaD1NYXRoLnJvdW5kKGYueTErXG5ZK1Y8TWF0aC5tYXgoTyxuKT9NYXRoLm1heChPLG4pOmYueTErWStWKSxPPTA8YS5sZW5ndGg/MDpiW2ddLl9sYWJlbHMmJjA8YltnXS5fbGFiZWxzLmxlbmd0aD9iW2ddLl9sYWJlbHNbMF0udGV4dEJsb2NrLmhlaWdodC8yOjAsaz1NYXRoLnJvdW5kKGYueTItKFcrZStPKSksYltnXS5saW5lQ29vcmRpbmF0ZXM9e3gxOmwrVSx5MTpoLHgyOmwrVSx5MjprLGhlaWdodDpNYXRoLmFicyhrLWgpfSxcImluc2lkZVwiPT09YltnXS5sYWJlbFBsYWNlbWVudCYmMDxnJiYoYltnXS5saW5lQ29vcmRpbmF0ZXMueDE9YltnLTFdLmxpbmVDb29yZGluYXRlcy54MitVKyhiW2ddLmxhYmVsRWZmZWN0aXZlV2lkdGh8fDApLGJbZ10ubGluZUNvb3JkaW5hdGVzLngyPWJbZ10ubGluZUNvb3JkaW5hdGVzLngxK2JbZ10ubGluZVRoaWNrbmVzcy8yKSxcImluc2lkZVwiPT09YltnXS50aWNrUGxhY2VtZW50JiYwPGcmJihiW2ddLmxpbmVDb29yZGluYXRlcy54MSs9YltnXS50aWNrTGVuZ3RoLGJbZ10ubGluZUNvb3JkaW5hdGVzLngyPVxuYltnXS5saW5lQ29vcmRpbmF0ZXMueDErYltnXS5saW5lVGhpY2tuZXNzLzIpLGJbZ10uYm91bmRzPXt4MTpsK1UseTE6aCx4MjpwKyhBW2ddK1UpLHkyOmssaGVpZ2h0OmstaH0sYltnXS5ib3VuZHMud2lkdGg9YltnXS5ib3VuZHMueDItYltnXS5ib3VuZHMueDEsYltnXS50aXRsZSYmKGJbZ10uX3RpdGxlVGV4dEJsb2NrLm1heFdpZHRoPTA8YltnXS50aXRsZU1heFdpZHRoJiZiW2ddLnRpdGxlTWF4V2lkdGg8YltnXS5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0P2JbZ10udGl0bGVNYXhXaWR0aDpiW2ddLmxpbmVDb29yZGluYXRlcy5oZWlnaHQpLFUrPUFbZ10rYltnXS5tYXJnaW4pO2lmKGEmJjA8YS5sZW5ndGgpZm9yKGc9MDtnPGEubGVuZ3RoO2crKylhW2ddJiYoYVtnXS5jYWxjdWxhdGVWYWx1ZVRvUGl4ZWxDb252ZXJzaW9uUGFyYW1ldGVycygpLGFbZ10uY2FsY3VsYXRlQnJlYWtzU2l6ZUluVmFsdWVzKCksYVtnXS5fbGFiZWxzJiYxPGFbZ10uX2xhYmVscy5sZW5ndGgmJihEPVxuKGFbZ10ubG9nYXJpdGhtaWM/TWF0aC5sb2coYVtnXS5fbGFiZWxzWzFdLnBvc2l0aW9uL2FbZ10udmlld3BvcnRNaW5pbXVtKS9hW2ddLmNvbnZlcnNpb25QYXJhbWV0ZXJzLmxuTG9nYXJpdGhtQmFzZTphW2ddLl9sYWJlbHNbMV0ucG9zaXRpb24tYVtnXS52aWV3cG9ydE1pbmltdW0pKk1hdGguYWJzKGFbZ10uY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KSthW2ddLmxpbmVDb29yZGluYXRlcy54MSxsPWFbZ10uX2xhYmVsc1thW2ddLl9sYWJlbHMubGVuZ3RoLShcImRhdGVUaW1lXCI9PT1hW2ddLnZhbHVlVHlwZT8yOjEpXS5wb3NpdGlvbixsPWFbZ10uZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGFbZ10udmlld3BvcnRNaW5pbXVtLGwpLEI9YVtnXS5sb2dhcml0aG1pYz8oMTxsP01hdGgubG9nKGwpL2FbZ10uY29udmVyc2lvblBhcmFtZXRlcnMubG5Mb2dhcml0aG1CYXNlKk1hdGguYWJzKGFbZ10uY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KTowKSthW2ddLmxpbmVDb29yZGluYXRlcy54MTpcbigwPGw/bCpNYXRoLmFicyhhW2ddLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdCk6MCkrYVtnXS5saW5lQ29vcmRpbmF0ZXMueDEpKTtpZihkJiYwPGQubGVuZ3RoKWZvcihnPTA7ZzxkLmxlbmd0aDtnKyspZFtnXS5jYWxjdWxhdGVWYWx1ZVRvUGl4ZWxDb252ZXJzaW9uUGFyYW1ldGVycygpLGRbZ10uY2FsY3VsYXRlQnJlYWtzU2l6ZUluVmFsdWVzKCksZFtnXS5fbGFiZWxzJiYxPGRbZ10uX2xhYmVscy5sZW5ndGgmJihEPShkW2ddLmxvZ2FyaXRobWljP01hdGgubG9nKGRbZ10uX2xhYmVsc1sxXS5wb3NpdGlvbi9kW2ddLnZpZXdwb3J0TWluaW11bSkvZFtnXS5jb252ZXJzaW9uUGFyYW1ldGVycy5sbkxvZ2FyaXRobUJhc2U6ZFtnXS5fbGFiZWxzWzFdLnBvc2l0aW9uLWRbZ10udmlld3BvcnRNaW5pbXVtKSpNYXRoLmFicyhkW2ddLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdCkrZFtnXS5saW5lQ29vcmRpbmF0ZXMueDEsbD1kW2ddLl9sYWJlbHNbZFtnXS5fbGFiZWxzLmxlbmd0aC1cbihcImRhdGVUaW1lXCI9PT1kW2ddLnZhbHVlVHlwZT8yOjEpXS5wb3NpdGlvbixsPWRbZ10uZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGRbZ10udmlld3BvcnRNaW5pbXVtLGwpLEI9ZFtnXS5sb2dhcml0aG1pYz8oMTxsP01hdGgubG9nKGwpL2RbZ10uY29udmVyc2lvblBhcmFtZXRlcnMubG5Mb2dhcml0aG1CYXNlKk1hdGguYWJzKGRbZ10uY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KTowKStkW2ddLmxpbmVDb29yZGluYXRlcy54MTooMDxsP2wqTWF0aC5hYnMoZFtnXS5jb252ZXJzaW9uUGFyYW1ldGVycy5waXhlbFBlclVuaXQpOjApK2RbZ10ubGluZUNvb3JkaW5hdGVzLngxKTtmb3IoZz0wO2c8cS5sZW5ndGg7ZysrKVwiYXhpc1lcIj09PXFbZ10udHlwZSYmKHFbZ10uY2FsY3VsYXRlVmFsdWVUb1BpeGVsQ29udmVyc2lvblBhcmFtZXRlcnMoKSxxW2ddLmNhbGN1bGF0ZUJyZWFrc1NpemVJblZhbHVlcygpKTtpZigwPHcpe2lmKGEmJjA8YS5sZW5ndGgpZm9yKGc9MDtnPGEubGVuZ3RoO2crKylzPVxuTVt3LTFdW2ddPT09TVt3XVtnXT8hMDohMTtlbHNlIHM9ITA7aWYoZCYmMDxkLmxlbmd0aClmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKUc9UVt3LTFdW2ddPT09UVt3XVtnXT8hMDohMTtlbHNlIEc9ITA7aWYoYyYmMDxjLmxlbmd0aClmb3IoZz0wO2c8Yy5sZW5ndGg7ZysrKUo9Tlt3LTFdW2ddPT09Tlt3XVtnXT8hMDohMTtlbHNlIEo9ITA7aWYoYiYmMDxiLmxlbmd0aClmb3IoZz0wO2c8Yi5sZW5ndGg7ZysrKUs9UFt3LTFdW2ddPT09UFt3XVtnXT8hMDohMTtlbHNlIEs9ITB9aWYocyYmRyYmSiYmSylicmVhazt3Kyt9aWYoYSYmMDxhLmxlbmd0aClmb3IoZz0wO2c8YS5sZW5ndGg7ZysrKWFbZ10uY2FsY3VsYXRlU3RyaXBMaW5lc1RoaWNrbmVzc0luVmFsdWVzKCksYVtnXS5jYWxjdWxhdGVCcmVha3NJblBpeGVscygpO2lmKGQmJjA8ZC5sZW5ndGgpZm9yKGc9MDtnPGQubGVuZ3RoO2crKylkW2ddLmNhbGN1bGF0ZVN0cmlwTGluZXNUaGlja25lc3NJblZhbHVlcygpLGRbZ10uY2FsY3VsYXRlQnJlYWtzSW5QaXhlbHMoKTtcbmlmKGMmJjA8Yy5sZW5ndGgpZm9yKGc9MDtnPGMubGVuZ3RoO2crKyljW2ddLmNhbGN1bGF0ZVN0cmlwTGluZXNUaGlja25lc3NJblZhbHVlcygpLGNbZ10uY2FsY3VsYXRlQnJlYWtzSW5QaXhlbHMoKTtpZihiJiYwPGIubGVuZ3RoKWZvcihnPTA7ZzxiLmxlbmd0aDtnKyspYltnXS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXMoKSxiW2ddLmNhbGN1bGF0ZUJyZWFrc0luUGl4ZWxzKCl9ZWxzZXtuPVtdO0Q9W107RT1bXTt2PVtdO0I9W107dT1bXTtNPVtdO2ZvcihRPVtdOzQ+dzspe1c9VT1UPVo9Tz1WPWU9UD1OPUY9WT0wO2lmKGEmJjA8YS5sZW5ndGgpZm9yKEU9W10sZz1VPTA7ZzxhLmxlbmd0aDtnKyspRS5wdXNoKE1hdGguY2VpbChhW2ddP2FbZ10uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTowKSksVSs9RVtnXSxlKz1hW2ddJiYhbS5pc05hdmlnYXRvcj9hW2ddLm1hcmdpbjowO2Vsc2UgRS5wdXNoKE1hdGguY2VpbChhWzBdP2FbMF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlV2lkdGgoKTpcbjApKTtNLnB1c2goRSk7aWYoZCYmMDxkLmxlbmd0aClmb3Iodj1bXSxnPVc9MDtnPGQubGVuZ3RoO2crKyl2LnB1c2goTWF0aC5jZWlsKGRbZ10/ZFtnXS5jcmVhdGVMYWJlbHNBbmRDYWxjdWxhdGVXaWR0aCgpOjApKSxXKz12W2ddLFYrPWRbZ10/ZFtnXS5tYXJnaW46MDtlbHNlIHYucHVzaChNYXRoLmNlaWwoZFswXT9kWzBdLmNyZWF0ZUxhYmVsc0FuZENhbGN1bGF0ZVdpZHRoKCk6MCkpO1EucHVzaCh2KTtpZihjJiYwPGMubGVuZ3RoKWZvcihnPTA7ZzxjLmxlbmd0aDtnKyspY1tnXS5saW5lQ29vcmRpbmF0ZXM9e30sbD1NYXRoLnJvdW5kKGYueDErVStlKSxwPU1hdGgucm91bmQoZi54Mi1XLVY+bS53aWR0aC0xMD9tLndpZHRoLTEwOmYueDItVy1WKSxjW2ddLmxhYmVsQXV0b0ZpdCYmIXIoeSkmJigwPCFhLmxlbmd0aCYmKGw9MD5jW2ddLmxhYmVsQW5nbGU/TWF0aC5tYXgobCx5KTowPT09Y1tnXS5sYWJlbEFuZ2xlP01hdGgubWF4KGwseS8yKTpsKSwwPCFkLmxlbmd0aCYmKHA9XG4wPGNbZ10ubGFiZWxBbmdsZT9wLXgvMjowPT09Y1tnXS5sYWJlbEFuZ2xlP3AteC8yOnApKSxjW2ddLmxpbmVDb29yZGluYXRlcy54MT1sLGNbZ10ubGluZUNvb3JkaW5hdGVzLngyPXAsY1tnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg9TWF0aC5hYnMocC1sKSxjW2ddLnRpdGxlJiYoY1tnXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxjW2ddLnRpdGxlTWF4V2lkdGgmJmNbZ10udGl0bGVNYXhXaWR0aDxjW2ddLmxpbmVDb29yZGluYXRlcy53aWR0aD9jW2ddLnRpdGxlTWF4V2lkdGg6Y1tnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGgpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGc9MDtnPGIubGVuZ3RoO2crKyliW2ddLmxpbmVDb29yZGluYXRlcz17fSxsPU1hdGgucm91bmQoZi54MStVK2UpLHA9TWF0aC5yb3VuZChmLngyLVctVj5iW2ddLmNoYXJ0LndpZHRoLTEwP2JbZ10uY2hhcnQud2lkdGgtMTA6Zi54Mi1XLVYpLGJbZ10mJmJbZ10ubGFiZWxBdXRvRml0JiYhcih6KSYmKDA8IWEubGVuZ3RoJiZcbihsPTA8YltnXS5sYWJlbEFuZ2xlP01hdGgubWF4KGwseik6MD09PWJbZ10ubGFiZWxBbmdsZT9NYXRoLm1heChsLHovMik6bCksMDwhZC5sZW5ndGgmJihwLT1BLzIpKSxiW2ddLmxpbmVDb29yZGluYXRlcy54MT1sLGJbZ10ubGluZUNvb3JkaW5hdGVzLngyPXAsYltnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg9TWF0aC5hYnMocC1sKSxiW2ddLnRpdGxlJiYoYltnXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxiW2ddLnRpdGxlTWF4V2lkdGgmJmJbZ10udGl0bGVNYXhXaWR0aDxiW2ddLmxpbmVDb29yZGluYXRlcy53aWR0aD9iW2ddLnRpdGxlTWF4V2lkdGg6YltnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGgpO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKG49W10sZz1UPTA7ZzxjLmxlbmd0aDtnKyspbi5wdXNoKE1hdGguY2VpbChjW2ddP2NbZ10uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlSGVpZ2h0KCk6MCkpLFQrPW5bZ10rY1tnXS5tYXJnaW4sTys9Y1tnXS5tYXJnaW47ZWxzZSBuLnB1c2goTWF0aC5jZWlsKGNbMF0/XG5jWzBdLmNyZWF0ZUxhYmVsc0FuZENhbGN1bGF0ZUhlaWdodCgpOjApKTtCLnB1c2gobik7aWYoYiYmMDxiLmxlbmd0aClmb3IoRD1bXSxnPTA7ZzxiLmxlbmd0aDtnKyspRC5wdXNoKE1hdGguY2VpbChiW2ddP2JbZ10uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlSGVpZ2h0KCk6MCkpLForPWJbZ10ubWFyZ2luO2Vsc2UgRC5wdXNoKE1hdGguY2VpbChiWzBdP2JbMF0uY3JlYXRlTGFiZWxzQW5kQ2FsY3VsYXRlSGVpZ2h0KCk6MCkpO3UucHVzaChEKTtpZihjJiYwPGMubGVuZ3RoKWZvcihnPTA7ZzxjLmxlbmd0aDtnKyspMDxjW2ddLl9sYWJlbHMubGVuZ3RoJiYoaz1jW2ddLl9sYWJlbHNbMF0saD1jW2ddLl9sYWJlbHNbY1tnXS5fbGFiZWxzLmxlbmd0aC0xXSx5PWsudGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKk1hdGguYWJzKGsudGV4dEJsb2NrLmFuZ2xlKSkrKGsudGV4dEJsb2NrLmhlaWdodC1oLnRleHRCbG9jay5mb250U2l6ZS8yKSpNYXRoLnNpbihNYXRoLlBJL1xuMTgwKk1hdGguYWJzKGsudGV4dEJsb2NrLmFuZ2xlKSkseD1oLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyhoLnRleHRCbG9jay5hbmdsZSkpKyhoLnRleHRCbG9jay5oZWlnaHQtaC50ZXh0QmxvY2suZm9udFNpemUvMikqTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnMoaC50ZXh0QmxvY2suYW5nbGUpKSk7aWYoYiYmMDxiLmxlbmd0aClmb3IoZz0wO2c8Yi5sZW5ndGg7ZysrKWJbZ10mJjA8YltnXS5fbGFiZWxzLmxlbmd0aCYmKGs9YltnXS5fbGFiZWxzWzBdLGg9YltnXS5fbGFiZWxzW2JbZ10uX2xhYmVscy5sZW5ndGgtMV0sej1rLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCpNYXRoLmFicyhrLnRleHRCbG9jay5hbmdsZSkpKyhrLnRleHRCbG9jay5oZWlnaHQtaC50ZXh0QmxvY2suZm9udFNpemUvMikqTWF0aC5zaW4oTWF0aC5QSS8xODAqTWF0aC5hYnMoay50ZXh0QmxvY2suYW5nbGUpKSxBPWgudGV4dEJsb2NrLndpZHRoKlxuTWF0aC5jb3MoTWF0aC5QSS8xODAqTWF0aC5hYnMoaC50ZXh0QmxvY2suYW5nbGUpKSsoaC50ZXh0QmxvY2suaGVpZ2h0LWgudGV4dEJsb2NrLmZvbnRTaXplLzIpKk1hdGguc2luKE1hdGguUEkvMTgwKk1hdGguYWJzKGgudGV4dEJsb2NrLmFuZ2xlKSkpO2lmKG0ucGFuRW5hYmxlZClmb3IoZz0wO2c8Yy5sZW5ndGg7ZysrKW5bZ109cihtLnNlc3Npb25WYXJpYWJsZXMuYXhpc1lbZ10uaGVpZ2h0KT9tLnNlc3Npb25WYXJpYWJsZXMuYXhpc1lbZ10uaGVpZ2h0PW5bZ106bS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZW2ddLmhlaWdodDtlbHNlIGZvcihnPTA7ZzxjLmxlbmd0aDtnKyspbS5zZXNzaW9uVmFyaWFibGVzLmF4aXNZW2ddLmhlaWdodD1uW2ddO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKGc9Yy5sZW5ndGgtMTswPD1nO2ctLSloPU1hdGgucm91bmQoZi55Miksaz1NYXRoLnJvdW5kKGYueTI+Y1tnXS5jaGFydC5oZWlnaHQ/Y1tnXS5jaGFydC5oZWlnaHQ6Zi55MiksY1tnXS5saW5lQ29vcmRpbmF0ZXMueTE9XG5oLShuW2ddK2NbZ10ubWFyZ2luK1kpLGNbZ10ubGluZUNvb3JkaW5hdGVzLnkyPWgtKG5bZ10rY1tnXS5tYXJnaW4rWSksXCJpbnNpZGVcIj09PWNbZ10ubGFiZWxQbGFjZW1lbnQmJjA8ZyYmKGNbZ10ubGluZUNvb3JkaW5hdGVzLnkxPWNbZ10ubGluZUNvb3JkaW5hdGVzLnkxK25bZ10tKGNbZ10uX3RpdGxlVGV4dEJsb2NrP2NbZ10uX3RpdGxlVGV4dEJsb2NrLmhlaWdodDowKS1jW2ddLnRpY2tMZW5ndGgtKGNbZ10uc3RyaXBMaW5lTGFiZWxFZmZlY3RpdmVIZWlnaHR8fDApLTUsY1tnXS5saW5lQ29vcmRpbmF0ZXMueTI9Y1tnXS5saW5lQ29vcmRpbmF0ZXMueTErY1tnXS5saW5lVGhpY2tuZXNzLzIpLFwiaW5zaWRlXCI9PT1jW2ddLnRpY2tQbGFjZW1lbnQmJjA8ZyYmKGNbZ10ubGluZUNvb3JkaW5hdGVzLnkxKz1jW2ddLnRpY2tMZW5ndGgsY1tnXS5saW5lQ29vcmRpbmF0ZXMueTI9Y1tnXS5saW5lQ29vcmRpbmF0ZXMueTErY1tnXS5saW5lVGhpY2tuZXNzLzIpLGNbZ10uYm91bmRzPVxue3gxOmwseTE6aC0obltnXStZK2NbZ10ubWFyZ2luKSx4MjpwLHkyOmstKFkrY1tnXS5tYXJnaW4pLHdpZHRoOnAtbCxoZWlnaHQ6bltnXX0sY1tnXS50aXRsZSYmKGNbZ10uX3RpdGxlVGV4dEJsb2NrLm1heFdpZHRoPTA8Y1tnXS50aXRsZU1heFdpZHRoJiZjW2ddLnRpdGxlTWF4V2lkdGg8Y1tnXS5saW5lQ29vcmRpbmF0ZXMud2lkdGg/Y1tnXS50aXRsZU1heFdpZHRoOmNbZ10ubGluZUNvb3JkaW5hdGVzLndpZHRoKSxZKz1uW2ddK2NbZ10ubWFyZ2luO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGc9Yi5sZW5ndGgtMTswPD1nO2ctLSliW2ddJiYoaD1NYXRoLnJvdW5kKGYueTEpLGs9TWF0aC5yb3VuZChmLnkxKyhEW2ddK2JbZ10ubWFyZ2luK0YpKSxiW2ddLmxpbmVDb29yZGluYXRlcy55MT1rLGJbZ10ubGluZUNvb3JkaW5hdGVzLnkyPWssXCJpbnNpZGVcIj09PWJbZ10ubGFiZWxQbGFjZW1lbnQmJjA8ZyYmKGJbZ10ubGluZUNvb3JkaW5hdGVzLnkxPWstRFtnXSsoYltnXS5fdGl0bGVUZXh0QmxvY2s/XG5iW2ddLl90aXRsZVRleHRCbG9jay5oZWlnaHQ6MCkrYltnXS50aWNrTGVuZ3RoKyhiW2ddLnN0cmlwTGluZUxhYmVsRWZmZWN0aXZlSGVpZ2h0fHwwKSxiW2ddLmxpbmVDb29yZGluYXRlcy55Mj1iW2ddLmxpbmVDb29yZGluYXRlcy55MS1iW2ddLmxpbmVUaGlja25lc3MvMiksXCJpbnNpZGVcIj09PWJbZ10udGlja1BsYWNlbWVudCYmMDxnJiYoYltnXS5saW5lQ29vcmRpbmF0ZXMueTEtPWJbZ10udGlja0xlbmd0aCxiW2ddLmxpbmVDb29yZGluYXRlcy55Mj1iW2ddLmxpbmVDb29yZGluYXRlcy55MS1iW2ddLmxpbmVUaGlja25lc3MvMiksYltnXS5ib3VuZHM9e3gxOmwseTE6aCsoYltnXS5tYXJnaW4rRikseDI6cCx5MjprLHdpZHRoOnAtbH0sYltnXS5ib3VuZHMuaGVpZ2h0PWJbZ10uYm91bmRzLnkyLWJbZ10uYm91bmRzLnkxLGJbZ10udGl0bGUmJihiW2ddLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aD0wPGJbZ10udGl0bGVNYXhXaWR0aCYmYltnXS50aXRsZU1heFdpZHRoPGJbZ10ubGluZUNvb3JkaW5hdGVzLndpZHRoP1xuYltnXS50aXRsZU1heFdpZHRoOmJbZ10ubGluZUNvb3JkaW5hdGVzLndpZHRoKSxGKz1EW2ddK2JbZ10ubWFyZ2luKTtpZihhJiYwPGEubGVuZ3RoKWZvcihnPTA7ZzxhLmxlbmd0aDtnKyspe089YVtnXS5fbGFiZWxzJiYwPGFbZ10uX2xhYmVscy5sZW5ndGg/YVtnXS5fbGFiZWxzWzBdLnRleHRCbG9jay5mb250U2l6ZS8yOjA7bD1NYXRoLnJvdW5kKGYueDErZSk7aD1iJiYwPGIubGVuZ3RoP01hdGgucm91bmQoYlswXT9iWzBdLmxpbmVDb29yZGluYXRlcy55MjpmLnkxPE1hdGgubWF4KE8sMTApP01hdGgubWF4KE8sMTApOmYueTEpOmYueTE8TWF0aC5tYXgoTywxMCk/TWF0aC5tYXgoTywxMCk6Zi55MTtwPU1hdGgucm91bmQoZi54MStVK2UpO2s9YyYmMDxjLmxlbmd0aD9NYXRoLnJvdW5kKGNbMF0/Y1swXS5saW5lQ29vcmRpbmF0ZXMueTE6Zi55Mi1UPm0uaGVpZ2h0LU1hdGgubWF4KE8sMTApP20uaGVpZ2h0LU1hdGgubWF4KE8sMTApOmYueTItVCk6Zi55Mj5tLmhlaWdodC1NYXRoLm1heChPLFxuMTApP20uaGVpZ2h0LU1hdGgubWF4KE8sMTApOmYueTI7aWYoYyYmMDxjLmxlbmd0aClmb3IoTz0wO088Yy5sZW5ndGg7TysrKWNbT10mJmNbT10ubGFiZWxBdXRvRml0JiYocD1jW09dLmxpbmVDb29yZGluYXRlcy54MSxsPTA+Y1tPXS5sYWJlbEFuZ2xlfHwwPT09Y1tPXS5sYWJlbEFuZ2xlP3AtVTpsKTtpZihiJiYwPGIubGVuZ3RoKWZvcihPPTA7TzxiLmxlbmd0aDtPKyspYltPXSYmYltPXS5sYWJlbEF1dG9GaXQmJihwPWJbT10ubGluZUNvb3JkaW5hdGVzLngxLGw9cC1VKTthW2ddLmxpbmVDb29yZGluYXRlcz17eDE6cC1OLHkxOmgseDI6cC1OLHkyOmssaGVpZ2h0Ok1hdGguYWJzKGstaCl9O1wiaW5zaWRlXCI9PT1hW2ddLmxhYmVsUGxhY2VtZW50JiYwPGcmJihhW2ddLmxpbmVDb29yZGluYXRlcy54MT1hW2ddLmxpbmVDb29yZGluYXRlcy54MS0oRVtnXS0oYVtnXS5fdGl0bGVUZXh0QmxvY2s/YVtnXS5fdGl0bGVUZXh0QmxvY2suaGVpZ2h0OjApKSthW2ddLnRpY2tMZW5ndGgrXG4oYVtnXS5zdHJpcExpbmVMYWJlbEVmZmVjdGl2ZVdpZHRofHwwKSxhW2ddLmxpbmVDb29yZGluYXRlcy54Mj1hW2ddLmxpbmVDb29yZGluYXRlcy54MSthW2ddLmxpbmVUaGlja25lc3MvMik7XCJpbnNpZGVcIj09PWFbZ10udGlja1BsYWNlbWVudCYmMDxnJiYoYVtnXS5saW5lQ29vcmRpbmF0ZXMueDEtPWFbZ10udGlja0xlbmd0aCxhW2ddLmxpbmVDb29yZGluYXRlcy54Mj1hW2ddLmxpbmVDb29yZGluYXRlcy54MSthW2ddLmxpbmVUaGlja25lc3MvMik7YVtnXS5ib3VuZHM9e3gxOnAtKEVbZ10rTikseTE6aCx4MjpwLU4seTI6ayxoZWlnaHQ6ay1ofTthW2ddLmJvdW5kcy53aWR0aD1hW2ddLmJvdW5kcy54Mi1hW2ddLmJvdW5kcy54MTthW2ddLnRpdGxlJiYoYVtnXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9MDxhW2ddLnRpdGxlTWF4V2lkdGgmJmFbZ10udGl0bGVNYXhXaWR0aDxhW2ddLmxpbmVDb29yZGluYXRlcy5oZWlnaHQ/YVtnXS50aXRsZU1heFdpZHRoOmFbZ10ubGluZUNvb3JkaW5hdGVzLmhlaWdodCk7XG5hW2ddLmNhbGN1bGF0ZVZhbHVlVG9QaXhlbENvbnZlcnNpb25QYXJhbWV0ZXJzKCk7YVtnXS5jYWxjdWxhdGVCcmVha3NTaXplSW5WYWx1ZXMoKTtOKz1FW2ddK2FbZ10ubWFyZ2lufWlmKGQmJjA8ZC5sZW5ndGgpZm9yKGc9MDtnPGQubGVuZ3RoO2crKyl7Tz1kW2ddLl9sYWJlbHMmJjA8ZFtnXS5fbGFiZWxzLmxlbmd0aD9kW2ddLl9sYWJlbHNbMF0udGV4dEJsb2NrLmZvbnRTaXplLzI6MDtsPU1hdGgucm91bmQoZi54MS1lKTtoPWImJjA8Yi5sZW5ndGg/TWF0aC5yb3VuZChiWzBdP2JbMF0ubGluZUNvb3JkaW5hdGVzLnkyOmYueTE8TWF0aC5tYXgoTywxMCk/TWF0aC5tYXgoTywxMCk6Zi55MSk6Zi55MTxNYXRoLm1heChPLDEwKT9NYXRoLm1heChPLDEwKTpmLnkxO3A9TWF0aC5yb3VuZChmLngyLVctVik7az1jJiYwPGMubGVuZ3RoP01hdGgucm91bmQoY1swXT9jWzBdLmxpbmVDb29yZGluYXRlcy55MTpmLnkyLVQ+bS5oZWlnaHQtTWF0aC5tYXgoTywxMCk/bS5oZWlnaHQtTWF0aC5tYXgoTyxcbjEwKTpmLnkyLVQpOmYueTI+bS5oZWlnaHQtTWF0aC5tYXgoTywxMCk/bS5oZWlnaHQtTWF0aC5tYXgoTywxMCk6Zi55MjtpZihjJiYwPGMubGVuZ3RoKWZvcihPPTA7TzxjLmxlbmd0aDtPKyspY1tPXSYmY1tPXS5sYWJlbEF1dG9GaXQmJihwPTA+Y1tPXS5sYWJlbEFuZ2xlP01hdGgubWF4KHAseSk6MD09PWNbT10ubGFiZWxBbmdsZT9NYXRoLm1heChwLHkvMik6cCxsPTA+Y1tPXS5sYWJlbEFuZ2xlfHwwPT09Y1tPXS5sYWJlbEFuZ2xlP3AtVzpsKTtpZihiJiYwPGIubGVuZ3RoKWZvcihPPTA7TzxiLmxlbmd0aDtPKyspYltPXSYmYltPXS5sYWJlbEF1dG9GaXQmJihwPWJbT10ubGluZUNvb3JkaW5hdGVzLngyLGw9cC1XKTtkW2ddLmxpbmVDb29yZGluYXRlcz17eDE6cCtQLHkxOmgseDI6cCtQLHkyOmssaGVpZ2h0Ok1hdGguYWJzKGstaCl9O1wiaW5zaWRlXCI9PT1kW2ddLmxhYmVsUGxhY2VtZW50JiYwPGcmJihkW2ddLmxpbmVDb29yZGluYXRlcy54MT1kW2ddLmxpbmVDb29yZGluYXRlcy54MStcbih2W2ddLShkW2ddLl90aXRsZVRleHRCbG9jaz9kW2ddLl90aXRsZVRleHRCbG9jay5oZWlnaHQ6MCktMiktZFtnXS50aWNrTGVuZ3RoLShkW2ddLnN0cmlwTGluZUxhYmVsRWZmZWN0aXZlV2lkdGh8fDApLGRbZ10ubGluZUNvb3JkaW5hdGVzLngyPWRbZ10ubGluZUNvb3JkaW5hdGVzLngxK2RbZ10ubGluZVRoaWNrbmVzcy8yKTtcImluc2lkZVwiPT09ZFtnXS50aWNrUGxhY2VtZW50JiYwPGcmJihkW2ddLmxpbmVDb29yZGluYXRlcy54MSs9ZFtnXS50aWNrTGVuZ3RoLGRbZ10ubGluZUNvb3JkaW5hdGVzLngyPWRbZ10ubGluZUNvb3JkaW5hdGVzLngxK2RbZ10ubGluZVRoaWNrbmVzcy8yKTtkW2ddLmJvdW5kcz17eDE6ZFtnXS5saW5lQ29vcmRpbmF0ZXMueDEseTE6aCx4MjpwK3ZbZ10rUCx5MjprLHdpZHRoOnAtbCxoZWlnaHQ6ay1ofTtkW2ddLmJvdW5kcy53aWR0aD1kW2ddLmJvdW5kcy54Mi1kW2ddLmJvdW5kcy54MTtkW2ddLnRpdGxlJiYoZFtnXS5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGg9XG4wPGRbZ10udGl0bGVNYXhXaWR0aCYmZFtnXS50aXRsZU1heFdpZHRoPGRbZ10ubGluZUNvb3JkaW5hdGVzLmhlaWdodD9kW2ddLnRpdGxlTWF4V2lkdGg6ZFtnXS5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0KTtkW2ddLmNhbGN1bGF0ZVZhbHVlVG9QaXhlbENvbnZlcnNpb25QYXJhbWV0ZXJzKCk7ZFtnXS5jYWxjdWxhdGVCcmVha3NTaXplSW5WYWx1ZXMoKTtQKz12W2ddK2RbZ10ubWFyZ2lufWZvcihnPTA7ZzxxLmxlbmd0aDtnKyspXCJheGlzWVwiPT09cVtnXS50eXBlJiYocVtnXS5jYWxjdWxhdGVWYWx1ZVRvUGl4ZWxDb252ZXJzaW9uUGFyYW1ldGVycygpLHFbZ10uY2FsY3VsYXRlQnJlYWtzU2l6ZUluVmFsdWVzKCkpO2lmKDA8dyl7aWYoYSYmMDxhLmxlbmd0aClmb3IoZz0wO2c8YS5sZW5ndGg7ZysrKXM9TVt3LTFdW2ddPT09TVt3XVtnXT8hMDohMTtlbHNlIHM9ITA7aWYoZCYmMDxkLmxlbmd0aClmb3IoZz0wO2c8ZC5sZW5ndGg7ZysrKUc9UVt3LTFdW2ddPT09UVt3XVtnXT8hMDpcbiExO2Vsc2UgRz0hMDtpZihjJiYwPGMubGVuZ3RoKWZvcihnPTA7ZzxjLmxlbmd0aDtnKyspSj1CW3ctMV1bZ109PT1CW3ddW2ddPyEwOiExO2Vsc2UgSj0hMDtpZihiJiYwPGIubGVuZ3RoKWZvcihnPTA7ZzxiLmxlbmd0aDtnKyspSz11W3ctMV1bZ109PT11W3ddW2ddPyEwOiExO2Vsc2UgSz0hMH1pZihzJiZHJiZKJiZLKWJyZWFrO3crK31pZihjJiYwPGMubGVuZ3RoKWZvcihnPTA7ZzxjLmxlbmd0aDtnKyspY1tnXS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXMoKSxjW2ddLmNhbGN1bGF0ZUJyZWFrc0luUGl4ZWxzKCk7aWYoYiYmMDxiLmxlbmd0aClmb3IoZz0wO2c8Yi5sZW5ndGg7ZysrKWJbZ10uY2FsY3VsYXRlU3RyaXBMaW5lc1RoaWNrbmVzc0luVmFsdWVzKCksYltnXS5jYWxjdWxhdGVCcmVha3NJblBpeGVscygpO2lmKGEmJjA8YS5sZW5ndGgpZm9yKGc9MDtnPGEubGVuZ3RoO2crKylhW2ddLmNhbGN1bGF0ZVN0cmlwTGluZXNUaGlja25lc3NJblZhbHVlcygpLFxuYVtnXS5jYWxjdWxhdGVCcmVha3NJblBpeGVscygpO2lmKGQmJjA8ZC5sZW5ndGgpZm9yKGc9MDtnPGQubGVuZ3RoO2crKylkW2ddLmNhbGN1bGF0ZVN0cmlwTGluZXNUaGlja25lc3NJblZhbHVlcygpLGRbZ10uY2FsY3VsYXRlQnJlYWtzSW5QaXhlbHMoKX19O0EucmVuZGVyPWZ1bmN0aW9uKGEsZCxjLGIsZSl7dmFyIGY9YVswXT9hWzBdLmNoYXJ0OmRbMF0uY2hhcnQ7ZT1mLmN0eDtmLmFsaWduVmVydGljYWxBeGVzJiZmLmFsaWduVmVydGljYWxBeGVzKCk7ZS5zYXZlKCk7ZS5iZWdpblBhdGgoKTthJiZhLmxlbmd0aCYmZS5yZWN0KDUsYVswXS5ib3VuZHMueTEsYVswXS5jaGFydC53aWR0aC0xMCxhW2EubGVuZ3RoLTFdLmJvdW5kcy55Mik7ZCYmZC5sZW5ndGgmJmUucmVjdCg1LGRbZC5sZW5ndGgtMV0uYm91bmRzLnkxLGRbMF0uY2hhcnQud2lkdGgtMTAsZFswXS5ib3VuZHMueTIpO2UuY2xpcCgpO2lmKGEmJjA8YS5sZW5ndGgpZm9yKHZhciBsPTA7bDxhLmxlbmd0aDtsKyspYVtsXS5yZW5kZXJMYWJlbHNUaWNrc0FuZFRpdGxlKCk7XG5pZihkJiYwPGQubGVuZ3RoKWZvcihsPTA7bDxkLmxlbmd0aDtsKyspZFtsXS5yZW5kZXJMYWJlbHNUaWNrc0FuZFRpdGxlKCk7ZS5yZXN0b3JlKCk7aWYoYyYmMDxjLmxlbmd0aClmb3IobD0wO2w8Yy5sZW5ndGg7bCsrKWNbbF0ucmVuZGVyTGFiZWxzVGlja3NBbmRUaXRsZSgpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGw9MDtsPGIubGVuZ3RoO2wrKyliW2xdLnJlbmRlckxhYmVsc1RpY2tzQW5kVGl0bGUoKTtmLnByZXBhcmVQbG90QXJlYSgpO2Y9Zi5wbG90QXJlYTtlLnNhdmUoKTtlLmJlZ2luUGF0aCgpO2UucmVjdChmLngxLGYueTEsTWF0aC5hYnMoZi54Mi1mLngxKSxNYXRoLmFicyhmLnkyLWYueTEpKTtlLmNsaXAoKTtpZihhJiYwPGEubGVuZ3RoKWZvcihsPTA7bDxhLmxlbmd0aDtsKyspYVtsXS5yZW5kZXJTdHJpcExpbmVzT2ZUaGlja25lc3NUeXBlKFwidmFsdWVcIik7aWYoZCYmMDxkLmxlbmd0aClmb3IobD0wO2w8ZC5sZW5ndGg7bCsrKWRbbF0ucmVuZGVyU3RyaXBMaW5lc09mVGhpY2tuZXNzVHlwZShcInZhbHVlXCIpO1xuaWYoYyYmMDxjLmxlbmd0aClmb3IobD0wO2w8Yy5sZW5ndGg7bCsrKWNbbF0ucmVuZGVyU3RyaXBMaW5lc09mVGhpY2tuZXNzVHlwZShcInZhbHVlXCIpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGw9MDtsPGIubGVuZ3RoO2wrKyliW2xdLnJlbmRlclN0cmlwTGluZXNPZlRoaWNrbmVzc1R5cGUoXCJ2YWx1ZVwiKTtpZihhJiYwPGEubGVuZ3RoKWZvcihsPTA7bDxhLmxlbmd0aDtsKyspYVtsXS5yZW5kZXJJbnRlcmxhY2VkQ29sb3JzKCk7aWYoZCYmMDxkLmxlbmd0aClmb3IobD0wO2w8ZC5sZW5ndGg7bCsrKWRbbF0ucmVuZGVySW50ZXJsYWNlZENvbG9ycygpO2lmKGMmJjA8Yy5sZW5ndGgpZm9yKGw9MDtsPGMubGVuZ3RoO2wrKyljW2xdLnJlbmRlckludGVybGFjZWRDb2xvcnMoKTtpZihiJiYwPGIubGVuZ3RoKWZvcihsPTA7bDxiLmxlbmd0aDtsKyspYltsXS5yZW5kZXJJbnRlcmxhY2VkQ29sb3JzKCk7ZS5yZXN0b3JlKCk7aWYoYSYmMDxhLmxlbmd0aClmb3IobD0wO2w8YS5sZW5ndGg7bCsrKWFbbF0ucmVuZGVyR3JpZCgpLFxudyYmKGFbbF0uY3JlYXRlTWFzaygpLGFbbF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtpZihkJiYwPGQubGVuZ3RoKWZvcihsPTA7bDxkLmxlbmd0aDtsKyspZFtsXS5yZW5kZXJHcmlkKCksdyYmKGRbbF0uY3JlYXRlTWFzaygpLGRbbF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtpZihjJiYwPGMubGVuZ3RoKWZvcihsPTA7bDxjLmxlbmd0aDtsKyspY1tsXS5yZW5kZXJHcmlkKCksdyYmKGNbbF0uY3JlYXRlTWFzaygpLGNbbF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtpZihiJiYwPGIubGVuZ3RoKWZvcihsPTA7bDxiLmxlbmd0aDtsKyspYltsXS5yZW5kZXJHcmlkKCksdyYmKGJbbF0uY3JlYXRlTWFzaygpLGJbbF0ucmVuZGVyQnJlYWtzQmFja2dyb3VuZCgpKTtpZihhJiYwPGEubGVuZ3RoKWZvcihsPTA7bDxhLmxlbmd0aDtsKyspYVtsXS5yZW5kZXJBeGlzTGluZSgpO2lmKGQmJjA8ZC5sZW5ndGgpZm9yKGw9MDtsPGQubGVuZ3RoO2wrKylkW2xdLnJlbmRlckF4aXNMaW5lKCk7XG5pZihjJiYwPGMubGVuZ3RoKWZvcihsPTA7bDxjLmxlbmd0aDtsKyspY1tsXS5yZW5kZXJBeGlzTGluZSgpO2lmKGImJjA8Yi5sZW5ndGgpZm9yKGw9MDtsPGIubGVuZ3RoO2wrKyliW2xdLnJlbmRlckF4aXNMaW5lKCk7aWYoYSYmMDxhLmxlbmd0aClmb3IobD0wO2w8YS5sZW5ndGg7bCsrKWFbbF0ucmVuZGVyU3RyaXBMaW5lc09mVGhpY2tuZXNzVHlwZShcInBpeGVsXCIpO2lmKGQmJjA8ZC5sZW5ndGgpZm9yKGw9MDtsPGQubGVuZ3RoO2wrKylkW2xdLnJlbmRlclN0cmlwTGluZXNPZlRoaWNrbmVzc1R5cGUoXCJwaXhlbFwiKTtpZihjJiYwPGMubGVuZ3RoKWZvcihsPTA7bDxjLmxlbmd0aDtsKyspY1tsXS5yZW5kZXJTdHJpcExpbmVzT2ZUaGlja25lc3NUeXBlKFwicGl4ZWxcIik7aWYoYiYmMDxiLmxlbmd0aClmb3IobD0wO2w8Yi5sZW5ndGg7bCsrKWJbbF0ucmVuZGVyU3RyaXBMaW5lc09mVGhpY2tuZXNzVHlwZShcInBpeGVsXCIpfTtBLnByb3RvdHlwZS5jYWxjdWxhdGVTdHJpcExpbmVzVGhpY2tuZXNzSW5WYWx1ZXM9XG5mdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8dGhpcy5zdHJpcExpbmVzLmxlbmd0aDthKyspaWYobnVsbCE9PXRoaXMuc3RyaXBMaW5lc1thXS5zdGFydFZhbHVlJiZudWxsIT09dGhpcy5zdHJpcExpbmVzW2FdLmVuZFZhbHVlKXt2YXIgZD1NYXRoLm1pbih0aGlzLnN0cmlwTGluZXNbYV0uc3RhcnRWYWx1ZSx0aGlzLnN0cmlwTGluZXNbYV0uZW5kVmFsdWUpLGM9TWF0aC5tYXgodGhpcy5zdHJpcExpbmVzW2FdLnN0YXJ0VmFsdWUsdGhpcy5zdHJpcExpbmVzW2FdLmVuZFZhbHVlKSxiPXRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGQsYyk7dGhpcy5zdHJpcExpbmVzW2FdLnZhbHVlPXRoaXMuY29udmVydFBpeGVsVG9WYWx1ZShNYXRoLmFicyh0aGlzLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoZCkrdGhpcy5jb252ZXJ0VmFsdWVUb1BpeGVsKGMpKS8yKTt0aGlzLnN0cmlwTGluZXNbYV0udGhpY2tuZXNzPWI7dGhpcy5zdHJpcExpbmVzW2FdLl90aGlja25lc3NUeXBlPVwidmFsdWVcIn19O1xuQS5wcm90b3R5cGUuY2FsY3VsYXRlQnJlYWtzU2l6ZUluVmFsdWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPVwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uP3RoaXMubGluZUNvb3JkaW5hdGVzLmhlaWdodHx8dGhpcy5jaGFydC5oZWlnaHQ6dGhpcy5saW5lQ29vcmRpbmF0ZXMud2lkdGh8fHRoaXMuY2hhcnQud2lkdGgsZD10aGlzLnNjYWxlQnJlYWtzP3RoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3M6W10sYz10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdHx8YS8odGhpcy5sb2dhcml0aG1pYz90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1heGltdW0vdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtOnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWF4aW11bS10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pLGI9dGhpcy5zY2FsZUJyZWFrcyYmIXIodGhpcy5zY2FsZUJyZWFrcy5vcHRpb25zLnNwYWNpbmcpLFxuZSxmPTA7ZjxkLmxlbmd0aDtmKyspZT1ifHwhcihkW2ZdLm9wdGlvbnMuc3BhY2luZyksZFtmXS5zcGFjaW5nPVRhKGRbZl0uc3BhY2luZyxhLDgsZT8wLjEqYTo4LGU/MDozKTw8MCxkW2ZdLnNpemU9MD5kW2ZdLnNwYWNpbmc/MDpNYXRoLmFicyhkW2ZdLnNwYWNpbmcvYyksdGhpcy5sb2dhcml0aG1pYyYmKGRbZl0uc2l6ZT1NYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsZFtmXS5zaXplKSl9O0EucHJvdG90eXBlLmNhbGN1bGF0ZUJyZWFrc0luUGl4ZWxzPWZ1bmN0aW9uKCl7aWYoISh0aGlzLnNjYWxlQnJlYWtzJiYwPj10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCkpe3ZhciBhPXRoaXMuc2NhbGVCcmVha3M/dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrczpbXTthLmxlbmd0aCYmKHRoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4PXRoaXMuc2NhbGVCcmVha3MubGFzdEJyZWFrSW5kZXg9bnVsbCk7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aCYmXG4hKGFbZF0uc3RhcnRWYWx1ZT50aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1heGltdW0pO2QrKylhW2RdLmVuZFZhbHVlPHRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bXx8KHIodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXgpJiYodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXg9ZCksYVtkXS5zdGFydFZhbHVlPj10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0mJihhW2RdLnN0YXJ0UGl4ZWw9dGhpcy5jb252ZXJ0VmFsdWVUb1BpeGVsKGFbZF0uc3RhcnRWYWx1ZSksdGhpcy5zY2FsZUJyZWFrcy5sYXN0QnJlYWtJbmRleD1kKSxhW2RdLmVuZFZhbHVlPD10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1heGltdW0mJihhW2RdLmVuZFBpeGVsPXRoaXMuY29udmVydFZhbHVlVG9QaXhlbChhW2RdLmVuZFZhbHVlKSkpfX07QS5wcm90b3R5cGUucmVuZGVyTGFiZWxzVGlja3NBbmRUaXRsZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMsZD0hMSxcbmM9MCxiPTAsZT0xLGY9MDswIT09dGhpcy5sYWJlbEFuZ2xlJiYzNjAhPT10aGlzLmxhYmVsQW5nbGUmJihlPTEuMik7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpe2lmKFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uKWlmKHRoaXMubG9nYXJpdGhtaWMmJiF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwmJnRoaXMubGFiZWxBdXRvRml0KXtmb3IodmFyIGM9W10sZT0wIT09dGhpcy5sYWJlbEFuZ2xlJiYzNjAhPT10aGlzLmxhYmVsQW5nbGU/MToxLjIsbCxoPXRoaXMudmlld3BvcnRNYXhpbXVtLHA9dGhpcy5saW5lQ29vcmRpbmF0ZXMud2lkdGgvTWF0aC5sb2codGhpcy5yYW5nZSksaz10aGlzLl9sYWJlbHMubGVuZ3RoLTE7MDw9aztrLS0pe249dGhpcy5fbGFiZWxzW2tdO2lmKG4ucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW0pYnJlYWs7bi5wb3NpdGlvbj50aGlzLnZpZXdwb3J0TWF4aW11bXx8IShrPT09XG50aGlzLl9sYWJlbHMubGVuZ3RoLTF8fGw8TWF0aC5sb2coaC9uLnBvc2l0aW9uKSpwL2UpfHwoYy5wdXNoKG4pLGg9bi5wb3NpdGlvbixsPW4udGV4dEJsb2NrLndpZHRoKk1hdGguYWJzKE1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSkpK24udGV4dEJsb2NrLmhlaWdodCpNYXRoLmFicyhNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKSl9dGhpcy5fbGFiZWxzPWN9ZWxzZXtmb3Ioaz0wO2s8dGhpcy5fbGFiZWxzLmxlbmd0aDtrKyspbj10aGlzLl9sYWJlbHNba10sbi5wb3NpdGlvbjx0aGlzLnZpZXdwb3J0TWluaW11bXx8KGw9bi50ZXh0QmxvY2sud2lkdGgqTWF0aC5hYnMoTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSkrbi50ZXh0QmxvY2suaGVpZ2h0Kk1hdGguYWJzKE1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSkpLGMrPWwpO2M+dGhpcy5saW5lQ29vcmRpbmF0ZXMud2lkdGgqZSYmdGhpcy5sYWJlbEF1dG9GaXQmJlxuKGQ9ITApfWlmKFwibGVmdFwiPT09dGhpcy5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uKWlmKHRoaXMubG9nYXJpdGhtaWMmJiF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwmJnRoaXMubGFiZWxBdXRvRml0KXtmb3IodmFyIGM9W10sbSxoPXRoaXMudmlld3BvcnRNYXhpbXVtLHA9dGhpcy5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0L01hdGgubG9nKHRoaXMucmFuZ2UpLGs9dGhpcy5fbGFiZWxzLmxlbmd0aC0xOzA8PWs7ay0tKXtuPXRoaXMuX2xhYmVsc1trXTtpZihuLnBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtKWJyZWFrO24ucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fCEoaz09PXRoaXMuX2xhYmVscy5sZW5ndGgtMXx8bTxNYXRoLmxvZyhoL24ucG9zaXRpb24pKnApfHwoYy5wdXNoKG4pLGg9bi5wb3NpdGlvbixtPW4udGV4dEJsb2NrLmhlaWdodCpNYXRoLmFicyhNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKStuLnRleHRCbG9jay53aWR0aCpcbk1hdGguYWJzKE1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSkpKX10aGlzLl9sYWJlbHM9Y31lbHNle2ZvcihrPTA7azx0aGlzLl9sYWJlbHMubGVuZ3RoO2srKyluPXRoaXMuX2xhYmVsc1trXSxuLnBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtfHwobT1uLnRleHRCbG9jay5oZWlnaHQqTWF0aC5hYnMoTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSkrbi50ZXh0QmxvY2sud2lkdGgqTWF0aC5hYnMoTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSksYis9bSk7Yj50aGlzLmxpbmVDb29yZGluYXRlcy5oZWlnaHQqZSYmdGhpcy5sYWJlbEF1dG9GaXQmJihkPSEwKX19dGhpcy5sb2dhcml0aG1pYyYmKCF0aGlzLmVxdWlkaXN0YW50SW50ZXJ2YWwmJnRoaXMubGFiZWxBdXRvRml0KSYmdGhpcy5fbGFiZWxzLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5wb3NpdGlvbi1iLnBvc2l0aW9ufSk7dmFyIGs9MCxuLHE7aWYoXCJib3R0b21cIj09PVxudGhpcy5fcG9zaXRpb24pe2ZvcihrPTA7azx0aGlzLl9sYWJlbHMubGVuZ3RoO2srKyluPXRoaXMuX2xhYmVsc1trXSxuLnBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtfHxuLnBvc2l0aW9uPnRoaXMudmlld3BvcnRNYXhpbXVtfHwocT10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMobi5wb3NpdGlvbiksdGhpcy50aWNrVGhpY2tuZXNzJiZcImluc2lkZVwiIT10aGlzLnRpY2tQbGFjZW1lbnQmJih0aGlzLmN0eC5saW5lV2lkdGg9dGhpcy50aWNrVGhpY2tuZXNzLHRoaXMuY3R4LnN0cm9rZVN0eWxlPXRoaXMudGlja0NvbG9yLGI9MT09PXRoaXMuY3R4LmxpbmVXaWR0aCUyPyhxLng8PDApKzAuNTpxLng8PDAsdGhpcy5jdHguYmVnaW5QYXRoKCksdGhpcy5jdHgubW92ZVRvKGIscS55PDwwKSx0aGlzLmN0eC5saW5lVG8oYixxLnkrdGhpcy50aWNrTGVuZ3RoPDwwKSx0aGlzLmN0eC5zdHJva2UoKSksZCYmMCE9PWYrKyUyJiZ0aGlzLmxhYmVsQXV0b0ZpdHx8KDA9PT1uLnRleHRCbG9jay5hbmdsZT9cbihxLngtPW4udGV4dEJsb2NrLndpZHRoLzIscS55PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50P3EueS0oKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/dGhpcy50aWNrTGVuZ3RoOjApK24udGV4dEJsb2NrLmhlaWdodC1uLnRleHRCbG9jay5mb250U2l6ZS8yKTpxLnkrKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/MDp0aGlzLnRpY2tMZW5ndGgpK24udGV4dEJsb2NrLmZvbnRTaXplLzIrNSk6KHEueD1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD8wPnRoaXMubGFiZWxBbmdsZT9xLng6cS54LW4udGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6cS54LSgwPnRoaXMubGFiZWxBbmdsZT9uLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpOjApLHEueT1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD8wPnRoaXMubGFiZWxBbmdsZT9xLnktKFwiaW5zaWRlXCI9PT1cbnRoaXMudGlja1BsYWNlbWVudD90aGlzLnRpY2tMZW5ndGg6MCktNTpxLnktKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/dGhpcy50aWNrTGVuZ3RoOjApLU1hdGguYWJzKG4udGV4dEJsb2NrLndpZHRoKk1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSkrNSk6cS55KyhcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50PzA6dGhpcy50aWNrTGVuZ3RoKStNYXRoLmFicygwPnRoaXMubGFiZWxBbmdsZT9uLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLTU6NSkpLG4udGV4dEJsb2NrLng9cS54LG4udGV4dEJsb2NrLnk9cS55KSk7XCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudCYmdGhpcy5jaGFydC5hZGRFdmVudExpc3RlbmVyKFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zm9yKGs9MDtrPGEuX2xhYmVscy5sZW5ndGg7aysrKWlmKG49YS5fbGFiZWxzW2tdLCEobi5wb3NpdGlvbjxcbmEudmlld3BvcnRNaW5pbXVtfHxuLnBvc2l0aW9uPmEudmlld3BvcnRNYXhpbXVtKSYmKHE9YS5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKG4ucG9zaXRpb24pLGEudGlja1RoaWNrbmVzcykpe2EuY3R4LmxpbmVXaWR0aD1hLnRpY2tUaGlja25lc3M7YS5jdHguc3Ryb2tlU3R5bGU9YS50aWNrQ29sb3I7dmFyIGI9MT09PWEuY3R4LmxpbmVXaWR0aCUyPyhxLng8PDApKzAuNTpxLng8PDA7YS5jdHguc2F2ZSgpO2EuY3R4LmJlZ2luUGF0aCgpO2EuY3R4Lm1vdmVUbyhiLHEueTw8MCk7YS5jdHgubGluZVRvKGIscS55LWEudGlja0xlbmd0aDw8MCk7YS5jdHguc3Ryb2tlKCk7YS5jdHgucmVzdG9yZSgpfX0sdGhpcyk7dGhpcy50aXRsZSYmKHRoaXMuX3RpdGxlVGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksdGhpcy5fdGl0bGVUZXh0QmxvY2sueD10aGlzLmxpbmVDb29yZGluYXRlcy54MSt0aGlzLmxpbmVDb29yZGluYXRlcy53aWR0aC8yLXRoaXMuX3RpdGxlVGV4dEJsb2NrLndpZHRoL1xuMix0aGlzLl90aXRsZVRleHRCbG9jay55PXRoaXMuYm91bmRzLnkyLXRoaXMuX3RpdGxlVGV4dEJsb2NrLmhlaWdodC0zLHRoaXMudGl0bGVNYXhXaWR0aD10aGlzLl90aXRsZVRleHRCbG9jay5tYXhXaWR0aCx0aGlzLl90aXRsZVRleHRCbG9jay5yZW5kZXIoITApKX1lbHNlIGlmKFwidG9wXCI9PT10aGlzLl9wb3NpdGlvbil7Zm9yKGs9MDtrPHRoaXMuX2xhYmVscy5sZW5ndGg7aysrKW49dGhpcy5fbGFiZWxzW2tdLG4ucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW18fG4ucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fChxPXRoaXMuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyhuLnBvc2l0aW9uKSx0aGlzLnRpY2tUaGlja25lc3MmJlwiaW5zaWRlXCIhPXRoaXMudGlja1BsYWNlbWVudCYmKHRoaXMuY3R4LmxpbmVXaWR0aD10aGlzLnRpY2tUaGlja25lc3MsdGhpcy5jdHguc3Ryb2tlU3R5bGU9dGhpcy50aWNrQ29sb3IsYj0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KHEueDw8XG4wKSswLjU6cS54PDwwLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4Lm1vdmVUbyhiLHEueTw8MCksdGhpcy5jdHgubGluZVRvKGIscS55LXRoaXMudGlja0xlbmd0aDw8MCksdGhpcy5jdHguc3Ryb2tlKCkpLGQmJjAhPT1mKyslMiYmdGhpcy5sYWJlbEF1dG9GaXR8fCgwPT09bi50ZXh0QmxvY2suYW5nbGU/KHEueC09bi50ZXh0QmxvY2sud2lkdGgvMixxLnk9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/cS55K3RoaXMubGFiZWxGb250U2l6ZS8yKyhcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50P3RoaXMudGlja0xlbmd0aDowKSs1OnEueS0oKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/MDp0aGlzLnRpY2tMZW5ndGgpK24udGV4dEJsb2NrLmhlaWdodC1uLnRleHRCbG9jay5mb250U2l6ZS8yKSk6KHEueD1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD8wPHRoaXMubGFiZWxBbmdsZT9xLng6cS54LW4udGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvXG4xODAqdGhpcy5sYWJlbEFuZ2xlKTpxLngrKG4udGV4dEJsb2NrLmhlaWdodC10aGlzLmxhYmVsRm9udFNpemUpKk1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSktKDA8dGhpcy5sYWJlbEFuZ2xlP24udGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6MCkscS55PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50PzA8dGhpcy5sYWJlbEFuZ2xlP3EueSsoXCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudD90aGlzLnRpY2tMZW5ndGg6MCkrNTpxLnktbi50ZXh0QmxvY2sud2lkdGgqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSsoXCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudD90aGlzLnRpY2tMZW5ndGg6MCkrNTpxLnktKChcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50PzA6dGhpcy50aWNrTGVuZ3RoKSsoKG4udGV4dEJsb2NrLmhlaWdodC1uLnRleHRCbG9jay5mb250U2l6ZS8yKSpcbk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSkrKDA8dGhpcy5sYWJlbEFuZ2xlP24udGV4dEJsb2NrLndpZHRoKk1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6MCkpKSksbi50ZXh0QmxvY2sueD1xLngsbi50ZXh0QmxvY2sueT1xLnkpKTtcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50JiZ0aGlzLmNoYXJ0LmFkZEV2ZW50TGlzdGVuZXIoXCJkYXRhQW5pbWF0aW9uSXRlcmF0aW9uRW5kXCIsZnVuY3Rpb24oKXtmb3Ioaz0wO2s8YS5fbGFiZWxzLmxlbmd0aDtrKyspaWYobj1hLl9sYWJlbHNba10sIShuLnBvc2l0aW9uPGEudmlld3BvcnRNaW5pbXVtfHxuLnBvc2l0aW9uPmEudmlld3BvcnRNYXhpbXVtKSYmKHE9YS5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKG4ucG9zaXRpb24pLGEudGlja1RoaWNrbmVzcykpe2EuY3R4LmxpbmVXaWR0aD1hLnRpY2tUaGlja25lc3M7YS5jdHguc3Ryb2tlU3R5bGU9YS50aWNrQ29sb3I7dmFyIGI9MT09PWEuY3R4LmxpbmVXaWR0aCVcbjI/KHEueDw8MCkrMC41OnEueDw8MDthLmN0eC5zYXZlKCk7YS5jdHguYmVnaW5QYXRoKCk7YS5jdHgubW92ZVRvKGIscS55PDwwKTthLmN0eC5saW5lVG8oYixxLnkrYS50aWNrTGVuZ3RoPDwwKTthLmN0eC5zdHJva2UoKTthLmN0eC5yZXN0b3JlKCl9fSx0aGlzKTt0aGlzLnRpdGxlJiYodGhpcy5fdGl0bGVUZXh0QmxvY2subWVhc3VyZVRleHQoKSx0aGlzLl90aXRsZVRleHRCbG9jay54PXRoaXMubGluZUNvb3JkaW5hdGVzLngxK3RoaXMubGluZUNvb3JkaW5hdGVzLndpZHRoLzItdGhpcy5fdGl0bGVUZXh0QmxvY2sud2lkdGgvMix0aGlzLl90aXRsZVRleHRCbG9jay55PXRoaXMuYm91bmRzLnkxKzEsdGhpcy50aXRsZU1heFdpZHRoPXRoaXMuX3RpdGxlVGV4dEJsb2NrLm1heFdpZHRoLHRoaXMuX3RpdGxlVGV4dEJsb2NrLnJlbmRlcighMCkpfWVsc2UgaWYoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbil7Zm9yKGs9MDtrPHRoaXMuX2xhYmVscy5sZW5ndGg7aysrKW49dGhpcy5fbGFiZWxzW2tdLFxubi5wb3NpdGlvbjx0aGlzLnZpZXdwb3J0TWluaW11bXx8bi5wb3NpdGlvbj50aGlzLnZpZXdwb3J0TWF4aW11bXx8KHE9dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKG4ucG9zaXRpb24pLHRoaXMudGlja1RoaWNrbmVzcyYmXCJpbnNpZGVcIiE9dGhpcy50aWNrUGxhY2VtZW50JiYodGhpcy5jdHgubGluZVdpZHRoPXRoaXMudGlja1RoaWNrbmVzcyx0aGlzLmN0eC5zdHJva2VTdHlsZT10aGlzLnRpY2tDb2xvcixiPTE9PT10aGlzLmN0eC5saW5lV2lkdGglMj8ocS55PDwwKSswLjU6cS55PDwwLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4Lm1vdmVUbyhxLng8PDAsYiksdGhpcy5jdHgubGluZVRvKHEueC10aGlzLnRpY2tMZW5ndGg8PDAsYiksdGhpcy5jdHguc3Ryb2tlKCkpLGQmJjAhPT1mKyslMiYmdGhpcy5sYWJlbEF1dG9GaXR8fCgwPT09dGhpcy5sYWJlbEFuZ2xlPyhuLnRleHRCbG9jay55PXEueSxuLnRleHRCbG9jay54PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50P1xucS54KyhcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50P3RoaXMudGlja0xlbmd0aDowKSs1OnEueC1uLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLShcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50PzA6dGhpcy50aWNrTGVuZ3RoKS01KToobi50ZXh0QmxvY2sueT1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD9xLnk6cS55LW4udGV4dEJsb2NrLndpZHRoKk1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSksbi50ZXh0QmxvY2sueD1cImluc2lkZVwiPT09dGhpcy5sYWJlbFBsYWNlbWVudD9xLngrKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/dGhpcy50aWNrTGVuZ3RoOjApKzU6MDx0aGlzLmxhYmVsQW5nbGU/cS54LW4udGV4dEJsb2NrLndpZHRoKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSktKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/MDp0aGlzLnRpY2tMZW5ndGgpLVxuNTpxLngtbi50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSsobi50ZXh0QmxvY2suaGVpZ2h0LW4udGV4dEJsb2NrLmZvbnRTaXplLzItNSkqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKS0oXCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudD8wOnRoaXMudGlja0xlbmd0aCkpKSk7XCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudCYmdGhpcy5jaGFydC5hZGRFdmVudExpc3RlbmVyKFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zm9yKGs9MDtrPGEuX2xhYmVscy5sZW5ndGg7aysrKWlmKG49YS5fbGFiZWxzW2tdLCEobi5wb3NpdGlvbjxhLnZpZXdwb3J0TWluaW11bXx8bi5wb3NpdGlvbj5hLnZpZXdwb3J0TWF4aW11bSkmJihxPWEuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyhuLnBvc2l0aW9uKSxhLnRpY2tUaGlja25lc3MpKXthLmN0eC5saW5lV2lkdGg9YS50aWNrVGhpY2tuZXNzO1xuYS5jdHguc3Ryb2tlU3R5bGU9YS50aWNrQ29sb3I7dmFyIGI9MT09PWEuY3R4LmxpbmVXaWR0aCUyPyhxLnk8PDApKzAuNTpxLnk8PDA7YS5jdHguc2F2ZSgpO2EuY3R4LmJlZ2luUGF0aCgpO2EuY3R4Lm1vdmVUbyhxLng8PDAsYik7YS5jdHgubGluZVRvKHEueCthLnRpY2tMZW5ndGg8PDAsYik7YS5jdHguc3Ryb2tlKCk7YS5jdHgucmVzdG9yZSgpfX0sdGhpcyk7dGhpcy50aXRsZSYmKHRoaXMuX3RpdGxlVGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksdGhpcy5fdGl0bGVUZXh0QmxvY2sueD10aGlzLmJvdW5kcy54MSsxLHRoaXMuX3RpdGxlVGV4dEJsb2NrLnk9dGhpcy5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0LzIrdGhpcy5fdGl0bGVUZXh0QmxvY2sud2lkdGgvMit0aGlzLmxpbmVDb29yZGluYXRlcy55MSx0aGlzLnRpdGxlTWF4V2lkdGg9dGhpcy5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGgsdGhpcy5fdGl0bGVUZXh0QmxvY2sucmVuZGVyKCEwKSl9ZWxzZSBpZihcInJpZ2h0XCI9PT1cbnRoaXMuX3Bvc2l0aW9uKXtmb3Ioaz0wO2s8dGhpcy5fbGFiZWxzLmxlbmd0aDtrKyspbj10aGlzLl9sYWJlbHNba10sbi5wb3NpdGlvbjx0aGlzLnZpZXdwb3J0TWluaW11bXx8bi5wb3NpdGlvbj50aGlzLnZpZXdwb3J0TWF4aW11bXx8KHE9dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKG4ucG9zaXRpb24pLHRoaXMudGlja1RoaWNrbmVzcyYmXCJpbnNpZGVcIiE9dGhpcy50aWNrUGxhY2VtZW50JiYodGhpcy5jdHgubGluZVdpZHRoPXRoaXMudGlja1RoaWNrbmVzcyx0aGlzLmN0eC5zdHJva2VTdHlsZT10aGlzLnRpY2tDb2xvcixiPTE9PT10aGlzLmN0eC5saW5lV2lkdGglMj8ocS55PDwwKSswLjU6cS55PDwwLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4Lm1vdmVUbyhxLng8PDAsYiksdGhpcy5jdHgubGluZVRvKHEueCt0aGlzLnRpY2tMZW5ndGg8PDAsYiksdGhpcy5jdHguc3Ryb2tlKCkpLGQmJjAhPT1mKyslMiYmdGhpcy5sYWJlbEF1dG9GaXR8fCgwPT09dGhpcy5sYWJlbEFuZ2xlP1xuKG4udGV4dEJsb2NrLnk9cS55LG4udGV4dEJsb2NrLng9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/cS54LW4udGV4dEJsb2NrLndpZHRoLShcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50P3RoaXMudGlja0xlbmd0aDowKS01OnEueCsoXCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudD8wOnRoaXMudGlja0xlbmd0aCkrNSk6KG4udGV4dEJsb2NrLnk9XCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQ/cS55LW4udGV4dEJsb2NrLndpZHRoKk1hdGguc2luKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSk6MD50aGlzLmxhYmVsQW5nbGU/cS55OnEueS0obi50ZXh0QmxvY2suaGVpZ2h0LW4udGV4dEJsb2NrLmZvbnRTaXplLzItNSkqTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSxuLnRleHRCbG9jay54PVwiaW5zaWRlXCI9PT10aGlzLmxhYmVsUGxhY2VtZW50P3EueC1uLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLVxuKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/dGhpcy50aWNrTGVuZ3RoOjApLTU6MDx0aGlzLmxhYmVsQW5nbGU/cS54KyhuLnRleHRCbG9jay5oZWlnaHQtbi50ZXh0QmxvY2suZm9udFNpemUvMi01KSpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpKyhcImluc2lkZVwiPT09dGhpcy50aWNrUGxhY2VtZW50PzA6dGhpcy50aWNrTGVuZ3RoKTpxLngrKFwiaW5zaWRlXCI9PT10aGlzLnRpY2tQbGFjZW1lbnQ/MDp0aGlzLnRpY2tMZW5ndGgpKzUpKSk7XCJpbnNpZGVcIj09PXRoaXMudGlja1BsYWNlbWVudCYmdGhpcy5jaGFydC5hZGRFdmVudExpc3RlbmVyKFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zm9yKGs9MDtrPGEuX2xhYmVscy5sZW5ndGg7aysrKWlmKG49YS5fbGFiZWxzW2tdLCEobi5wb3NpdGlvbjxhLnZpZXdwb3J0TWluaW11bXx8bi5wb3NpdGlvbj5hLnZpZXdwb3J0TWF4aW11bSkmJihxPWEuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyhuLnBvc2l0aW9uKSxcbmEudGlja1RoaWNrbmVzcykpe2EuY3R4LmxpbmVXaWR0aD1hLnRpY2tUaGlja25lc3M7YS5jdHguc3Ryb2tlU3R5bGU9YS50aWNrQ29sb3I7dmFyIGI9MT09PWEuY3R4LmxpbmVXaWR0aCUyPyhxLnk8PDApKzAuNTpxLnk8PDA7YS5jdHguc2F2ZSgpO2EuY3R4LmJlZ2luUGF0aCgpO2EuY3R4Lm1vdmVUbyhxLng8PDAsYik7YS5jdHgubGluZVRvKHEueC1hLnRpY2tMZW5ndGg8PDAsYik7YS5jdHguc3Ryb2tlKCk7YS5jdHgucmVzdG9yZSgpfX0sdGhpcyk7dGhpcy50aXRsZSYmKHRoaXMuX3RpdGxlVGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksdGhpcy5fdGl0bGVUZXh0QmxvY2sueD10aGlzLmJvdW5kcy54Mi0xLHRoaXMuX3RpdGxlVGV4dEJsb2NrLnk9dGhpcy5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0LzItdGhpcy5fdGl0bGVUZXh0QmxvY2sud2lkdGgvMit0aGlzLmxpbmVDb29yZGluYXRlcy55MSx0aGlzLnRpdGxlTWF4V2lkdGg9dGhpcy5fdGl0bGVUZXh0QmxvY2subWF4V2lkdGgsdGhpcy5fdGl0bGVUZXh0QmxvY2sucmVuZGVyKCEwKSl9Zj1cbjA7aWYoXCJpbnNpZGVcIj09PXRoaXMubGFiZWxQbGFjZW1lbnQpdGhpcy5jaGFydC5hZGRFdmVudExpc3RlbmVyKFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLGZ1bmN0aW9uKCl7Zm9yKGs9MDtrPGEuX2xhYmVscy5sZW5ndGg7aysrKW49YS5fbGFiZWxzW2tdLG4ucG9zaXRpb248YS52aWV3cG9ydE1pbmltdW18fChuLnBvc2l0aW9uPmEudmlld3BvcnRNYXhpbXVtfHxkJiYwIT09ZisrJTImJmEubGFiZWxBdXRvRml0KXx8KGEuY3R4LnNhdmUoKSxhLmN0eC5iZWdpblBhdGgoKSxuLnRleHRCbG9jay5yZW5kZXIoITApLGEuY3R4LnJlc3RvcmUoKSl9LHRoaXMpO2Vsc2UgZm9yKGs9MDtrPHRoaXMuX2xhYmVscy5sZW5ndGg7aysrKW49dGhpcy5fbGFiZWxzW2tdLG4ucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW18fChuLnBvc2l0aW9uPnRoaXMudmlld3BvcnRNYXhpbXVtfHxkJiYwIT09ZisrJTImJnRoaXMubGFiZWxBdXRvRml0KXx8bi50ZXh0QmxvY2sucmVuZGVyKCEwKX07XG5BLnByb3RvdHlwZS5yZW5kZXJJbnRlcmxhY2VkQ29sb3JzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydC5wbG90QXJlYS5jdHgsZCxjLGI9dGhpcy5jaGFydC5wbG90QXJlYSxlPTA7ZD0hMDtpZigoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24pJiZ0aGlzLmludGVybGFjZWRDb2xvcilmb3IoYS5maWxsU3R5bGU9dGhpcy5pbnRlcmxhY2VkQ29sb3IsZT0wO2U8dGhpcy5fbGFiZWxzLmxlbmd0aDtlKyspZD8oZD10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5fbGFiZWxzW2VdLnBvc2l0aW9uKSxjPWUrMT50aGlzLl9sYWJlbHMubGVuZ3RoLTE/dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKHRoaXMudmlld3BvcnRNYXhpbXVtKTp0aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5fbGFiZWxzW2UrMV0ucG9zaXRpb24pLGEuZmlsbFJlY3QoTWF0aC5taW4oYy54LGQueCksYi55MSxNYXRoLmFicyhjLngtXG5kLngpLE1hdGguYWJzKGIueTEtYi55MikpLGQ9ITEpOmQ9ITA7ZWxzZSBpZigoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pJiZ0aGlzLmludGVybGFjZWRDb2xvcilmb3IoYS5maWxsU3R5bGU9dGhpcy5pbnRlcmxhY2VkQ29sb3IsZT0wO2U8dGhpcy5fbGFiZWxzLmxlbmd0aDtlKyspZD8oYz10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5fbGFiZWxzW2VdLnBvc2l0aW9uKSxkPWUrMT50aGlzLl9sYWJlbHMubGVuZ3RoLTE/dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKHRoaXMudmlld3BvcnRNYXhpbXVtKTp0aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5fbGFiZWxzW2UrMV0ucG9zaXRpb24pLGEuZmlsbFJlY3QoYi54MSxNYXRoLm1pbihjLnksZC55KSxNYXRoLmFicyhiLngxLWIueDIpLE1hdGguYWJzKGQueS1jLnkpKSxkPSExKTpkPSEwO2EuYmVnaW5QYXRoKCl9O0EucHJvdG90eXBlLnJlbmRlclN0cmlwTGluZXNPZlRoaWNrbmVzc1R5cGU9XG5mdW5jdGlvbihhKXtpZih0aGlzLnN0cmlwTGluZXMmJjA8dGhpcy5zdHJpcExpbmVzLmxlbmd0aCYmYSl7dmFyIGQ9dGhpcyxjLGIsZT0wLGY9MCxsPSExO2I9ITE7Zm9yKHZhciBoPVtdLHA9W10saz0hMSxlPTA7ZTx0aGlzLnN0cmlwTGluZXMubGVuZ3RoO2UrKyl7dmFyIG09dGhpcy5zdHJpcExpbmVzW2VdO20uX3RoaWNrbmVzc1R5cGU9PT1hJiYoXCJwaXhlbFwiPT09YSYmKG0udmFsdWU8dGhpcy52aWV3cG9ydE1pbmltdW18fG0udmFsdWU+dGhpcy52aWV3cG9ydE1heGltdW18fHIobS52YWx1ZSl8fGlzTmFOKHRoaXMucmFuZ2UpKXx8XCJ2YWx1ZVwiPT09YSYmKG0uc3RhcnRWYWx1ZTw9dGhpcy52aWV3cG9ydE1pbmltdW0mJm0uZW5kVmFsdWU8PXRoaXMudmlld3BvcnRNaW5pbXVtfHxtLnN0YXJ0VmFsdWU+PXRoaXMudmlld3BvcnRNYXhpbXVtJiZtLmVuZFZhbHVlPj10aGlzLnZpZXdwb3J0TWF4aW11bXx8cihtLnN0YXJ0VmFsdWUpfHxyKG0uZW5kVmFsdWUpfHxpc05hTih0aGlzLnJhbmdlKSl8fFxuaC5wdXNoKG0pKX1mb3IoZT0wO2U8dGhpcy5fc3RyaXBMaW5lTGFiZWxzLmxlbmd0aDtlKyspaWYobT10aGlzLnN0cmlwTGluZXNbZV0sYz10aGlzLl9zdHJpcExpbmVMYWJlbHNbZV0sIShjLnBvc2l0aW9uPHRoaXMudmlld3BvcnRNaW5pbXVtfHxjLnBvc2l0aW9uPnRoaXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnJhbmdlKSkpaWYoYj10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXMoYy5wb3NpdGlvbiksXCJvdXRzaWRlXCI9PT1jLnN0cmlwTGluZS5sYWJlbFBsYWNlbWVudCl7bSYmKHRoaXMuY3R4LnN0cm9rZVN0eWxlPW0uY29sb3IsdGhpcy5jdHgubGluZVdpZHRoPVwicGl4ZWxcIj09PW0uX3RoaWNrbmVzc1R5cGU/bS50aGlja25lc3M6dGhpcy50aWNrVGhpY2tuZXNzKTtpZihcImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb24pe3ZhciBuPTE9PT10aGlzLmN0eC5saW5lV2lkdGglMj8oYi54PDwwKSswLjU6Yi54PDwwO3RoaXMuY3R4LmJlZ2luUGF0aCgpO3RoaXMuY3R4Lm1vdmVUbyhuLFxuYi55PDwwKTt0aGlzLmN0eC5saW5lVG8obixiLnkrdGhpcy50aWNrTGVuZ3RoPDwwKTt0aGlzLmN0eC5zdHJva2UoKTswPT09dGhpcy5sYWJlbEFuZ2xlPyhiLngtPWMudGV4dEJsb2NrLndpZHRoLzIsYi55Kz10aGlzLnRpY2tMZW5ndGgrYy50ZXh0QmxvY2suZm9udFNpemUvMis1KTooYi54LT0wPnRoaXMubGFiZWxBbmdsZT9jLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpOjAsYi55Kz10aGlzLnRpY2tMZW5ndGgrTWF0aC5hYnMoMD50aGlzLmxhYmVsQW5nbGU/Yy50ZXh0QmxvY2sud2lkdGgqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKS01OjUpKX1lbHNlXCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPyhuPTE9PT10aGlzLmN0eC5saW5lV2lkdGglMj8oYi54PDwwKSswLjU6Yi54PDwwLHRoaXMuY3R4LmJlZ2luUGF0aCgpLHRoaXMuY3R4Lm1vdmVUbyhuLGIueTw8MCksdGhpcy5jdHgubGluZVRvKG4sYi55LXRoaXMudGlja0xlbmd0aDw8XG4wKSx0aGlzLmN0eC5zdHJva2UoKSwwPT09dGhpcy5sYWJlbEFuZ2xlPyhiLngtPWMudGV4dEJsb2NrLndpZHRoLzIsYi55LT10aGlzLnRpY2tMZW5ndGgrYy50ZXh0QmxvY2suaGVpZ2h0LWMudGV4dEJsb2NrLmZvbnRTaXplLzIpOihiLngrPShjLnRleHRCbG9jay5oZWlnaHQtdGhpcy50aWNrTGVuZ3RoLXRoaXMubGFiZWxGb250U2l6ZS8yKSpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLSgwPHRoaXMubGFiZWxBbmdsZT9jLnRleHRCbG9jay53aWR0aCpNYXRoLmNvcyhNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpOjApLGIueS09dGhpcy50aWNrTGVuZ3RoKyhjLnRleHRCbG9jay5oZWlnaHQqTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSsoMDx0aGlzLmxhYmVsQW5nbGU/Yy50ZXh0QmxvY2sud2lkdGgqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKTowKSkpKTpcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9uPyhuPTE9PT1cbnRoaXMuY3R4LmxpbmVXaWR0aCUyPyhiLnk8PDApKzAuNTpiLnk8PDAsdGhpcy5jdHguYmVnaW5QYXRoKCksdGhpcy5jdHgubW92ZVRvKGIueDw8MCxuKSx0aGlzLmN0eC5saW5lVG8oYi54LXRoaXMudGlja0xlbmd0aDw8MCxuKSx0aGlzLmN0eC5zdHJva2UoKSwwPT09dGhpcy5sYWJlbEFuZ2xlP2IueD1iLngtYy50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKS10aGlzLnRpY2tMZW5ndGgtNTooYi55LT1jLnRleHRCbG9jay53aWR0aCpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLGIueD0wPHRoaXMubGFiZWxBbmdsZT9iLngtYy50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKS10aGlzLnRpY2tMZW5ndGgtNTpiLngtYy50ZXh0QmxvY2sud2lkdGgqTWF0aC5jb3MoTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKSsoYy50ZXh0QmxvY2suaGVpZ2h0LWMudGV4dEJsb2NrLmZvbnRTaXplL1xuMi01KSpNYXRoLnNpbihNYXRoLlBJLzE4MCp0aGlzLmxhYmVsQW5nbGUpLXRoaXMudGlja0xlbmd0aCkpOlwicmlnaHRcIj09PXRoaXMuX3Bvc2l0aW9uJiYobj0xPT09dGhpcy5jdHgubGluZVdpZHRoJTI/KGIueTw8MCkrMC41OmIueTw8MCx0aGlzLmN0eC5iZWdpblBhdGgoKSx0aGlzLmN0eC5tb3ZlVG8oYi54PDwwLG4pLHRoaXMuY3R4LmxpbmVUbyhiLngrdGhpcy50aWNrTGVuZ3RoPDwwLG4pLHRoaXMuY3R4LnN0cm9rZSgpLDA9PT10aGlzLmxhYmVsQW5nbGU/Yi54PWIueCt0aGlzLnRpY2tMZW5ndGgrNTooYi55PTA+dGhpcy5sYWJlbEFuZ2xlP2IueTpiLnktKGMudGV4dEJsb2NrLmhlaWdodC1jLnRleHRCbG9jay5mb250U2l6ZS8yLTUpKk1hdGguY29zKE1hdGguUEkvMTgwKnRoaXMubGFiZWxBbmdsZSksYi54PTA8dGhpcy5sYWJlbEFuZ2xlP2IueCsoYy50ZXh0QmxvY2suaGVpZ2h0LWMudGV4dEJsb2NrLmZvbnRTaXplLzItNSkqTWF0aC5zaW4oTWF0aC5QSS8xODAqdGhpcy5sYWJlbEFuZ2xlKStcbnRoaXMudGlja0xlbmd0aDpiLngrdGhpcy50aWNrTGVuZ3RoKzUpKTtjLnRleHRCbG9jay54PWIueDtjLnRleHRCbG9jay55PWIueTtwLnB1c2goYyl9ZWxzZSBtLl90aGlja25lc3NUeXBlPT09YSYmKGMudGV4dEJsb2NrLmFuZ2xlPS05MCxcImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb24/KGMudGV4dEJsb2NrLm1heFdpZHRoPXRoaXMub3B0aW9ucy5zdHJpcExpbmVzW2VdLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLnN0cmlwTGluZXNbZV0ubGFiZWxNYXhXaWR0aDp0aGlzLmNoYXJ0LnBsb3RBcmVhLmhlaWdodC0zLGMudGV4dEJsb2NrLm1lYXN1cmVUZXh0KCksYi54LWMudGV4dEJsb2NrLmhlaWdodC1tLnRoaWNrbmVzcy8yPnRoaXMuY2hhcnQucGxvdEFyZWEueDE/cihtLnN0YXJ0VmFsdWUpP2IueC09Yy50ZXh0QmxvY2suaGVpZ2h0LWMudGV4dEJsb2NrLmZvbnRTaXplLzIrbS50aGlja25lc3MvMjpiLngtPWMudGV4dEJsb2NrLmhlaWdodC8yLWMudGV4dEJsb2NrLmZvbnRTaXplL1xuMjooYy50ZXh0QmxvY2suYW5nbGU9OTAscihtLnN0YXJ0VmFsdWUpP2IueCs9Yy50ZXh0QmxvY2suaGVpZ2h0LWMudGV4dEJsb2NrLmZvbnRTaXplLzIrbS50aGlja25lc3MvMjpiLngrPWMudGV4dEJsb2NrLmhlaWdodC8yLWMudGV4dEJsb2NrLmZvbnRTaXplLzIpLGIueT0tOTA9PT1jLnRleHRCbG9jay5hbmdsZT9cIm5lYXJcIj09PWMuc3RyaXBMaW5lLmxhYmVsQWxpZ24/dGhpcy5jaGFydC5wbG90QXJlYS55Mi0zOlwiY2VudGVyXCI9PT1jLnN0cmlwTGluZS5sYWJlbEFsaWduPyh0aGlzLmNoYXJ0LnBsb3RBcmVhLnkyK3RoaXMuY2hhcnQucGxvdEFyZWEueTErYy50ZXh0QmxvY2sud2lkdGgpLzI6dGhpcy5jaGFydC5wbG90QXJlYS55MStjLnRleHRCbG9jay53aWR0aCszOlwibmVhclwiPT09Yy5zdHJpcExpbmUubGFiZWxBbGlnbj90aGlzLmNoYXJ0LnBsb3RBcmVhLnkyLWMudGV4dEJsb2NrLndpZHRoLTM6XCJjZW50ZXJcIj09PWMuc3RyaXBMaW5lLmxhYmVsQWxpZ24/KHRoaXMuY2hhcnQucGxvdEFyZWEueTIrXG50aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLWMudGV4dEJsb2NrLndpZHRoKS8yOnRoaXMuY2hhcnQucGxvdEFyZWEueTErMyk6XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPyhjLnRleHRCbG9jay5tYXhXaWR0aD10aGlzLm9wdGlvbnMuc3RyaXBMaW5lc1tlXS5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5zdHJpcExpbmVzW2VdLmxhYmVsTWF4V2lkdGg6dGhpcy5jaGFydC5wbG90QXJlYS5oZWlnaHQtMyxjLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLGIueC1jLnRleHRCbG9jay5oZWlnaHQtbS50aGlja25lc3MvMj50aGlzLmNoYXJ0LnBsb3RBcmVhLngxP3IobS5zdGFydFZhbHVlKT9iLngtPWMudGV4dEJsb2NrLmhlaWdodC1jLnRleHRCbG9jay5mb250U2l6ZS8yK20udGhpY2tuZXNzLzI6Yi54LT1jLnRleHRCbG9jay5oZWlnaHQvMi1jLnRleHRCbG9jay5mb250U2l6ZS8yOihjLnRleHRCbG9jay5hbmdsZT05MCxyKG0uc3RhcnRWYWx1ZSk/Yi54Kz1jLnRleHRCbG9jay5oZWlnaHQtYy50ZXh0QmxvY2suZm9udFNpemUvXG4yK20udGhpY2tuZXNzLzI6Yi54Kz1jLnRleHRCbG9jay5oZWlnaHQvMi1jLnRleHRCbG9jay5mb250U2l6ZS8yKSxiLnk9LTkwPT09Yy50ZXh0QmxvY2suYW5nbGU/XCJuZWFyXCI9PT1jLnN0cmlwTGluZS5sYWJlbEFsaWduP3RoaXMuY2hhcnQucGxvdEFyZWEueTErYy50ZXh0QmxvY2sud2lkdGgrMzpcImNlbnRlclwiPT09Yy5zdHJpcExpbmUubGFiZWxBbGlnbj8odGhpcy5jaGFydC5wbG90QXJlYS55Mit0aGlzLmNoYXJ0LnBsb3RBcmVhLnkxK2MudGV4dEJsb2NrLndpZHRoKS8yOnRoaXMuY2hhcnQucGxvdEFyZWEueTItMzpcIm5lYXJcIj09PWMuc3RyaXBMaW5lLmxhYmVsQWxpZ24/dGhpcy5jaGFydC5wbG90QXJlYS55MSszOlwiY2VudGVyXCI9PT1jLnN0cmlwTGluZS5sYWJlbEFsaWduPyh0aGlzLmNoYXJ0LnBsb3RBcmVhLnkyK3RoaXMuY2hhcnQucGxvdEFyZWEueTEtYy50ZXh0QmxvY2sud2lkdGgpLzI6dGhpcy5jaGFydC5wbG90QXJlYS55Mi1jLnRleHRCbG9jay53aWR0aC0zKTpcImxlZnRcIj09PVxudGhpcy5fcG9zaXRpb24/KGMudGV4dEJsb2NrLm1heFdpZHRoPXRoaXMub3B0aW9ucy5zdHJpcExpbmVzW2VdLmxhYmVsTWF4V2lkdGg/dGhpcy5vcHRpb25zLnN0cmlwTGluZXNbZV0ubGFiZWxNYXhXaWR0aDp0aGlzLmNoYXJ0LnBsb3RBcmVhLndpZHRoLTMsYy50ZXh0QmxvY2suYW5nbGU9MCxjLnRleHRCbG9jay5tZWFzdXJlVGV4dCgpLGIueS1jLnRleHRCbG9jay5oZWlnaHQtbS50aGlja25lc3MvMj50aGlzLmNoYXJ0LnBsb3RBcmVhLnkxP3IobS5zdGFydFZhbHVlKT9iLnktPWMudGV4dEJsb2NrLmhlaWdodC1jLnRleHRCbG9jay5mb250U2l6ZS8yK20udGhpY2tuZXNzLzI6Yi55LT1jLnRleHRCbG9jay5oZWlnaHQvMi1jLnRleHRCbG9jay5mb250U2l6ZS8yOnIobS5zdGFydFZhbHVlKT9iLnkrPWMudGV4dEJsb2NrLmhlaWdodC1jLnRleHRCbG9jay5mb250U2l6ZS8yK20udGhpY2tuZXNzLzI6Yi55Kz1jLnRleHRCbG9jay5oZWlnaHQvMi1jLnRleHRCbG9jay5mb250U2l6ZStcbjMsYi54PVwibmVhclwiPT09Yy5zdHJpcExpbmUubGFiZWxBbGlnbj90aGlzLmNoYXJ0LnBsb3RBcmVhLngxKzM6XCJjZW50ZXJcIj09PWMuc3RyaXBMaW5lLmxhYmVsQWxpZ24/KHRoaXMuY2hhcnQucGxvdEFyZWEueDIrdGhpcy5jaGFydC5wbG90QXJlYS54MSkvMi1jLnRleHRCbG9jay53aWR0aC8yOnRoaXMuY2hhcnQucGxvdEFyZWEueDItYy50ZXh0QmxvY2sud2lkdGgtMyk6XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24mJihjLnRleHRCbG9jay5tYXhXaWR0aD10aGlzLm9wdGlvbnMuc3RyaXBMaW5lc1tlXS5sYWJlbE1heFdpZHRoP3RoaXMub3B0aW9ucy5zdHJpcExpbmVzW2VdLmxhYmVsTWF4V2lkdGg6dGhpcy5jaGFydC5wbG90QXJlYS53aWR0aC0zLGMudGV4dEJsb2NrLmFuZ2xlPTAsYy50ZXh0QmxvY2subWVhc3VyZVRleHQoKSxiLnktYy50ZXh0QmxvY2suaGVpZ2h0LW0udGhpY2tuZXNzLzI+dGhpcy5jaGFydC5wbG90QXJlYS55MT9yKG0uc3RhcnRWYWx1ZSk/Yi55LT1jLnRleHRCbG9jay5oZWlnaHQtXG5jLnRleHRCbG9jay5mb250U2l6ZS8yK20udGhpY2tuZXNzLzI6Yi55LT1jLnRleHRCbG9jay5oZWlnaHQvMi1jLnRleHRCbG9jay5mb250U2l6ZS8yOnIobS5zdGFydFZhbHVlKT9iLnkrPWMudGV4dEJsb2NrLmhlaWdodC1jLnRleHRCbG9jay5mb250U2l6ZS8yK20udGhpY2tuZXNzLzI6Yi55LT1jLnRleHRCbG9jay5oZWlnaHQvMi1jLnRleHRCbG9jay5mb250U2l6ZS8yKzMsYi54PVwibmVhclwiPT09Yy5zdHJpcExpbmUubGFiZWxBbGlnbj90aGlzLmNoYXJ0LnBsb3RBcmVhLngyLWMudGV4dEJsb2NrLndpZHRoLTM6XCJjZW50ZXJcIj09PWMuc3RyaXBMaW5lLmxhYmVsQWxpZ24/KHRoaXMuY2hhcnQucGxvdEFyZWEueDIrdGhpcy5jaGFydC5wbG90QXJlYS54MSkvMi1jLnRleHRCbG9jay53aWR0aC8yOnRoaXMuY2hhcnQucGxvdEFyZWEueDErMyksYy50ZXh0QmxvY2sueD1iLngsYy50ZXh0QmxvY2sueT1iLnkscC5wdXNoKGMpKTtpZighayl7Yj0hMTt0aGlzLmN0eC5zYXZlKCk7dGhpcy5jdHguYmVnaW5QYXRoKCk7XG50aGlzLmN0eC5yZWN0KHRoaXMuY2hhcnQucGxvdEFyZWEueDEsdGhpcy5jaGFydC5wbG90QXJlYS55MSx0aGlzLmNoYXJ0LnBsb3RBcmVhLndpZHRoLHRoaXMuY2hhcnQucGxvdEFyZWEuaGVpZ2h0KTt0aGlzLmN0eC5jbGlwKCk7Zm9yKGU9MDtlPGgubGVuZ3RoO2UrKyltPWhbZV0sbS5zaG93T25Ub3A/bHx8KGw9ITAsdGhpcy5jaGFydC5hZGRFdmVudExpc3RlbmVyKFwiZGF0YUFuaW1hdGlvbkl0ZXJhdGlvbkVuZFwiLGZ1bmN0aW9uKCl7dGhpcy5jdHguc2F2ZSgpO3RoaXMuY3R4LmJlZ2luUGF0aCgpO3RoaXMuY3R4LnJlY3QodGhpcy5jaGFydC5wbG90QXJlYS54MSx0aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLHRoaXMuY2hhcnQucGxvdEFyZWEud2lkdGgsdGhpcy5jaGFydC5wbG90QXJlYS5oZWlnaHQpO3RoaXMuY3R4LmNsaXAoKTtmb3IoZj0wO2Y8aC5sZW5ndGg7ZisrKW09aFtmXSxtLnNob3dPblRvcCYmbS5yZW5kZXIoKTt0aGlzLmN0eC5yZXN0b3JlKCl9LG0pKTptLnJlbmRlcigpO1xuZm9yKGU9MDtlPHAubGVuZ3RoO2UrKyljPXBbZV0sYy5zdHJpcExpbmUuc2hvd09uVG9wP2J8fChiPSEwLHRoaXMuY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFBbmltYXRpb25JdGVyYXRpb25FbmRcIixmdW5jdGlvbigpe2ZvcihmPTA7ZjxwLmxlbmd0aDtmKyspYz1wW2ZdLFwiaW5zaWRlXCI9PT1jLnN0cmlwTGluZS5sYWJlbFBsYWNlbWVudCYmYy5zdHJpcExpbmUuc2hvd09uVG9wJiYoZC5jdHguc2F2ZSgpLGQuY3R4LmJlZ2luUGF0aCgpLGQuY3R4LnJlY3QoZC5jaGFydC5wbG90QXJlYS54MSxkLmNoYXJ0LnBsb3RBcmVhLnkxLGQuY2hhcnQucGxvdEFyZWEud2lkdGgsZC5jaGFydC5wbG90QXJlYS5oZWlnaHQpLGQuY3R4LmNsaXAoKSxjLnRleHRCbG9jay5yZW5kZXIoITApLGQuY3R4LnJlc3RvcmUoKSl9LGMudGV4dEJsb2NrKSk6XCJpbnNpZGVcIj09PWMuc3RyaXBMaW5lLmxhYmVsUGxhY2VtZW50JiZjLnRleHRCbG9jay5yZW5kZXIoITApO3RoaXMuY3R4LnJlc3RvcmUoKTtrPVxuITB9aWYoaylmb3IoYj0hMSxlPTA7ZTxwLmxlbmd0aDtlKyspYz1wW2VdLFwib3V0c2lkZVwiPT09Yy5zdHJpcExpbmUubGFiZWxQbGFjZW1lbnQmJmMudGV4dEJsb2NrLnJlbmRlcighMCl9fTtBLnByb3RvdHlwZS5yZW5kZXJCcmVha3NCYWNrZ3JvdW5kPWZ1bmN0aW9uKCl7dGhpcy5jaGFydC5fYnJlYWtzQ2FudmFzJiYodGhpcy5zY2FsZUJyZWFrcyYmMDx0aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCYmdGhpcy5tYXNrQ2FudmFzKSYmKHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eC5zYXZlKCksdGhpcy5jaGFydC5fYnJlYWtzQ2FudmFzQ3R4LmJlZ2luUGF0aCgpLHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eC5yZWN0KHRoaXMuY2hhcnQucGxvdEFyZWEueDEsdGhpcy5jaGFydC5wbG90QXJlYS55MSx0aGlzLmNoYXJ0LnBsb3RBcmVhLndpZHRoLHRoaXMuY2hhcnQucGxvdEFyZWEuaGVpZ2h0KSx0aGlzLmNoYXJ0Ll9icmVha3NDYW52YXNDdHguY2xpcCgpLFxudGhpcy5jaGFydC5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLm1hc2tDYW52YXMsMCwwLHRoaXMuY2hhcnQud2lkdGgsdGhpcy5jaGFydC5oZWlnaHQpLHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eC5yZXN0b3JlKCkpfTtBLnByb3RvdHlwZS5jcmVhdGVNYXNrPWZ1bmN0aW9uKCl7aWYodGhpcy5zY2FsZUJyZWFrcyYmMDx0aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLmxlbmd0aCl7dmFyIGE9dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrczt3Pyh0aGlzLm1hc2tDYW52YXM9dWEodGhpcy5jaGFydC53aWR0aCx0aGlzLmNoYXJ0LmhlaWdodCksdGhpcy5tYXNrQ3R4PXRoaXMubWFza0NhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikpOih0aGlzLm1hc2tDYW52YXM9dGhpcy5jaGFydC5wbG90QXJlYS5jYW52YXMsdGhpcy5tYXNrQ3R4PXRoaXMuY2hhcnQucGxvdEFyZWEuY3R4KTt0aGlzLm1hc2tDdHguc2F2ZSgpO3RoaXMubWFza0N0eC5iZWdpblBhdGgoKTtcbnRoaXMubWFza0N0eC5yZWN0KHRoaXMuY2hhcnQucGxvdEFyZWEueDEsdGhpcy5jaGFydC5wbG90QXJlYS55MSx0aGlzLmNoYXJ0LnBsb3RBcmVhLndpZHRoLHRoaXMuY2hhcnQucGxvdEFyZWEuaGVpZ2h0KTt0aGlzLm1hc2tDdHguY2xpcCgpO2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKWFbZF0uZW5kVmFsdWU8dGhpcy52aWV3cG9ydE1pbmltdW18fChhW2RdLnN0YXJ0VmFsdWU+dGhpcy52aWV3cG9ydE1heGltdW18fGlzTmFOKHRoaXMucmFuZ2UpKXx8YVtkXS5yZW5kZXIodGhpcy5tYXNrQ3R4KTt0aGlzLm1hc2tDdHgucmVzdG9yZSgpfX07QS5wcm90b3R5cGUucmVuZGVyQ3Jvc3NoYWlyPWZ1bmN0aW9uKGEsZCl7aXNGaW5pdGUodGhpcy5taW5pbXVtKSYmaXNGaW5pdGUodGhpcy5tYXhpbXVtKSYmdGhpcy5jcm9zc2hhaXIucmVuZGVyKGEsZCl9O0EucHJvdG90eXBlLnNob3dDcm9zc2hhaXI9ZnVuY3Rpb24oYSl7cihhKXx8KGE8dGhpcy52aWV3cG9ydE1pbmltdW18fGE+dGhpcy52aWV3cG9ydE1heGltdW0pfHxcbihcInRvcFwiPT09dGhpcy5fcG9zaXRpb258fFwiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbj90aGlzLmNyb3NzaGFpci5yZW5kZXIodGhpcy5jb252ZXJ0VmFsdWVUb1BpeGVsKGEpLG51bGwsYSk6dGhpcy5jcm9zc2hhaXIucmVuZGVyKG51bGwsdGhpcy5jb252ZXJ0VmFsdWVUb1BpeGVsKGEpLGEpKX07QS5wcm90b3R5cGUucmVuZGVyR3JpZD1mdW5jdGlvbigpe2lmKHRoaXMuZ3JpZFRoaWNrbmVzcyYmMDx0aGlzLmdyaWRUaGlja25lc3Mpe3ZhciBhPXRoaXMuY2hhcnQuY3R4O2Euc2F2ZSgpO3ZhciBkLGM9dGhpcy5jaGFydC5wbG90QXJlYTthLmxpbmVXaWR0aD10aGlzLmdyaWRUaGlja25lc3M7YS5zdHJva2VTdHlsZT10aGlzLmdyaWRDb2xvcjthLnNldExpbmVEYXNoJiZhLnNldExpbmVEYXNoKEoodGhpcy5ncmlkRGFzaFR5cGUsdGhpcy5ncmlkVGhpY2tuZXNzKSk7aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24pZm9yKGI9MDtiPHRoaXMuX2xhYmVscy5sZW5ndGg7YisrKXRoaXMuX2xhYmVsc1tiXS5wb3NpdGlvbjxcbnRoaXMudmlld3BvcnRNaW5pbXVtfHwodGhpcy5fbGFiZWxzW2JdLnBvc2l0aW9uPnRoaXMudmlld3BvcnRNYXhpbXVtfHx0aGlzLl9sYWJlbHNbYl0uYnJlYWtzTGFiZWxUeXBlKXx8KGEuYmVnaW5QYXRoKCksZD10aGlzLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5fbGFiZWxzW2JdLnBvc2l0aW9uKSxkPTE9PT1hLmxpbmVXaWR0aCUyPyhkLng8PDApKzAuNTpkLng8PDAsYS5tb3ZlVG8oZCxjLnkxPDwwKSxhLmxpbmVUbyhkLGMueTI8PDApLGEuc3Ryb2tlKCkpO2Vsc2UgaWYoXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pZm9yKHZhciBiPTA7Yjx0aGlzLl9sYWJlbHMubGVuZ3RoO2IrKyl0aGlzLl9sYWJlbHNbYl0ucG9zaXRpb248dGhpcy52aWV3cG9ydE1pbmltdW18fCh0aGlzLl9sYWJlbHNbYl0ucG9zaXRpb24+dGhpcy52aWV3cG9ydE1heGltdW18fHRoaXMuX2xhYmVsc1tiXS5icmVha3NMYWJlbFR5cGUpfHwoYS5iZWdpblBhdGgoKSxcbmQ9dGhpcy5nZXRQaXhlbENvb3JkaW5hdGVzT25BeGlzKHRoaXMuX2xhYmVsc1tiXS5wb3NpdGlvbiksZD0xPT09YS5saW5lV2lkdGglMj8oZC55PDwwKSswLjU6ZC55PDwwLGEubW92ZVRvKGMueDE8PDAsZCksYS5saW5lVG8oYy54Mjw8MCxkKSxhLnN0cm9rZSgpKTthLnJlc3RvcmUoKX19O0EucHJvdG90eXBlLnJlbmRlckF4aXNMaW5lPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydC5jdHgsZD13P3RoaXMuY2hhcnQuX3ByZVJlbmRlckN0eDphLGM9TWF0aC5jZWlsKHRoaXMudGlja1RoaWNrbmVzcy8odGhpcy5yZXZlcnNlZD8tMjoyKSksYj1NYXRoLmNlaWwodGhpcy50aWNrVGhpY2tuZXNzLyh0aGlzLnJldmVyc2VkPzI6LTIpKSxlLGY7ZC5zYXZlKCk7aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24pe2lmKHRoaXMubGluZVRoaWNrbmVzcyl7dGhpcy5yZXZlcnNlZD8oZT10aGlzLmxpbmVDb29yZGluYXRlcy54MixmPXRoaXMubGluZUNvb3JkaW5hdGVzLngxKTpcbihlPXRoaXMubGluZUNvb3JkaW5hdGVzLngxLGY9dGhpcy5saW5lQ29vcmRpbmF0ZXMueDIpO2QubGluZVdpZHRoPXRoaXMubGluZVRoaWNrbmVzcztkLnN0cm9rZVN0eWxlPXRoaXMubGluZUNvbG9yP3RoaXMubGluZUNvbG9yOlwiYmxhY2tcIjtkLnNldExpbmVEYXNoJiZkLnNldExpbmVEYXNoKEoodGhpcy5saW5lRGFzaFR5cGUsdGhpcy5saW5lVGhpY2tuZXNzKSk7dmFyIGw9MT09PXRoaXMubGluZVRoaWNrbmVzcyUyPyh0aGlzLmxpbmVDb29yZGluYXRlcy55MTw8MCkrMC41OnRoaXMubGluZUNvb3JkaW5hdGVzLnkxPDwwO2QuYmVnaW5QYXRoKCk7aWYodGhpcy5zY2FsZUJyZWFrcyYmIXIodGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXgpKWlmKHIodGhpcy5zY2FsZUJyZWFrcy5sYXN0QnJlYWtJbmRleCkpZT10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW3RoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4XS5lbmRQaXhlbCtiO2Vsc2UgZm9yKHZhciBoPVxudGhpcy5zY2FsZUJyZWFrcy5maXJzdEJyZWFrSW5kZXg7aDw9dGhpcy5zY2FsZUJyZWFrcy5sYXN0QnJlYWtJbmRleDtoKyspZC5tb3ZlVG8oZSxsKSxkLmxpbmVUbyh0aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2hdLnN0YXJ0UGl4ZWwrYyxsKSxlPXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbaF0uZW5kUGl4ZWwrYjtlJiYoZC5tb3ZlVG8oZSxsKSxkLmxpbmVUbyhmLGwpKTtkLnN0cm9rZSgpfX1lbHNlIGlmKChcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLl9wb3NpdGlvbikmJnRoaXMubGluZVRoaWNrbmVzcyl7dGhpcy5yZXZlcnNlZD8oZT10aGlzLmxpbmVDb29yZGluYXRlcy55MSxmPXRoaXMubGluZUNvb3JkaW5hdGVzLnkyKTooZT10aGlzLmxpbmVDb29yZGluYXRlcy55MixmPXRoaXMubGluZUNvb3JkaW5hdGVzLnkxKTtkLmxpbmVXaWR0aD10aGlzLmxpbmVUaGlja25lc3M7ZC5zdHJva2VTdHlsZT10aGlzLmxpbmVDb2xvcjtcbmQuc2V0TGluZURhc2gmJmQuc2V0TGluZURhc2goSih0aGlzLmxpbmVEYXNoVHlwZSx0aGlzLmxpbmVUaGlja25lc3MpKTtsPTE9PT10aGlzLmxpbmVUaGlja25lc3MlMj8odGhpcy5saW5lQ29vcmRpbmF0ZXMueDE8PDApKzAuNTp0aGlzLmxpbmVDb29yZGluYXRlcy54MTw8MDtkLmJlZ2luUGF0aCgpO2lmKHRoaXMuc2NhbGVCcmVha3MmJiFyKHRoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4KSlpZihyKHRoaXMuc2NhbGVCcmVha3MubGFzdEJyZWFrSW5kZXgpKWU9dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1t0aGlzLnNjYWxlQnJlYWtzLmZpcnN0QnJlYWtJbmRleF0uZW5kUGl4ZWwrYztlbHNlIGZvcihoPXRoaXMuc2NhbGVCcmVha3MuZmlyc3RCcmVha0luZGV4O2g8PXRoaXMuc2NhbGVCcmVha3MubGFzdEJyZWFrSW5kZXg7aCsrKWQubW92ZVRvKGwsZSksZC5saW5lVG8obCx0aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2hdLnN0YXJ0UGl4ZWwrYiksXG5lPXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbaF0uZW5kUGl4ZWwrYztlJiYoZC5tb3ZlVG8obCxlKSxkLmxpbmVUbyhsLGYpKTtkLnN0cm9rZSgpfXcmJihhLmRyYXdJbWFnZSh0aGlzLmNoYXJ0Ll9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMuY2hhcnQud2lkdGgsdGhpcy5jaGFydC5oZWlnaHQpLHRoaXMuY2hhcnQuX2JyZWFrc0NhbnZhc0N0eCYmdGhpcy5jaGFydC5fYnJlYWtzQ2FudmFzQ3R4LmRyYXdJbWFnZSh0aGlzLmNoYXJ0Ll9wcmVSZW5kZXJDYW52YXMsMCwwLHRoaXMuY2hhcnQud2lkdGgsdGhpcy5jaGFydC5oZWlnaHQpLGQuY2xlYXJSZWN0KDAsMCx0aGlzLmNoYXJ0LndpZHRoLHRoaXMuY2hhcnQuaGVpZ2h0KSk7ZC5yZXN0b3JlKCl9O0EucHJvdG90eXBlLmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXM9ZnVuY3Rpb24oYSl7dmFyIGQ9e307aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24pZC54PXRoaXMuY29udmVydFZhbHVlVG9QaXhlbChhKSxcbmQueT10aGlzLmxpbmVDb29yZGluYXRlcy55MTtpZihcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLl9wb3NpdGlvbilkLnk9dGhpcy5jb252ZXJ0VmFsdWVUb1BpeGVsKGEpLGQueD10aGlzLmxpbmVDb29yZGluYXRlcy54MjtyZXR1cm4gZH07QS5wcm90b3R5cGUuY29udmVydFBpeGVsVG9WYWx1ZT1mdW5jdGlvbihhKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7dmFyIGQ9MCxjPTAsYixkPSEwLGU9dGhpcy5zY2FsZUJyZWFrcz90aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzOltdLGM9XCJudW1iZXJcIj09PXR5cGVvZiBhP2E6XCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24/YS55OmEueDtpZih0aGlzLmxvZ2FyaXRobWljKXthPWI9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLChjLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlKS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnBpeGVsUGVyVW5pdCk7XG5pZihjPD10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnJlZmVyZW5jZT09PShcImxlZnRcIj09PXRoaXMuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLl9wb3NpdGlvbikhPT10aGlzLnJldmVyc2VkKWZvcihjPTA7YzxlLmxlbmd0aDtjKyspe2lmKCEoZVtjXS5lbmRWYWx1ZTx0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pKWlmKGQpaWYoZVtjXS5zdGFydFZhbHVlPHRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSl7aWYoMTxlW2NdLnNpemUmJnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSpNYXRoLnBvdyhlW2NdLmVuZFZhbHVlL2VbY10uc3RhcnRWYWx1ZSxNYXRoLmxvZyhiKS9NYXRoLmxvZyhlW2NdLnNpemUpKTxlW2NdLmVuZFZhbHVlKXthPU1hdGgucG93KGVbY10uZW5kVmFsdWUvZVtjXS5zdGFydFZhbHVlLE1hdGgubG9nKGIpL01hdGgubG9nKGVbY10uc2l6ZSkpO2JyZWFrfWVsc2UgYSo9ZVtjXS5lbmRWYWx1ZS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0vXG5NYXRoLnBvdyhlW2NdLnNpemUsTWF0aC5sb2coZVtjXS5lbmRWYWx1ZS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pL01hdGgubG9nKGVbY10uZW5kVmFsdWUvZVtjXS5zdGFydFZhbHVlKSksYi89TWF0aC5wb3coZVtjXS5zaXplLE1hdGgubG9nKGVbY10uZW5kVmFsdWUvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKS9NYXRoLmxvZyhlW2NdLmVuZFZhbHVlL2VbY10uc3RhcnRWYWx1ZSkpO2Q9ITF9ZWxzZSBpZihiPmVbY10uc3RhcnRWYWx1ZS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pe2IvPWVbY10uc3RhcnRWYWx1ZS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW07aWYoYjxlW2NdLnNpemUpe2EqPU1hdGgucG93KGVbY10uZW5kVmFsdWUvZVtjXS5zdGFydFZhbHVlLDE9PT1lW2NdLnNpemU/MTpNYXRoLmxvZyhiKS9NYXRoLmxvZyhlW2NdLnNpemUpKS9iO2JyZWFrfWVsc2UgYSo9ZVtjXS5lbmRWYWx1ZS9lW2NdLnN0YXJ0VmFsdWUvXG5lW2NdLnNpemU7Yi89ZVtjXS5zaXplO2Q9ITF9ZWxzZSBicmVhaztlbHNlIGlmKGI+ZVtjXS5zdGFydFZhbHVlL2VbYy0xXS5lbmRWYWx1ZSl7Yi89ZVtjXS5zdGFydFZhbHVlL2VbYy0xXS5lbmRWYWx1ZTtpZihiPGVbY10uc2l6ZSl7YSo9TWF0aC5wb3coZVtjXS5lbmRWYWx1ZS9lW2NdLnN0YXJ0VmFsdWUsMT09PWVbY10uc2l6ZT8xOk1hdGgubG9nKGIpL01hdGgubG9nKGVbY10uc2l6ZSkpL2I7YnJlYWt9ZWxzZSBhKj1lW2NdLmVuZFZhbHVlL2VbY10uc3RhcnRWYWx1ZS9lW2NdLnNpemU7Yi89ZVtjXS5zaXplfWVsc2UgYnJlYWt9ZWxzZSBmb3IoYz1lLmxlbmd0aC0xOzA8PWM7Yy0tKWlmKCEoZVtjXS5zdGFydFZhbHVlPnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkpaWYoZClpZihlW2NdLmVuZFZhbHVlPnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSl7aWYoMTxlW2NdLnNpemUmJnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSpNYXRoLnBvdyhlW2NdLmVuZFZhbHVlL1xuZVtjXS5zdGFydFZhbHVlLE1hdGgubG9nKGIpL01hdGgubG9nKGVbY10uc2l6ZSkpPmVbY10uc3RhcnRWYWx1ZSl7YT1NYXRoLnBvdyhlW2NdLmVuZFZhbHVlL2VbY10uc3RhcnRWYWx1ZSxNYXRoLmxvZyhiKS9NYXRoLmxvZyhlW2NdLnNpemUpKTticmVha31lbHNlIGEqPWVbY10uc3RhcnRWYWx1ZS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0qTWF0aC5wb3coZVtjXS5zaXplLE1hdGgubG9nKGVbY10uc3RhcnRWYWx1ZS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pL01hdGgubG9nKGVbY10uZW5kVmFsdWUvZVtjXS5zdGFydFZhbHVlKSkqYixiKj1NYXRoLnBvdyhlW2NdLnNpemUsTWF0aC5sb2codGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtL2VbY10uc3RhcnRWYWx1ZSkvTWF0aC5sb2coZVtjXS5lbmRWYWx1ZS9lW2NdLnN0YXJ0VmFsdWUpKTtkPSExfWVsc2UgaWYoYjxlW2NdLmVuZFZhbHVlL3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSl7Yi89XG5lW2NdLmVuZFZhbHVlL3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bTtpZihiPjEvZVtjXS5zaXplKXthKj1NYXRoLnBvdyhlW2NdLmVuZFZhbHVlL2VbY10uc3RhcnRWYWx1ZSwxPj1lW2NdLnNpemU/MTpNYXRoLmxvZyhiKS9NYXRoLmxvZyhlW2NdLnNpemUpKSpiO2JyZWFrfWVsc2UgYS89ZVtjXS5lbmRWYWx1ZS9lW2NdLnN0YXJ0VmFsdWUvZVtjXS5zaXplO2IqPWVbY10uc2l6ZTtkPSExfWVsc2UgYnJlYWs7ZWxzZSBpZihiPGVbY10uZW5kVmFsdWUvZVtjKzFdLnN0YXJ0VmFsdWUpe2IvPWVbY10uZW5kVmFsdWUvZVtjKzFdLnN0YXJ0VmFsdWU7aWYoYj4xL2VbY10uc2l6ZSl7YSo9TWF0aC5wb3coZVtjXS5lbmRWYWx1ZS9lW2NdLnN0YXJ0VmFsdWUsMT49ZVtjXS5zaXplPzE6TWF0aC5sb2coYikvTWF0aC5sb2coZVtjXS5zaXplKSkqYjticmVha31lbHNlIGEvPWVbY10uZW5kVmFsdWUvZVtjXS5zdGFydFZhbHVlL2VbY10uc2l6ZTtiKj1lW2NdLnNpemV9ZWxzZSBicmVhaztcbmQ9YSp0aGlzLnZpZXdwb3J0TWluaW11bX1lbHNle2E9Yj0oYy10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLnJlZmVyZW5jZSkvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5waXhlbFBlclVuaXQ7aWYoYzw9dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5yZWZlcmVuY2U9PT0oXCJsZWZ0XCI9PT10aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pIT09dGhpcy5yZXZlcnNlZClmb3IoYz0wO2M8ZS5sZW5ndGg7YysrKXtpZighKGVbY10uZW5kVmFsdWU8dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKSlpZihkKWlmKGVbY10uc3RhcnRWYWx1ZTx0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pe2lmKGVbY10uc2l6ZSYmdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtK2IqKGVbY10uZW5kVmFsdWUtZVtjXS5zdGFydFZhbHVlKS9lW2NdLnNpemU8ZVtjXS5lbmRWYWx1ZSl7YT0wPj1lW2NdLnNpemU/MDpiKihlW2NdLmVuZFZhbHVlLVxuZVtjXS5zdGFydFZhbHVlKS9lW2NdLnNpemU7YnJlYWt9ZWxzZSBhKz1lW2NdLmVuZFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bS1lW2NdLnNpemUqKGVbY10uZW5kVmFsdWUtdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKS8oZVtjXS5lbmRWYWx1ZS1lW2NdLnN0YXJ0VmFsdWUpLGItPWVbY10uc2l6ZSooZVtjXS5lbmRWYWx1ZS10aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pLyhlW2NdLmVuZFZhbHVlLWVbY10uc3RhcnRWYWx1ZSk7ZD0hMX1lbHNlIGlmKGI+ZVtjXS5zdGFydFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSl7Yi09ZVtjXS5zdGFydFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bTtpZihiPGVbY10uc2l6ZSl7YSs9KGVbY10uZW5kVmFsdWUtZVtjXS5zdGFydFZhbHVlKSooMD09PWVbY10uc2l6ZT8xOmIvZVtjXS5zaXplKS1iO2JyZWFrfWVsc2UgYSs9ZVtjXS5lbmRWYWx1ZS1cbmVbY10uc3RhcnRWYWx1ZS1lW2NdLnNpemU7Yi09ZVtjXS5zaXplO2Q9ITF9ZWxzZSBicmVhaztlbHNlIGlmKGI+ZVtjXS5zdGFydFZhbHVlLWVbYy0xXS5lbmRWYWx1ZSl7Yi09ZVtjXS5zdGFydFZhbHVlLWVbYy0xXS5lbmRWYWx1ZTtpZihiPGVbY10uc2l6ZSl7YSs9KGVbY10uZW5kVmFsdWUtZVtjXS5zdGFydFZhbHVlKSooMD09PWVbY10uc2l6ZT8xOmIvZVtjXS5zaXplKS1iO2JyZWFrfWVsc2UgYSs9ZVtjXS5lbmRWYWx1ZS1lW2NdLnN0YXJ0VmFsdWUtZVtjXS5zaXplO2ItPWVbY10uc2l6ZX1lbHNlIGJyZWFrfWVsc2UgZm9yKGM9ZS5sZW5ndGgtMTswPD1jO2MtLSlpZighKGVbY10uc3RhcnRWYWx1ZT50aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0pKWlmKGQpaWYoZVtjXS5lbmRWYWx1ZT50aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0paWYoZVtjXS5zaXplJiZ0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0rYiooZVtjXS5lbmRWYWx1ZS1cbmVbY10uc3RhcnRWYWx1ZSkvZVtjXS5zaXplPmVbY10uc3RhcnRWYWx1ZSl7YT0wPj1lW2NdLnNpemU/MDpiKihlW2NdLmVuZFZhbHVlLWVbY10uc3RhcnRWYWx1ZSkvZVtjXS5zaXplO2JyZWFrfWVsc2UgYSs9ZVtjXS5zdGFydFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bStlW2NdLnNpemUqKHRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bS1lW2NdLnN0YXJ0VmFsdWUpLyhlW2NdLmVuZFZhbHVlLWVbY10uc3RhcnRWYWx1ZSksYis9ZVtjXS5zaXplKih0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0tZVtjXS5zdGFydFZhbHVlKS8oZVtjXS5lbmRWYWx1ZS1lW2NdLnN0YXJ0VmFsdWUpLGQ9ITE7ZWxzZSBpZihiPGVbY10uZW5kVmFsdWUtdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKXtiLT1lW2NdLmVuZFZhbHVlLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bTtpZihiPi0xKmVbY10uc2l6ZSl7YSs9KGVbY10uZW5kVmFsdWUtXG5lW2NdLnN0YXJ0VmFsdWUpKigwPT09ZVtjXS5zaXplPzE6Yi9lW2NdLnNpemUpK2I7YnJlYWt9ZWxzZSBhLT1lW2NdLmVuZFZhbHVlLWVbY10uc3RhcnRWYWx1ZS1lW2NdLnNpemU7Yis9ZVtjXS5zaXplO2Q9ITF9ZWxzZSBicmVhaztlbHNlIGlmKGI8ZVtjXS5lbmRWYWx1ZS1lW2MrMV0uc3RhcnRWYWx1ZSl7Yi09ZVtjXS5lbmRWYWx1ZS1lW2MrMV0uc3RhcnRWYWx1ZTtpZihiPi0xKmVbY10uc2l6ZSl7YSs9KGVbY10uZW5kVmFsdWUtZVtjXS5zdGFydFZhbHVlKSooMD09PWVbY10uc2l6ZT8xOmIvZVtjXS5zaXplKStiO2JyZWFrfWVsc2UgYS09ZVtjXS5lbmRWYWx1ZS1lW2NdLnN0YXJ0VmFsdWUtZVtjXS5zaXplO2IrPWVbY10uc2l6ZX1lbHNlIGJyZWFrO2Q9dGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtK2F9cmV0dXJuIGR9O0EucHJvdG90eXBlLmNvbnZlcnRWYWx1ZVRvUGl4ZWw9ZnVuY3Rpb24oYSl7YT10aGlzLmdldEFwcGFyZW50RGlmZmVyZW5jZSh0aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLm1pbmltdW0sXG5hLGEpO3JldHVybiB0aGlzLmxvZ2FyaXRobWljP3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlK3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0Kk1hdGgubG9nKGEvdGhpcy5jb252ZXJzaW9uUGFyYW1ldGVycy5taW5pbXVtKS90aGlzLmNvbnZlcnNpb25QYXJhbWV0ZXJzLmxuTG9nYXJpdGhtQmFzZSswLjU8PDA6XCJheGlzWFwiPT09dGhpcy50eXBlP3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlK3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KihhLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkrMC41PDwwOnRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucmVmZXJlbmNlK3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnMucGl4ZWxQZXJVbml0KihhLXRoaXMuY29udmVyc2lvblBhcmFtZXRlcnMubWluaW11bSkrMC41fTtBLnByb3RvdHlwZS5nZXRBcHBhcmVudERpZmZlcmVuY2U9ZnVuY3Rpb24oYSxcbmQsYyxiKXt2YXIgZT10aGlzLnNjYWxlQnJlYWtzP3RoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3M6W107aWYodGhpcy5sb2dhcml0aG1pYyl7Yz1yKGMpP2QvYTpjO2Zvcih2YXIgZj0wO2Y8ZS5sZW5ndGgmJiEoZDxlW2ZdLnN0YXJ0VmFsdWUpO2YrKylhPmVbZl0uZW5kVmFsdWV8fChhPD1lW2ZdLnN0YXJ0VmFsdWUmJmQ+PWVbZl0uZW5kVmFsdWU/Yz1jL2VbZl0uZW5kVmFsdWUqZVtmXS5zdGFydFZhbHVlKmVbZl0uc2l6ZTphPj1lW2ZdLnN0YXJ0VmFsdWUmJmQ+PWVbZl0uZW5kVmFsdWU/Yz1jL2VbZl0uZW5kVmFsdWUqYSpNYXRoLnBvdyhlW2ZdLnNpemUsTWF0aC5sb2coZVtmXS5lbmRWYWx1ZS9hKS9NYXRoLmxvZyhlW2ZdLmVuZFZhbHVlL2VbZl0uc3RhcnRWYWx1ZSkpOmE8PWVbZl0uc3RhcnRWYWx1ZSYmZDw9ZVtmXS5lbmRWYWx1ZT9jPWMvZCplW2ZdLnN0YXJ0VmFsdWUqTWF0aC5wb3coZVtmXS5zaXplLE1hdGgubG9nKGQvZVtmXS5zdGFydFZhbHVlKS9NYXRoLmxvZyhlW2ZdLmVuZFZhbHVlL1xuZVtmXS5zdGFydFZhbHVlKSk6IWImJihhPmVbZl0uc3RhcnRWYWx1ZSYmZDxlW2ZdLmVuZFZhbHVlKSYmKGM9YSpNYXRoLnBvdyhlW2ZdLnNpemUsTWF0aC5sb2coZC9hKS9NYXRoLmxvZyhlW2ZdLmVuZFZhbHVlL2VbZl0uc3RhcnRWYWx1ZSkpKSl9ZWxzZSBmb3IoYz1yKGMpP01hdGguYWJzKGQtYSk6YyxmPTA7ZjxlLmxlbmd0aCYmIShkPGVbZl0uc3RhcnRWYWx1ZSk7ZisrKWE+ZVtmXS5lbmRWYWx1ZXx8KGE8PWVbZl0uc3RhcnRWYWx1ZSYmZD49ZVtmXS5lbmRWYWx1ZT9jPWMtZVtmXS5lbmRWYWx1ZStlW2ZdLnN0YXJ0VmFsdWUrZVtmXS5zaXplOmE+ZVtmXS5zdGFydFZhbHVlJiZkPj1lW2ZdLmVuZFZhbHVlP2M9Yy1lW2ZdLmVuZFZhbHVlK2ErZVtmXS5zaXplKihlW2ZdLmVuZFZhbHVlLWEpLyhlW2ZdLmVuZFZhbHVlLWVbZl0uc3RhcnRWYWx1ZSk6YTw9ZVtmXS5zdGFydFZhbHVlJiZkPGVbZl0uZW5kVmFsdWU/Yz1jLWQrZVtmXS5zdGFydFZhbHVlK2VbZl0uc2l6ZSooZC1lW2ZdLnN0YXJ0VmFsdWUpL1xuKGVbZl0uZW5kVmFsdWUtZVtmXS5zdGFydFZhbHVlKTohYiYmKGE+ZVtmXS5zdGFydFZhbHVlJiZkPGVbZl0uZW5kVmFsdWUpJiYoYz1hK2VbZl0uc2l6ZSooZC1hKS8oZVtmXS5lbmRWYWx1ZS1lW2ZdLnN0YXJ0VmFsdWUpKSk7cmV0dXJuIGN9O0EucHJvdG90eXBlLnNldFZpZXdQb3J0UmFuZ2U9ZnVuY3Rpb24oYSxkKXt0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtPXRoaXMudmlld3BvcnRNaW5pbXVtPU1hdGgubWluKGEsZCk7dGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bT10aGlzLnZpZXdwb3J0TWF4aW11bT1NYXRoLm1heChhLGQpfTtBLnByb3RvdHlwZS5nZXRYVmFsdWVBdD1mdW5jdGlvbihhKXtpZighYSlyZXR1cm4gbnVsbDt2YXIgZD1udWxsO1wibGVmdFwiPT09dGhpcy5fcG9zaXRpb24/ZD10aGlzLmNvbnZlcnRQaXhlbFRvVmFsdWUoYS55KTpcImJvdHRvbVwiPT09dGhpcy5fcG9zaXRpb24mJihkPXRoaXMuY29udmVydFBpeGVsVG9WYWx1ZShhLngpKTtcbnJldHVybiBkfTtBLnByb3RvdHlwZS5jYWxjdWxhdGVWYWx1ZVRvUGl4ZWxDb252ZXJzaW9uUGFyYW1ldGVycz1mdW5jdGlvbihhKXthPXRoaXMuc2NhbGVCcmVha3M/dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrczpbXTt2YXIgZD17cGl4ZWxQZXJVbml0Om51bGwsbWluaW11bTpudWxsLHJlZmVyZW5jZTpudWxsfSxjPXRoaXMubGluZUNvb3JkaW5hdGVzLndpZHRoLGI9dGhpcy5saW5lQ29vcmRpbmF0ZXMuaGVpZ2h0LGM9XCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24/YzpiLGI9TWF0aC5hYnModGhpcy5yYW5nZSk7aWYodGhpcy5sb2dhcml0aG1pYylmb3IodmFyIGU9MDtlPGEubGVuZ3RoJiYhKHRoaXMudmlld3BvcnRNYXhpbXVtPGFbZV0uc3RhcnRWYWx1ZSk7ZSsrKXRoaXMudmlld3BvcnRNaW5pbXVtPmFbZV0uZW5kVmFsdWV8fCh0aGlzLnZpZXdwb3J0TWluaW11bT49YVtlXS5zdGFydFZhbHVlJiZ0aGlzLnZpZXdwb3J0TWF4aW11bTw9XG5hW2VdLmVuZFZhbHVlP2M9MDp0aGlzLnZpZXdwb3J0TWluaW11bTw9YVtlXS5zdGFydFZhbHVlJiZ0aGlzLnZpZXdwb3J0TWF4aW11bT49YVtlXS5lbmRWYWx1ZT8oYj1iL2FbZV0uZW5kVmFsdWUqYVtlXS5zdGFydFZhbHVlLGM9MDxhW2VdLnNwYWNpbmcudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKT9jKigxLXBhcnNlRmxvYXQoYVtlXS5zcGFjaW5nKS8xMDApOmMtTWF0aC5taW4oYVtlXS5zcGFjaW5nLDAuMSpjKSk6dGhpcy52aWV3cG9ydE1pbmltdW0+YVtlXS5zdGFydFZhbHVlJiZ0aGlzLnZpZXdwb3J0TWF4aW11bT49YVtlXS5lbmRWYWx1ZT8oYj1iL2FbZV0uZW5kVmFsdWUqdGhpcy52aWV3cG9ydE1pbmltdW0sYz0wPGFbZV0uc3BhY2luZy50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpP2MqKDEtcGFyc2VGbG9hdChhW2VdLnNwYWNpbmcpLzEwMCpNYXRoLmxvZyhhW2VdLmVuZFZhbHVlL3RoaXMudmlld3BvcnRNaW5pbXVtKS9NYXRoLmxvZyhhW2VdLmVuZFZhbHVlL2FbZV0uc3RhcnRWYWx1ZSkpOlxuYy1NYXRoLm1pbihhW2VdLnNwYWNpbmcsMC4xKmMpKk1hdGgubG9nKGFbZV0uZW5kVmFsdWUvdGhpcy52aWV3cG9ydE1pbmltdW0pL01hdGgubG9nKGFbZV0uZW5kVmFsdWUvYVtlXS5zdGFydFZhbHVlKSk6dGhpcy52aWV3cG9ydE1pbmltdW08PWFbZV0uc3RhcnRWYWx1ZSYmdGhpcy52aWV3cG9ydE1heGltdW08YVtlXS5lbmRWYWx1ZSYmKGI9Yi90aGlzLnZpZXdwb3J0TWF4aW11bSphW2VdLnN0YXJ0VmFsdWUsYz0wPGFbZV0uc3BhY2luZy50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpP2MqKDEtcGFyc2VGbG9hdChhW2VdLnNwYWNpbmcpLzEwMCpNYXRoLmxvZyh0aGlzLnZpZXdwb3J0TWF4aW11bS9hW2VdLnN0YXJ0VmFsdWUpL01hdGgubG9nKGFbZV0uZW5kVmFsdWUvYVtlXS5zdGFydFZhbHVlKSk6Yy1NYXRoLm1pbihhW2VdLnNwYWNpbmcsMC4xKmMpKk1hdGgubG9nKHRoaXMudmlld3BvcnRNYXhpbXVtL2FbZV0uc3RhcnRWYWx1ZSkvTWF0aC5sb2coYVtlXS5lbmRWYWx1ZS9hW2VdLnN0YXJ0VmFsdWUpKSk7XG5lbHNlIGZvcihlPTA7ZTxhLmxlbmd0aCYmISh0aGlzLnZpZXdwb3J0TWF4aW11bTxhW2VdLnN0YXJ0VmFsdWUpO2UrKyl0aGlzLnZpZXdwb3J0TWluaW11bT5hW2VdLmVuZFZhbHVlfHwodGhpcy52aWV3cG9ydE1pbmltdW0+PWFbZV0uc3RhcnRWYWx1ZSYmdGhpcy52aWV3cG9ydE1heGltdW08PWFbZV0uZW5kVmFsdWU/Yz0wOnRoaXMudmlld3BvcnRNaW5pbXVtPD1hW2VdLnN0YXJ0VmFsdWUmJnRoaXMudmlld3BvcnRNYXhpbXVtPj1hW2VdLmVuZFZhbHVlPyhiPWItYVtlXS5lbmRWYWx1ZSthW2VdLnN0YXJ0VmFsdWUsYz0wPGFbZV0uc3BhY2luZy50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpP2MqKDEtcGFyc2VGbG9hdChhW2VdLnNwYWNpbmcpLzEwMCk6Yy1NYXRoLm1pbihhW2VdLnNwYWNpbmcsMC4xKmMpKTp0aGlzLnZpZXdwb3J0TWluaW11bT5hW2VdLnN0YXJ0VmFsdWUmJnRoaXMudmlld3BvcnRNYXhpbXVtPj1hW2VdLmVuZFZhbHVlPyhiPWItYVtlXS5lbmRWYWx1ZSt0aGlzLnZpZXdwb3J0TWluaW11bSxcbmM9MDxhW2VdLnNwYWNpbmcudG9TdHJpbmcoKS5pbmRleE9mKFwiJVwiKT9jKigxLXBhcnNlRmxvYXQoYVtlXS5zcGFjaW5nKS8xMDAqKGFbZV0uZW5kVmFsdWUtdGhpcy52aWV3cG9ydE1pbmltdW0pLyhhW2VdLmVuZFZhbHVlLWFbZV0uc3RhcnRWYWx1ZSkpOmMtTWF0aC5taW4oYVtlXS5zcGFjaW5nLDAuMSpjKSooYVtlXS5lbmRWYWx1ZS10aGlzLnZpZXdwb3J0TWluaW11bSkvKGFbZV0uZW5kVmFsdWUtYVtlXS5zdGFydFZhbHVlKSk6dGhpcy52aWV3cG9ydE1pbmltdW08PWFbZV0uc3RhcnRWYWx1ZSYmdGhpcy52aWV3cG9ydE1heGltdW08YVtlXS5lbmRWYWx1ZSYmKGI9Yi10aGlzLnZpZXdwb3J0TWF4aW11bSthW2VdLnN0YXJ0VmFsdWUsYz0wPGFbZV0uc3BhY2luZy50b1N0cmluZygpLmluZGV4T2YoXCIlXCIpP2MqKDEtcGFyc2VGbG9hdChhW2VdLnNwYWNpbmcpLzEwMCoodGhpcy52aWV3cG9ydE1heGltdW0tYVtlXS5zdGFydFZhbHVlKS8oYVtlXS5lbmRWYWx1ZS1hW2VdLnN0YXJ0VmFsdWUpKTpcbmMtTWF0aC5taW4oYVtlXS5zcGFjaW5nLDAuMSpjKSoodGhpcy52aWV3cG9ydE1heGltdW0tYVtlXS5zdGFydFZhbHVlKS8oYVtlXS5lbmRWYWx1ZS1hW2VdLnN0YXJ0VmFsdWUpKSk7ZC5taW5pbXVtPXRoaXMudmlld3BvcnRNaW5pbXVtO2QubWF4aW11bT10aGlzLnZpZXdwb3J0TWF4aW11bTtkLnJhbmdlPWI7aWYoXCJib3R0b21cIj09PXRoaXMuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5fcG9zaXRpb24pdGhpcy5sb2dhcml0aG1pYz8oZC5sbkxvZ2FyaXRobUJhc2U9TWF0aC5sb2codGhpcy5sb2dhcml0aG1CYXNlKSxkLnBpeGVsUGVyVW5pdD0odGhpcy5yZXZlcnNlZD8tMToxKSpjKmQubG5Mb2dhcml0aG1CYXNlL01hdGgubG9nKE1hdGguYWJzKGIpKSk6ZC5waXhlbFBlclVuaXQ9KHRoaXMucmV2ZXJzZWQ/LTE6MSkqYy9NYXRoLmFicyhiKSxkLnJlZmVyZW5jZT10aGlzLnJldmVyc2VkP3RoaXMubGluZUNvb3JkaW5hdGVzLngyOnRoaXMubGluZUNvb3JkaW5hdGVzLngxO2lmKFwibGVmdFwiPT09XG50aGlzLl9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5fcG9zaXRpb24pdGhpcy5sb2dhcml0aG1pYz8oZC5sbkxvZ2FyaXRobUJhc2U9TWF0aC5sb2codGhpcy5sb2dhcml0aG1CYXNlKSxkLnBpeGVsUGVyVW5pdD0odGhpcy5yZXZlcnNlZD8xOi0xKSpjKmQubG5Mb2dhcml0aG1CYXNlL01hdGgubG9nKE1hdGguYWJzKGIpKSk6ZC5waXhlbFBlclVuaXQ9KHRoaXMucmV2ZXJzZWQ/MTotMSkqYy9NYXRoLmFicyhiKSxkLnJlZmVyZW5jZT10aGlzLnJldmVyc2VkP3RoaXMubGluZUNvb3JkaW5hdGVzLnkxOnRoaXMubGluZUNvb3JkaW5hdGVzLnkyO3RoaXMuY29udmVyc2lvblBhcmFtZXRlcnM9ZH07QS5wcm90b3R5cGUuY2FsY3VsYXRlQXhpc1BhcmFtZXRlcnM9ZnVuY3Rpb24oKXtpZih0aGlzLmxvZ2FyaXRobWljKXRoaXMuY2FsY3VsYXRlTG9nYXJpdGhtaWNBeGlzUGFyYW1ldGVycygpO2Vsc2V7dmFyIGE9dGhpcy5jaGFydC5sYXlvdXRNYW5hZ2VyLmdldEZyZWVTcGFjZSgpLGQ9ITEsXG5jPSExO1wiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPyh0aGlzLm1heFdpZHRoPWEud2lkdGgsdGhpcy5tYXhIZWlnaHQ9YS5oZWlnaHQpOih0aGlzLm1heFdpZHRoPWEuaGVpZ2h0LHRoaXMubWF4SGVpZ2h0PWEud2lkdGgpO3ZhciBhPVwiYXhpc1hcIj09PXRoaXMudHlwZT9cInh5U3dhcHBlZFwiPT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50PzYyOjcwOlwieHlTd2FwcGVkXCI9PT10aGlzLmNoYXJ0LnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/NTA6NDAsYj00O1wiYXhpc1hcIj09PXRoaXMudHlwZSYmKGI9NjAwPnRoaXMubWF4V2lkdGg/ODo2KTt2YXIgYT1NYXRoLm1heChiLE1hdGguZmxvb3IodGhpcy5tYXhXaWR0aC9hKSksZSxmLGwsYj0wOyFyKHRoaXMub3B0aW9ucy52aWV3cG9ydE1pbmltdW0pJiYoIXIodGhpcy5vcHRpb25zLnZpZXdwb3J0TWF4aW11bSkmJnRoaXMub3B0aW9ucy52aWV3cG9ydE1pbmltdW0+PXRoaXMub3B0aW9ucy52aWV3cG9ydE1heGltdW0pJiZcbih0aGlzLnZpZXdwb3J0TWluaW11bT10aGlzLnZpZXdwb3J0TWF4aW11bT1udWxsKTtpZihyKHRoaXMub3B0aW9ucy52aWV3cG9ydE1pbmltdW0pJiYhcih0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtKSYmIWlzTmFOKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0pKXRoaXMudmlld3BvcnRNaW5pbXVtPXRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW07ZWxzZSBpZihudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKSl0aGlzLnZpZXdwb3J0TWluaW11bT10aGlzLm1pbmltdW07aWYocih0aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtKSYmIXIodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSkmJiFpc05hTih0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtKSl0aGlzLnZpZXdwb3J0TWF4aW11bT10aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtO1xuZWxzZSBpZihudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKSl0aGlzLnZpZXdwb3J0TWF4aW11bT10aGlzLm1heGltdW07aWYodGhpcy5zY2FsZUJyZWFrcylmb3IoYj0wO2I8dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrcy5sZW5ndGg7YisrKWlmKCghcih0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtKSYmdGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT49dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1tiXS5zdGFydFZhbHVlfHwhcih0aGlzLm9wdGlvbnMubWluaW11bSkmJnRoaXMub3B0aW9ucy5taW5pbXVtPj10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2JdLnN0YXJ0VmFsdWV8fCFyKHRoaXMub3B0aW9ucy52aWV3cG9ydE1pbmltdW0pJiZ0aGlzLnZpZXdwb3J0TWluaW11bT49dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1tiXS5zdGFydFZhbHVlKSYmXG4oIXIodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSkmJnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW08PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbYl0uZW5kVmFsdWV8fCFyKHRoaXMub3B0aW9ucy5tYXhpbXVtKSYmdGhpcy5vcHRpb25zLm1heGltdW08PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbYl0uZW5kVmFsdWV8fCFyKHRoaXMub3B0aW9ucy52aWV3cG9ydE1heGltdW0pJiZ0aGlzLnZpZXdwb3J0TWF4aW11bTw9dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1tiXS5lbmRWYWx1ZSkpe3RoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3Muc3BsaWNlKGIsMSk7YnJlYWt9aWYoXCJheGlzWFwiPT09dGhpcy50eXBlKXtpZih0aGlzLmRhdGFTZXJpZXMmJjA8dGhpcy5kYXRhU2VyaWVzLmxlbmd0aClmb3IoZT0wO2U8dGhpcy5kYXRhU2VyaWVzLmxlbmd0aDtlKyspXCJkYXRlVGltZVwiPT09dGhpcy5kYXRhU2VyaWVzW2VdLnhWYWx1ZVR5cGUmJlxuKGM9ITApO2U9bnVsbCE9PXRoaXMudmlld3BvcnRNaW5pbXVtP3RoaXMudmlld3BvcnRNaW5pbXVtOnRoaXMuZGF0YUluZm8udmlld1BvcnRNaW47Zj1udWxsIT09dGhpcy52aWV3cG9ydE1heGltdW0/dGhpcy52aWV3cG9ydE1heGltdW06dGhpcy5kYXRhSW5mby52aWV3UG9ydE1heDswPT09Zi1lJiYoYj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbD8wLjQ6dGhpcy5vcHRpb25zLmludGVydmFsLGYrPWIsZS09Yik7SW5maW5pdHkhPT10aGlzLmRhdGFJbmZvLm1pbkRpZmY/bD10aGlzLmRhdGFJbmZvLm1pbkRpZmY6MTxmLWU/bD0wLjUqTWF0aC5hYnMoZi1lKToobD0xLGMmJihkPSEwKSl9ZWxzZVwiYXhpc1lcIj09PXRoaXMudHlwZSYmKGU9bnVsbCE9PXRoaXMudmlld3BvcnRNaW5pbXVtP3RoaXMudmlld3BvcnRNaW5pbXVtOnRoaXMuZGF0YUluZm8udmlld1BvcnRNaW4sZj1udWxsIT09dGhpcy52aWV3cG9ydE1heGltdW0/dGhpcy52aWV3cG9ydE1heGltdW06XG50aGlzLmRhdGFJbmZvLnZpZXdQb3J0TWF4LGlzRmluaXRlKGUpfHxpc0Zpbml0ZShmKT9pc0Zpbml0ZShlKT9pc0Zpbml0ZShmKXx8KGY9ZSk6ZT1mOihmPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsPy1JbmZpbml0eTp0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsZT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbHx8aXNGaW5pdGUodGhpcy5kYXRhSW5mby5taW5EaWZmKT8wOkluZmluaXR5KSwwPT09ZSYmMD09PWY/KGYrPTksZT0wKTowPT09Zi1lPyhiPU1hdGgubWluKE1hdGguYWJzKDAuMDEqTWF0aC5hYnMoZikpLDUpLGYrPWIsZS09Yik6ZT5mPyhiPU1hdGgubWluKDAuMDEqTWF0aC5hYnModGhpcy5nZXRBcHBhcmVudERpZmZlcmVuY2UoZixlLG51bGwsITApKSw1KSwwPD1mP2U9Zi1iOmY9aXNGaW5pdGUoZSk/ZStiOjApOihiPU1hdGgubWluKDAuMDEqTWF0aC5hYnModGhpcy5nZXRBcHBhcmVudERpZmZlcmVuY2UoZSxmLFxubnVsbCwhMCkpLDAuMDUpLDAhPT1mJiYoZis9YiksMCE9PWUmJihlLT1iKSksbD1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6MTxmLWU/MC41Kk1hdGguYWJzKGYtZSk6MSx0aGlzLmluY2x1ZGVaZXJvJiYobnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWluaW11bSkpJiYwPGUmJihlPTApLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKSkmJjA+ZiYmKGY9MCkpO2I9dGhpcy5nZXRBcHBhcmVudERpZmZlcmVuY2UoaXNOYU4odGhpcy52aWV3cG9ydE1pbmltdW0pfHxudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW0/ZTp0aGlzLnZpZXdwb3J0TWluaW11bSxpc05hTih0aGlzLnZpZXdwb3J0TWF4aW11bSl8fG51bGw9PT10aGlzLnZpZXdwb3J0TWF4aW11bT9mOnRoaXMudmlld3BvcnRNYXhpbXVtLG51bGwsXG4hMCk7aWYoXCJheGlzWFwiPT09dGhpcy50eXBlJiZjKXt0aGlzLnZhbHVlVHlwZT1cImRhdGVUaW1lXCI7dGhpcy5pbnRlcnZhbFR5cGV8fChiLzE8PWE/KHRoaXMuaW50ZXJ2YWw9MSx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmIvMjw9YT8odGhpcy5pbnRlcnZhbD0yLHRoaXMuaW50ZXJ2YWxUeXBlPVwibWlsbGlzZWNvbmRcIik6Yi81PD1hPyh0aGlzLmludGVydmFsPTUsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaWxsaXNlY29uZFwiKTpiLzEwPD1hPyh0aGlzLmludGVydmFsPTEwLHRoaXMuaW50ZXJ2YWxUeXBlPVwibWlsbGlzZWNvbmRcIik6Yi8yMDw9YT8odGhpcy5pbnRlcnZhbD0yMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmIvNTA8PWE/KHRoaXMuaW50ZXJ2YWw9NTAsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaWxsaXNlY29uZFwiKTpiLzEwMDw9YT8odGhpcy5pbnRlcnZhbD0xMDAsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaWxsaXNlY29uZFwiKTpiLzIwMDw9YT8odGhpcy5pbnRlcnZhbD1cbjIwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmIvMjUwPD1hPyh0aGlzLmludGVydmFsPTI1MCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmIvMzAwPD1hPyh0aGlzLmludGVydmFsPTMwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmIvNDAwPD1hPyh0aGlzLmludGVydmFsPTQwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmIvNTAwPD1hPyh0aGlzLmludGVydmFsPTUwMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbGxpc2Vjb25kXCIpOmIvKDEqVC5zZWNvbmREdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MSx0aGlzLmludGVydmFsVHlwZT1cInNlY29uZFwiKTpiLygyKlQuc2Vjb25kRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTIsdGhpcy5pbnRlcnZhbFR5cGU9XCJzZWNvbmRcIik6Yi8oNSpULnNlY29uZER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD01LHRoaXMuaW50ZXJ2YWxUeXBlPVwic2Vjb25kXCIpOmIvKDEwKlQuc2Vjb25kRHVyYXRpb24pPD1cbmE/KHRoaXMuaW50ZXJ2YWw9MTAsdGhpcy5pbnRlcnZhbFR5cGU9XCJzZWNvbmRcIik6Yi8oMTUqVC5zZWNvbmREdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MTUsdGhpcy5pbnRlcnZhbFR5cGU9XCJzZWNvbmRcIik6Yi8oMjAqVC5zZWNvbmREdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MjAsdGhpcy5pbnRlcnZhbFR5cGU9XCJzZWNvbmRcIik6Yi8oMzAqVC5zZWNvbmREdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MzAsdGhpcy5pbnRlcnZhbFR5cGU9XCJzZWNvbmRcIik6Yi8oMSpULm1pbnV0ZUR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0xLHRoaXMuaW50ZXJ2YWxUeXBlPVwibWludXRlXCIpOmIvKDIqVC5taW51dGVEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9Mix0aGlzLmludGVydmFsVHlwZT1cIm1pbnV0ZVwiKTpiLyg1KlQubWludXRlRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTUsdGhpcy5pbnRlcnZhbFR5cGU9XCJtaW51dGVcIik6Yi8oMTAqVC5taW51dGVEdXJhdGlvbik8PVxuYT8odGhpcy5pbnRlcnZhbD0xMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbnV0ZVwiKTpiLygxNSpULm1pbnV0ZUR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0xNSx0aGlzLmludGVydmFsVHlwZT1cIm1pbnV0ZVwiKTpiLygyMCpULm1pbnV0ZUR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0yMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbnV0ZVwiKTpiLygzMCpULm1pbnV0ZUR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0zMCx0aGlzLmludGVydmFsVHlwZT1cIm1pbnV0ZVwiKTpiLygxKlQuaG91ckR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0xLHRoaXMuaW50ZXJ2YWxUeXBlPVwiaG91clwiKTpiLygyKlQuaG91ckR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0yLHRoaXMuaW50ZXJ2YWxUeXBlPVwiaG91clwiKTpiLygzKlQuaG91ckR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0zLHRoaXMuaW50ZXJ2YWxUeXBlPVwiaG91clwiKTpiLyg2KlQuaG91ckR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD1cbjYsdGhpcy5pbnRlcnZhbFR5cGU9XCJob3VyXCIpOmIvKDEqVC5kYXlEdXJhdGlvbik8PWE/KHRoaXMuaW50ZXJ2YWw9MSx0aGlzLmludGVydmFsVHlwZT1cImRheVwiKTpiLygyKlQuZGF5RHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTIsdGhpcy5pbnRlcnZhbFR5cGU9XCJkYXlcIik6Yi8oNCpULmRheUR1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD00LHRoaXMuaW50ZXJ2YWxUeXBlPVwiZGF5XCIpOmIvKDEqVC53ZWVrRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTEsdGhpcy5pbnRlcnZhbFR5cGU9XCJ3ZWVrXCIpOmIvKDIqVC53ZWVrRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTIsdGhpcy5pbnRlcnZhbFR5cGU9XCJ3ZWVrXCIpOmIvKDMqVC53ZWVrRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTMsdGhpcy5pbnRlcnZhbFR5cGU9XCJ3ZWVrXCIpOmIvKDEqVC5tb250aER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0xLHRoaXMuaW50ZXJ2YWxUeXBlPVwibW9udGhcIik6Yi8oMipULm1vbnRoRHVyYXRpb24pPD1cbmE/KHRoaXMuaW50ZXJ2YWw9Mix0aGlzLmludGVydmFsVHlwZT1cIm1vbnRoXCIpOmIvKDMqVC5tb250aER1cmF0aW9uKTw9YT8odGhpcy5pbnRlcnZhbD0zLHRoaXMuaW50ZXJ2YWxUeXBlPVwibW9udGhcIik6Yi8oNipULm1vbnRoRHVyYXRpb24pPD1hPyh0aGlzLmludGVydmFsPTYsdGhpcy5pbnRlcnZhbFR5cGU9XCJtb250aFwiKToodGhpcy5pbnRlcnZhbD1iLygxKlQueWVhckR1cmF0aW9uKTw9YT8xOmIvKDIqVC55ZWFyRHVyYXRpb24pPD1hPzI6Yi8oNCpULnllYXJEdXJhdGlvbik8PWE/NDpNYXRoLmZsb29yKEEuZ2V0TmljZU51bWJlcihiLyhhLTEpLCEwKS9ULnllYXJEdXJhdGlvbiksdGhpcy5pbnRlcnZhbFR5cGU9XCJ5ZWFyXCIpKTtpZihudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKSl0aGlzLnZpZXdwb3J0TWluaW11bT1lLWwvMjtpZihudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKSl0aGlzLnZpZXdwb3J0TWF4aW11bT1cbmYrbC8yO2Q/dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmc9XCJNTU0gREQgWVlZWSBISDptbVwiOlwieWVhclwiPT09dGhpcy5pbnRlcnZhbFR5cGU/dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmc9XCJZWVlZXCI6XCJtb250aFwiPT09dGhpcy5pbnRlcnZhbFR5cGU/dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmc9XCJNTU0gWVlZWVwiOlwid2Vla1wiPT09dGhpcy5pbnRlcnZhbFR5cGU/dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmc9XCJNTU0gREQgWVlZWVwiOlwiZGF5XCI9PT10aGlzLmludGVydmFsVHlwZT90aGlzLmF1dG9WYWx1ZUZvcm1hdFN0cmluZz1cIk1NTSBERCBZWVlZXCI6XCJob3VyXCI9PT10aGlzLmludGVydmFsVHlwZT90aGlzLmF1dG9WYWx1ZUZvcm1hdFN0cmluZz1cImhoOm1tIFRUXCI6XCJtaW51dGVcIj09PXRoaXMuaW50ZXJ2YWxUeXBlP3RoaXMuYXV0b1ZhbHVlRm9ybWF0U3RyaW5nPVwiaGg6bW0gVFRcIjpcInNlY29uZFwiPT09dGhpcy5pbnRlcnZhbFR5cGU/dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmc9XG5cImhoOm1tOnNzIFRUXCI6XCJtaWxsaXNlY29uZFwiPT09dGhpcy5pbnRlcnZhbFR5cGUmJih0aGlzLmF1dG9WYWx1ZUZvcm1hdFN0cmluZz1cImZmZidtcydcIik7dGhpcy52YWx1ZUZvcm1hdFN0cmluZ3x8KHRoaXMudmFsdWVGb3JtYXRTdHJpbmc9dGhpcy5hdXRvVmFsdWVGb3JtYXRTdHJpbmcpfWVsc2V7dGhpcy5pbnRlcnZhbFR5cGU9XCJudW1iZXJcIjtiPUEuZ2V0TmljZU51bWJlcihiLCExKTt0aGlzLmludGVydmFsPXRoaXMub3B0aW9ucyYmMDx0aGlzLm9wdGlvbnMuaW50ZXJ2YWw/dGhpcy5vcHRpb25zLmludGVydmFsOkEuZ2V0TmljZU51bWJlcihiLyhhLTEpLCEwKTtpZihudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKSl0aGlzLnZpZXdwb3J0TWluaW11bT1cImF4aXNYXCI9PT10aGlzLnR5cGU/ZS1sLzI6TWF0aC5mbG9vcihlL3RoaXMuaW50ZXJ2YWwpKnRoaXMuaW50ZXJ2YWw7aWYobnVsbD09PXRoaXMudmlld3BvcnRNYXhpbXVtfHxcbmlzTmFOKHRoaXMudmlld3BvcnRNYXhpbXVtKSl0aGlzLnZpZXdwb3J0TWF4aW11bT1cImF4aXNYXCI9PT10aGlzLnR5cGU/ZitsLzI6TWF0aC5jZWlsKGYvdGhpcy5pbnRlcnZhbCkqdGhpcy5pbnRlcnZhbDswPT09dGhpcy52aWV3cG9ydE1heGltdW0mJjA9PT10aGlzLnZpZXdwb3J0TWluaW11bSYmKDA9PT10aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtP3RoaXMudmlld3BvcnRNYXhpbXVtKz0xMDowPT09dGhpcy5vcHRpb25zLnZpZXdwb3J0TWF4aW11bSYmKHRoaXMudmlld3BvcnRNaW5pbXVtLT0xMCksdGhpcy5vcHRpb25zJiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbCYmKHRoaXMuaW50ZXJ2YWw9QS5nZXROaWNlTnVtYmVyKCh0aGlzLnZpZXdwb3J0TWF4aW11bS10aGlzLnZpZXdwb3J0TWluaW11bSkvKGEtMSksITApKSl9aWYobnVsbD09PXRoaXMubWluaW11bXx8bnVsbD09PXRoaXMubWF4aW11bSlpZihcImF4aXNYXCI9PT10aGlzLnR5cGU/KGU9XG5udWxsIT09dGhpcy5taW5pbXVtP3RoaXMubWluaW11bTp0aGlzLmRhdGFJbmZvLm1pbixmPW51bGwhPT10aGlzLm1heGltdW0/dGhpcy5tYXhpbXVtOnRoaXMuZGF0YUluZm8ubWF4LDA9PT1mLWUmJihiPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsPzAuNDp0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsZis9YixlLT1iKSxsPUluZmluaXR5IT09dGhpcy5kYXRhSW5mby5taW5EaWZmP3RoaXMuZGF0YUluZm8ubWluRGlmZjoxPGYtZT8wLjUqTWF0aC5hYnMoZi1lKToxKTpcImF4aXNZXCI9PT10aGlzLnR5cGUmJihlPW51bGwhPT10aGlzLm1pbmltdW0/dGhpcy5taW5pbXVtOnRoaXMuZGF0YUluZm8ubWluLGY9bnVsbCE9PXRoaXMubWF4aW11bT90aGlzLm1heGltdW06dGhpcy5kYXRhSW5mby5tYXgsaXNGaW5pdGUoZSl8fGlzRmluaXRlKGYpPzA9PT1lJiYwPT09Zj8oZis9OSxlPTApOjA9PT1mLWU/KGI9TWF0aC5taW4oTWF0aC5hYnMoMC4wMSpNYXRoLmFicyhmKSksXG41KSxmKz1iLGUtPWIpOmU+Zj8oYj1NYXRoLm1pbigwLjAxKk1hdGguYWJzKHRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGYsZSxudWxsLCEwKSksNSksMDw9Zj9lPWYtYjpmPWlzRmluaXRlKGUpP2UrYjowKTooYj1NYXRoLm1pbigwLjAxKk1hdGguYWJzKHRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGUsZixudWxsLCEwKSksMC4wNSksMCE9PWYmJihmKz1iKSwwIT09ZSYmKGUtPWIpKTooZj1cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbD8tSW5maW5pdHk6dGhpcy5vcHRpb25zLmludGVydmFsLGU9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLm9wdGlvbnMuaW50ZXJ2YWx8fGlzRmluaXRlKHRoaXMuZGF0YUluZm8ubWluRGlmZik/MDpJbmZpbml0eSksbD1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6MTxmLWU/MC41Kk1hdGguYWJzKGYtZSk6MSx0aGlzLmluY2x1ZGVaZXJvJiYobnVsbD09PXRoaXMubWluaW11bXx8XG5pc05hTih0aGlzLm1pbmltdW0pKSYmMDxlJiYoZT0wKSx0aGlzLmluY2x1ZGVaZXJvJiYobnVsbD09PXRoaXMubWF4aW11bXx8aXNOYU4odGhpcy5tYXhpbXVtKSkmJjA+ZiYmKGY9MCkpLE1hdGguYWJzKHRoaXMuZ2V0QXBwYXJlbnREaWZmZXJlbmNlKGUsZixudWxsLCEwKSksXCJheGlzWFwiPT09dGhpcy50eXBlJiZjKXt0aGlzLnZhbHVlVHlwZT1cImRhdGVUaW1lXCI7aWYobnVsbD09PXRoaXMubWluaW11bXx8aXNOYU4odGhpcy5taW5pbXVtKSl0aGlzLm1pbmltdW09ZS1sLzIsdGhpcy5taW5pbXVtPU1hdGgubWluKHRoaXMubWluaW11bSxudWxsPT09dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bXx8aXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bSk/SW5maW5pdHk6dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bSk7aWYobnVsbD09PXRoaXMubWF4aW11bXx8aXNOYU4odGhpcy5tYXhpbXVtKSl0aGlzLm1heGltdW09XG5mK2wvMix0aGlzLm1heGltdW09TWF0aC5tYXgodGhpcy5tYXhpbXVtLG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtKT8tSW5maW5pdHk6dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWF4aW11bSl9ZWxzZSB0aGlzLmludGVydmFsVHlwZT10aGlzLnZhbHVlVHlwZT1cIm51bWJlclwiLG51bGw9PT10aGlzLm1pbmltdW0mJih0aGlzLm1pbmltdW09XCJheGlzWFwiPT09dGhpcy50eXBlP2UtbC8yOk1hdGguZmxvb3IoZS90aGlzLmludGVydmFsKSp0aGlzLmludGVydmFsLHRoaXMubWluaW11bT1NYXRoLm1pbih0aGlzLm1pbmltdW0sbnVsbD09PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW0pP0luZmluaXR5OnRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW0pKSxcbm51bGw9PT10aGlzLm1heGltdW0mJih0aGlzLm1heGltdW09XCJheGlzWFwiPT09dGhpcy50eXBlP2YrbC8yOk1hdGguY2VpbChmL3RoaXMuaW50ZXJ2YWwpKnRoaXMuaW50ZXJ2YWwsdGhpcy5tYXhpbXVtPU1hdGgubWF4KHRoaXMubWF4aW11bSxudWxsPT09dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWF4aW11bXx8aXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWF4aW11bSk/LUluZmluaXR5OnRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1heGltdW0pKSwwPT09dGhpcy5tYXhpbXVtJiYwPT09dGhpcy5taW5pbXVtJiYoMD09PXRoaXMub3B0aW9ucy5taW5pbXVtP3RoaXMubWF4aW11bSs9MTA6MD09PXRoaXMub3B0aW9ucy5tYXhpbXVtJiYodGhpcy5taW5pbXVtLT0xMCkpO3IodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bSkmJih0aGlzLnZpZXdwb3J0TWluaW11bT1NYXRoLm1heCh0aGlzLnZpZXdwb3J0TWluaW11bSx0aGlzLm1pbmltdW0pKTtcbnIodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWF4aW11bSkmJih0aGlzLnZpZXdwb3J0TWF4aW11bT1NYXRoLm1pbih0aGlzLnZpZXdwb3J0TWF4aW11bSx0aGlzLm1heGltdW0pKTt0aGlzLnJhbmdlPXRoaXMudmlld3BvcnRNYXhpbXVtLXRoaXMudmlld3BvcnRNaW5pbXVtO3RoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uPVwiYXhpc1hcIj09PXRoaXMudHlwZSYmYz90aGlzLmdldExhYmVsU3RhcnRQb2ludChuZXcgRGF0ZSh0aGlzLnZpZXdwb3J0TWluaW11bSksdGhpcy5pbnRlcnZhbFR5cGUsdGhpcy5pbnRlcnZhbCk6TWF0aC5mbG9vcigodGhpcy52aWV3cG9ydE1pbmltdW0rMC4yKnRoaXMuaW50ZXJ2YWwpL3RoaXMuaW50ZXJ2YWwpKnRoaXMuaW50ZXJ2YWw7dGhpcy52YWx1ZUZvcm1hdFN0cmluZ3x8KHRoaXMudmFsdWVGb3JtYXRTdHJpbmc9QS5nZW5lcmF0ZVZhbHVlRm9ybWF0U3RyaW5nKHRoaXMucmFuZ2UsMikpfX07QS5wcm90b3R5cGUuY2FsY3VsYXRlTG9nYXJpdGhtaWNBeGlzUGFyYW1ldGVycz1cbmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydC5sYXlvdXRNYW5hZ2VyLmdldEZyZWVTcGFjZSgpLGQ9TWF0aC5sb2codGhpcy5sb2dhcml0aG1CYXNlKSxjO1wiYm90dG9tXCI9PT10aGlzLl9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuX3Bvc2l0aW9uPyh0aGlzLm1heFdpZHRoPWEud2lkdGgsdGhpcy5tYXhIZWlnaHQ9YS5oZWlnaHQpOih0aGlzLm1heFdpZHRoPWEuaGVpZ2h0LHRoaXMubWF4SGVpZ2h0PWEud2lkdGgpO3ZhciBhPVwiYXhpc1hcIj09PXRoaXMudHlwZT81MDA+dGhpcy5tYXhXaWR0aD83Ok1hdGgubWF4KDcsTWF0aC5mbG9vcih0aGlzLm1heFdpZHRoLzEwMCkpOk1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5tYXhXaWR0aC81MCksMyksYixlLGYsbDtsPTE7aWYobnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWluaW11bSkpdGhpcy52aWV3cG9ydE1pbmltdW09dGhpcy5taW5pbXVtO2lmKG51bGw9PT10aGlzLnZpZXdwb3J0TWF4aW11bXx8XG5pc05hTih0aGlzLnZpZXdwb3J0TWF4aW11bSkpdGhpcy52aWV3cG9ydE1heGltdW09dGhpcy5tYXhpbXVtO2lmKHRoaXMuc2NhbGVCcmVha3MpZm9yKGw9MDtsPHRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3MubGVuZ3RoO2wrKylpZigoIXIodGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bSkmJnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW0+PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbbF0uc3RhcnRWYWx1ZXx8IXIodGhpcy5vcHRpb25zLm1pbmltdW0pJiZ0aGlzLm9wdGlvbnMubWluaW11bT49dGhpcy5zY2FsZUJyZWFrcy5fYXBwbGllZEJyZWFrc1tsXS5zdGFydFZhbHVlfHwhcih0aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtKSYmdGhpcy52aWV3cG9ydE1pbmltdW0+PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbbF0uc3RhcnRWYWx1ZSkmJighcih0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtKSYmXG50aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtPD10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2xdLmVuZFZhbHVlfHwhcih0aGlzLm9wdGlvbnMubWF4aW11bSkmJnRoaXMub3B0aW9ucy5tYXhpbXVtPD10aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzW2xdLmVuZFZhbHVlfHwhcih0aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtKSYmdGhpcy52aWV3cG9ydE1heGltdW08PXRoaXMuc2NhbGVCcmVha3MuX2FwcGxpZWRCcmVha3NbbF0uZW5kVmFsdWUpKXt0aGlzLnNjYWxlQnJlYWtzLl9hcHBsaWVkQnJlYWtzLnNwbGljZShsLDEpO2JyZWFrfVwiYXhpc1hcIj09PXRoaXMudHlwZT8oYj1udWxsIT09dGhpcy52aWV3cG9ydE1pbmltdW0/dGhpcy52aWV3cG9ydE1pbmltdW06dGhpcy5kYXRhSW5mby52aWV3UG9ydE1pbixlPW51bGwhPT10aGlzLnZpZXdwb3J0TWF4aW11bT90aGlzLnZpZXdwb3J0TWF4aW11bTp0aGlzLmRhdGFJbmZvLnZpZXdQb3J0TWF4LFxuMT09PWUvYiYmKGw9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLFwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsPzAuNDp0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpLGUqPWwsYi89bCksZj1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6ZS9iPnRoaXMubG9nYXJpdGhtQmFzZT9lL2IqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlKTpcImF4aXNZXCI9PT10aGlzLnR5cGUmJihiPW51bGwhPT10aGlzLnZpZXdwb3J0TWluaW11bT90aGlzLnZpZXdwb3J0TWluaW11bTp0aGlzLmRhdGFJbmZvLnZpZXdQb3J0TWluLGU9bnVsbCE9PXRoaXMudmlld3BvcnRNYXhpbXVtP3RoaXMudmlld3BvcnRNYXhpbXVtOnRoaXMuZGF0YUluZm8udmlld1BvcnRNYXgsMD49YiYmIWlzRmluaXRlKGUpPyhlPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsPzA6XG50aGlzLm9wdGlvbnMuaW50ZXJ2YWwsYj0xKTowPj1iP2I9ZTppc0Zpbml0ZShlKXx8KGU9YiksMT09PWImJjE9PT1lPyhlKj10aGlzLmxvZ2FyaXRobUJhc2UtMS90aGlzLmxvZ2FyaXRobUJhc2UsYj0xKToxPT09ZS9iPyhsPU1hdGgubWluKGUqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuMDEpLE1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSw1KSksZSo9bCxiLz1sKTpiPmU/KGw9TWF0aC5taW4oYi9lKk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSwwLjAxKSxNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsNSkpLDE8PWU/Yj1lL2w6ZT1iKmwpOihsPU1hdGgubWluKGUvYipNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsMC4wMSksTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuMDQpKSwxIT09ZSYmKGUqPWwpLDEhPT1iJiYoYi89bCkpLGY9SW5maW5pdHkhPT10aGlzLmRhdGFJbmZvLm1pbkRpZmY/dGhpcy5kYXRhSW5mby5taW5EaWZmOmUvYj50aGlzLmxvZ2FyaXRobUJhc2U/XG5lL2IqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09dGhpcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKSkmJjE8YiYmKGI9MSksdGhpcy5pbmNsdWRlWmVybyYmKG51bGw9PT10aGlzLnZpZXdwb3J0TWF4aW11bXx8aXNOYU4odGhpcy52aWV3cG9ydE1heGltdW0pKSYmMT5lJiYoZT0xKSk7bD0oaXNOYU4odGhpcy52aWV3cG9ydE1heGltdW0pfHxudWxsPT09dGhpcy52aWV3cG9ydE1heGltdW0/ZTp0aGlzLnZpZXdwb3J0TWF4aW11bSkvKGlzTmFOKHRoaXMudmlld3BvcnRNaW5pbXVtKXx8bnVsbD09PXRoaXMudmlld3BvcnRNaW5pbXVtP2I6dGhpcy52aWV3cG9ydE1pbmltdW0pO3ZhciBoPShpc05hTih0aGlzLnZpZXdwb3J0TWF4aW11bSl8fG51bGw9PT10aGlzLnZpZXdwb3J0TWF4aW11bT9lOnRoaXMudmlld3BvcnRNYXhpbXVtKS0oaXNOYU4odGhpcy52aWV3cG9ydE1pbmltdW0pfHxcbm51bGw9PT10aGlzLnZpZXdwb3J0TWluaW11bT9iOnRoaXMudmlld3BvcnRNaW5pbXVtKTt0aGlzLmludGVydmFsVHlwZT1cIm51bWJlclwiO2w9TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLEEuZ2V0TmljZU51bWJlcihNYXRoLmFicyhNYXRoLmxvZyhsKS9kKSwhMSkpO3RoaXMub3B0aW9ucyYmMDx0aGlzLm9wdGlvbnMuaW50ZXJ2YWw/dGhpcy5pbnRlcnZhbD10aGlzLm9wdGlvbnMuaW50ZXJ2YWw6KHRoaXMuaW50ZXJ2YWw9QS5nZXROaWNlRXhwb25lbnQoTWF0aC5sb2cobCkvZC8oYS0xKSwhMCksYz1BLmdldE5pY2VOdW1iZXIoaC8oYS0xKSwhMCkpO2lmKG51bGw9PT10aGlzLnZpZXdwb3J0TWluaW11bXx8aXNOYU4odGhpcy52aWV3cG9ydE1pbmltdW0pKXRoaXMudmlld3BvcnRNaW5pbXVtPVwiYXhpc1hcIj09PXRoaXMudHlwZT9iL01hdGguc3FydChmKTpNYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsdGhpcy5pbnRlcnZhbCpNYXRoLmZsb29yKE1hdGgubG9nKGIpL2QvdGhpcy5pbnRlcnZhbCkpO1xuaWYobnVsbD09PXRoaXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnZpZXdwb3J0TWF4aW11bSkpdGhpcy52aWV3cG9ydE1heGltdW09XCJheGlzWFwiPT09dGhpcy50eXBlP2UqTWF0aC5zcXJ0KGYpOk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSx0aGlzLmludGVydmFsKk1hdGguY2VpbChNYXRoLmxvZyhlKS9kL3RoaXMuaW50ZXJ2YWwpKTsxPT09dGhpcy52aWV3cG9ydE1heGltdW0mJjE9PT10aGlzLnZpZXdwb3J0TWluaW11bSYmKDE9PT10aGlzLm9wdGlvbnMudmlld3BvcnRNaW5pbXVtP3RoaXMudmlld3BvcnRNYXhpbXVtKj10aGlzLmxvZ2FyaXRobUJhc2UtMS90aGlzLmxvZ2FyaXRobUJhc2U6MT09PXRoaXMub3B0aW9ucy52aWV3cG9ydE1heGltdW0mJih0aGlzLnZpZXdwb3J0TWluaW11bS89dGhpcy5sb2dhcml0aG1CYXNlLTEvdGhpcy5sb2dhcml0aG1CYXNlKSx0aGlzLm9wdGlvbnMmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsJiZcbih0aGlzLmludGVydmFsPUEuZ2V0TmljZUV4cG9uZW50KE1hdGguY2VpbChNYXRoLmxvZyhsKS9kKS8oYS0xKSksYz1BLmdldE5pY2VOdW1iZXIoKHRoaXMudmlld3BvcnRNYXhpbXVtLXRoaXMudmlld3BvcnRNaW5pbXVtKS8oYS0xKSwhMCkpKTtpZihudWxsPT09dGhpcy5taW5pbXVtfHxudWxsPT09dGhpcy5tYXhpbXVtKVwiYXhpc1hcIj09PXRoaXMudHlwZT8oYj1udWxsIT09dGhpcy5taW5pbXVtP3RoaXMubWluaW11bTp0aGlzLmRhdGFJbmZvLm1pbixlPW51bGwhPT10aGlzLm1heGltdW0/dGhpcy5tYXhpbXVtOnRoaXMuZGF0YUluZm8ubWF4LDE9PT1lL2ImJihsPU1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMub3B0aW9ucy5pbnRlcnZhbD8wLjQ6dGhpcy5vcHRpb25zLmludGVydmFsKSxlKj1sLGIvPWwpLGY9SW5maW5pdHkhPT10aGlzLmRhdGFJbmZvLm1pbkRpZmY/dGhpcy5kYXRhSW5mby5taW5EaWZmOmUvYj50aGlzLmxvZ2FyaXRobUJhc2U/XG5lL2IqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlKTpcImF4aXNZXCI9PT10aGlzLnR5cGUmJihiPW51bGwhPT10aGlzLm1pbmltdW0/dGhpcy5taW5pbXVtOnRoaXMuZGF0YUluZm8ubWluLGU9bnVsbCE9PXRoaXMubWF4aW11bT90aGlzLm1heGltdW06dGhpcy5kYXRhSW5mby5tYXgsaXNGaW5pdGUoYil8fGlzRmluaXRlKGUpPzE9PT1iJiYxPT09ZT8oZSo9dGhpcy5sb2dhcml0aG1CYXNlLGIvPXRoaXMubG9nYXJpdGhtQmFzZSk6MT09PWUvYj8obD1NYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsdGhpcy5pbnRlcnZhbCksZSo9bCxiLz1sKTpiPmU/KGw9TWF0aC5taW4oMC4wMSooYi9lKSw1KSwxPD1lP2I9ZS9sOmU9YipsKToobD1NYXRoLm1pbihlL2IqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuMDEpLE1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSwwLjA0KSksMSE9PWUmJihlKj1sKSwxIT09YiYmKGIvPWwpKTooZT1cInVuZGVmaW5lZFwiPT09XG50eXBlb2YgdGhpcy5vcHRpb25zLmludGVydmFsPzA6dGhpcy5vcHRpb25zLmludGVydmFsLGI9MSksZj1JbmZpbml0eSE9PXRoaXMuZGF0YUluZm8ubWluRGlmZj90aGlzLmRhdGFJbmZvLm1pbkRpZmY6ZS9iPnRoaXMubG9nYXJpdGhtQmFzZT9lL2IqTWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDAuNSk6dGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW5jbHVkZVplcm8mJihudWxsPT09dGhpcy5taW5pbXVtfHxpc05hTih0aGlzLm1pbmltdW0pKSYmMTxiJiYoYj0xKSx0aGlzLmluY2x1ZGVaZXJvJiYobnVsbD09PXRoaXMubWF4aW11bXx8aXNOYU4odGhpcy5tYXhpbXVtKSkmJjE+ZSYmKGU9MSkpLHRoaXMuaW50ZXJ2YWxUeXBlPVwibnVtYmVyXCIsbnVsbD09PXRoaXMubWluaW11bSYmKHRoaXMubWluaW11bT1cImF4aXNYXCI9PT10aGlzLnR5cGU/Yi9NYXRoLnNxcnQoZik6TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLHRoaXMuaW50ZXJ2YWwqTWF0aC5mbG9vcihNYXRoLmxvZyhiKS9cbmQvdGhpcy5pbnRlcnZhbCkpLHIobnVsbD09PXRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW18fGlzTmFOKHRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW0pP1widW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5zZXNzaW9uVmFyaWFibGVzLm5ld1ZpZXdwb3J0TWluaW11bT9JbmZpbml0eTp0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1pbmltdW0pfHwodGhpcy5taW5pbXVtPU1hdGgubWluKHRoaXMubWluaW11bSxudWxsPT09dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bXx8aXNOYU4odGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWluaW11bSk/XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNaW5pbXVtP0luZmluaXR5OnRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1pbmltdW06XG50aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNaW5pbXVtKSkpLG51bGw9PT10aGlzLm1heGltdW0mJih0aGlzLm1heGltdW09XCJheGlzWFwiPT09dGhpcy50eXBlP2UqTWF0aC5zcXJ0KGYpOk1hdGgucG93KHRoaXMubG9nYXJpdGhtQmFzZSx0aGlzLmludGVydmFsKk1hdGguY2VpbChNYXRoLmxvZyhlKS9kL3RoaXMuaW50ZXJ2YWwpKSxyKG51bGw9PT10aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtfHxpc05hTih0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtKT9cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW0/MDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1heGltdW0pfHwodGhpcy5tYXhpbXVtPU1hdGgubWF4KHRoaXMubWF4aW11bSxudWxsPT09dGhpcy5zZXNzaW9uVmFyaWFibGVzLnZpZXdwb3J0TWF4aW11bXx8XG5pc05hTih0aGlzLnNlc3Npb25WYXJpYWJsZXMudmlld3BvcnRNYXhpbXVtKT9cInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMuc2Vzc2lvblZhcmlhYmxlcy5uZXdWaWV3cG9ydE1heGltdW0/MDp0aGlzLnNlc3Npb25WYXJpYWJsZXMubmV3Vmlld3BvcnRNYXhpbXVtOnRoaXMuc2Vzc2lvblZhcmlhYmxlcy52aWV3cG9ydE1heGltdW0pKSksMT09PXRoaXMubWF4aW11bSYmMT09PXRoaXMubWluaW11bSYmKDE9PT10aGlzLm9wdGlvbnMubWluaW11bT90aGlzLm1heGltdW0qPXRoaXMubG9nYXJpdGhtQmFzZS0xL3RoaXMubG9nYXJpdGhtQmFzZToxPT09dGhpcy5vcHRpb25zLm1heGltdW0mJih0aGlzLm1pbmltdW0vPXRoaXMubG9nYXJpdGhtQmFzZS0xL3RoaXMubG9nYXJpdGhtQmFzZSkpO3RoaXMudmlld3BvcnRNaW5pbXVtPU1hdGgubWF4KHRoaXMudmlld3BvcnRNaW5pbXVtLHRoaXMubWluaW11bSk7dGhpcy52aWV3cG9ydE1heGltdW09TWF0aC5taW4odGhpcy52aWV3cG9ydE1heGltdW0sXG50aGlzLm1heGltdW0pO3RoaXMudmlld3BvcnRNaW5pbXVtPnRoaXMudmlld3BvcnRNYXhpbXVtJiYoIXRoaXMub3B0aW9ucy52aWV3cG9ydE1pbmltdW0mJiF0aGlzLm9wdGlvbnMubWluaW11bXx8dGhpcy5vcHRpb25zLnZpZXdwb3J0TWF4aW11bXx8dGhpcy5vcHRpb25zLm1heGltdW0/dGhpcy5vcHRpb25zLnZpZXdwb3J0TWluaW11bXx8dGhpcy5vcHRpb25zLm1pbmltdW18fCF0aGlzLm9wdGlvbnMudmlld3BvcnRNYXhpbXVtJiYhdGhpcy5vcHRpb25zLm1heGltdW18fCh0aGlzLnZpZXdwb3J0TWluaW11bT10aGlzLm1pbmltdW09KHRoaXMub3B0aW9ucy52aWV3cG9ydE1heGltdW18fHRoaXMub3B0aW9ucy5tYXhpbXVtKS9NYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsMipNYXRoLmNlaWwodGhpcy5pbnRlcnZhbCkpKTp0aGlzLnZpZXdwb3J0TWF4aW11bT10aGlzLm1heGltdW09dGhpcy5vcHRpb25zLnZpZXdwb3J0TWluaW11bXx8dGhpcy5vcHRpb25zLm1pbmltdW0pO2I9XG5NYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsTWF0aC5mbG9vcihNYXRoLmxvZyh0aGlzLnZpZXdwb3J0TWluaW11bSkvKGQqdGhpcy5pbnRlcnZhbCkrMC4yKSp0aGlzLmludGVydmFsKTt0aGlzLnJhbmdlPXRoaXMudmlld3BvcnRNYXhpbXVtL3RoaXMudmlld3BvcnRNaW5pbXVtO3RoaXMubm9UaWNrcz1hO2lmKCF0aGlzLm9wdGlvbnMuaW50ZXJ2YWwmJnRoaXMucmFuZ2U8TWF0aC5wb3codGhpcy5sb2dhcml0aG1CYXNlLDg+dGhpcy52aWV3cG9ydE1heGltdW18fDM+YT8yOjMpKXtmb3IoZD1NYXRoLmZsb29yKHRoaXMudmlld3BvcnRNaW5pbXVtL2MrMC41KSpjO2Q8dGhpcy52aWV3cG9ydE1pbmltdW07KWQrPWM7dGhpcy5lcXVpZGlzdGFudEludGVydmFsPSExO3RoaXMuaW50ZXJ2YWxTdGFydFBvc2l0aW9uPWQ7dGhpcy5pbnRlcnZhbD1jfWVsc2UgdGhpcy5vcHRpb25zLmludGVydmFsfHwoYz1NYXRoLmNlaWwodGhpcy5pbnRlcnZhbCksdGhpcy5yYW5nZT50aGlzLmludGVydmFsJiZcbih0aGlzLmludGVydmFsPWMsYj1NYXRoLnBvdyh0aGlzLmxvZ2FyaXRobUJhc2UsTWF0aC5mbG9vcihNYXRoLmxvZyh0aGlzLnZpZXdwb3J0TWluaW11bSkvKGQqdGhpcy5pbnRlcnZhbCkrMC4yKSp0aGlzLmludGVydmFsKSkpLHRoaXMuZXF1aWRpc3RhbnRJbnRlcnZhbD0hMCx0aGlzLmludGVydmFsU3RhcnRQb3NpdGlvbj1iO2lmKCF0aGlzLnZhbHVlRm9ybWF0U3RyaW5nJiYodGhpcy52YWx1ZUZvcm1hdFN0cmluZz1cIiMsIyMwLiMjXCIsMT50aGlzLnZpZXdwb3J0TWluaW11bSkpe2Q9TWF0aC5mbG9vcihNYXRoLmFicyhNYXRoLmxvZyh0aGlzLnZpZXdwb3J0TWluaW11bSkvTWF0aC5MTjEwKSkrMjtpZihpc05hTihkKXx8IWlzRmluaXRlKGQpKWQ9MjtpZigyPGQpZm9yKGw9MDtsPGQtMjtsKyspdGhpcy52YWx1ZUZvcm1hdFN0cmluZys9XCIjXCJ9fTtBLmdlbmVyYXRlVmFsdWVGb3JtYXRTdHJpbmc9ZnVuY3Rpb24oYSxkKXt2YXIgYz1cIiMsIyMwLlwiLGI9ZDsxPmEmJihiKz1NYXRoLmZsb29yKE1hdGguYWJzKE1hdGgubG9nKGEpL1xuTWF0aC5MTjEwKSksaXNOYU4oYil8fCFpc0Zpbml0ZShiKSkmJihiPWQpO2Zvcih2YXIgZT0wO2U8YjtlKyspYys9XCIjXCI7cmV0dXJuIGN9O0EuZ2V0TmljZUV4cG9uZW50PWZ1bmN0aW9uKGEsZCl7dmFyIGM9TWF0aC5mbG9vcihNYXRoLmxvZyhhKS9NYXRoLkxOMTApLGI9YS9NYXRoLnBvdygxMCxjKSxiPTA+Yz8xPj1iPzE6NT49Yj81OjEwOk1hdGgubWF4KE1hdGguZmxvb3IoYiksMSk7cmV0dXJuLTIwPmM/TnVtYmVyKGIqTWF0aC5wb3coMTAsYykpOk51bWJlcigoYipNYXRoLnBvdygxMCxjKSkudG9GaXhlZCgyMCkpfTtBLmdldE5pY2VOdW1iZXI9ZnVuY3Rpb24oYSxkKXt2YXIgYz1NYXRoLmZsb29yKE1hdGgubG9nKGEpL01hdGguTE4xMCksYj1hL01hdGgucG93KDEwLGMpLGI9ZD8xLjU+Yj8xOjM+Yj8yOjc+Yj81OjEwOjE+PWI/MToyPj1iPzI6NT49Yj81OjEwO3JldHVybi0yMD5jP051bWJlcihiKk1hdGgucG93KDEwLGMpKTpOdW1iZXIoKGIqTWF0aC5wb3coMTAsYykpLnRvRml4ZWQoMjApKX07XG5BLnByb3RvdHlwZS5nZXRMYWJlbFN0YXJ0UG9pbnQ9ZnVuY3Rpb24oKXt2YXIgYT1UW3RoaXMuaW50ZXJ2YWxUeXBlK1wiRHVyYXRpb25cIl0qdGhpcy5pbnRlcnZhbCxhPW5ldyBEYXRlKE1hdGguZmxvb3IodGhpcy52aWV3cG9ydE1pbmltdW0vYSkqYSk7aWYoXCJtaWxsaXNlY29uZFwiIT09dGhpcy5pbnRlcnZhbFR5cGUpaWYoXCJzZWNvbmRcIj09PXRoaXMuaW50ZXJ2YWxUeXBlKTA8YS5nZXRNaWxsaXNlY29uZHMoKSYmKGEuc2V0U2Vjb25kcyhhLmdldFNlY29uZHMoKSsxKSxhLnNldE1pbGxpc2Vjb25kcygwKSk7ZWxzZSBpZihcIm1pbnV0ZVwiPT09dGhpcy5pbnRlcnZhbFR5cGUpe2lmKDA8YS5nZXRTZWNvbmRzKCl8fDA8YS5nZXRNaWxsaXNlY29uZHMoKSlhLnNldE1pbnV0ZXMoYS5nZXRNaW51dGVzKCkrMSksYS5zZXRTZWNvbmRzKDApLGEuc2V0TWlsbGlzZWNvbmRzKDApfWVsc2UgaWYoXCJob3VyXCI9PT10aGlzLmludGVydmFsVHlwZSl7aWYoMDxhLmdldE1pbnV0ZXMoKXx8MDxhLmdldFNlY29uZHMoKXx8XG4wPGEuZ2V0TWlsbGlzZWNvbmRzKCkpYS5zZXRIb3VycyhhLmdldEhvdXJzKCkrMSksYS5zZXRNaW51dGVzKDApLGEuc2V0U2Vjb25kcygwKSxhLnNldE1pbGxpc2Vjb25kcygwKX1lbHNlIGlmKFwiZGF5XCI9PT10aGlzLmludGVydmFsVHlwZSl7aWYoMDxhLmdldEhvdXJzKCl8fDA8YS5nZXRNaW51dGVzKCl8fDA8YS5nZXRTZWNvbmRzKCl8fDA8YS5nZXRNaWxsaXNlY29uZHMoKSlhLnNldERhdGUoYS5nZXREYXRlKCkrMSksYS5zZXRIb3VycygwKSxhLnNldE1pbnV0ZXMoMCksYS5zZXRTZWNvbmRzKDApLGEuc2V0TWlsbGlzZWNvbmRzKDApfWVsc2UgaWYoXCJ3ZWVrXCI9PT10aGlzLmludGVydmFsVHlwZSl7aWYoMDxhLmdldERheSgpfHwwPGEuZ2V0SG91cnMoKXx8MDxhLmdldE1pbnV0ZXMoKXx8MDxhLmdldFNlY29uZHMoKXx8MDxhLmdldE1pbGxpc2Vjb25kcygpKWEuc2V0RGF0ZShhLmdldERhdGUoKSsoNy1hLmdldERheSgpKSksYS5zZXRIb3VycygwKSxhLnNldE1pbnV0ZXMoMCksXG5hLnNldFNlY29uZHMoMCksYS5zZXRNaWxsaXNlY29uZHMoMCl9ZWxzZSBpZihcIm1vbnRoXCI9PT10aGlzLmludGVydmFsVHlwZSl7aWYoMTxhLmdldERhdGUoKXx8MDxhLmdldEhvdXJzKCl8fDA8YS5nZXRNaW51dGVzKCl8fDA8YS5nZXRTZWNvbmRzKCl8fDA8YS5nZXRNaWxsaXNlY29uZHMoKSlhLnNldE1vbnRoKGEuZ2V0TW9udGgoKSsxKSxhLnNldERhdGUoMSksYS5zZXRIb3VycygwKSxhLnNldE1pbnV0ZXMoMCksYS5zZXRTZWNvbmRzKDApLGEuc2V0TWlsbGlzZWNvbmRzKDApfWVsc2VcInllYXJcIj09PXRoaXMuaW50ZXJ2YWxUeXBlJiYoMDxhLmdldE1vbnRoKCl8fDE8YS5nZXREYXRlKCl8fDA8YS5nZXRIb3VycygpfHwwPGEuZ2V0TWludXRlcygpfHwwPGEuZ2V0U2Vjb25kcygpfHwwPGEuZ2V0TWlsbGlzZWNvbmRzKCkpJiYoYS5zZXRGdWxsWWVhcihhLmdldEZ1bGxZZWFyKCkrMSksYS5zZXRNb250aCgwKSxhLnNldERhdGUoMSksYS5zZXRIb3VycygwKSxhLnNldE1pbnV0ZXMoMCksXG5hLnNldFNlY29uZHMoMCksYS5zZXRNaWxsaXNlY29uZHMoMCkpO3JldHVybiBhfTtvYShmYSxHKTtvYShhYSxHKTthYS5wcm90b3R5cGUuY3JlYXRlVXNlck9wdGlvbnM9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhfHx0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXIpe3ZhciBkPTA7dGhpcy5wYXJlbnQub3B0aW9ucy5faXNQbGFjZWhvbGRlciYmdGhpcy5wYXJlbnQuY3JlYXRlVXNlck9wdGlvbnMoKTt0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXJ8fChFYSh0aGlzLnBhcmVudFt0aGlzLm9wdGlvbnNOYW1lXSksZD10aGlzLnBhcmVudC5vcHRpb25zW3RoaXMub3B0aW9uc05hbWVdLmluZGV4T2YodGhpcy5vcHRpb25zKSk7dGhpcy5vcHRpb25zPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYT97fTphO3RoaXMucGFyZW50Lm9wdGlvbnNbdGhpcy5vcHRpb25zTmFtZV1bZF09dGhpcy5vcHRpb25zfX07YWEucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhKXtpZigwIT09XG50aGlzLnNwYWNpbmd8fDAhPT10aGlzLm9wdGlvbnMubGluZVRoaWNrbmVzcyYmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgdGhpcy5vcHRpb25zLmxpbmVUaGlja25lc3N8fDAhPT10aGlzLnBhcmVudC5saW5lVGhpY2tuZXNzKSl7dmFyIGQ9dGhpcy5jdHgsYz10aGlzLmN0eC5nbG9iYWxBbHBoYTt0aGlzLmN0eD1hfHx0aGlzLmN0eDt0aGlzLmN0eC5zYXZlKCk7dGhpcy5jdHguYmVnaW5QYXRoKCk7dGhpcy5jdHgucmVjdCh0aGlzLmNoYXJ0LnBsb3RBcmVhLngxLHRoaXMuY2hhcnQucGxvdEFyZWEueTEsdGhpcy5jaGFydC5wbG90QXJlYS53aWR0aCx0aGlzLmNoYXJ0LnBsb3RBcmVhLmhlaWdodCk7dGhpcy5jdHguY2xpcCgpO3ZhciBiPXRoaXMuc2NhbGVCcmVha3MucGFyZW50LmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5zdGFydFZhbHVlKSxlPXRoaXMuc2NhbGVCcmVha3MucGFyZW50LmdldFBpeGVsQ29vcmRpbmF0ZXNPbkF4aXModGhpcy5lbmRWYWx1ZSk7dGhpcy5jdHguc3Ryb2tlU3R5bGU9XG50aGlzLmxpbmVDb2xvcjt0aGlzLmN0eC5maWxsU3R5bGU9dGhpcy5jb2xvcjt0aGlzLmN0eC5iZWdpblBhdGgoKTt0aGlzLmN0eC5nbG9iYWxBbHBoYT0xO1godGhpcy5pZCk7dmFyIGYsaCxwLHIsayxtO2E9TWF0aC5tYXgodGhpcy5zcGFjaW5nLDMpO3ZhciBuPU1hdGgubWF4KDAsdGhpcy5saW5lVGhpY2tuZXNzKTt0aGlzLmN0eC5saW5lV2lkdGg9bjt0aGlzLmN0eC5zZXRMaW5lRGFzaCYmdGhpcy5jdHguc2V0TGluZURhc2goSih0aGlzLmxpbmVEYXNoVHlwZSxuKSk7aWYoXCJib3R0b21cIj09PXRoaXMuc2NhbGVCcmVha3MucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMuc2NhbGVCcmVha3MucGFyZW50Ll9wb3NpdGlvbilpZihiPTE9PT1uJTI/KGIueDw8MCkrMC41OmIueDw8MCxoPTE9PT1uJTI/KGUueDw8MCkrMC41OmUueDw8MCxcInRvcFwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9uPyhlPXRoaXMuY2hhcnQucGxvdEFyZWEueTEscD10aGlzLmNoYXJ0LnBsb3RBcmVhLnkyK1xubi8yKzAuNTw8MCk6KGU9dGhpcy5jaGFydC5wbG90QXJlYS55MixwPXRoaXMuY2hhcnQucGxvdEFyZWEueTEtbi8yKzAuNTw8MCxhKj0tMSksdGhpcy5ib3VuZHM9e3gxOmItbi8yLHkxOmUseDI6aCtuLzIseTI6cH0sdGhpcy5jdHgubW92ZVRvKGIsZSksXCJzdHJhaWdodFwiPT09dGhpcy50eXBlfHxcInRvcFwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9uJiYwPj1hfHxcImJvdHRvbVwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9uJiYwPD1hKXRoaXMuY3R4LmxpbmVUbyhiLHApLHRoaXMuY3R4LmxpbmVUbyhoLHApLHRoaXMuY3R4LmxpbmVUbyhoLGUpO2Vsc2UgaWYoXCJ3YXZ5XCI9PT10aGlzLnR5cGUpe3I9YjtrPWU7Zj0wLjU7bT0ocC1rKS9hLzM7Zm9yKHZhciBxPTA7cTxtO3ErKyl0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKHIrZiphLGsrYSxyK2YqYSxrKzIqYSxyLGsrMyphKSxrKz0zKmEsZio9LTE7dGhpcy5jdHguYmV6aWVyQ3VydmVUbyhyK2YqYSxcbmsrYSxyK2YqYSxrKzIqYSxyLGsrMyphKTtyPWg7Zio9LTE7dGhpcy5jdHgubGluZVRvKHIsayk7Zm9yKHE9MDtxPG07cSsrKXRoaXMuY3R4LmJlemllckN1cnZlVG8ocitmKmEsay1hLHIrZiphLGstMiphLHIsay0zKmEpLGstPTMqYSxmKj0tMX1lbHNle2lmKFwiemlnemFnXCI9PT10aGlzLnR5cGUpe2Y9LTE7az1lK2E7cj1iK2E7bT0ocC1rKS9hLzI7Zm9yKHE9MDtxPG07cSsrKXRoaXMuY3R4LmxpbmVUbyhyLGspLHIrPTIqZiphLGsrPTIqYSxmKj0tMTt0aGlzLmN0eC5saW5lVG8ocixrKTtyKz1oLWI7Zm9yKHE9MDtxPG0rMTtxKyspdGhpcy5jdHgubGluZVRvKHIsaykscis9MipmKmEsay09MiphLGYqPS0xO3RoaXMuY3R4LmxpbmVUbyhyK2YqYSxrK2EpfX1lbHNlIGlmKFwibGVmdFwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnNjYWxlQnJlYWtzLnBhcmVudC5fcG9zaXRpb24paWYoZT0xPT09biUyPyhlLnk8PDApKzAuNTplLnk8PFxuMCxwPTE9PT1uJTI/KGIueTw8MCkrMC41OmIueTw8MCxcImxlZnRcIj09PXRoaXMuc2NhbGVCcmVha3MucGFyZW50Ll9wb3NpdGlvbj8oYj10aGlzLmNoYXJ0LnBsb3RBcmVhLngxLGg9dGhpcy5jaGFydC5wbG90QXJlYS54MituLzIrMC41PDwwKTooYj10aGlzLmNoYXJ0LnBsb3RBcmVhLngyLGg9dGhpcy5jaGFydC5wbG90QXJlYS54MS1uLzIrMC41PDwwLGEqPS0xKSx0aGlzLmJvdW5kcz17eDE6Yix5MTplLW4vMix4MjpoLHkyOnArbi8yfSx0aGlzLmN0eC5tb3ZlVG8oYixlKSxcInN0cmFpZ2h0XCI9PT10aGlzLnR5cGV8fFwibGVmdFwiPT09dGhpcy5zY2FsZUJyZWFrcy5wYXJlbnQuX3Bvc2l0aW9uJiYwPj1hfHxcInJpZ2h0XCI9PT10aGlzLnNjYWxlQnJlYWtzLnBhcmVudC5fcG9zaXRpb24mJjA8PWEpdGhpcy5jdHgubGluZVRvKGgsZSksdGhpcy5jdHgubGluZVRvKGgscCksdGhpcy5jdHgubGluZVRvKGIscCk7ZWxzZSBpZihcIndhdnlcIj09PXRoaXMudHlwZSl7cj1iO2s9ZTtmPTAuNTttPVxuKGgtcikvYS8zO2ZvcihxPTA7cTxtO3ErKyl0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKHIrYSxrK2YqYSxyKzIqYSxrK2YqYSxyKzMqYSxrKSxyKz0zKmEsZio9LTE7dGhpcy5jdHguYmV6aWVyQ3VydmVUbyhyK2EsaytmKmEscisyKmEsaytmKmEsciszKmEsayk7az1wO2YqPS0xO3RoaXMuY3R4LmxpbmVUbyhyLGspO2ZvcihxPTA7cTxtO3ErKyl0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKHItYSxrK2YqYSxyLTIqYSxrK2YqYSxyLTMqYSxrKSxyLT0zKmEsZio9LTF9ZWxzZSBpZihcInppZ3phZ1wiPT09dGhpcy50eXBlKXtmPTE7az1lLWE7cj1iK2E7bT0oaC1yKS9hLzI7Zm9yKHE9MDtxPG07cSsrKXRoaXMuY3R4LmxpbmVUbyhyLGspLGsrPTIqZiphLHIrPTIqYSxmKj0tMTt0aGlzLmN0eC5saW5lVG8ocixrKTtrKz1wLWU7Zm9yKHE9MDtxPG0rMTtxKyspdGhpcy5jdHgubGluZVRvKHIsayksays9MipmKmEsci09MiphLGYqPS0xO3RoaXMuY3R4LmxpbmVUbyhyK2EsaytmKmEpfTA8biYmdGhpcy5jdHguc3Ryb2tlKCk7XG50aGlzLmN0eC5jbG9zZVBhdGgoKTt0aGlzLmN0eC5nbG9iYWxBbHBoYT10aGlzLmZpbGxPcGFjaXR5O3RoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbj1cImRlc3RpbmF0aW9uLW92ZXJcIjt0aGlzLmN0eC5maWxsKCk7dGhpcy5jdHgucmVzdG9yZSgpO3RoaXMuY3R4Lmdsb2JhbEFscGhhPWM7dGhpcy5jdHg9ZH19O29hKE4sRyk7Ti5wcm90b3R5cGUuY3JlYXRlVXNlck9wdGlvbnM9ZnVuY3Rpb24oYSl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhfHx0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXIpe3ZhciBkPTA7dGhpcy5wYXJlbnQub3B0aW9ucy5faXNQbGFjZWhvbGRlciYmdGhpcy5wYXJlbnQuY3JlYXRlVXNlck9wdGlvbnMoKTt0aGlzLm9wdGlvbnMuX2lzUGxhY2Vob2xkZXJ8fChFYSh0aGlzLnBhcmVudC5zdHJpcExpbmVzKSxkPXRoaXMucGFyZW50Lm9wdGlvbnMuc3RyaXBMaW5lcy5pbmRleE9mKHRoaXMub3B0aW9ucykpO3RoaXMub3B0aW9ucz1cInVuZGVmaW5lZFwiPT09XG50eXBlb2YgYT97fTphO3RoaXMucGFyZW50Lm9wdGlvbnMuc3RyaXBMaW5lc1tkXT10aGlzLm9wdGlvbnN9fTtOLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt0aGlzLmN0eC5zYXZlKCk7dmFyIGE9dGhpcy5wYXJlbnQuZ2V0UGl4ZWxDb29yZGluYXRlc09uQXhpcyh0aGlzLnZhbHVlKSxkPU1hdGguYWJzKFwicGl4ZWxcIj09PXRoaXMuX3RoaWNrbmVzc1R5cGU/dGhpcy50aGlja25lc3M6TWF0aC5hYnModGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh0aGlzLmVuZFZhbHVlKS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHRoaXMuc3RhcnRWYWx1ZSkpKTtpZigwPGQpe3ZhciBjPW51bGw9PT10aGlzLm9wYWNpdHk/MTp0aGlzLm9wYWNpdHk7dGhpcy5jdHguc3Ryb2tlU3R5bGU9dGhpcy5jb2xvcjt0aGlzLmN0eC5iZWdpblBhdGgoKTt2YXIgYj10aGlzLmN0eC5nbG9iYWxBbHBoYTt0aGlzLmN0eC5nbG9iYWxBbHBoYT1jO1godGhpcy5pZCk7dmFyIGUsZixoLFxucDt0aGlzLmN0eC5saW5lV2lkdGg9ZDt0aGlzLmN0eC5zZXRMaW5lRGFzaCYmdGhpcy5jdHguc2V0TGluZURhc2goSih0aGlzLmxpbmVEYXNoVHlwZSxkKSk7aWYoXCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbillPWY9MT09PXRoaXMuY3R4LmxpbmVXaWR0aCUyPyhhLng8PDApKzAuNTphLng8PDAsaD10aGlzLmNoYXJ0LnBsb3RBcmVhLnkxLHA9dGhpcy5jaGFydC5wbG90QXJlYS55Mix0aGlzLmJvdW5kcz17eDE6ZS1kLzIseTE6aCx4MjpmK2QvMix5MjpwfTtlbHNlIGlmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24paD1wPTE9PT10aGlzLmN0eC5saW5lV2lkdGglMj8oYS55PDwwKSswLjU6YS55PDwwLGU9dGhpcy5jaGFydC5wbG90QXJlYS54MSxmPXRoaXMuY2hhcnQucGxvdEFyZWEueDIsdGhpcy5ib3VuZHM9e3gxOmUseTE6aC1kLzIseDI6ZixcbnkyOnArZC8yfTt0aGlzLmN0eC5tb3ZlVG8oZSxoKTt0aGlzLmN0eC5saW5lVG8oZixwKTt0aGlzLmN0eC5zdHJva2UoKTt0aGlzLmN0eC5nbG9iYWxBbHBoYT1ifXRoaXMuY3R4LnJlc3RvcmUoKX07b2EoY2EsRyk7Y2EucHJvdG90eXBlLnNob3dBdD1mdW5jdGlvbihhKXtpZighdGhpcy5lbmFibGVkKXJldHVybiExO3ZhciBkPXRoaXMuY2hhcnQsYz0hMTtkLnJlc2V0T3ZlcmxheWVkQ2FudmFzKCk7ZC5jbGVhcmVkT3ZlcmxheWVkQ2FudmFzPXRoaXMucGFyZW50LnR5cGU7dGhpcy5jaGFydC5yZW5kZXJDcm9zc2hhaXJzKHRoaXMucGFyZW50KTtpZihcInh5U3dhcHBlZFwiPT09ZC5wbG90SW5mby5heGlzUGxhY2VtZW50KWlmKFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pZm9yKHZhciBiPTA7YjxkLmF4aXNZLmxlbmd0aDtiKyspdGhpcy5wYXJlbnQ9PT1kLmF4aXNZW2JdJiYoZC5heGlzWVtiXS5fY3Jvc3NoYWlyVmFsdWU9YT49ZC5heGlzWVtiXS52aWV3cG9ydE1pbmltdW0mJlxuYTw9ZC5heGlzWVtiXS52aWV3cG9ydE1heGltdW0/YTpudWxsKTtlbHNlIGlmKFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pZm9yKGI9MDtiPGQuYXhpc1kyLmxlbmd0aDtiKyspdGhpcy5wYXJlbnQ9PT1kLmF4aXNZMltiXSYmKGQuYXhpc1kyW2JdLl9jcm9zc2hhaXJWYWx1ZT1hPj1kLmF4aXNZMltiXS52aWV3cG9ydE1pbmltdW0mJmE8PWQuYXhpc1kyW2JdLnZpZXdwb3J0TWF4aW11bT9hOm51bGwpO2Vsc2UgaWYoXCJsZWZ0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pZm9yKGI9MDtiPGQuYXhpc1gubGVuZ3RoO2IrKyl0aGlzLnBhcmVudD09PWQuYXhpc1hbYl0mJihkLmF4aXNYW2JdLl9jcm9zc2hhaXJWYWx1ZT1hPj1kLmF4aXNYW2JdLnZpZXdwb3J0TWluaW11bSYmYTw9ZC5heGlzWFtiXS52aWV3cG9ydE1heGltdW0/YTpudWxsKTtlbHNle2lmKFwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbilmb3IoYj0wO2I8ZC5heGlzWDIubGVuZ3RoO2IrKyl0aGlzLnBhcmVudD09PVxuZC5heGlzWDJbYl0mJihkLmF4aXNYMltiXS5fY3Jvc3NoYWlyVmFsdWU9YT49ZC5heGlzWDJbYl0udmlld3BvcnRNaW5pbXVtJiZhPD1kLmF4aXNYMltiXS52aWV3cG9ydE1heGltdW0/YTpudWxsKX1lbHNlIGlmKFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pZm9yKGI9MDtiPGQuYXhpc1gubGVuZ3RoO2IrKyl0aGlzLnBhcmVudD09PWQuYXhpc1hbYl0mJihkLmF4aXNYW2JdLl9jcm9zc2hhaXJWYWx1ZT1hPj1kLmF4aXNYW2JdLnZpZXdwb3J0TWluaW11bSYmYTw9ZC5heGlzWFtiXS52aWV3cG9ydE1heGltdW0/YTpudWxsKTtlbHNlIGlmKFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pZm9yKGI9MDtiPGQuYXhpc1gyLmxlbmd0aDtiKyspdGhpcy5wYXJlbnQ9PT1kLmF4aXNYMltiXSYmKGQuYXhpc1gyW2JdLl9jcm9zc2hhaXJWYWx1ZT1hPj1kLmF4aXNYMltiXS52aWV3cG9ydE1pbmltdW0mJmE8PWQuYXhpc1gyW2JdLnZpZXdwb3J0TWF4aW11bT9hOm51bGwpO1xuZWxzZSBpZihcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbilmb3IoYj0wO2I8ZC5heGlzWS5sZW5ndGg7YisrKXRoaXMucGFyZW50PT09ZC5heGlzWVtiXSYmKGQuYXhpc1lbYl0uX2Nyb3NzaGFpclZhbHVlPWE+PWQuYXhpc1lbYl0udmlld3BvcnRNaW5pbXVtJiZhPD1kLmF4aXNZW2JdLnZpZXdwb3J0TWF4aW11bT9hOm51bGwpO2Vsc2UgaWYoXCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKWZvcihiPTA7YjxkLmF4aXNZMi5sZW5ndGg7YisrKXRoaXMucGFyZW50PT09ZC5heGlzWTJbYl0mJihkLmF4aXNZMltiXS5fY3Jvc3NoYWlyVmFsdWU9YT49ZC5heGlzWTJbYl0udmlld3BvcnRNaW5pbXVtJiZhPD1kLmF4aXNZMltiXS52aWV3cG9ydE1heGltdW0/YTpudWxsKTtmb3IoYj0wO2I8ZC5heGlzWC5sZW5ndGg7YisrKWE9ZC5heGlzWFtiXS5fY3Jvc3NoYWlyVmFsdWUsZC5heGlzWFtiXS5jcm9zc2hhaXImJihkLmF4aXNYW2JdLmNyb3NzaGFpci5lbmFibGVkJiYhcihhKSYmXG5hPj1kLmF4aXNYW2JdLnZpZXdwb3J0TWluaW11bSYmYTw9ZC5heGlzWFtiXS52aWV3cG9ydE1heGltdW0pJiYoZC5heGlzWFtiXS5zaG93Q3Jvc3NoYWlyKGEpLGQuYXhpc1hbYl0uY3Jvc3NoYWlyLl91cGRhdGVkVmFsdWU9YSx0aGlzPT09ZC5heGlzWFtiXS5jcm9zc2hhaXImJihjPSEwKSk7Zm9yKGI9MDtiPGQuYXhpc1gyLmxlbmd0aDtiKyspYT1kLmF4aXNYMltiXS5fY3Jvc3NoYWlyVmFsdWUsZC5heGlzWDJbYl0uY3Jvc3NoYWlyJiYoZC5heGlzWDJbYl0uY3Jvc3NoYWlyLmVuYWJsZWQmJiFyKGEpJiZhPj1kLmF4aXNYMltiXS52aWV3cG9ydE1pbmltdW0mJmE8PWQuYXhpc1gyW2JdLnZpZXdwb3J0TWF4aW11bSkmJihkLmF4aXNYMltiXS5zaG93Q3Jvc3NoYWlyKGEpLGQuYXhpc1gyW2JdLmNyb3NzaGFpci5fdXBkYXRlZFZhbHVlPWEsdGhpcz09PWQuYXhpc1gyW2JdLmNyb3NzaGFpciYmKGM9ITApKTtmb3IoYj0wO2I8ZC5heGlzWS5sZW5ndGg7YisrKWE9ZC5heGlzWVtiXS5fY3Jvc3NoYWlyVmFsdWUsXG5kLmF4aXNZW2JdLmNyb3NzaGFpciYmKGQuYXhpc1lbYl0uY3Jvc3NoYWlyLmVuYWJsZWQmJiFyKGEpJiZhPj1kLmF4aXNZW2JdLnZpZXdwb3J0TWluaW11bSYmYTw9ZC5heGlzWVtiXS52aWV3cG9ydE1heGltdW0pJiYoZC5heGlzWVtiXS5zaG93Q3Jvc3NoYWlyKGEpLGQuYXhpc1lbYl0uY3Jvc3NoYWlyLl91cGRhdGVkVmFsdWU9YSx0aGlzPT09ZC5heGlzWVtiXS5jcm9zc2hhaXImJihjPSEwKSk7Zm9yKGI9MDtiPGQuYXhpc1kyLmxlbmd0aDtiKyspYT1kLmF4aXNZMltiXS5fY3Jvc3NoYWlyVmFsdWUsZC5heGlzWTJbYl0uY3Jvc3NoYWlyJiYoZC5heGlzWTJbYl0uY3Jvc3NoYWlyLmVuYWJsZWQmJiFyKGEpJiZhPj1kLmF4aXNZMltiXS52aWV3cG9ydE1pbmltdW0mJmE8PWQuYXhpc1kyW2JdLnZpZXdwb3J0TWF4aW11bSkmJihkLmF4aXNZMltiXS5zaG93Q3Jvc3NoYWlyKGEpLGQuYXhpc1kyW2JdLmNyb3NzaGFpci5fdXBkYXRlZFZhbHVlPWEsdGhpcz09PWQuYXhpc1kyW2JdLmNyb3NzaGFpciYmXG4oYz0hMCkpO3RoaXMuY2hhcnQudG9vbFRpcCYmdGhpcy5jaGFydC50b29sVGlwLl9lbnRyaWVzJiZ0aGlzLmNoYXJ0LnRvb2xUaXAuaGlnaGxpZ2h0T2JqZWN0cyh0aGlzLmNoYXJ0LnRvb2xUaXAuX2VudHJpZXMpO3JldHVybiBjfTtjYS5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe3RoaXMuY2hhcnQucmVzZXRPdmVybGF5ZWRDYW52YXMoKTt0aGlzLmNoYXJ0LnJlbmRlckNyb3NzaGFpcnModGhpcy5wYXJlbnQpO3RoaXMuX2hpZGRlbj0hMH07Y2EucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhLGQsYyl7dmFyIGIsZSxmLGgscD1udWxsLHc9bnVsbCxrPW51bGwsbT1cIlwiO2lmKCF0aGlzLnZhbHVlRm9ybWF0U3RyaW5nKWlmKFwiZGF0ZVRpbWVcIj09PXRoaXMucGFyZW50LnZhbHVlVHlwZSl0aGlzLnZhbHVlRm9ybWF0U3RyaW5nPXRoaXMucGFyZW50LnZhbHVlRm9ybWF0U3RyaW5nO2Vsc2V7dmFyIG49MCxuPVwieHlTd2FwcGVkXCI9PT10aGlzLmNoYXJ0LnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQ/XG41MDx0aGlzLnBhcmVudC5yYW5nZT8wOjUwMDx0aGlzLmNoYXJ0LndpZHRoJiYyNT50aGlzLnBhcmVudC5yYW5nZT8yOk1hdGguZmxvb3IoTWF0aC5hYnMoTWF0aC5sb2codGhpcy5wYXJlbnQucmFuZ2UpL01hdGguTE4xMCkpKyg1PnRoaXMucGFyZW50LnJhbmdlPzI6MTA+dGhpcy5wYXJlbnQucmFuZ2U/MTowKTo1MDx0aGlzLnBhcmVudC5yYW5nZT8wOk1hdGguZmxvb3IoTWF0aC5hYnMoTWF0aC5sb2codGhpcy5wYXJlbnQucmFuZ2UpL01hdGguTE4xMCkpKyg1PnRoaXMucGFyZW50LnJhbmdlPzI6MTA+dGhpcy5wYXJlbnQucmFuZ2U/MTowKTt0aGlzLnZhbHVlRm9ybWF0U3RyaW5nPUEuZ2VuZXJhdGVWYWx1ZUZvcm1hdFN0cmluZyh0aGlzLnBhcmVudC5yYW5nZSxuKX12YXIgaz1udWxsPT09dGhpcy5vcGFjaXR5PzE6dGhpcy5vcGFjaXR5LG49TWF0aC5hYnMoXCJwaXhlbFwiPT09dGhpcy5fdGhpY2tuZXNzVHlwZT90aGlzLnRoaWNrbmVzczp0aGlzLnBhcmVudC5jb252ZXJzaW9uUGFyYW1ldGVycy5waXhlbFBlclVuaXQqXG50aGlzLnRoaWNrbmVzcykscT10aGlzLmNoYXJ0Lm92ZXJsYWlkQ2FudmFzQ3R4LGc9cS5nbG9iYWxBbHBoYTtxLmdsb2JhbEFscGhhPWs7cS5iZWdpblBhdGgoKTtxLnN0cm9rZVN0eWxlPXRoaXMuY29sb3I7cS5saW5lV2lkdGg9bjtxLnNhdmUoKTt0aGlzLmxhYmVsRm9udFNpemU9TWF0aC5hYnMocih0aGlzLm9wdGlvbnMubGFiZWxGb250U2l6ZSk/dGhpcy5wYXJlbnQubGFiZWxGb250U2l6ZTp0aGlzLmxhYmVsRm9udFNpemUpO3RoaXMubGFiZWxNYXhXaWR0aD1yKHRoaXMub3B0aW9ucy5sYWJlbE1heFdpZHRoKT8wLjMqdGhpcy5jaGFydC53aWR0aDp0aGlzLmxhYmVsTWF4V2lkdGg7dGhpcy5sYWJlbE1heEhlaWdodD1yKHRoaXMub3B0aW9ucy5sYWJlbFdyYXApfHx0aGlzLmxhYmVsV3JhcD8wLjMqdGhpcy5jaGFydC5oZWlnaHQ6Mip0aGlzLmxhYmVsRm9udFNpemU7MDxuJiZxLnNldExpbmVEYXNoJiZxLnNldExpbmVEYXNoKEoodGhpcy5saW5lRGFzaFR5cGUsbikpO2s9bmV3IGphKHEsXG57eDowLHk6MCxwYWRkaW5nOnt0b3A6MixyaWdodDozLGJvdHRvbToyLGxlZnQ6NH0sYmFja2dyb3VuZENvbG9yOnRoaXMubGFiZWxCYWNrZ3JvdW5kQ29sb3IsYm9yZGVyQ29sb3I6dGhpcy5sYWJlbEJvcmRlckNvbG9yLGJvcmRlclRoaWNrbmVzczp0aGlzLmxhYmVsQm9yZGVyVGhpY2tuZXNzLGNvcm5lclJhZGl1czp0aGlzLmxhYmVsQ29ybmVyUmFkaXVzLG1heFdpZHRoOnRoaXMubGFiZWxNYXhXaWR0aCxtYXhIZWlnaHQ6dGhpcy5sYWJlbE1heEhlaWdodCxhbmdsZTp0aGlzLmxhYmVsQW5nbGUsdGV4dDptLGhvcml6b250YWxBbGlnbjpcImxlZnRcIixmb250U2l6ZTp0aGlzLmxhYmVsRm9udFNpemUsZm9udEZhbWlseTp0aGlzLmxhYmVsRm9udEZhbWlseSxmb250V2VpZ2h0OnRoaXMubGFiZWxGb250V2VpZ2h0LGZvbnRDb2xvcjp0aGlzLmxhYmVsRm9udENvbG9yLGZvbnRTdHlsZTp0aGlzLmxhYmVsRm9udFN0eWxlLHRleHRCYXNlbGluZTpcIm1pZGRsZVwifSk7aWYodGhpcy5zbmFwVG9EYXRhUG9pbnQpe3ZhciBzPVxuMCxtPVtdO2lmKFwieHlTd2FwcGVkXCI9PT10aGlzLmNoYXJ0LnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpe3ZhciB2PW51bGw7aWYoXCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbilzPXRoaXMucGFyZW50LmRhdGFTZXJpZXNbMF0uYXhpc1guY29udmVydFBpeGVsVG9WYWx1ZSh7eTpkfSk7ZWxzZSBpZihcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKXM9dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZSh7eTpkfSk7Zm9yKHZhciBCPTA7Qjx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtCKyspKHY9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS5nZXREYXRhUG9pbnRBdFgocywhMCkpJiYwPD12LmluZGV4JiYodi5kYXRhU2VyaWVzPXRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0sbnVsbCE9PXYuZGF0YVBvaW50LnkmJnYuZGF0YVNlcmllcy52aXNpYmxlJiZcbm0ucHVzaCh2KSk7dj1udWxsO2lmKDA9PT1tLmxlbmd0aClyZXR1cm47bS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZGlzdGFuY2UtYi5kaXN0YW5jZX0pO3Y9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bMF0uZGF0YVBvaW50LnkpKTtCPTA7aWYoXCJyYW5nZUJhclwiPT09bVswXS5kYXRhU2VyaWVzLnR5cGV8fFwiZXJyb3JcIj09PW1bMF0uZGF0YVNlcmllcy50eXBlKWZvcih2YXIgdj1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVtCXS5kYXRhUG9pbnQueVswXSkpLHU9MCxzPTA7czxtLmxlbmd0aDtzKyspaWYobVtzXS5kYXRhUG9pbnQueSYmbVtzXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKHZhciB5PTA7eTxtW3NdLmRhdGFQb2ludC55Lmxlbmd0aDt5KyspdT1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVtzXS5kYXRhUG9pbnQueVt5XSkpLHU8diYmKHY9dSxCPXMpO2Vsc2UgdT1cbk1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtW3NdLmRhdGFQb2ludC55KSksdTx2JiYodj11LEI9cyk7ZWxzZSBpZihcInN0YWNrZWRCYXJcIj09PW1bMF0uZGF0YVNlcmllcy50eXBlKWZvcih2YXIgdj1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVswXS5kYXRhUG9pbnQueSkpLHg9dT0wLHM9Qj0wO3M8bS5sZW5ndGg7cysrKWlmKG1bc10uZGF0YVBvaW50LnkmJm1bc10uZGF0YVBvaW50LnkubGVuZ3RoKWZvcih5PTA7eTxtW3NdLmRhdGFQb2ludC55Lmxlbmd0aDt5KyspdT1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVtzXS5kYXRhUG9pbnQueVt5XSkpLHU8diYmKHY9dSxCPXMpO2Vsc2UgeCs9bVtzXS5kYXRhUG9pbnQueSx1PU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh4KSksdTx2JiYodj11LEI9cyk7ZWxzZSBpZihcInN0YWNrZWRCYXIxMDBcIj09PW1bMF0uZGF0YVNlcmllcy50eXBlKWZvcih2YXIgdj1cbk1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtWzBdLmRhdGFQb2ludC55KSksej14PXU9MCxzPTA7czxtLmxlbmd0aDtzKyspaWYobVtzXS5kYXRhUG9pbnQueSYmbVtzXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKHk9MDt5PG1bc10uZGF0YVBvaW50LnkubGVuZ3RoO3krKyl1PU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtW3NdLmRhdGFQb2ludC55W3ldKSksdTx2JiYodj11LEI9cyk7ZWxzZSB4Kz1tW3NdLmRhdGFQb2ludC55LHo9bVtzXS5kYXRhUG9pbnQueC5nZXRUaW1lP21bc10uZGF0YVBvaW50LnguZ2V0VGltZSgpOm1bc10uZGF0YVBvaW50Lngsej0xMDAqKHgvbVtzXS5kYXRhU2VyaWVzLnBsb3RVbml0LmRhdGFQb2ludFlTdW1zW3pdKSx1PU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh6KSksdTx2JiYodj11LEI9cyk7ZWxzZSBmb3Iodj1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVswXS5kYXRhUG9pbnQueSkpLFxucz1CPXU9MDtzPG0ubGVuZ3RoO3MrKylpZihtW3NdLmRhdGFQb2ludC55JiZtW3NdLmRhdGFQb2ludC55Lmxlbmd0aClmb3IoeT0wO3k8bVtzXS5kYXRhUG9pbnQueS5sZW5ndGg7eSsrKXU9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bc10uZGF0YVBvaW50LnlbeV0pKSx1PHYmJih2PXUsQj1zKTtlbHNlIHU9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bc10uZGF0YVBvaW50LnkpKSx1PHYmJih2PXUsQj1zKTt5PW1bQl07aWYoXCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbil7Yj0wO2lmKFwicmFuZ2VCYXJcIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0udHlwZXx8XCJlcnJvclwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS50eXBlKXt2PU1hdGguYWJzKGEtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh5LmRhdGFQb2ludC55WzBdKSk7XG5mb3Iocz11PTA7czx5LmRhdGFQb2ludC55Lmxlbmd0aDtzKyspdT1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeS5kYXRhUG9pbnQueVtzXSkpLHU8diYmKHY9dSxiPXMpO3A9MT09PXEubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeS5kYXRhUG9pbnQueVtiXSk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHkuZGF0YVBvaW50LnlbYl0pPDwwO3RoaXMudmFsdWU9eS5kYXRhUG9pbnQueVtiXTtrLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnkuZGF0YVBvaW50LnlbYl19KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/ZGEocihjKT95LmRhdGFQb2ludC55W2JdOmMsdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6XG50aGlzLmxhYmVsfWVsc2UgaWYoXCJzdGFja2VkQmFyXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW0JdLnR5cGUpe3Y9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bMF0uZGF0YVBvaW50LnkpKTt4PXU9MDtmb3Iocz1COzA8PXM7cy0tKXgrPW1bc10uZGF0YVBvaW50LnksdT1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeCkpLHU8diYmKHY9dSxiPXMpO3A9MT09PXEubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeCk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHgpPDwwO3RoaXMudmFsdWU9eDtrLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnkuZGF0YVBvaW50Lnl9KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/XG5kYShyKGMpP3kuZGF0YVBvaW50Lnk6Yyx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsfWVsc2UgaWYoXCJzdGFja2VkQmFyMTAwXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW0JdLnR5cGUpe3Y9TWF0aC5hYnMoYS10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bMF0uZGF0YVBvaW50LnkpKTt6PXg9dT0wO2ZvcihzPUI7MDw9cztzLS0peCs9bVtzXS5kYXRhUG9pbnQueSx6PW1bc10uZGF0YVBvaW50LnguZ2V0VGltZT9tW3NdLmRhdGFQb2ludC54LmdldFRpbWUoKTptW3NdLmRhdGFQb2ludC54LHo9MTAwKih4L21bc10uZGF0YVNlcmllcy5wbG90VW5pdC5kYXRhUG9pbnRZU3Vtc1t6XSksdT1NYXRoLmFicyhhLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeikpLHU8diYmKHY9dSxiPXMpO3A9MT09PXEubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeik8PDApKzAuNTpcbnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeik8PDA7dGhpcy52YWx1ZT16O2sudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6en0pOnIodGhpcy5vcHRpb25zLmxhYmVsKT9kYShyKGMpP3o6Yyx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsfWVsc2UgcD0xPT09cS5saW5lV2lkdGglMj8odGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh5LmRhdGFQb2ludC55KTw8MCkrMC41OnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeS5kYXRhUG9pbnQueSk8PDAsdGhpcy52YWx1ZT15LmRhdGFQb2ludC55LGsudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLFxuY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp5LmRhdGFQb2ludC55fSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP2RhKHIoYyk/eS5kYXRhUG9pbnQueTpjLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw7Yj1lPXA7Zj10aGlzLmNoYXJ0LnBsb3RBcmVhLnkxO2g9dGhpcy5jaGFydC5wbG90QXJlYS55Mjt0aGlzLmJvdW5kcz17eDE6Yi1uLzIseTE6Zix4MjplK24vMix5MjpofTtrLng9Yi1rLm1lYXN1cmVUZXh0KCkud2lkdGgvMjtrLngray53aWR0aD50aGlzLmNoYXJ0LmJvdW5kcy54Mj9rLng9dGhpcy5jaGFydC5ib3VuZHMueDItay53aWR0aDprLng8dGhpcy5jaGFydC5ib3VuZHMueDEmJihrLng9dGhpcy5jaGFydC5ib3VuZHMueDEpO2sueT10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueTIrKFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24/LWsuaGVpZ2h0K3RoaXMucGFyZW50LnRpY2tMZW5ndGg6ay5mb250U2l6ZS9cbjIpKzI7ay55K2suaGVpZ2h0PnRoaXMuY2hhcnQuYm91bmRzLnkyP2sueT10aGlzLmNoYXJ0LmJvdW5kcy55Mi1rLmhlaWdodDprLnk8dGhpcy5jaGFydC5ib3VuZHMueTEmJihrLnk9dGhpcy5jaGFydC5ib3VuZHMueTEpfWVsc2UgaWYoXCJsZWZ0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb258fFwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbil7Zj1oPXc9MT09PXEubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeS5kYXRhUG9pbnQueCk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHkuZGF0YVBvaW50LngpPDwwO2I9dGhpcy5jaGFydC5wbG90QXJlYS54MTtlPXRoaXMuY2hhcnQucGxvdEFyZWEueDI7dGhpcy5ib3VuZHM9e3gxOmIseTE6Zi1uLzIseDI6ZSx5MjpoK24vMn07ej0hMTtpZih0aGlzLnBhcmVudC5sYWJlbHMpZm9yKG09TWF0aC5jZWlsKHRoaXMucGFyZW50LmludGVydmFsKSxzPTA7czx0aGlzLnBhcmVudC52aWV3cG9ydE1heGltdW07cys9XG5tKWlmKHRoaXMucGFyZW50LmxhYmVsc1tzXSl6PSEwO2Vsc2V7ej0hMTticmVha31pZih6KXtpZihcImF4aXNYXCI9PT10aGlzLnBhcmVudC50eXBlKWZvcihzPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3k6ZH0pLHY9bnVsbCxCPTA7Qjx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtCKyspKHY9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS5nZXREYXRhUG9pbnRBdFgocywhMCkpJiYwPD12LmluZGV4JiYoay50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp5LmRhdGFQb2ludC54fSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP3YuZGF0YVBvaW50LmxhYmVsOnRoaXMubGFiZWwpfWVsc2Ugay50ZXh0PVwiZGF0ZVRpbWVcIiE9PXRoaXMucGFyZW50LnZhbHVlVHlwZXx8dGhpcy5wYXJlbnQubG9nYXJpdGhtaWM/XG50aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6eS5kYXRhUG9pbnQueH0pOnIodGhpcy5vcHRpb25zLmxhYmVsKT9kYSh5LmRhdGFQb2ludC54LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw6dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnkuZGF0YVBvaW50Lnh9KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/QmEoeS5kYXRhUG9pbnQueCx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsO3RoaXMudmFsdWU9eS5kYXRhUG9pbnQueDtrLnk9aCtrLmZvbnRTaXplLzItay5tZWFzdXJlVGV4dCgpLmhlaWdodC9cbjIrMjtrLnktay5mb250U2l6ZS8yPHRoaXMuY2hhcnQuYm91bmRzLnkxP2sueT10aGlzLmNoYXJ0LmJvdW5kcy55MStrLmZvbnRTaXplLzIrMjprLnkray5tZWFzdXJlVGV4dCgpLmhlaWdodC1rLmZvbnRTaXplLzI+dGhpcy5jaGFydC5ib3VuZHMueTImJihrLnk9dGhpcy5jaGFydC5ib3VuZHMueTItay5tZWFzdXJlVGV4dCgpLmhlaWdodCtrLmZvbnRTaXplLzIpO1wibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uP2sueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDItay5tZWFzdXJlVGV4dCgpLndpZHRoOlwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmKGsueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDIpfX1lbHNlIGlmKFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pe3M9dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZSh7eDphfSk7Zm9yKEI9MDtCPHRoaXMucGFyZW50LmRhdGFTZXJpZXMubGVuZ3RoO0IrKykodj1cbnRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0uZ2V0RGF0YVBvaW50QXRYKHMsITApKSYmMDw9di5pbmRleCYmKHYuZGF0YVNlcmllcz10aGlzLnBhcmVudC5kYXRhU2VyaWVzW0JdLG51bGwhPT12LmRhdGFQb2ludC55JiZ2LmRhdGFTZXJpZXMudmlzaWJsZSYmbS5wdXNoKHYpKTtpZigwPT09bS5sZW5ndGgpcmV0dXJuO20uc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLmRpc3RhbmNlLWIuZGlzdGFuY2V9KTt5PW1bMF07Yj1lPXA9MT09PXEubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeS5kYXRhUG9pbnQueCk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHkuZGF0YVBvaW50LngpPDwwO2Y9dGhpcy5jaGFydC5wbG90QXJlYS55MTtoPXRoaXMuY2hhcnQucGxvdEFyZWEueTI7dGhpcy5ib3VuZHM9e3gxOmItbi8yLHkxOmYseDI6ZStuLzIseTI6aH07ej0hMTtpZih0aGlzLnBhcmVudC5sYWJlbHMpZm9yKG09TWF0aC5jZWlsKHRoaXMucGFyZW50LmludGVydmFsKSxcbnM9MDtzPHRoaXMucGFyZW50LnZpZXdwb3J0TWF4aW11bTtzKz1tKWlmKHRoaXMucGFyZW50LmxhYmVsc1tzXSl6PSEwO2Vsc2V7ej0hMTticmVha31pZih6KXtpZihcImF4aXNYXCI9PT10aGlzLnBhcmVudC50eXBlKWZvcihzPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pLHY9bnVsbCxCPTA7Qjx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtCKyspKHY9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS5nZXREYXRhUG9pbnRBdFgocywhMCkpJiYwPD12LmluZGV4JiYoay50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp5LmRhdGFQb2ludC54fSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP3YuZGF0YVBvaW50LmxhYmVsOnRoaXMubGFiZWwpfWVsc2Ugay50ZXh0PVwiZGF0ZVRpbWVcIiE9PXRoaXMucGFyZW50LnZhbHVlVHlwZXx8XG50aGlzLnBhcmVudC5sb2dhcml0aG1pYz90aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6eS5kYXRhUG9pbnQueH0pOnIodGhpcy5vcHRpb25zLmxhYmVsKT9kYSh5LmRhdGFQb2ludC54LHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw6dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnkuZGF0YVBvaW50Lnh9KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/QmEoeS5kYXRhUG9pbnQueCx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsO3RoaXMudmFsdWU9eS5kYXRhUG9pbnQueDtcbmsueD1iLWsubWVhc3VyZVRleHQoKS53aWR0aC8yO2sueCtrLndpZHRoPnRoaXMuY2hhcnQuYm91bmRzLngyJiYoay54PXRoaXMuY2hhcnQuYm91bmRzLngyLWsud2lkdGgpO2sueDx0aGlzLmNoYXJ0LmJvdW5kcy54MSYmKGsueD10aGlzLmNoYXJ0LmJvdW5kcy54MSk7XCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbj9rLnk9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLnkyK2suZm9udFNpemUvMisyOlwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJihrLnk9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLnkxLWsuaGVpZ2h0K2suZm9udFNpemUvMisyKX1lbHNlIGlmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24peyFyKHRoaXMucGFyZW50LmRhdGFTZXJpZXMpJiYwPHRoaXMucGFyZW50LmRhdGFTZXJpZXMubGVuZ3RoJiYocz10aGlzLnBhcmVudC5kYXRhU2VyaWVzWzBdLmF4aXNYLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pKTtcbmZvcihCPTA7Qjx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtCKyspKHY9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS5nZXREYXRhUG9pbnRBdFgocywhMCkpJiYwPD12LmluZGV4JiYodi5kYXRhU2VyaWVzPXRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0sbnVsbCE9PXYuZGF0YVBvaW50LnkmJnYuZGF0YVNlcmllcy52aXNpYmxlJiZtLnB1c2godikpO2lmKDA9PT1tLmxlbmd0aClyZXR1cm47bS5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZGlzdGFuY2UtYi5kaXN0YW5jZX0pO0I9MDtpZihcInJhbmdlQ29sdW1uXCI9PT1tWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJyYW5nZUFyZWFcIj09PW1bMF0uZGF0YVNlcmllcy50eXBlfHxcImVycm9yXCI9PT1tWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJyYW5nZVNwbGluZUFyZWFcIj09PW1bMF0uZGF0YVNlcmllcy50eXBlfHxcImNhbmRsZXN0aWNrXCI9PT1tWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJvaGxjXCI9PT1tWzBdLmRhdGFTZXJpZXMudHlwZXx8XG5cImJveEFuZFdoaXNrZXJcIj09PW1bMF0uZGF0YVNlcmllcy50eXBlKWZvcih2PU1hdGguYWJzKGQtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtWzBdLmRhdGFQb2ludC55WzBdKSkscz11PTA7czxtLmxlbmd0aDtzKyspaWYobVtzXS5kYXRhUG9pbnQueSYmbVtzXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKHk9MDt5PG1bc10uZGF0YVBvaW50LnkubGVuZ3RoO3krKyl1PU1hdGguYWJzKGQtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtW3NdLmRhdGFQb2ludC55W3ldKSksdTx2JiYodj11LEI9cyk7ZWxzZSB1PU1hdGguYWJzKGQtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtW3NdLmRhdGFQb2ludC55KSksdTx2JiYodj11LEI9cyk7ZWxzZSBpZihcInN0YWNrZWRDb2x1bW5cIj09PW1bMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRBcmVhXCI9PT1tWzBdLmRhdGFTZXJpZXMudHlwZSlmb3Iodj1NYXRoLmFicyhkLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVswXS5kYXRhUG9pbnQueSkpLFxucz14PXU9MDtzPG0ubGVuZ3RoO3MrKylpZihtW3NdLmRhdGFQb2ludC55JiZtW3NdLmRhdGFQb2ludC55Lmxlbmd0aClmb3IoeT0wO3k8bVtzXS5kYXRhUG9pbnQueS5sZW5ndGg7eSsrKXU9TWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bc10uZGF0YVBvaW50LnlbeV0pKSx1PHYmJih2PXUsQj1zKTtlbHNlIHgrPW1bc10uZGF0YVBvaW50LnksdT1NYXRoLmFicyhkLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeCkpLHU8diYmKHY9dSxCPXMpO2Vsc2UgaWYoXCJzdGFja2VkQ29sdW1uMTAwXCI9PT1tWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGFja2VkQXJlYTEwMFwiPT09bVswXS5kYXRhU2VyaWVzLnR5cGUpZm9yKHY9TWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bMF0uZGF0YVBvaW50LnkpKSxzPXo9eD11PTA7czxtLmxlbmd0aDtzKyspaWYobVtzXS5kYXRhUG9pbnQueSYmbVtzXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKHk9XG4wO3k8bVtzXS5kYXRhUG9pbnQueS5sZW5ndGg7eSsrKXU9TWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bc10uZGF0YVBvaW50LnlbeV0pKSx1PHYmJih2PXUsQj1zKTtlbHNlIHgrPW1bc10uZGF0YVBvaW50Lnksej1tW3NdLmRhdGFQb2ludC54LmdldFRpbWU/bVtzXS5kYXRhUG9pbnQueC5nZXRUaW1lKCk6bVtzXS5kYXRhUG9pbnQueCx6PTEwMCooeC9tW3NdLmRhdGFTZXJpZXMucGxvdFVuaXQuZGF0YVBvaW50WVN1bXNbel0pLHU9TWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHopKSx1PHYmJih2PXUsQj1zKTtlbHNlIGZvcih2PU1hdGguYWJzKGQtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbChtWzBdLmRhdGFQb2ludC55KSkscz11PTA7czxtLmxlbmd0aDtzKyspaWYobVtzXS5kYXRhUG9pbnQueSYmbVtzXS5kYXRhUG9pbnQueS5sZW5ndGgpZm9yKHk9MDt5PG1bc10uZGF0YVBvaW50LnkubGVuZ3RoO3krKyl1PVxuTWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bc10uZGF0YVBvaW50LnlbeV0pKSx1PHYmJih2PXUsQj1zKTtlbHNlIHU9TWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bc10uZGF0YVBvaW50LnkpKSx1PHYmJih2PXUsQj1zKTt5PW1bQl07Yj0wO2lmKFwicmFuZ2VDb2x1bW5cIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0udHlwZXx8XCJyYW5nZUFyZWFcIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0udHlwZXx8XCJlcnJvclwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS50eXBlfHxcInJhbmdlU3BsaW5lQXJlYVwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS50eXBlfHxcImNhbmRsZXN0aWNrXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW0JdLnR5cGV8fFwib2hsY1wiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS50eXBlfHxcImJveEFuZFdoaXNrZXJcIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0udHlwZSl7dj1cbk1hdGguYWJzKGQtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh5LmRhdGFQb2ludC55WzBdKSk7Zm9yKHM9dT0wO3M8eS5kYXRhUG9pbnQueS5sZW5ndGg7cysrKXU9TWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHkuZGF0YVBvaW50Lnlbc10pKSx1PHYmJih2PXUsYj1zKTt3PTE9PT1xLmxpbmVXaWR0aCUyPyh0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHkuZGF0YVBvaW50LnlbYl0pPDwwKSswLjU6dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh5LmRhdGFQb2ludC55W2JdKTw8MDtrLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnkuZGF0YVBvaW50LnlbYl19KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/ZGEocihjKT95LmRhdGFQb2ludC55W2JdOmMsdGhpcy52YWx1ZUZvcm1hdFN0cmluZyxcbnRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsO3RoaXMudmFsdWU9eS5kYXRhUG9pbnQueVtiXX1lbHNlIGlmKFwic3RhY2tlZENvbHVtblwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS50eXBlfHxcInN0YWNrZWRBcmVhXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW0JdLnR5cGUpe3Y9TWF0aC5hYnMoZC10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKG1bMF0uZGF0YVBvaW50LnkpKTt4PXU9MDtmb3Iocz1COzA8PXM7cy0tKXgrPW1bc10uZGF0YVBvaW50LnksdT1NYXRoLmFicyhkLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeCkpLHU8diYmKHY9dSxiPXMpO3c9MT09PXEubGluZVdpZHRoJTI/KHRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeCk8PDApKzAuNTp0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHgpPDwwO2sudGV4dD10aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsXG5heGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp5LmRhdGFQb2ludC55fSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP2RhKHIoYyk/eS5kYXRhUG9pbnQueTpjLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw7dGhpcy52YWx1ZT14fWVsc2UgaWYoXCJzdGFja2VkQ29sdW1uMTAwXCI9PT10aGlzLnBhcmVudC5kYXRhU2VyaWVzW0JdLnR5cGV8fFwic3RhY2tlZEFyZWExMDBcIj09PXRoaXMucGFyZW50LmRhdGFTZXJpZXNbQl0udHlwZSl7dj1NYXRoLmFicyhkLXRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwobVswXS5kYXRhUG9pbnQueSkpO3g9dT0wO2ZvcihzPUI7MDw9cztzLS0peCs9bVtzXS5kYXRhUG9pbnQueSx6PW1bc10uZGF0YVBvaW50LnguZ2V0VGltZT9tW3NdLmRhdGFQb2ludC54LmdldFRpbWUoKTptW3NdLmRhdGFQb2ludC54LHo9MTAwKih4L21bc10uZGF0YVNlcmllcy5wbG90VW5pdC5kYXRhUG9pbnRZU3Vtc1t6XSksXG51PU1hdGguYWJzKGQtdGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh6KSksdTx2JiYodj11LGI9cyk7dz0xPT09cS5saW5lV2lkdGglMj8odGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh6KTw8MCkrMC41OnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeik8PDA7ay50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTp6fSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP2RhKHIoYyk/ejpjLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw7dGhpcy52YWx1ZT16fWVsc2VcIndhdGVyZmFsbFwiPT09dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS50eXBlPyh3PTE9PT1xLmxpbmVXaWR0aCUyPyh0aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHkuZGF0YVNlcmllcy5kYXRhUG9pbnRFT3NbeS5pbmRleF0uY3VtdWxhdGl2ZVN1bSk8PFxuMCkrMC41OnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeS5kYXRhU2VyaWVzLmRhdGFQb2ludEVPc1t5LmluZGV4XS5jdW11bGF0aXZlU3VtKTw8MCxrLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnkuZGF0YVNlcmllcy5kYXRhUG9pbnRFT3NbeS5pbmRleF0uY3VtdWxhdGl2ZVN1bX0pOnIodGhpcy5vcHRpb25zLmxhYmVsKT9kYShyKGMpP3kuZGF0YVNlcmllcy5kYXRhUG9pbnRFT3NbeS5pbmRleF0uY3VtdWxhdGl2ZVN1bTpjLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWwsdGhpcy52YWx1ZT15LmRhdGFTZXJpZXMuZGF0YVBvaW50RU9zW3kuaW5kZXhdLmN1bXVsYXRpdmVTdW0pOih3PTE9PT1xLmxpbmVXaWR0aCUyPyhyKGEpP2Q6dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh5LmRhdGFQb2ludC55KTw8XG4wKSswLjU6cihhKT9kOnRoaXMucGFyZW50LmNvbnZlcnRWYWx1ZVRvUGl4ZWwoeS5kYXRhUG9pbnQueSk8PDAsay50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTpyKGMpP3kuZGF0YVBvaW50Lnk6Y30pOnIodGhpcy5vcHRpb25zLmxhYmVsKT9kYShyKGMpP3kuZGF0YVBvaW50Lnk6Yyx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsLHRoaXMudmFsdWU9eS5kYXRhUG9pbnQueSk7Zj1oPXc7Yj10aGlzLmNoYXJ0LnBsb3RBcmVhLngxO2U9dGhpcy5jaGFydC5wbG90QXJlYS54Mjt0aGlzLmJvdW5kcz17eDE6Yix5MTpmLW4vMix4MjplLHkyOmgrbi8yfTtrLnk9aCtrLmZvbnRTaXplLzItay5tZWFzdXJlVGV4dCgpLmhlaWdodC8yKzI7ay55LWsuZm9udFNpemUvMjx0aGlzLmNoYXJ0LmJvdW5kcy55MT9cbmsueT10aGlzLmNoYXJ0LmJvdW5kcy55MStrLmZvbnRTaXplLzIrMjprLnkray5tZWFzdXJlVGV4dCgpLmhlaWdodC1rLmZvbnRTaXplLzI+dGhpcy5jaGFydC5ib3VuZHMueTImJihrLnk9dGhpcy5jaGFydC5ib3VuZHMueTItay5tZWFzdXJlVGV4dCgpLmhlaWdodCtrLmZvbnRTaXplLzIpO1wibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uP2sueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDItay5tZWFzdXJlVGV4dCgpLndpZHRoOlwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmKGsueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDIpfW09bnVsbDtpZihcImJvdHRvbVwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKVwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJmsueS1rLmZvbnRTaXplLzI8dGhpcy5jaGFydC5ib3VuZHMueTEmJihrLnk9dGhpcy5jaGFydC5ib3VuZHMueTEray5mb250U2l6ZS9cbjIpLFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJnRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy55Mi1rLmZvbnRTaXplLzIray5tZWFzdXJlVGV4dCgpLmhlaWdodD50aGlzLmNoYXJ0LmJvdW5kcy55MiYmKGsueT10aGlzLmNoYXJ0LmJvdW5kcy55Mi1rLmhlaWdodCtrLmZvbnRTaXplLzIrMiksYj49dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh0aGlzLnBhcmVudC5yZXZlcnNlZD90aGlzLnBhcmVudC52aWV3cG9ydE1heGltdW06dGhpcy5wYXJlbnQudmlld3BvcnRNaW5pbXVtKSYmZTw9dGhpcy5wYXJlbnQuY29udmVydFZhbHVlVG9QaXhlbCh0aGlzLnBhcmVudC5yZXZlcnNlZD90aGlzLnBhcmVudC52aWV3cG9ydE1pbmltdW06dGhpcy5wYXJlbnQudmlld3BvcnRNYXhpbXVtKSYmKDA8biYmKHEubW92ZVRvKGIsZikscS5saW5lVG8oZSxoKSxxLnN0cm9rZSgpLHRoaXMuX2hpZGRlbj0hMSkscS5yZXN0b3JlKCkpO2lmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcblwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbilcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmay54PHRoaXMuY2hhcnQuYm91bmRzLngxJiYoay54PXRoaXMuY2hhcnQuYm91bmRzLngxKSxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJmsueCtrLm1lYXN1cmVUZXh0KCkud2lkdGg+dGhpcy5jaGFydC5ib3VuZHMueDImJihrLng9dGhpcy5jaGFydC5ib3VuZHMueDItay5tZWFzdXJlVGV4dCgpLndpZHRoKSxoPj10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHRoaXMucGFyZW50LnJldmVyc2VkP3RoaXMucGFyZW50LnZpZXdwb3J0TWluaW11bTp0aGlzLnBhcmVudC52aWV3cG9ydE1heGltdW0pJiZmPD10aGlzLnBhcmVudC5jb252ZXJ0VmFsdWVUb1BpeGVsKHRoaXMucGFyZW50LnJldmVyc2VkP3RoaXMucGFyZW50LnZpZXdwb3J0TWF4aW11bTp0aGlzLnBhcmVudC52aWV3cG9ydE1pbmltdW0pJiYoMDxuJiYocS5tb3ZlVG8oYixmKSxxLmxpbmVUbyhlLFxuaCkscS5zdHJva2UoKSx0aGlzLl9oaWRkZW49ITEpLHEucmVzdG9yZSgpKX1lbHNle2lmKFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb258fFwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pYj1lPXA9MT09PXEubGluZVdpZHRoJTI/KGE8PDApKzAuNTphPDwwLGY9dGhpcy5jaGFydC5wbG90QXJlYS55MSxoPXRoaXMuY2hhcnQucGxvdEFyZWEueTIsdGhpcy5ib3VuZHM9e3gxOmItbi8yLHkxOmYseDI6ZStuLzIseTI6aH07ZWxzZSBpZihcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKWY9aD13PTE9PT1xLmxpbmVXaWR0aCUyPyhkPDwwKSswLjU6ZDw8MCxiPXRoaXMuY2hhcnQucGxvdEFyZWEueDEsZT10aGlzLmNoYXJ0LnBsb3RBcmVhLngyLHRoaXMuYm91bmRzPXt4MTpiLHkxOmYtbi8yLHgyOmUseTI6aCtuLzJ9O2lmKFwieHlTd2FwcGVkXCI9PT10aGlzLmNoYXJ0LnBsb3RJbmZvLmF4aXNQbGFjZW1lbnQpaWYoXCJsZWZ0XCI9PT1cbnRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJyaWdodFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKXt6PSExO2lmKHRoaXMucGFyZW50LmxhYmVscylmb3IobT1NYXRoLmNlaWwodGhpcy5wYXJlbnQuaW50ZXJ2YWwpLHM9MDtzPHRoaXMucGFyZW50LnZpZXdwb3J0TWF4aW11bTtzKz1tKWlmKHRoaXMucGFyZW50LmxhYmVsc1tzXSl6PSEwO2Vsc2V7ej0hMTticmVha31pZih6KXtpZihcImF4aXNYXCI9PT10aGlzLnBhcmVudC50eXBlKWZvcihzPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3k6ZH0pLHY9bnVsbCxCPTA7Qjx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtCKyspKHY9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS5nZXREYXRhUG9pbnRBdFgocywhMCkpJiYwPD12LmluZGV4JiYoay50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyxcbnZhbHVlOnIoYyk/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShhKTpjfSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP3YuZGF0YVBvaW50LmxhYmVsOnRoaXMubGFiZWwpfWVsc2Ugay50ZXh0PVwiZGF0ZVRpbWVcIiE9PXRoaXMucGFyZW50LnZhbHVlVHlwZXx8dGhpcy5wYXJlbnQubG9nYXJpdGhtaWM/dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnIoYyk/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShkKTpjfSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP2RhKHIoYyk/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShkKTpjLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWw6dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LFxuYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6cihjKT90aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGQpOmN9KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/QmEocihjKT90aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGQpOmMsdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6dGhpcy5sYWJlbDtrLnk9ZCtrLmZvbnRTaXplLzItay5tZWFzdXJlVGV4dCgpLmhlaWdodC8yKzI7ay55LWsuZm9udFNpemUvMjx0aGlzLmNoYXJ0LmJvdW5kcy55MT9rLnk9dGhpcy5jaGFydC5ib3VuZHMueTEray5mb250U2l6ZS8yKzI6ay55K2subWVhc3VyZVRleHQoKS5oZWlnaHQtay5mb250U2l6ZS8yPnRoaXMuY2hhcnQuYm91bmRzLnkyJiYoay55PXRoaXMuY2hhcnQuYm91bmRzLnkyLWsubWVhc3VyZVRleHQoKS5oZWlnaHQray5mb250U2l6ZS8yKTtcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbj9cbmsueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDEtay5tZWFzdXJlVGV4dCgpLndpZHRoOlwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmKGsueD10aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueDIpfWVsc2V7aWYoXCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbnx8XCJ0b3BcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbilrLnRleHQ9dGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnIoYyk/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShhKTpjfSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP2RhKHIoYyk/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShhKTpjLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWwsay54PWItay5tZWFzdXJlVGV4dCgpLndpZHRoL1xuMixrLngray53aWR0aD50aGlzLmNoYXJ0LmJvdW5kcy54MiYmKGsueD10aGlzLmNoYXJ0LmJvdW5kcy54Mi1rLndpZHRoKSxrLng8dGhpcy5jaGFydC5ib3VuZHMueDEmJihrLng9dGhpcy5jaGFydC5ib3VuZHMueDEpLFwiYm90dG9tXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24/ay55PXRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy55MitrLmZvbnRTaXplLzIrMjpcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uJiYoay55PXRoaXMucGFyZW50LmxpbmVDb29yZGluYXRlcy55MS1rLmhlaWdodCtrLmZvbnRTaXplLzIrMil9ZWxzZSBpZihcImJvdHRvbVwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKXt6PSExO209XCJcIjtpZih0aGlzLnBhcmVudC5sYWJlbHMpZm9yKG09TWF0aC5jZWlsKHRoaXMucGFyZW50LmludGVydmFsKSxzPTA7czx0aGlzLnBhcmVudC52aWV3cG9ydE1heGltdW07cys9bSlpZih0aGlzLnBhcmVudC5sYWJlbHNbc10pej1cbiEwO2Vsc2V7ej0hMTticmVha31pZih6KXtpZihcImF4aXNYXCI9PT10aGlzLnBhcmVudC50eXBlKWZvcihzPXRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pLHY9bnVsbCxCPTA7Qjx0aGlzLnBhcmVudC5kYXRhU2VyaWVzLmxlbmd0aDtCKyspKHY9dGhpcy5wYXJlbnQuZGF0YVNlcmllc1tCXS5nZXREYXRhUG9pbnRBdFgocywhMCkpJiYwPD12LmluZGV4JiYoay50ZXh0PXRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTpyKGMpP3RoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoYSk6Y30pOnIodGhpcy5vcHRpb25zLmxhYmVsKT9yKGMpP3YuZGF0YVBvaW50LmxhYmVsOmM6dGhpcy5sYWJlbCl9ZWxzZSBrLnRleHQ9XCJkYXRlVGltZVwiIT09dGhpcy5wYXJlbnQudmFsdWVUeXBlfHx0aGlzLnBhcmVudC5sb2dhcml0aG1pYz9cbnRoaXMubGFiZWxGb3JtYXR0ZXI/dGhpcy5sYWJlbEZvcm1hdHRlcih7Y2hhcnQ6dGhpcy5jaGFydCxheGlzOnRoaXMucGFyZW50Lm9wdGlvbnMsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyx2YWx1ZTpyKGMpPzA8dGhpcy5wYXJlbnQuZGF0YVNlcmllcy5sZW5ndGg/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShhKTpcIlwiOmN9KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/ZGEocihjKT90aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGEpOmMsdGhpcy52YWx1ZUZvcm1hdFN0cmluZyx0aGlzLmNoYXJ0Ll9jdWx0dXJlSW5mbyk6dGhpcy5sYWJlbDp0aGlzLmxhYmVsRm9ybWF0dGVyP3RoaXMubGFiZWxGb3JtYXR0ZXIoe2NoYXJ0OnRoaXMuY2hhcnQsYXhpczp0aGlzLnBhcmVudC5vcHRpb25zLGNyb3NzaGFpcjp0aGlzLm9wdGlvbnMsdmFsdWU6cihjKT90aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKGEpOmN9KTpyKHRoaXMub3B0aW9ucy5sYWJlbCk/QmEocihjKT9cbnRoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoYSk6Yyx0aGlzLnZhbHVlRm9ybWF0U3RyaW5nLHRoaXMuY2hhcnQuX2N1bHR1cmVJbmZvKTp0aGlzLmxhYmVsO2sueD1iLWsubWVhc3VyZVRleHQoKS53aWR0aC8yO2sueCtrLndpZHRoPnRoaXMuY2hhcnQuYm91bmRzLngyJiYoay54PXRoaXMuY2hhcnQuYm91bmRzLngyLWsud2lkdGgpO2sueDx0aGlzLmNoYXJ0LmJvdW5kcy54MSYmKGsueD10aGlzLmNoYXJ0LmJvdW5kcy54MSk7XCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbj9rLnk9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLnkyK2suZm9udFNpemUvMisyOlwidG9wXCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJihrLnk9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLnkxLWsuaGVpZ2h0K2suZm9udFNpemUvMisyKX1lbHNlIGlmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24pay50ZXh0PVxudGhpcy5sYWJlbEZvcm1hdHRlcj90aGlzLmxhYmVsRm9ybWF0dGVyKHtjaGFydDp0aGlzLmNoYXJ0LGF4aXM6dGhpcy5wYXJlbnQub3B0aW9ucyxjcm9zc2hhaXI6dGhpcy5vcHRpb25zLHZhbHVlOnIoYyk/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShkKTpjfSk6cih0aGlzLm9wdGlvbnMubGFiZWwpP2RhKHIoYyk/dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShkKTpjLHRoaXMudmFsdWVGb3JtYXRTdHJpbmcsdGhpcy5jaGFydC5fY3VsdHVyZUluZm8pOnRoaXMubGFiZWwsay55PWQray5mb250U2l6ZS8yLWsubWVhc3VyZVRleHQoKS5oZWlnaHQvMisyLGsueS1rLmZvbnRTaXplLzI8dGhpcy5jaGFydC5ib3VuZHMueTE/ay55PXRoaXMuY2hhcnQuYm91bmRzLnkxK2suZm9udFNpemUvMisyOmsueStrLm1lYXN1cmVUZXh0KCkuaGVpZ2h0LWsuZm9udFNpemUvMj50aGlzLmNoYXJ0LmJvdW5kcy55MiYmKGsueT10aGlzLmNoYXJ0LmJvdW5kcy55Mi1rLm1lYXN1cmVUZXh0KCkuaGVpZ2h0K1xuay5mb250U2l6ZS8yKSxcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbj9rLng9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLngyLWsubWVhc3VyZVRleHQoKS53aWR0aDpcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJihrLng9dGhpcy5wYXJlbnQubGluZUNvb3JkaW5hdGVzLngyKTtcImxlZnRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmay54PHRoaXMuY2hhcnQuYm91bmRzLngxP2sueD10aGlzLmNoYXJ0LmJvdW5kcy54MTpcInJpZ2h0XCI9PT10aGlzLnBhcmVudC5fcG9zaXRpb24mJmsueCtrLm1lYXN1cmVUZXh0KCkud2lkdGg+dGhpcy5jaGFydC5ib3VuZHMueDI/ay54PXRoaXMuY2hhcnQuYm91bmRzLngyLWsubWVhc3VyZVRleHQoKS53aWR0aDpcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uJiZrLnktay5mb250U2l6ZS8yPHRoaXMuY2hhcnQuYm91bmRzLnkxP2sueT10aGlzLmNoYXJ0LmJvdW5kcy55MStrLmZvbnRTaXplLzI6XCJib3R0b21cIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbiYmXG50aGlzLnBhcmVudC5saW5lQ29vcmRpbmF0ZXMueTItay5mb250U2l6ZS8yK2subWVhc3VyZVRleHQoKS5oZWlnaHQ+dGhpcy5jaGFydC5ib3VuZHMueTImJihrLnk9dGhpcy5jaGFydC5ib3VuZHMueTItay5oZWlnaHQray5mb250U2l6ZS8yKzIpOzA8biYmKHEubW92ZVRvKGIsZikscS5saW5lVG8oZSxoKSxxLnN0cm9rZSgpLHRoaXMuX2hpZGRlbj0hMSk7cS5yZXN0b3JlKCk7dGhpcy52YWx1ZT1cImJvdHRvbVwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uP3RoaXMucGFyZW50LmNvbnZlcnRQaXhlbFRvVmFsdWUoYSk6dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZShkKX1pZihcImJvdHRvbVwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcInRvcFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9uKXRoaXMuX3VwZGF0ZWRWYWx1ZT10aGlzLnBhcmVudC5jb252ZXJ0UGl4ZWxUb1ZhbHVlKHApO2lmKFwibGVmdFwiPT09dGhpcy5wYXJlbnQuX3Bvc2l0aW9ufHxcblwicmlnaHRcIj09PXRoaXMucGFyZW50Ll9wb3NpdGlvbil0aGlzLl91cGRhdGVkVmFsdWU9dGhpcy5wYXJlbnQuY29udmVydFBpeGVsVG9WYWx1ZSh3KTt0aGlzLl90ZXh0QmxvY2s9azt0aGlzLl9sYWJlbD1jO3IoYyl8fHRoaXMucmVuZGVyTGFiZWwoKTtxLmdsb2JhbEFscGhhPWd9O2NhLnByb3RvdHlwZS5yZW5kZXJMYWJlbD1mdW5jdGlvbigpe3IodGhpcy5fdGV4dEJsb2NrKXx8KHIodGhpcy5fdGV4dEJsb2NrLnRleHQpfHwhKFwibnVtYmVyXCI9PT10eXBlb2YgdGhpcy5fdGV4dEJsb2NrLnRleHQudmFsdWVPZigpfHwwPHRoaXMuX3RleHRCbG9jay50ZXh0Lmxlbmd0aCl8fHRoaXMuX2hpZGRlbil8fHRoaXMuX3RleHRCbG9jay5yZW5kZXIoITApO3IodGhpcy5fbGFiZWwpJiZ0aGlzLmRpc3BhdGNoRXZlbnQoXCJ1cGRhdGVkXCIse2NoYXJ0OnRoaXMuY2hhcnQsY3Jvc3NoYWlyOnRoaXMub3B0aW9ucyxheGlzOnRoaXMucGFyZW50LHZhbHVlOnRoaXMudmFsdWV9LHRoaXMucGFyZW50KX07XG5vYShVLEcpO1UucHJvdG90eXBlLl9pbml0aWFsaXplPWZ1bmN0aW9uKCl7dGhpcy51cGRhdGVPcHRpb24oXCJ1cGRhdGVkXCIpO3RoaXMudXBkYXRlT3B0aW9uKFwiaGlkZGVuXCIpO2lmKHRoaXMuZW5hYmxlZCl7dGhpcy5jb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLFwiY2FudmFzanMtY2hhcnQtdG9vbHRpcFwiKTt0aGlzLmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCI7dGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0PVwiYXV0b1wiO3RoaXMuY29udGFpbmVyLnN0eWxlLmJveFNoYWRvdz1cIjFweCAxcHggMnB4IDJweCByZ2JhKDAsMCwwLDAuMSlcIjt0aGlzLmNvbnRhaW5lci5zdHlsZS56SW5kZXg9XCIxMDAwXCI7dGhpcy5jb250YWluZXIuc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIjt0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5hLnN0eWxlLndpZHRoPVwiYXV0b1wiO2Euc3R5bGUuaGVpZ2h0PVwiYXV0b1wiO2Euc3R5bGUubWluV2lkdGg9XCI1MHB4XCI7YS5zdHlsZS5saW5lSGVpZ2h0PVwibm9ybWFsXCI7YS5zdHlsZS5tYXJnaW49XCIwcHggMHB4IDBweCAwcHhcIjthLnN0eWxlLnBhZGRpbmc9XCI1cHhcIjthLnN0eWxlLmZvbnRGYW1pbHk9XCJDYWxpYnJpLCBBcmlhbCwgR2VvcmdpYSwgc2VyaWZcIjthLnN0eWxlLmZvbnRXZWlnaHQ9XCJub3JtYWxcIjthLnN0eWxlLmZvbnRTdHlsZT13P1wiaXRhbGljXCI6XCJub3JtYWxcIjthLnN0eWxlLmZvbnRTaXplPVwiMTRweFwiO2Euc3R5bGUuY29sb3I9XCIjMDAwMDAwXCI7YS5zdHlsZS50ZXh0U2hhZG93PVwiMXB4IDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpXCI7YS5zdHlsZS50ZXh0QWxpZ249XCJsZWZ0XCI7YS5zdHlsZS5ib3JkZXI9XCIycHggc29saWQgZ3JheVwiO2Euc3R5bGUuYmFja2dyb3VuZD13P1wicmdiYSgyNTUsMjU1LDI1NSwuOSlcIjpcInJnYigyNTUsMjU1LDI1NSlcIjthLnN0eWxlLnRleHRJbmRlbnQ9XG5cIjBweFwiO2Euc3R5bGUud2hpdGVTcGFjZT1cIm5vd3JhcFwiO2Euc3R5bGUuYm9yZGVyUmFkaXVzPVwiNXB4XCI7YS5zdHlsZS5Nb3pVc2VyU2VsZWN0PVwibm9uZVwiO2Euc3R5bGUuV2Via2l0VXNlclNlbGVjdD1cIm5vbmVcIjthLnN0eWxlLm1zVXNlclNlbGVjdD1cIm5vbmVcIjthLnN0eWxlLnVzZXJTZWxlY3Q9XCJub25lXCI7d3x8KGEuc3R5bGUuZmlsdGVyPVwiYWxwaGEob3BhY2l0eSA9IDkwKVwiLGEuc3R5bGUuZmlsdGVyPVwicHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LlNoYWRvdyhTdHJlbmd0aD0zLCBEaXJlY3Rpb249MTM1LCBDb2xvcj0nIzY2NjY2NicpXCIpO2EuaW5uZXJUZXh0PVwiU2FtcGxlIFRvb2x0aXBcIjt0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChhKTt0aGlzLmNvbnRlbnREaXY9dGhpcy5jb250YWluZXIuZmlyc3RDaGlsZDt0aGlzLmNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXM9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJhZGl1czt0aGlzLmNoYXJ0Ll9jYW52YXNKU0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcil9fTtcblUucHJvdG90eXBlLm1vdXNlTW92ZUhhbmRsZXI9ZnVuY3Rpb24oYSxkKXt0aGlzLl9sYXN0VXBkYXRlZCYmND4obmV3IERhdGUpLmdldFRpbWUoKS10aGlzLl9sYXN0VXBkYXRlZHx8KHRoaXMuX2xhc3RVcGRhdGVkPShuZXcgRGF0ZSkuZ2V0VGltZSgpLHRoaXMuY2hhcnQucmVzZXRPdmVybGF5ZWRDYW52YXMoKSx0aGlzLl91cGRhdGVUb29sVGlwKGEsZCksIXRoaXMuX3VwZGF0ZWRFdmVudFBhcmFtZXRlcnN8fChpc05hTih0aGlzLl9wcmV2WCl8fGlzTmFOKHRoaXMuX3ByZXZZKSl8fHRoaXMuZGlzcGF0Y2hFdmVudChcInVwZGF0ZWRcIix0aGlzLl91cGRhdGVkRXZlbnRQYXJhbWV0ZXJzLHRoaXMpKX07VS5wcm90b3R5cGUuX3VwZGF0ZVRvb2xUaXA9ZnVuY3Rpb24oYSxkLGMpe2M9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBjPyEwOmM7dGhpcy5jb250YWluZXJ8fHRoaXMuX2luaXRpYWxpemUoKTt0aGlzLmVuYWJsZWR8fHRoaXMuaGlkZSgpO2lmKCF0aGlzLmNoYXJ0LmRpc2FibGVUb29sVGlwKXtpZihcInVuZGVmaW5lZFwiPT09XG50eXBlb2YgYXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBkKXtpZihpc05hTih0aGlzLl9wcmV2WCl8fGlzTmFOKHRoaXMuX3ByZXZZKSlyZXR1cm47YT10aGlzLl9wcmV2WDtkPXRoaXMuX3ByZXZZfWVsc2UgdGhpcy5fcHJldlg9YSx0aGlzLl9wcmV2WT1kO3ZhciBiPW51bGwsZT1udWxsLGY9W10saD0wO2lmKHRoaXMuc2hhcmVkJiZ0aGlzLmVuYWJsZWQmJlwibm9uZVwiIT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50KXt2YXIgcD1bXTtpZih0aGlzLmNoYXJ0LmF4aXNYKWZvcih2YXIgdj0wO3Y8dGhpcy5jaGFydC5heGlzWC5sZW5ndGg7disrKXtmb3IodmFyIGg9XCJ4eVN3YXBwZWRcIj09PXRoaXMuY2hhcnQucGxvdEluZm8uYXhpc1BsYWNlbWVudD90aGlzLmNoYXJ0LmF4aXNYW3ZdLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3k6ZH0pOnRoaXMuY2hhcnQuYXhpc1hbdl0uY29udmVydFBpeGVsVG9WYWx1ZSh7eDphfSksaz1udWxsLGI9MDtiPHRoaXMuY2hhcnQuYXhpc1hbdl0uZGF0YVNlcmllcy5sZW5ndGg7YisrKShrPVxudGhpcy5jaGFydC5heGlzWFt2XS5kYXRhU2VyaWVzW2JdLmdldERhdGFQb2ludEF0WChoLGMpKSYmMDw9ay5pbmRleCYmKGsuZGF0YVNlcmllcz10aGlzLmNoYXJ0LmF4aXNYW3ZdLmRhdGFTZXJpZXNbYl0sbnVsbCE9PWsuZGF0YVBvaW50LnkmJmsuZGF0YVNlcmllcy52aXNpYmxlJiZwLnB1c2goaykpO2s9bnVsbH1pZih0aGlzLmNoYXJ0LmF4aXNYMilmb3Iodj0wO3Y8dGhpcy5jaGFydC5heGlzWDIubGVuZ3RoO3YrKyl7aD1cInh5U3dhcHBlZFwiPT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50P3RoaXMuY2hhcnQuYXhpc1gyW3ZdLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3k6ZH0pOnRoaXMuY2hhcnQuYXhpc1gyW3ZdLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pO2s9bnVsbDtmb3IoYj0wO2I8dGhpcy5jaGFydC5heGlzWDJbdl0uZGF0YVNlcmllcy5sZW5ndGg7YisrKShrPXRoaXMuY2hhcnQuYXhpc1gyW3ZdLmRhdGFTZXJpZXNbYl0uZ2V0RGF0YVBvaW50QXRYKGgsXG5jKSkmJjA8PWsuaW5kZXgmJihrLmRhdGFTZXJpZXM9dGhpcy5jaGFydC5heGlzWDJbdl0uZGF0YVNlcmllc1tiXSxudWxsIT09ay5kYXRhUG9pbnQueSYmay5kYXRhU2VyaWVzLnZpc2libGUmJnAucHVzaChrKSk7az1udWxsfWlmKDA9PT1wLmxlbmd0aClyZXR1cm47cC5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZGlzdGFuY2UtYi5kaXN0YW5jZX0pO2M9cFswXTtmb3IoYj0wO2I8cC5sZW5ndGg7YisrKXBbYl0uZGF0YVBvaW50LngudmFsdWVPZigpPT09Yy5kYXRhUG9pbnQueC52YWx1ZU9mKCkmJmYucHVzaChwW2JdKTtwPW51bGx9ZWxzZXtpZihiPXRoaXMuY2hhcnQuZ2V0RGF0YVBvaW50QXRYWShhLGQsYykpdGhpcy5jdXJyZW50RGF0YVBvaW50SW5kZXg9Yi5kYXRhUG9pbnRJbmRleCx0aGlzLmN1cnJlbnRTZXJpZXNJbmRleD1iLmRhdGFTZXJpZXMuaW5kZXg7ZWxzZSBpZih3KWlmKGI9JGEoYSxkLHRoaXMuY2hhcnQuX2V2ZW50TWFuYWdlci5naG9zdEN0eCksMDxiJiZcblwidW5kZWZpbmVkXCIhPT10eXBlb2YgdGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLm9iamVjdE1hcFtiXSl7Yj10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2JdO2lmKFwibGVnZW5kSXRlbVwiPT09Yi5vYmplY3RUeXBlKXJldHVybjt0aGlzLmN1cnJlbnRTZXJpZXNJbmRleD1iLmRhdGFTZXJpZXNJbmRleDt0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleD0wPD1iLmRhdGFQb2ludEluZGV4P2IuZGF0YVBvaW50SW5kZXg6LTF9ZWxzZSB0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleD0tMTtlbHNlIHRoaXMuY3VycmVudERhdGFQb2ludEluZGV4PS0xO2lmKDA8PXRoaXMuY3VycmVudFNlcmllc0luZGV4KXtlPXRoaXMuY2hhcnQuZGF0YVt0aGlzLmN1cnJlbnRTZXJpZXNJbmRleF07az17fTtpZigwPD10aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleCliPWUuZGF0YVBvaW50c1t0aGlzLmN1cnJlbnREYXRhUG9pbnRJbmRleF0say5kYXRhU2VyaWVzPWUsay5kYXRhUG9pbnQ9YixcbmsuaW5kZXg9dGhpcy5jdXJyZW50RGF0YVBvaW50SW5kZXgsay5kaXN0YW5jZT1NYXRoLmFicyhiLngtaCksXCJ3YXRlcmZhbGxcIj09PWUudHlwZSYmKGsuY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlPWUuZGF0YVBvaW50RU9zW3RoaXMuY3VycmVudERhdGFQb2ludEluZGV4XS5jdW11bGF0aXZlU3VtWVN0YXJ0VmFsdWUsay5jdW11bGF0aXZlU3VtPWUuZGF0YVBvaW50RU9zW3RoaXMuY3VycmVudERhdGFQb2ludEluZGV4XS5jdW11bGF0aXZlU3VtKTtlbHNle2lmKCF0aGlzLmVuYWJsZWR8fFwibGluZVwiIT09ZS50eXBlJiZcInN0ZXBMaW5lXCIhPT1lLnR5cGUmJlwic3BsaW5lXCIhPT1lLnR5cGUmJlwiYXJlYVwiIT09ZS50eXBlJiZcInN0ZXBBcmVhXCIhPT1lLnR5cGUmJlwic3BsaW5lQXJlYVwiIT09ZS50eXBlJiZcInN0YWNrZWRBcmVhXCIhPT1lLnR5cGUmJlwic3RhY2tlZEFyZWExMDBcIiE9PWUudHlwZSYmXCJyYW5nZUFyZWFcIiE9PWUudHlwZSYmXCJyYW5nZVNwbGluZUFyZWFcIiE9PWUudHlwZSYmXCJjYW5kbGVzdGlja1wiIT09XG5lLnR5cGUmJlwib2hsY1wiIT09ZS50eXBlJiZcImJveEFuZFdoaXNrZXJcIiE9PWUudHlwZSlyZXR1cm47aD1lLmF4aXNYLmNvbnZlcnRQaXhlbFRvVmFsdWUoe3g6YX0pO2s9ZS5nZXREYXRhUG9pbnRBdFgoaCxjKTtyKGspfHwoay5kYXRhU2VyaWVzPWUsdGhpcy5jdXJyZW50RGF0YVBvaW50SW5kZXg9ay5pbmRleCxiPWsuZGF0YVBvaW50KX1pZighcihrKSYmIXIoay5kYXRhUG9pbnQpJiYhcihrLmRhdGFQb2ludC55KSlpZihrLmRhdGFTZXJpZXMuYXhpc1kpaWYoMDxrLmRhdGFQb2ludC55Lmxlbmd0aCl7Zm9yKGI9Yz0wO2I8ay5kYXRhUG9pbnQueS5sZW5ndGg7YisrKWsuZGF0YVBvaW50LnlbYl08ay5kYXRhU2VyaWVzLmF4aXNZLnZpZXdwb3J0TWluaW11bT9jLS06ay5kYXRhUG9pbnQueVtiXT5rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtJiZjKys7YzxrLmRhdGFQb2ludC55Lmxlbmd0aCYmYz4tay5kYXRhUG9pbnQueS5sZW5ndGgmJmYucHVzaChrKX1lbHNlXCJjb2x1bW5cIj09PVxuZS50eXBlfHxcImJhclwiPT09ZS50eXBlPzA+ay5kYXRhUG9pbnQueT8wPmsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1pbmltdW0mJmsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1heGltdW0+PWsuZGF0YVBvaW50LnkmJmYucHVzaChrKTprLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNaW5pbXVtPD1rLmRhdGFQb2ludC55JiYwPD1rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtJiZmLnB1c2goayk6XCJidWJibGVcIj09PWUudHlwZT8oYz10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2UuZGF0YVBvaW50SWRzW2suaW5kZXhdXS5zaXplLzIsay5kYXRhUG9pbnQueT49ay5kYXRhU2VyaWVzLmF4aXNZLnZpZXdwb3J0TWluaW11bS1jJiZrLmRhdGFQb2ludC55PD1rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtK2MmJmYucHVzaChrKSk6XCJ3YXRlcmZhbGxcIj09PWUudHlwZT8oYz0wLGsuY3VtdWxhdGl2ZVN1bVlTdGFydFZhbHVlPGsuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1pbmltdW0/XG5jLS06ay5jdW11bGF0aXZlU3VtWVN0YXJ0VmFsdWU+ay5kYXRhU2VyaWVzLmF4aXNZLnZpZXdwb3J0TWF4aW11bSYmYysrLGsuY3VtdWxhdGl2ZVN1bTxrLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNaW5pbXVtP2MtLTprLmN1bXVsYXRpdmVTdW0+ay5kYXRhU2VyaWVzLmF4aXNZLnZpZXdwb3J0TWF4aW11bSYmYysrLDI+YyYmLTI8YyYmZi5wdXNoKGspKTooMDw9ay5kYXRhU2VyaWVzLnR5cGUuaW5kZXhPZihcIjEwMFwiKXx8XCJzdGFja2VkQ29sdW1uXCI9PT1lLnR5cGV8fFwic3RhY2tlZEJhclwiPT09ZS50eXBlfHxrLmRhdGFQb2ludC55Pj1rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNaW5pbXVtJiZrLmRhdGFQb2ludC55PD1rLmRhdGFTZXJpZXMuYXhpc1kudmlld3BvcnRNYXhpbXVtKSYmZi5wdXNoKGspO2Vsc2UgZi5wdXNoKGspfX1pZigwPGYubGVuZ3RoKXtpZih0aGlzLmhpZ2hsaWdodE9iamVjdHMoZiksdGhpcy5lbmFibGVkKXtjPVwiXCI7Yz10aGlzLmdldFRvb2xUaXBJbm5lckhUTUwoe2VudHJpZXM6Zn0pO1xuaWYobnVsbCE9PWMpe3RoaXMuY29udGVudERpdi5pbm5lckhUTUw9YztpZih0aGlzLmlzVG9vbFRpcERlZmluZWRJbkRhdGEmJnIodGhpcy5vcHRpb25zLmNvbnRlbnQpJiZyKHRoaXMub3B0aW9ucy5jb250ZW50Rm9ybWF0dGVyKSlmb3IoaD10aGlzLmNvbnRlbnREaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzcGFuXCIpLGI9MDtiPGgubGVuZ3RoO2IrKyloW2JdJiYoaFtiXS5zdHlsZS5jb2xvcj1oW2JdLmdldEF0dHJpYnV0ZShcImRhdGEtY29sb3JcIikpO2g9ITE7XCJub25lXCI9PT10aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5JiYoaD0hMCx0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIik7dHJ5e3RoaXMuY29udGVudERpdi5zdHlsZS5iYWNrZ3JvdW5kPXRoaXMuYmFja2dyb3VuZENvbG9yP3RoaXMuYmFja2dyb3VuZENvbG9yOnc/XCJyZ2JhKDI1NSwyNTUsMjU1LC45KVwiOlwicmdiKDI1NSwyNTUsMjU1KVwiLHRoaXMuYm9yZGVyQ29sb3I9XCJ3YXRlcmZhbGxcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlP1xudGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJpZ2h0Q29sb3I9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlckxlZnRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyQ29sb3I9dGhpcy5vcHRpb25zLmJvcmRlckNvbG9yP3RoaXMub3B0aW9ucy5ib3JkZXJDb2xvcjpmWzBdLmRhdGFQb2ludC5jb2xvcj9mWzBdLmRhdGFQb2ludC5jb2xvcjowPGZbMF0uZGF0YVBvaW50Lnk/ZlswXS5kYXRhU2VyaWVzLnJpc2luZ0NvbG9yOmZbMF0uZGF0YVNlcmllcy5mYWxsaW5nQ29sb3I6XCJlcnJvclwiPT09ZlswXS5kYXRhU2VyaWVzLnR5cGU/dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJpZ2h0Q29sb3I9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlckxlZnRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyQ29sb3I9dGhpcy5vcHRpb25zLmJvcmRlckNvbG9yP3RoaXMub3B0aW9ucy5ib3JkZXJDb2xvcjpmWzBdLmRhdGFTZXJpZXMuY29sb3I/ZlswXS5kYXRhU2VyaWVzLmNvbG9yOlxuZlswXS5kYXRhU2VyaWVzLl9jb2xvclNldFtlLmluZGV4JWZbMF0uZGF0YVNlcmllcy5fY29sb3JTZXQubGVuZ3RoXTp0aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyUmlnaHRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyTGVmdENvbG9yPXRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJDb2xvcj10aGlzLm9wdGlvbnMuYm9yZGVyQ29sb3I/dGhpcy5vcHRpb25zLmJvcmRlckNvbG9yOmZbMF0uZGF0YVBvaW50LmNvbG9yP2ZbMF0uZGF0YVBvaW50LmNvbG9yOmZbMF0uZGF0YVNlcmllcy5jb2xvcj9mWzBdLmRhdGFTZXJpZXMuY29sb3I6ZlswXS5kYXRhU2VyaWVzLl9jb2xvclNldFtmWzBdLmluZGV4JWZbMF0uZGF0YVNlcmllcy5fY29sb3JTZXQubGVuZ3RoXSx0aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyV2lkdGg9dGhpcy5ib3JkZXJUaGlja25lc3N8fDA9PT10aGlzLmJvcmRlclRoaWNrbmVzcz90aGlzLmJvcmRlclRoaWNrbmVzcytcInB4XCI6XCIycHhcIix0aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyUmFkaXVzPVxudGhpcy5jb3JuZXJSYWRpdXN8fDA9PT10aGlzLmNvcm5lclJhZGl1cz90aGlzLmNvcm5lclJhZGl1cytcInB4XCI6XCI1cHhcIix0aGlzLmNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXM9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJhZGl1cyx0aGlzLmNvbnRlbnREaXYuc3R5bGUuZm9udFNpemU9dGhpcy5mb250U2l6ZXx8MD09PXRoaXMuZm9udFNpemU/dGhpcy5mb250U2l6ZStcInB4XCI6XCIxNHB4XCIsdGhpcy5jb250ZW50RGl2LnN0eWxlLmNvbG9yPXRoaXMuZm9udENvbG9yP3RoaXMuZm9udENvbG9yOlwiIzAwMDAwMFwiLHRoaXMuY29udGVudERpdi5zdHlsZS5mb250RmFtaWx5PXRoaXMuZm9udEZhbWlseT90aGlzLmZvbnRGYW1pbHk6XCJDYWxpYnJpLCBBcmlhbCwgR2VvcmdpYSwgc2VyaWY7XCIsdGhpcy5jb250ZW50RGl2LnN0eWxlLmZvbnRXZWlnaHQ9dGhpcy5mb250V2VpZ2h0P3RoaXMuZm9udFdlaWdodDpcIm5vcm1hbFwiLHRoaXMuY29udGVudERpdi5zdHlsZS5mb250U3R5bGU9XG50aGlzLmZvbnRTdHlsZT90aGlzLmZvbnRTdHlsZTp3P1wiaXRhbGljXCI6XCJub3JtYWxcIn1jYXRjaChtKXt9XCJwaWVcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcImRvdWdobnV0XCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJmdW5uZWxcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcInB5cmFtaWRcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcImJhclwiPT09ZlswXS5kYXRhU2VyaWVzLnR5cGV8fFwicmFuZ2VCYXJcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRCYXJcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRCYXIxMDBcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlP2E9YS0xMC10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDooYT1mWzBdLmRhdGFTZXJpZXMuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChmWzBdLmRhdGFQb2ludC54KS10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDw8MCxhLT0xMCk7MD5hJiYoYSs9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgrXG4yMCk7YSt0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aD5NYXRoLm1heCh0aGlzLmNoYXJ0LmNvbnRhaW5lci5jbGllbnRXaWR0aCx0aGlzLmNoYXJ0LndpZHRoKSYmKGE9TWF0aC5tYXgoMCxNYXRoLm1heCh0aGlzLmNoYXJ0LmNvbnRhaW5lci5jbGllbnRXaWR0aCx0aGlzLmNoYXJ0LndpZHRoKS10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCkpO2Q9MSE9PWYubGVuZ3RofHx0aGlzLnNoYXJlZHx8XCJsaW5lXCIhPT1mWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJzdGVwTGluZVwiIT09ZlswXS5kYXRhU2VyaWVzLnR5cGUmJlwic3BsaW5lXCIhPT1mWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJhcmVhXCIhPT1mWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJzdGVwQXJlYVwiIT09ZlswXS5kYXRhU2VyaWVzLnR5cGUmJlwic3BsaW5lQXJlYVwiIT09ZlswXS5kYXRhU2VyaWVzLnR5cGU/XCJiYXJcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcInJhbmdlQmFyXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGFja2VkQmFyXCI9PT1cbmZbMF0uZGF0YVNlcmllcy50eXBlfHxcInN0YWNrZWRCYXIxMDBcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlP2ZbMF0uZGF0YVNlcmllcy5heGlzWC5jb252ZXJ0VmFsdWVUb1BpeGVsKGZbMF0uZGF0YVBvaW50LngpOmQ6ZlswXS5kYXRhU2VyaWVzLmF4aXNZLmNvbnZlcnRWYWx1ZVRvUGl4ZWwoZlswXS5kYXRhUG9pbnQueSk7ZD0tZCsxMDswPGQrdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0KzUmJihkLT1kK3RoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCs1LTApO3RoaXMuZml4TW96VHJhbnNpdGlvbkRlbGF5KGEsZCk7IXRoaXMuYW5pbWF0aW9uRW5hYmxlZHx8aD90aGlzLmRpc2FibGVBbmltYXRpb24oKToodGhpcy5lbmFibGVBbmltYXRpb24oKSx0aGlzLmNvbnRhaW5lci5zdHlsZS5Nb3pUcmFuc2l0aW9uPXRoaXMubW96Q29udGFpbmVyVHJhbnNpdGlvbik7dGhpcy5wb3NpdGlvbkxlZnQ9YTt0aGlzLnBvc2l0aW9uQm90dG9tPWQ7dGhpcy5jb250YWluZXIuc3R5bGUubGVmdD1cbmErXCJweFwiO3RoaXMuY29udGFpbmVyLnN0eWxlLmJvdHRvbT1kK1wicHhcIn1lbHNlIHRoaXMuaGlkZSghMSksdGhpcy5lbmFibGVkJiZ0aGlzLmRpc3BhdGNoRXZlbnQoXCJoaWRkZW5cIix7Y2hhcnQ6dGhpcy5jaGFydCx0b29sVGlwOnRoaXN9LHRoaXMpO2Q9W107Zm9yKGI9MDtiPGYubGVuZ3RoO2IrKylkLnB1c2goe3hWYWx1ZTpmW2JdLmRhdGFQb2ludC54LGRhdGFQb2ludDpmW2JdLmRhdGFQb2ludCxkYXRhU2VyaWVzOmZbYl0uZGF0YVNlcmllcyxkYXRhUG9pbnRJbmRleDpmW2JdLmluZGV4LGRhdGFTZXJpZXNJbmRleDpmW2JdLmRhdGFTZXJpZXMuX2luZGV4fSk7dGhpcy5fdXBkYXRlZEV2ZW50UGFyYW1ldGVycz17Y2hhcnQ6dGhpcy5jaGFydCx0b29sVGlwOnRoaXMub3B0aW9ucyxjb250ZW50OmMsZW50cmllczpkfTt0aGlzLl9lbnRyaWVzPWZ9fWVsc2UgdGhpcy5oaWRlKCksdGhpcy5lbmFibGVkJiZ0aGlzLmRpc3BhdGNoRXZlbnQoXCJoaWRkZW5cIix7Y2hhcnQ6dGhpcy5jaGFydCxcbnRvb2xUaXA6dGhpc30sdGhpcyl9fTtVLnByb3RvdHlwZS5oaWdobGlnaHRPYmplY3RzPWZ1bmN0aW9uKGEpe3ZhciBkPXRoaXMuY2hhcnQub3ZlcmxhaWRDYW52YXNDdHg7aWYocih0aGlzLmNoYXJ0LmNsZWFyZWRPdmVybGF5ZWRDYW52YXMpfHxcInRvb2xUaXBcIj09PXRoaXMuY2hhcnQuY2xlYXJlZE92ZXJsYXllZENhbnZhcyl0aGlzLmNoYXJ0LnJlc2V0T3ZlcmxheWVkQ2FudmFzKCksZC5jbGVhclJlY3QoMCwwLHRoaXMuY2hhcnQud2lkdGgsdGhpcy5jaGFydC5oZWlnaHQpLHRoaXMuY2hhcnQuY2xlYXJlZE92ZXJsYXllZENhbnZhcz1cInRvb2xUaXBcIjtkLnNhdmUoKTt2YXIgYz10aGlzLmNoYXJ0LnBsb3RBcmVhLGI9MDtkLmJlZ2luUGF0aCgpO2QucmVjdChjLngxLGMueTEsYy54Mi1jLngxLGMueTItYy55MSk7ZC5jbGlwKCk7Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGU9YVtjXTtpZigoZT10aGlzLmNoYXJ0Ll9ldmVudE1hbmFnZXIub2JqZWN0TWFwW2UuZGF0YVNlcmllcy5kYXRhUG9pbnRJZHNbZS5pbmRleF1dKSYmXG5lLm9iamVjdFR5cGUmJlwiZGF0YVBvaW50XCI9PT1lLm9iamVjdFR5cGUpe3ZhciBiPXRoaXMuY2hhcnQuZGF0YVtlLmRhdGFTZXJpZXNJbmRleF0sZj1iLmRhdGFQb2ludHNbZS5kYXRhUG9pbnRJbmRleF0saD1lLmRhdGFQb2ludEluZGV4OyExPT09Zi5oaWdobGlnaHRFbmFibGVkfHwhMCE9PWIuaGlnaGxpZ2h0RW5hYmxlZCYmITAhPT1mLmhpZ2hsaWdodEVuYWJsZWR8fChcImxpbmVcIj09PWIudHlwZXx8XCJzdGVwTGluZVwiPT09Yi50eXBlfHxcInNwbGluZVwiPT09Yi50eXBlfHxcInNjYXR0ZXJcIj09PWIudHlwZXx8XCJhcmVhXCI9PT1iLnR5cGV8fFwic3RlcEFyZWFcIj09PWIudHlwZXx8XCJzcGxpbmVBcmVhXCI9PT1iLnR5cGV8fFwic3RhY2tlZEFyZWFcIj09PWIudHlwZXx8XCJzdGFja2VkQXJlYTEwMFwiPT09Yi50eXBlfHxcInJhbmdlQXJlYVwiPT09Yi50eXBlfHxcInJhbmdlU3BsaW5lQXJlYVwiPT09Yi50eXBlPyhmPWIuZ2V0TWFya2VyUHJvcGVydGllcyhoLGUueDEsZS55MSx0aGlzLmNoYXJ0Lm92ZXJsYWlkQ2FudmFzQ3R4KSxcbmYuc2l6ZT1NYXRoLm1heCgxLjUqZi5zaXplPDwwLDEwKSxmLmJvcmRlckNvbG9yPWYuYm9yZGVyQ29sb3J8fFwiI0ZGRkZGRlwiLGYuYm9yZGVyVGhpY2tuZXNzPWYuYm9yZGVyVGhpY2tuZXNzfHxNYXRoLmNlaWwoMC4xKmYuc2l6ZSksVy5kcmF3TWFya2VycyhbZl0pLFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZS55MiYmKGY9Yi5nZXRNYXJrZXJQcm9wZXJ0aWVzKGgsZS54MSxlLnkyLHRoaXMuY2hhcnQub3ZlcmxhaWRDYW52YXNDdHgpLGYuc2l6ZT1NYXRoLm1heCgxLjUqZi5zaXplPDwwLDEwKSxmLmJvcmRlckNvbG9yPWYuYm9yZGVyQ29sb3J8fFwiI0ZGRkZGRlwiLGYuYm9yZGVyVGhpY2tuZXNzPWYuYm9yZGVyVGhpY2tuZXNzfHxNYXRoLmNlaWwoMC4xKmYuc2l6ZSksVy5kcmF3TWFya2VycyhbZl0pKSk6XCJidWJibGVcIj09PWIudHlwZT8oZj1iLmdldE1hcmtlclByb3BlcnRpZXMoaCxlLngxLGUueTEsdGhpcy5jaGFydC5vdmVybGFpZENhbnZhc0N0eCksZi5zaXplPWUuc2l6ZSxmLmNvbG9yPVxuXCJ3aGl0ZVwiLGYuYm9yZGVyQ29sb3I9XCJ3aGl0ZVwiLGQuZ2xvYmFsQWxwaGE9MC4zLFcuZHJhd01hcmtlcnMoW2ZdKSxkLmdsb2JhbEFscGhhPTEpOlwiY29sdW1uXCI9PT1iLnR5cGV8fFwic3RhY2tlZENvbHVtblwiPT09Yi50eXBlfHxcInN0YWNrZWRDb2x1bW4xMDBcIj09PWIudHlwZXx8XCJiYXJcIj09PWIudHlwZXx8XCJyYW5nZUJhclwiPT09Yi50eXBlfHxcInN0YWNrZWRCYXJcIj09PWIudHlwZXx8XCJzdGFja2VkQmFyMTAwXCI9PT1iLnR5cGV8fFwicmFuZ2VDb2x1bW5cIj09PWIudHlwZXx8XCJ3YXRlcmZhbGxcIj09PWIudHlwZT9ZKGQsZS54MSxlLnkxLGUueDIsZS55MixcIndoaXRlXCIsMCxudWxsLCExLCExLCExLCExLDAuMyk6XCJwaWVcIj09PWIudHlwZXx8XCJkb3VnaG51dFwiPT09Yi50eXBlP3BhKGQsZS5jZW50ZXIsZS5yYWRpdXMsXCJ3aGl0ZVwiLGIudHlwZSxlLnN0YXJ0QW5nbGUsZS5lbmRBbmdsZSwwLjMsZS5wZXJjZW50SW5uZXJSYWRpdXMpOlwiZnVubmVsXCI9PT1iLnR5cGV8fFwicHlyYW1pZFwiPT09Yi50eXBlP1xucmEoZCxlLmZ1bm5lbFNlY3Rpb24sMC4zLFwid2hpdGVcIik6XCJjYW5kbGVzdGlja1wiPT09Yi50eXBlPyhkLmdsb2JhbEFscGhhPTEsZC5zdHJva2VTdHlsZT1lLmNvbG9yLGQubGluZVdpZHRoPTIqZS5ib3JkZXJUaGlja25lc3MsYj0wPT09ZC5saW5lV2lkdGglMj8wOjAuNSxkLmJlZ2luUGF0aCgpLGQubW92ZVRvKGUueDMtYixNYXRoLm1pbihlLnkyLGUueTMpKSxkLmxpbmVUbyhlLngzLWIsTWF0aC5taW4oZS55MSxlLnk0KSksZC5zdHJva2UoKSxkLmJlZ2luUGF0aCgpLGQubW92ZVRvKGUueDMtYixNYXRoLm1heChlLnkxLGUueTQpKSxkLmxpbmVUbyhlLngzLWIsTWF0aC5tYXgoZS55MixlLnkzKSksZC5zdHJva2UoKSxZKGQsZS54MSxNYXRoLm1pbihlLnkxLGUueTQpLGUueDIsTWF0aC5tYXgoZS55MSxlLnk0KSxcInRyYW5zcGFyZW50XCIsMiplLmJvcmRlclRoaWNrbmVzcyxlLmNvbG9yLCExLCExLCExLCExKSxkLmdsb2JhbEFscGhhPTEpOlwib2hsY1wiPT09Yi50eXBlPyhkLmdsb2JhbEFscGhhPVxuMSxkLnN0cm9rZVN0eWxlPWUuY29sb3IsZC5saW5lV2lkdGg9MiplLmJvcmRlclRoaWNrbmVzcyxiPTA9PT1kLmxpbmVXaWR0aCUyPzA6MC41LGQuYmVnaW5QYXRoKCksZC5tb3ZlVG8oZS54My1iLGUueTIpLGQubGluZVRvKGUueDMtYixlLnkzKSxkLnN0cm9rZSgpLGQuYmVnaW5QYXRoKCksZC5tb3ZlVG8oZS54MyxlLnkxKSxkLmxpbmVUbyhlLngxLGUueTEpLGQuc3Ryb2tlKCksZC5iZWdpblBhdGgoKSxkLm1vdmVUbyhlLngzLGUueTQpLGQubGluZVRvKGUueDIsZS55NCksZC5zdHJva2UoKSxkLmdsb2JhbEFscGhhPTEpOlwiYm94QW5kV2hpc2tlclwiPT09Yi50eXBlPyhkLnNhdmUoKSxkLmdsb2JhbEFscGhhPTEsZC5zdHJva2VTdHlsZT1lLnN0ZW1Db2xvcixkLmxpbmVXaWR0aD0yKmUuc3RlbVRoaWNrbmVzcywwPGUuc3RlbVRoaWNrbmVzcyYmKGQuYmVnaW5QYXRoKCksZC5tb3ZlVG8oZS54MyxlLnkyK2UuYm9yZGVyVGhpY2tuZXNzLzIpLGQubGluZVRvKGUueDMsZS55MStlLndoaXNrZXJUaGlja25lc3MvXG4yKSxkLnN0cm9rZSgpLGQuYmVnaW5QYXRoKCksZC5tb3ZlVG8oZS54MyxlLnk0LWUud2hpc2tlclRoaWNrbmVzcy8yKSxkLmxpbmVUbyhlLngzLGUueTMtZS5ib3JkZXJUaGlja25lc3MvMiksZC5zdHJva2UoKSksZC5iZWdpblBhdGgoKSxZKGQsZS54MS1lLmJvcmRlclRoaWNrbmVzcy8yLE1hdGgubWF4KGUueTIrZS5ib3JkZXJUaGlja25lc3MvMixlLnkzK2UuYm9yZGVyVGhpY2tuZXNzLzIpLGUueDIrZS5ib3JkZXJUaGlja25lc3MvMixNYXRoLm1pbihlLnkyLWUuYm9yZGVyVGhpY2tuZXNzLzIsZS55My1lLmJvcmRlclRoaWNrbmVzcy8yKSxcInRyYW5zcGFyZW50XCIsZS5ib3JkZXJUaGlja25lc3MsZS5jb2xvciwhMSwhMSwhMSwhMSksZC5nbG9iYWxBbHBoYT0xLGQuc3Ryb2tlU3R5bGU9ZS53aGlza2VyQ29sb3IsZC5saW5lV2lkdGg9MiplLndoaXNrZXJUaGlja25lc3MsMDxlLndoaXNrZXJUaGlja25lc3MmJihkLmJlZ2luUGF0aCgpLGQubW92ZVRvKE1hdGguZmxvb3IoZS54My1cbmUud2hpc2tlckxlbmd0aC8yKSxlLnk0KSxkLmxpbmVUbyhNYXRoLmNlaWwoZS54MytlLndoaXNrZXJMZW5ndGgvMiksZS55NCksZC5zdHJva2UoKSxkLmJlZ2luUGF0aCgpLGQubW92ZVRvKE1hdGguZmxvb3IoZS54My1lLndoaXNrZXJMZW5ndGgvMiksZS55MSksZC5saW5lVG8oTWF0aC5jZWlsKGUueDMrZS53aGlza2VyTGVuZ3RoLzIpLGUueTEpLGQuc3Ryb2tlKCkpLGQuZ2xvYmFsQWxwaGE9MSxkLnN0cm9rZVN0eWxlPWUubGluZUNvbG9yLGQubGluZVdpZHRoPTIqZS5saW5lVGhpY2tuZXNzLDA8ZS5saW5lVGhpY2tuZXNzJiYoZC5iZWdpblBhdGgoKSxkLm1vdmVUbyhlLngxLGUueTUpLGQubGluZVRvKGUueDIsZS55NSksZC5zdHJva2UoKSksZC5yZXN0b3JlKCksZC5nbG9iYWxBbHBoYT0xKTpcImVycm9yXCI9PT1iLnR5cGUmJkIoZCxlLngxLGUueTEsZS54MixlLnkyLFwid2hpdGVcIixlLndoaXNrZXJQcm9wZXJ0aWVzLGUuc3RlbVByb3BlcnRpZXMsZS5pc1hZU3dhcHBlZCwwLjMpKX19ZC5yZXN0b3JlKCk7XG5kLmdsb2JhbEFscGhhPTE7ZC5iZWdpblBhdGgoKX07VS5wcm90b3R5cGUuZ2V0VG9vbFRpcElubmVySFRNTD1mdW5jdGlvbihhKXthPWEuZW50cmllczt2YXIgZD1udWxsLGM9bnVsbCxiPW51bGwsZT0wLGY9XCJcIjt0aGlzLmlzVG9vbFRpcERlZmluZWRJbkRhdGE9ITA7Zm9yKHZhciBoPTA7aDxhLmxlbmd0aDtoKyspaWYoYVtoXS5kYXRhU2VyaWVzLnRvb2xUaXBDb250ZW50fHxhW2hdLmRhdGFQb2ludC50b29sVGlwQ29udGVudCl7dGhpcy5pc1Rvb2xUaXBEZWZpbmVkSW5EYXRhPSExO2JyZWFrfWlmKHRoaXMuaXNUb29sVGlwRGVmaW5lZEluRGF0YSYmKHRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHRoaXMuY29udGVudHx8dGhpcy5jb250ZW50Rm9ybWF0dGVyKSlhPXtjaGFydDp0aGlzLmNoYXJ0LHRvb2xUaXA6dGhpcy5vcHRpb25zLGVudHJpZXM6YX0sZD10aGlzLmNvbnRlbnRGb3JtYXR0ZXI/dGhpcy5jb250ZW50Rm9ybWF0dGVyKGEpOnRoaXMuY29udGVudChhKTtcbmVsc2UgaWYodGhpcy5zaGFyZWQmJlwibm9uZVwiIT09dGhpcy5jaGFydC5wbG90SW5mby5heGlzUGxhY2VtZW50KXtmb3IodmFyIHA9bnVsbCxyPVwiXCIsaD0wO2g8YS5sZW5ndGg7aCsrKXtjPWFbaF0uZGF0YVNlcmllcztiPWFbaF0uZGF0YVBvaW50O2U9YVtoXS5pbmRleDtmPVwiXCI7aWYoMD09PWgmJnRoaXMuaXNUb29sVGlwRGVmaW5lZEluRGF0YSYmIXRoaXMuY29udGVudCl7dGhpcy5jaGFydC5heGlzWCYmMDx0aGlzLmNoYXJ0LmF4aXNYLmxlbmd0aD9yKz1cInVuZGVmaW5lZFwiIT09dHlwZW9mIHRoaXMuY2hhcnQuYXhpc1hbMF0ubGFiZWxzW2IueF0/dGhpcy5jaGFydC5heGlzWFswXS5sYWJlbHNbYi54XTpcInt4fVwiOnRoaXMuY2hhcnQuYXhpc1gyJiYwPHRoaXMuY2hhcnQuYXhpc1gyLmxlbmd0aCYmKHIrPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgdGhpcy5jaGFydC5heGlzWDJbMF0ubGFiZWxzW2IueF0/dGhpcy5jaGFydC5heGlzWDJbMF0ubGFiZWxzW2IueF06XCJ7eH1cIik7cis9XCI8L2JyPlwiO1xuaWYoIWMudmlzaWJsZSljb250aW51ZTtyPXRoaXMuY2hhcnQucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKHIsYixjLGUpfW51bGw9PT1iLnRvb2xUaXBDb250ZW50fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGIudG9vbFRpcENvbnRlbnQmJm51bGw9PT1jLm9wdGlvbnMudG9vbFRpcENvbnRlbnR8fChcImxpbmVcIj09PWMudHlwZXx8XCJzdGVwTGluZVwiPT09Yy50eXBlfHxcInNwbGluZVwiPT09Yy50eXBlfHxcImFyZWFcIj09PWMudHlwZXx8XCJzdGVwQXJlYVwiPT09Yy50eXBlfHxcInNwbGluZUFyZWFcIj09PWMudHlwZXx8XCJjb2x1bW5cIj09PWMudHlwZXx8XCJiYXJcIj09PWMudHlwZXx8XCJzY2F0dGVyXCI9PT1jLnR5cGV8fFwic3RhY2tlZENvbHVtblwiPT09Yy50eXBlfHxcInN0YWNrZWRDb2x1bW4xMDBcIj09PWMudHlwZXx8XCJzdGFja2VkQmFyXCI9PT1jLnR5cGV8fFwic3RhY2tlZEJhcjEwMFwiPT09Yy50eXBlfHxcInN0YWNrZWRBcmVhXCI9PT1jLnR5cGV8fFwic3RhY2tlZEFyZWExMDBcIj09PWMudHlwZXx8XCJ3YXRlcmZhbGxcIj09PVxuYy50eXBlPyh0aGlzLmNoYXJ0LmF4aXNYJiYxPHRoaXMuY2hhcnQuYXhpc1gubGVuZ3RoJiYoZis9cCE9Yy5heGlzWEluZGV4P2MuYXhpc1gudGl0bGU/Yy5heGlzWC50aXRsZStcIjxici8+XCI6XCJYOntheGlzWEluZGV4fTxici8+XCI6XCJcIiksZis9Yi50b29sVGlwQ29udGVudD9iLnRvb2xUaXBDb250ZW50OmMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDp0aGlzLmNvbnRlbnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB0aGlzLmNvbnRlbnQ/dGhpcy5jb250ZW50OlwiPHNwYW4gZGF0YS1jb2xvcj0nXFxcIlwiKyh0aGlzLm9wdGlvbnMuZm9udENvbG9yP1wiXCI6XCIne2NvbG9yfSdcIikrXCJcXFwiJz57bmFtZX06PC9zcGFuPiZuYnNwOyZuYnNwO3t5fVwiLHA9Yy5heGlzWEluZGV4KTpcImJ1YmJsZVwiPT09Yy50eXBlPyh0aGlzLmNoYXJ0LmF4aXNYJiYxPHRoaXMuY2hhcnQuYXhpc1gubGVuZ3RoJiYoZis9cCE9Yy5heGlzWEluZGV4P2MuYXhpc1gudGl0bGU/Yy5heGlzWC50aXRsZStcIjxici8+XCI6XG5cIlg6e2F4aXNYSW5kZXh9PGJyLz5cIjpcIlwiKSxmKz1iLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OnRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHRoaXMuY29udGVudD90aGlzLmNvbnRlbnQ6XCI8c3BhbiBkYXRhLWNvbG9yPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIid7Y29sb3J9J1wiKStcIlxcXCInPntuYW1lfTo8L3NwYW4+Jm5ic3A7Jm5ic3A7e3l9LCAmbmJzcDsmbmJzcDt7en1cIik6XCJyYW5nZUNvbHVtblwiPT09Yy50eXBlfHxcInJhbmdlQmFyXCI9PT1jLnR5cGV8fFwicmFuZ2VBcmVhXCI9PT1jLnR5cGV8fFwicmFuZ2VTcGxpbmVBcmVhXCI9PT1jLnR5cGV8fFwiZXJyb3JcIj09PWMudHlwZT8odGhpcy5jaGFydC5heGlzWCYmMTx0aGlzLmNoYXJ0LmF4aXNYLmxlbmd0aCYmKGYrPXAhPWMuYXhpc1hJbmRleD9jLmF4aXNYLnRpdGxlP2MuYXhpc1gudGl0bGUrXCI8YnIvPlwiOlwiWDp7YXhpc1hJbmRleH08YnIvPlwiOlxuXCJcIiksZis9Yi50b29sVGlwQ29udGVudD9iLnRvb2xUaXBDb250ZW50OmMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDp0aGlzLmNvbnRlbnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB0aGlzLmNvbnRlbnQ/dGhpcy5jb250ZW50OlwiPHNwYW4gZGF0YS1jb2xvcj0nXFxcIlwiKyh0aGlzLm9wdGlvbnMuZm9udENvbG9yP1wiXCI6XCIne2NvbG9yfSdcIikrXCJcXFwiJz57bmFtZX06PC9zcGFuPiZuYnNwOyZuYnNwO3t5WzBdfSwmbmJzcDt7eVsxXX1cIik6XCJjYW5kbGVzdGlja1wiPT09Yy50eXBlfHxcIm9obGNcIj09PWMudHlwZT8odGhpcy5jaGFydC5heGlzWCYmMTx0aGlzLmNoYXJ0LmF4aXNYLmxlbmd0aCYmKGYrPXAhPWMuYXhpc1hJbmRleD9jLmF4aXNYLnRpdGxlP2MuYXhpc1gudGl0bGUrXCI8YnIvPlwiOlwiWDp7YXhpc1hJbmRleH08YnIvPlwiOlwiXCIpLGYrPWIudG9vbFRpcENvbnRlbnQ/Yi50b29sVGlwQ29udGVudDpjLnRvb2xUaXBDb250ZW50P2MudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcblwiZnVuY3Rpb25cIiE9PXR5cGVvZiB0aGlzLmNvbnRlbnQ/dGhpcy5jb250ZW50OlwiPHNwYW4gZGF0YS1jb2xvcj0nXFxcIlwiKyh0aGlzLm9wdGlvbnMuZm9udENvbG9yP1wiXCI6XCIne2NvbG9yfSdcIikrXCJcXFwiJz57bmFtZX06PC9zcGFuPjxici8+T3BlbjogJm5ic3A7Jm5ic3A7e3lbMF19PGJyLz5IaWdoOiAmbmJzcDsmbmJzcDsmbmJzcDt7eVsxXX08YnIvPkxvdzombmJzcDsmbmJzcDsmbmJzcDt7eVsyXX08YnIvPkNsb3NlOiAmbmJzcDsmbmJzcDt7eVszXX1cIik6XCJib3hBbmRXaGlza2VyXCI9PT1jLnR5cGUmJih0aGlzLmNoYXJ0LmF4aXNYJiYxPHRoaXMuY2hhcnQuYXhpc1gubGVuZ3RoJiYoZis9cCE9Yy5heGlzWEluZGV4P2MuYXhpc1gudGl0bGU/Yy5heGlzWC50aXRsZStcIjxici8+XCI6XCJYOntheGlzWEluZGV4fTxici8+XCI6XCJcIiksZis9Yi50b29sVGlwQ29udGVudD9iLnRvb2xUaXBDb250ZW50OmMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDp0aGlzLmNvbnRlbnQmJlwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIHRoaXMuY29udGVudD90aGlzLmNvbnRlbnQ6XCI8c3BhbiBkYXRhLWNvbG9yPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIid7Y29sb3J9J1wiKStcIlxcXCInPntuYW1lfTo8L3NwYW4+PGJyLz5NaW5pbXVtOiAmbmJzcDt7eVswXX08YnIvPlExOiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO3t5WzFdfTxici8+UTI6Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7e3lbNF19PGJyLz5RMzombmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDt7eVsyXX08YnIvPk1heGltdW06ICZuYnNwO3t5WzNdfVwiKSxudWxsPT09ZCYmKGQ9XCJcIiksYy52aXNpYmxlJiYoITA9PT10aGlzLnJldmVyc2VkPyhkPXRoaXMuY2hhcnQucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKGYsXG5iLGMsZSkrZCxoPGEubGVuZ3RoLTEmJihkPVwiPC9icj5cIitkKSk6KGQrPXRoaXMuY2hhcnQucmVwbGFjZUtleXdvcmRzV2l0aFZhbHVlKGYsYixjLGUpLGg8YS5sZW5ndGgtMSYmKGQrPVwiPC9icj5cIikpKSl9bnVsbCE9PWQmJihkPXIrZCl9ZWxzZXtjPWFbMF0uZGF0YVNlcmllcztiPWFbMF0uZGF0YVBvaW50O2U9YVswXS5pbmRleDtpZihudWxsPT09Yi50b29sVGlwQ29udGVudHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBiLnRvb2xUaXBDb250ZW50JiZudWxsPT09Yy5vcHRpb25zLnRvb2xUaXBDb250ZW50KXJldHVybiBudWxsO1wibGluZVwiPT09Yy50eXBlfHxcInN0ZXBMaW5lXCI9PT1jLnR5cGV8fFwic3BsaW5lXCI9PT1jLnR5cGV8fFwiYXJlYVwiPT09Yy50eXBlfHxcInN0ZXBBcmVhXCI9PT1jLnR5cGV8fFwic3BsaW5lQXJlYVwiPT09Yy50eXBlfHxcImNvbHVtblwiPT09Yy50eXBlfHxcImJhclwiPT09Yy50eXBlfHxcInNjYXR0ZXJcIj09PWMudHlwZXx8XCJzdGFja2VkQ29sdW1uXCI9PT1jLnR5cGV8fFwic3RhY2tlZENvbHVtbjEwMFwiPT09XG5jLnR5cGV8fFwic3RhY2tlZEJhclwiPT09Yy50eXBlfHxcInN0YWNrZWRCYXIxMDBcIj09PWMudHlwZXx8XCJzdGFja2VkQXJlYVwiPT09Yy50eXBlfHxcInN0YWNrZWRBcmVhMTAwXCI9PT1jLnR5cGV8fFwid2F0ZXJmYWxsXCI9PT1jLnR5cGU/Zj1iLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OnRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHRoaXMuY29udGVudD90aGlzLmNvbnRlbnQ6XCI8c3BhbiBkYXRhLWNvbG9yPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIid7Y29sb3J9J1wiKStcIlxcXCInPlwiKyhiLmxhYmVsP1wie2xhYmVsfVwiOlwie3h9XCIpK1wiOjwvc3Bhbj4mbmJzcDsmbmJzcDt7eX1cIjpcImJ1YmJsZVwiPT09Yy50eXBlP2Y9Yi50b29sVGlwQ29udGVudD9iLnRvb2xUaXBDb250ZW50OmMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDp0aGlzLmNvbnRlbnQmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB0aGlzLmNvbnRlbnQ/XG50aGlzLmNvbnRlbnQ6XCI8c3BhbiBkYXRhLWNvbG9yPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIid7Y29sb3J9J1wiKStcIlxcXCInPlwiKyhiLmxhYmVsP1wie2xhYmVsfVwiOlwie3h9XCIpK1wiOjwvc3Bhbj4mbmJzcDsmbmJzcDt7eX0sICZuYnNwOyZuYnNwO3t6fVwiOlwicGllXCI9PT1jLnR5cGV8fFwiZG91Z2hudXRcIj09PWMudHlwZXx8XCJmdW5uZWxcIj09PWMudHlwZXx8XCJweXJhbWlkXCI9PT1jLnR5cGU/Zj1iLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OnRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHRoaXMuY29udGVudD90aGlzLmNvbnRlbnQ6XCI8c3BhbiBkYXRhLWNvbG9yPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIid7Y29sb3J9J1wiKStcIlxcXCInPlwiKyhiLm5hbWU/XCJ7bmFtZX06PC9zcGFuPiZuYnNwOyZuYnNwO1wiOmIubGFiZWw/XCJ7bGFiZWx9Ojwvc3Bhbj4mbmJzcDsmbmJzcDtcIjpcblwiPC9zcGFuPlwiKStcInt5fVwiOlwicmFuZ2VDb2x1bW5cIj09PWMudHlwZXx8XCJyYW5nZUJhclwiPT09Yy50eXBlfHxcInJhbmdlQXJlYVwiPT09Yy50eXBlfHxcInJhbmdlU3BsaW5lQXJlYVwiPT09Yy50eXBlfHxcImVycm9yXCI9PT1jLnR5cGU/Zj1iLnRvb2xUaXBDb250ZW50P2IudG9vbFRpcENvbnRlbnQ6Yy50b29sVGlwQ29udGVudD9jLnRvb2xUaXBDb250ZW50OnRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHRoaXMuY29udGVudD90aGlzLmNvbnRlbnQ6XCI8c3BhbiBkYXRhLWNvbG9yPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIid7Y29sb3J9J1wiKStcIlxcXCInPlwiKyhiLmxhYmVsP1wie2xhYmVsfVwiOlwie3h9XCIpK1wiIDo8L3NwYW4+Jm5ic3A7Jm5ic3A7e3lbMF19LCAmbmJzcDt7eVsxXX1cIjpcImNhbmRsZXN0aWNrXCI9PT1jLnR5cGV8fFwib2hsY1wiPT09Yy50eXBlP2Y9Yi50b29sVGlwQ29udGVudD9iLnRvb2xUaXBDb250ZW50OmMudG9vbFRpcENvbnRlbnQ/Yy50b29sVGlwQ29udGVudDpcbnRoaXMuY29udGVudCYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHRoaXMuY29udGVudD90aGlzLmNvbnRlbnQ6XCI8c3BhbiBkYXRhLWNvbG9yPSdcXFwiXCIrKHRoaXMub3B0aW9ucy5mb250Q29sb3I/XCJcIjpcIid7Y29sb3J9J1wiKStcIlxcXCInPlwiKyhiLmxhYmVsP1wie2xhYmVsfVwiOlwie3h9XCIpK1wiPC9zcGFuPjxici8+T3BlbjogJm5ic3A7Jm5ic3A7e3lbMF19PGJyLz5IaWdoOiAmbmJzcDsmbmJzcDsmbmJzcDt7eVsxXX08YnIvPkxvdzogJm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7e3lbMl19PGJyLz5DbG9zZTogJm5ic3A7Jm5ic3A7e3lbM119XCI6XCJib3hBbmRXaGlza2VyXCI9PT1jLnR5cGUmJihmPWIudG9vbFRpcENvbnRlbnQ/Yi50b29sVGlwQ29udGVudDpjLnRvb2xUaXBDb250ZW50P2MudG9vbFRpcENvbnRlbnQ6dGhpcy5jb250ZW50JiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgdGhpcy5jb250ZW50P3RoaXMuY29udGVudDpcIjxzcGFuIGRhdGEtY29sb3I9J1xcXCJcIisodGhpcy5vcHRpb25zLmZvbnRDb2xvcj9cblwiXCI6XCIne2NvbG9yfSdcIikrXCJcXFwiJz5cIisoYi5sYWJlbD9cIntsYWJlbH1cIjpcInt4fVwiKStcIjwvc3Bhbj48YnIvPk1pbmltdW06ICZuYnNwO3t5WzBdfTxici8+UTE6Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7Jm5ic3A7e3lbMV19PGJyLz5RMjombmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDsmbmJzcDt7eVs0XX08YnIvPlEzOiZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwOyZuYnNwO3t5WzJdfTxici8+TWF4aW11bTogJm5ic3A7e3lbM119XCIpO251bGw9PT1kJiYoZD1cIlwiKTtkKz10aGlzLmNoYXJ0LnJlcGxhY2VLZXl3b3Jkc1dpdGhWYWx1ZShmLGIsYyxlKX1yZXR1cm4gZH07VS5wcm90b3R5cGUuZW5hYmxlQW5pbWF0aW9uPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY29udGFpbmVyLnN0eWxlLldlYmtpdFRyYW5zaXRpb24pe3ZhciBhPVxudGhpcy5nZXRDb250YWluZXJUcmFuc2l0aW9uKHRoaXMuY29udGFpbmVyVHJhbnNpdGlvbkR1cmF0aW9uKTt0aGlzLmNvbnRhaW5lci5zdHlsZS5XZWJraXRUcmFuc2l0aW9uPWE7dGhpcy5jb250YWluZXIuc3R5bGUuTXNUcmFuc2l0aW9uPWE7dGhpcy5jb250YWluZXIuc3R5bGUudHJhbnNpdGlvbj1hO3RoaXMuY29udGFpbmVyLnN0eWxlLk1velRyYW5zaXRpb249dGhpcy5tb3pDb250YWluZXJUcmFuc2l0aW9ufX07VS5wcm90b3R5cGUuZGlzYWJsZUFuaW1hdGlvbj1mdW5jdGlvbigpe3RoaXMuY29udGFpbmVyLnN0eWxlLldlYmtpdFRyYW5zaXRpb24mJih0aGlzLmNvbnRhaW5lci5zdHlsZS5XZWJraXRUcmFuc2l0aW9uPVwiXCIsdGhpcy5jb250YWluZXIuc3R5bGUuTW96VHJhbnNpdGlvbj1cIlwiLHRoaXMuY29udGFpbmVyLnN0eWxlLk1zVHJhbnNpdGlvbj1cIlwiLHRoaXMuY29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb249XCJcIil9O1UucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oYSl7dGhpcy5jb250YWluZXImJlxuKHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jdXJyZW50U2VyaWVzSW5kZXg9LTEsdGhpcy5fcHJldlk9dGhpcy5fcHJldlg9TmFOLChcInVuZGVmaW5lZFwiPT09dHlwZW9mIGF8fGEpJiZ0aGlzLmNoYXJ0LnJlc2V0T3ZlcmxheWVkQ2FudmFzKCkpfTtVLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKGEsZCxjKXt0aGlzLl91cGRhdGVUb29sVGlwKGEsZCxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGM/ITE6Yyl9O1UucHJvdG90eXBlLnNob3dBdEluZGV4PWZ1bmN0aW9uKGEsZCl7fTtVLnByb3RvdHlwZS5zaG93QXRYPWZ1bmN0aW9uKGEsZCl7aWYoIXRoaXMuZW5hYmxlZClyZXR1cm4hMTt0aGlzLmNoYXJ0LmNsZWFyZWRPdmVybGF5ZWRDYW52YXM9bnVsbDt2YXIgYyxiLGUsZj1bXTtlPSExO2Q9IXIoZCkmJjA8PWQmJmQ8dGhpcy5jaGFydC5kYXRhLmxlbmd0aD9kOjA7aWYodGhpcy5zaGFyZWQpZm9yKHZhciBoPTA7aDx0aGlzLmNoYXJ0LmRhdGEubGVuZ3RoO2grKyljPVxudGhpcy5jaGFydC5kYXRhW2hdLChiPWMuZ2V0RGF0YVBvaW50QXRYKGEsITEpKSYmKGIuZGF0YVBvaW50JiYhcihiLmRhdGFQb2ludC55KSYmYy52aXNpYmxlKSYmKGIuZGF0YVNlcmllcz1jLGYucHVzaChiKSk7ZWxzZSBjPXRoaXMuY2hhcnQuZGF0YVtkXSwoYj1jLmdldERhdGFQb2ludEF0WChhLCExKSkmJihiLmRhdGFQb2ludCYmIXIoYi5kYXRhUG9pbnQueSkmJmMudmlzaWJsZSkmJihiLmRhdGFTZXJpZXM9YyxmLnB1c2goYikpO2lmKDA8Zi5sZW5ndGgpe2ZvcihoPTA7aDxmLmxlbmd0aDtoKyspaWYoYj1mW2hdLCh0aGlzLnNoYXJlZHx8MDw9Yi5kYXRhU2VyaWVzLnR5cGUuaW5kZXhPZihcIjEwMFwiKSkmJmIuZGF0YVBvaW50Lng+PWIuZGF0YVNlcmllcy5heGlzWC52aWV3cG9ydE1pbmltdW0mJmIuZGF0YVBvaW50Lng8PWIuZGF0YVNlcmllcy5heGlzWC52aWV3cG9ydE1heGltdW0pe2U9ITE7YnJlYWt9ZWxzZSBpZihiLmRhdGFQb2ludC54PGIuZGF0YVNlcmllcy5heGlzWC52aWV3cG9ydE1pbmltdW18fFxuYi5kYXRhUG9pbnQueD5iLmRhdGFTZXJpZXMuYXhpc1gudmlld3BvcnRNYXhpbXVtfHxiLmRhdGFQb2ludC55PGIuZGF0YVNlcmllcy5heGlzWS52aWV3cG9ydE1pbmltdW18fGIuZGF0YVBvaW50Lnk+Yi5kYXRhU2VyaWVzLmF4aXNZLnZpZXdwb3J0TWF4aW11bSllPSEwO2Vsc2V7ZT0hMTticmVha31pZihlKXJldHVybiB0aGlzLmhpZGUoKSwhMTt0aGlzLmhpZ2hsaWdodE9iamVjdHMoZik7dGhpcy5fZW50cmllcz1mO2g9XCJcIjtoPXRoaXMuZ2V0VG9vbFRpcElubmVySFRNTCh7ZW50cmllczpmfSk7aWYobnVsbCE9PWgpe3RoaXMuY29udGVudERpdi5pbm5lckhUTUw9aDtpZih0aGlzLmlzVG9vbFRpcERlZmluZWRJbkRhdGEmJnIodGhpcy5vcHRpb25zLmNvbnRlbnQpJiZyKHRoaXMub3B0aW9ucy5jb250ZW50Rm9ybWF0dGVyKSlmb3IoYj10aGlzLmNvbnRlbnREaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzcGFuXCIpLGg9MDtoPGIubGVuZ3RoO2grKyliW2hdJiYoYltoXS5zdHlsZS5jb2xvcj1cbmJbaF0uZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKSk7aD0hMTtcIm5vbmVcIj09PXRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkmJihoPSEwLHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiKTt0cnl7dGhpcy5jb250ZW50RGl2LnN0eWxlLmJhY2tncm91bmQ9dGhpcy5iYWNrZ3JvdW5kQ29sb3I/dGhpcy5iYWNrZ3JvdW5kQ29sb3I6dz9cInJnYmEoMjU1LDI1NSwyNTUsLjkpXCI6XCJyZ2IoMjU1LDI1NSwyNTUpXCIsdGhpcy5ib3JkZXJDb2xvcj1cIndhdGVyZmFsbFwiPT09ZlswXS5kYXRhU2VyaWVzLnR5cGU/dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJpZ2h0Q29sb3I9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlckxlZnRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyQ29sb3I9dGhpcy5vcHRpb25zLmJvcmRlckNvbG9yP3RoaXMub3B0aW9ucy5ib3JkZXJDb2xvcjpmWzBdLmRhdGFQb2ludC5jb2xvcj9mWzBdLmRhdGFQb2ludC5jb2xvcjowPFxuZlswXS5kYXRhUG9pbnQueT9mWzBdLmRhdGFTZXJpZXMucmlzaW5nQ29sb3I6ZlswXS5kYXRhU2VyaWVzLmZhbGxpbmdDb2xvcjpcImVycm9yXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZT90aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyUmlnaHRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyTGVmdENvbG9yPXRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJDb2xvcj10aGlzLm9wdGlvbnMuYm9yZGVyQ29sb3I/dGhpcy5vcHRpb25zLmJvcmRlckNvbG9yOmZbMF0uZGF0YVNlcmllcy5jb2xvcj9mWzBdLmRhdGFTZXJpZXMuY29sb3I6ZlswXS5kYXRhU2VyaWVzLl9jb2xvclNldFtjLmluZGV4JWZbMF0uZGF0YVNlcmllcy5fY29sb3JTZXQubGVuZ3RoXTp0aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyUmlnaHRDb2xvcj10aGlzLmNvbnRlbnREaXYuc3R5bGUuYm9yZGVyTGVmdENvbG9yPXRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJDb2xvcj10aGlzLm9wdGlvbnMuYm9yZGVyQ29sb3I/XG50aGlzLm9wdGlvbnMuYm9yZGVyQ29sb3I6ZlswXS5kYXRhUG9pbnQuY29sb3I/ZlswXS5kYXRhUG9pbnQuY29sb3I6ZlswXS5kYXRhU2VyaWVzLmNvbG9yP2ZbMF0uZGF0YVNlcmllcy5jb2xvcjpmWzBdLmRhdGFTZXJpZXMuX2NvbG9yU2V0W2ZbMF0uaW5kZXglZlswXS5kYXRhU2VyaWVzLl9jb2xvclNldC5sZW5ndGhdLHRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJXaWR0aD10aGlzLmJvcmRlclRoaWNrbmVzc3x8MD09PXRoaXMuYm9yZGVyVGhpY2tuZXNzP3RoaXMuYm9yZGVyVGhpY2tuZXNzK1wicHhcIjpcIjJweFwiLHRoaXMuY29udGVudERpdi5zdHlsZS5ib3JkZXJSYWRpdXM9dGhpcy5jb3JuZXJSYWRpdXN8fDA9PT10aGlzLmNvcm5lclJhZGl1cz90aGlzLmNvcm5lclJhZGl1cytcInB4XCI6XCI1cHhcIix0aGlzLmNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXM9dGhpcy5jb250ZW50RGl2LnN0eWxlLmJvcmRlclJhZGl1cyx0aGlzLmNvbnRlbnREaXYuc3R5bGUuZm9udFNpemU9dGhpcy5mb250U2l6ZXx8XG4wPT09dGhpcy5mb250U2l6ZT90aGlzLmZvbnRTaXplK1wicHhcIjpcIjE0cHhcIix0aGlzLmNvbnRlbnREaXYuc3R5bGUuY29sb3I9dGhpcy5mb250Q29sb3I/dGhpcy5mb250Q29sb3I6XCIjMDAwMDAwXCIsdGhpcy5jb250ZW50RGl2LnN0eWxlLmZvbnRGYW1pbHk9dGhpcy5mb250RmFtaWx5P3RoaXMuZm9udEZhbWlseTpcIkNhbGlicmksIEFyaWFsLCBHZW9yZ2lhLCBzZXJpZjtcIix0aGlzLmNvbnRlbnREaXYuc3R5bGUuZm9udFdlaWdodD10aGlzLmZvbnRXZWlnaHQ/dGhpcy5mb250V2VpZ2h0Olwibm9ybWFsXCIsdGhpcy5jb250ZW50RGl2LnN0eWxlLmZvbnRTdHlsZT10aGlzLmZvbnRTdHlsZT90aGlzLmZvbnRTdHlsZTp3P1wiaXRhbGljXCI6XCJub3JtYWxcIn1jYXRjaChwKXt9XCJwaWVcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcImRvdWdobnV0XCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJmdW5uZWxcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcInB5cmFtaWRcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlP1xuYz1tb3VzZVgtMTAtdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg6KGM9XCJiYXJcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcInJhbmdlQmFyXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGFja2VkQmFyXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGFja2VkQmFyMTAwXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZT9mWzBdLmRhdGFTZXJpZXMuYXhpc1kuY29udmVydFZhbHVlVG9QaXhlbChmWzBdLmRhdGFQb2ludC55KS10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDw8MDpmWzBdLmRhdGFTZXJpZXMuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChmWzBdLmRhdGFQb2ludC54KS10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDw8MCxjLT0xMCk7MD5jJiYoYys9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgrMjApO2MrdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg+TWF0aC5tYXgodGhpcy5jaGFydC5jb250YWluZXIuY2xpZW50V2lkdGgsdGhpcy5jaGFydC53aWR0aCkmJihjPVxuTWF0aC5tYXgoMCxNYXRoLm1heCh0aGlzLmNoYXJ0LmNvbnRhaW5lci5jbGllbnRXaWR0aCx0aGlzLmNoYXJ0LndpZHRoKS10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCkpO2Y9MSE9PWYubGVuZ3RofHx0aGlzLnNoYXJlZHx8XCJsaW5lXCIhPT1mWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJzdGVwTGluZVwiIT09ZlswXS5kYXRhU2VyaWVzLnR5cGUmJlwic3BsaW5lXCIhPT1mWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJhcmVhXCIhPT1mWzBdLmRhdGFTZXJpZXMudHlwZSYmXCJzdGVwQXJlYVwiIT09ZlswXS5kYXRhU2VyaWVzLnR5cGUmJlwic3BsaW5lQXJlYVwiIT09ZlswXS5kYXRhU2VyaWVzLnR5cGU/XCJiYXJcIj09PWZbMF0uZGF0YVNlcmllcy50eXBlfHxcInJhbmdlQmFyXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGFja2VkQmFyXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZXx8XCJzdGFja2VkQmFyMTAwXCI9PT1mWzBdLmRhdGFTZXJpZXMudHlwZT9mWzBdLmRhdGFTZXJpZXMuYXhpc1guY29udmVydFZhbHVlVG9QaXhlbChmWzBdLmRhdGFQb2ludC54KTpcbmZbMF0uZGF0YVNlcmllcy5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGZbMF0uZGF0YVBvaW50LnkpOmZbMF0uZGF0YVNlcmllcy5heGlzWS5jb252ZXJ0VmFsdWVUb1BpeGVsKGZbMF0uZGF0YVBvaW50LnkpO2Y9LWYrMTA7MDxmK3RoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCs1JiYoZi09Zit0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQrNS0wKTt0aGlzLmZpeE1velRyYW5zaXRpb25EZWxheShjLGYpOyF0aGlzLmFuaW1hdGlvbkVuYWJsZWR8fGg/dGhpcy5kaXNhYmxlQW5pbWF0aW9uKCk6KHRoaXMuZW5hYmxlQW5pbWF0aW9uKCksdGhpcy5jb250YWluZXIuc3R5bGUuTW96VHJhbnNpdGlvbj10aGlzLm1vekNvbnRhaW5lclRyYW5zaXRpb24pO3RoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQ9YytcInB4XCI7dGhpcy5jb250YWluZXIuc3R5bGUuYm90dG9tPWYrXCJweFwifWVsc2UgcmV0dXJuIHRoaXMuaGlkZSghMSksITF9ZWxzZSByZXR1cm4gdGhpcy5oaWRlKCksITE7cmV0dXJuITB9O1xuVS5wcm90b3R5cGUuZml4TW96VHJhbnNpdGlvbkRlbGF5PWZ1bmN0aW9uKGEsZCl7aWYoMjA8dGhpcy5jaGFydC5fZXZlbnRNYW5hZ2VyLmxhc3RPYmplY3RJZCl0aGlzLm1vekNvbnRhaW5lclRyYW5zaXRpb249dGhpcy5nZXRDb250YWluZXJUcmFuc2l0aW9uKDApO2Vsc2V7dmFyIGM9cGFyc2VGbG9hdCh0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0KSxjPWlzTmFOKGMpPzA6YyxiPXBhcnNlRmxvYXQodGhpcy5jb250YWluZXIuc3R5bGUuYm90dG9tKSxiPWlzTmFOKGIpPzA6YjsxMDxNYXRoLnNxcnQoTWF0aC5wb3coYy1hLDIpK01hdGgucG93KGItZCwyKSk/dGhpcy5tb3pDb250YWluZXJUcmFuc2l0aW9uPXRoaXMuZ2V0Q29udGFpbmVyVHJhbnNpdGlvbigwLjEpOnRoaXMubW96Q29udGFpbmVyVHJhbnNpdGlvbj10aGlzLmdldENvbnRhaW5lclRyYW5zaXRpb24oMCl9fTtVLnByb3RvdHlwZS5nZXRDb250YWluZXJUcmFuc2l0aW9uPWZ1bmN0aW9uKGEpe3JldHVyblwibGVmdCBcIitcbmErXCJzIGVhc2Utb3V0IDBzLCBib3R0b20gXCIrYStcInMgZWFzZS1vdXQgMHNcIn07Wi5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmxhc3RPYmplY3RJZD0wO3RoaXMub2JqZWN0TWFwPVtdO3RoaXMucmVjdGFuZ3VsYXJSZWdpb25FdmVudFN1YnNjcmlwdGlvbnM9W107dGhpcy5wcmV2aW91c0RhdGFQb2ludEV2ZW50T2JqZWN0PW51bGw7dGhpcy5ldmVudE9iamVjdHM9W107dyYmKHRoaXMuZ2hvc3RDdHguY2xlYXJSZWN0KDAsMCx0aGlzLmNoYXJ0LndpZHRoLHRoaXMuY2hhcnQuaGVpZ2h0KSx0aGlzLmdob3N0Q3R4LmJlZ2luUGF0aCgpKX07Wi5wcm90b3R5cGUuZ2V0TmV3T2JqZWN0VHJhY2tpbmdJZD1mdW5jdGlvbigpe3JldHVybisrdGhpcy5sYXN0T2JqZWN0SWR9O1oucHJvdG90eXBlLm1vdXNlRXZlbnRIYW5kbGVyPWZ1bmN0aW9uKGEpe2lmKFwibW91c2Vtb3ZlXCI9PT1hLnR5cGV8fFwiY2xpY2tcIj09PWEudHlwZSl7dmFyIGQ9W10sYz1QYShhKSxiPW51bGw7aWYoKGI9XG50aGlzLmNoYXJ0LmdldE9iamVjdEF0WFkoYy54LGMueSwhMSkpJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHRoaXMub2JqZWN0TWFwW2JdKWlmKGI9dGhpcy5vYmplY3RNYXBbYl0sXCJkYXRhUG9pbnRcIj09PWIub2JqZWN0VHlwZSl7dmFyIGU9dGhpcy5jaGFydC5kYXRhW2IuZGF0YVNlcmllc0luZGV4XSxmPWUuZGF0YVBvaW50c1tiLmRhdGFQb2ludEluZGV4XSxoPWIuZGF0YVBvaW50SW5kZXg7Yi5ldmVudFBhcmFtZXRlcj17eDpjLngseTpjLnksZGF0YVBvaW50OmYsZGF0YVNlcmllczplLm9wdGlvbnMsZGF0YVBvaW50SW5kZXg6aCxkYXRhU2VyaWVzSW5kZXg6ZS5pbmRleCxjaGFydDp0aGlzLmNoYXJ0fTtiLmV2ZW50Q29udGV4dD17Y29udGV4dDpmLHVzZXJDb250ZXh0OmYsbW91c2VvdmVyOlwibW91c2VvdmVyXCIsbW91c2Vtb3ZlOlwibW91c2Vtb3ZlXCIsbW91c2VvdXQ6XCJtb3VzZW91dFwiLGNsaWNrOlwiY2xpY2tcIn07ZC5wdXNoKGIpO2I9dGhpcy5vYmplY3RNYXBbZS5pZF07Yi5ldmVudFBhcmFtZXRlcj1cbnt4OmMueCx5OmMueSxkYXRhUG9pbnQ6ZixkYXRhU2VyaWVzOmUub3B0aW9ucyxkYXRhUG9pbnRJbmRleDpoLGRhdGFTZXJpZXNJbmRleDplLmluZGV4LGNoYXJ0OnRoaXMuY2hhcnR9O2IuZXZlbnRDb250ZXh0PXtjb250ZXh0OmUsdXNlckNvbnRleHQ6ZS5vcHRpb25zLG1vdXNlb3ZlcjpcIm1vdXNlb3ZlclwiLG1vdXNlbW92ZTpcIm1vdXNlbW92ZVwiLG1vdXNlb3V0OlwibW91c2VvdXRcIixjbGljazpcImNsaWNrXCJ9O2QucHVzaCh0aGlzLm9iamVjdE1hcFtlLmlkXSl9ZWxzZVwibGVnZW5kSXRlbVwiPT09Yi5vYmplY3RUeXBlJiYoZT10aGlzLmNoYXJ0LmRhdGFbYi5kYXRhU2VyaWVzSW5kZXhdLGY9bnVsbCE9PWIuZGF0YVBvaW50SW5kZXg/ZS5kYXRhUG9pbnRzW2IuZGF0YVBvaW50SW5kZXhdOm51bGwsYi5ldmVudFBhcmFtZXRlcj17eDpjLngseTpjLnksZGF0YVNlcmllczplLm9wdGlvbnMsZGF0YVBvaW50OmYsZGF0YVBvaW50SW5kZXg6Yi5kYXRhUG9pbnRJbmRleCxkYXRhU2VyaWVzSW5kZXg6Yi5kYXRhU2VyaWVzSW5kZXgsXG5jaGFydDp0aGlzLmNoYXJ0fSxiLmV2ZW50Q29udGV4dD17Y29udGV4dDp0aGlzLmNoYXJ0LmxlZ2VuZCx1c2VyQ29udGV4dDp0aGlzLmNoYXJ0LmxlZ2VuZC5vcHRpb25zLG1vdXNlb3ZlcjpcIml0ZW1tb3VzZW92ZXJcIixtb3VzZW1vdmU6XCJpdGVtbW91c2Vtb3ZlXCIsbW91c2VvdXQ6XCJpdGVtbW91c2VvdXRcIixjbGljazpcIml0ZW1jbGlja1wifSxkLnB1c2goYikpO2U9W107Zm9yKGM9MDtjPHRoaXMubW91c2VvdmVyZWRPYmplY3RNYXBzLmxlbmd0aDtjKyspe2Y9ITA7Zm9yKGI9MDtiPGQubGVuZ3RoO2IrKylpZihkW2JdLmlkPT09dGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHNbY10uaWQpe2Y9ITE7YnJlYWt9Zj90aGlzLmZpcmVFdmVudCh0aGlzLm1vdXNlb3ZlcmVkT2JqZWN0TWFwc1tjXSxcIm1vdXNlb3V0XCIsYSk6ZS5wdXNoKHRoaXMubW91c2VvdmVyZWRPYmplY3RNYXBzW2NdKX10aGlzLm1vdXNlb3ZlcmVkT2JqZWN0TWFwcz1lO2ZvcihjPTA7YzxkLmxlbmd0aDtjKyspe2U9ITE7XG5mb3IoYj0wO2I8dGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHMubGVuZ3RoO2IrKylpZihkW2NdLmlkPT09dGhpcy5tb3VzZW92ZXJlZE9iamVjdE1hcHNbYl0uaWQpe2U9ITA7YnJlYWt9ZXx8KHRoaXMuZmlyZUV2ZW50KGRbY10sXCJtb3VzZW92ZXJcIixhKSx0aGlzLm1vdXNlb3ZlcmVkT2JqZWN0TWFwcy5wdXNoKGRbY10pKTtcImNsaWNrXCI9PT1hLnR5cGU/dGhpcy5maXJlRXZlbnQoZFtjXSxcImNsaWNrXCIsYSk6XCJtb3VzZW1vdmVcIj09PWEudHlwZSYmdGhpcy5maXJlRXZlbnQoZFtjXSxcIm1vdXNlbW92ZVwiLGEpfX19O1oucHJvdG90eXBlLmZpcmVFdmVudD1mdW5jdGlvbihhLGQsYyl7aWYoYSYmZCl7dmFyIGI9YS5ldmVudFBhcmFtZXRlcixlPWEuZXZlbnRDb250ZXh0LGY9YS5ldmVudENvbnRleHQudXNlckNvbnRleHQ7ZiYmKGUmJmZbZVtkXV0pJiZmW2VbZF1dLmNhbGwoZixiKTtcIm1vdXNlb3V0XCIhPT1kP2YuY3Vyc29yJiZmLmN1cnNvciE9PWMudGFyZ2V0LnN0eWxlLmN1cnNvciYmXG4oYy50YXJnZXQuc3R5bGUuY3Vyc29yPWYuY3Vyc29yKTooYy50YXJnZXQuc3R5bGUuY3Vyc29yPXRoaXMuY2hhcnQuX2RlZmF1bHRDdXJzb3IsZGVsZXRlIGEuZXZlbnRQYXJhbWV0ZXIsZGVsZXRlIGEuZXZlbnRDb250ZXh0KTtcImNsaWNrXCI9PT1kJiYoXCJkYXRhUG9pbnRcIj09PWEub2JqZWN0VHlwZSYmdGhpcy5jaGFydC5waWVEb3VnaG51dENsaWNrSGFuZGxlcikmJnRoaXMuY2hhcnQucGllRG91Z2hudXRDbGlja0hhbmRsZXIuY2FsbCh0aGlzLmNoYXJ0LmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhdLGIpO1wiY2xpY2tcIj09PWQmJihcImRhdGFQb2ludFwiPT09YS5vYmplY3RUeXBlJiZ0aGlzLmNoYXJ0LmZ1bm5lbFB5cmFtaWRDbGlja0hhbmRsZXIpJiZ0aGlzLmNoYXJ0LmZ1bm5lbFB5cmFtaWRDbGlja0hhbmRsZXIuY2FsbCh0aGlzLmNoYXJ0LmRhdGFbYS5kYXRhU2VyaWVzSW5kZXhdLGIpfX07aWEucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oYSxkLGMsYixlKXt2YXIgZj10aGlzO1xudGhpcy5jaGFydC5pc0FuaW1hdGluZz0hMDtlPWV8fE0uZWFzaW5nLmxpbmVhcjtjJiZ0aGlzLmFuaW1hdGlvbnMucHVzaCh7c3RhcnRUaW1lOihuZXcgRGF0ZSkuZ2V0VGltZSgpKyhhP2E6MCksZHVyYXRpb246ZCxhbmltYXRpb25DYWxsYmFjazpjLG9uQ29tcGxldGU6Yn0pO2ZvcihhPVtdOzA8dGhpcy5hbmltYXRpb25zLmxlbmd0aDspaWYoZD10aGlzLmFuaW1hdGlvbnMuc2hpZnQoKSxjPShuZXcgRGF0ZSkuZ2V0VGltZSgpLGI9MCxkLnN0YXJ0VGltZTw9YyYmKGI9ZShNYXRoLm1pbihjLWQuc3RhcnRUaW1lLGQuZHVyYXRpb24pLDAsMSxkLmR1cmF0aW9uKSxiPU1hdGgubWluKGIsMSksaXNOYU4oYil8fCFpc0Zpbml0ZShiKSkmJihiPTEpLDE+YiYmYS5wdXNoKGQpLGQuYW5pbWF0aW9uQ2FsbGJhY2soYiksMTw9YiYmZC5vbkNvbXBsZXRlKWQub25Db21wbGV0ZSgpO3RoaXMuYW5pbWF0aW9ucz1hOzA8dGhpcy5hbmltYXRpb25zLmxlbmd0aD90aGlzLmFuaW1hdGlvblJlcXVlc3RJZD1cbnRoaXMuY2hhcnQucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdyxmdW5jdGlvbigpe2YuYW5pbWF0ZS5jYWxsKGYpfSk6dGhpcy5jaGFydC5pc0FuaW1hdGluZz0hMX07aWEucHJvdG90eXBlLmNhbmNlbEFsbEFuaW1hdGlvbnM9ZnVuY3Rpb24oKXt0aGlzLmFuaW1hdGlvbnM9W107dGhpcy5hbmltYXRpb25SZXF1ZXN0SWQmJnRoaXMuY2hhcnQuY2FuY2VsUmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdyx0aGlzLmFuaW1hdGlvblJlcXVlc3RJZCk7dGhpcy5hbmltYXRpb25SZXF1ZXN0SWQ9bnVsbDt0aGlzLmNoYXJ0LmlzQW5pbWF0aW5nPSExfTt2YXIgTT17eVNjYWxlQW5pbWF0aW9uOmZ1bmN0aW9uKGEsZCl7aWYoMCE9PWEpe3ZhciBjPWQuZGVzdCxiPWQuc291cmNlLmNhbnZhcyxlPWQuYW5pbWF0aW9uQmFzZTtjLmRyYXdJbWFnZShiLDAsMCxiLndpZHRoLGIuaGVpZ2h0LDAsZS1lKmEsYy5jYW52YXMud2lkdGgvbGEsYSpjLmNhbnZhcy5oZWlnaHQvbGEpfX0seFNjYWxlQW5pbWF0aW9uOmZ1bmN0aW9uKGEsXG5kKXtpZigwIT09YSl7dmFyIGM9ZC5kZXN0LGI9ZC5zb3VyY2UuY2FudmFzLGU9ZC5hbmltYXRpb25CYXNlO2MuZHJhd0ltYWdlKGIsMCwwLGIud2lkdGgsYi5oZWlnaHQsZS1lKmEsMCxhKmMuY2FudmFzLndpZHRoL2xhLGMuY2FudmFzLmhlaWdodC9sYSl9fSx4Q2xpcEFuaW1hdGlvbjpmdW5jdGlvbihhLGQpe2lmKDAhPT1hKXt2YXIgYz1kLmRlc3QsYj1kLnNvdXJjZS5jYW52YXM7Yy5zYXZlKCk7MDxhJiZjLmRyYXdJbWFnZShiLDAsMCxiLndpZHRoKmEsYi5oZWlnaHQsMCwwLGIud2lkdGgqYS9sYSxiLmhlaWdodC9sYSk7Yy5yZXN0b3JlKCl9fSxmYWRlSW5BbmltYXRpb246ZnVuY3Rpb24oYSxkKXtpZigwIT09YSl7dmFyIGM9ZC5kZXN0LGI9ZC5zb3VyY2UuY2FudmFzO2Muc2F2ZSgpO2MuZ2xvYmFsQWxwaGE9YTtjLmRyYXdJbWFnZShiLDAsMCxiLndpZHRoLGIuaGVpZ2h0LDAsMCxjLmNhbnZhcy53aWR0aC9sYSxjLmNhbnZhcy5oZWlnaHQvbGEpO2MucmVzdG9yZSgpfX0sZWFzaW5nOntsaW5lYXI6ZnVuY3Rpb24oYSxcbmQsYyxiKXtyZXR1cm4gYyphL2IrZH0sZWFzZU91dFF1YWQ6ZnVuY3Rpb24oYSxkLGMsYil7cmV0dXJuLWMqKGEvPWIpKihhLTIpK2R9LGVhc2VPdXRRdWFydDpmdW5jdGlvbihhLGQsYyxiKXtyZXR1cm4tYyooKGE9YS9iLTEpKmEqYSphLTEpK2R9LGVhc2VJblF1YWQ6ZnVuY3Rpb24oYSxkLGMsYil7cmV0dXJuIGMqKGEvPWIpKmErZH0sZWFzZUluUXVhcnQ6ZnVuY3Rpb24oYSxkLGMsYil7cmV0dXJuIGMqKGEvPWIpKmEqYSphK2R9fX0sVz17ZHJhd01hcmtlcjpmdW5jdGlvbihhLGQsYyxiLGUsZixoLHApe2lmKGMpe3ZhciByPTE7Yy5maWxsU3R5bGU9Zj9mOlwiIzAwMDAwMFwiO2Muc3Ryb2tlU3R5bGU9aD9oOlwiIzAwMDAwMFwiO2MubGluZVdpZHRoPXA/cDowO2Muc2V0TGluZURhc2gmJmMuc2V0TGluZURhc2goSihcInNvbGlkXCIscCkpO1wiY2lyY2xlXCI9PT1iPyhjLm1vdmVUbyhhLGQpLGMuYmVnaW5QYXRoKCksYy5hcmMoYSxkLGUvMiwwLDIqTWF0aC5QSSwhMSksZiYmYy5maWxsKCksXG5wJiYoaD9jLnN0cm9rZSgpOihyPWMuZ2xvYmFsQWxwaGEsYy5nbG9iYWxBbHBoYT0wLjE1LGMuc3Ryb2tlU3R5bGU9XCJibGFja1wiLGMuc3Ryb2tlKCksYy5nbG9iYWxBbHBoYT1yKSkpOlwic3F1YXJlXCI9PT1iPyhjLmJlZ2luUGF0aCgpLGMucmVjdChhLWUvMixkLWUvMixlLGUpLGYmJmMuZmlsbCgpLHAmJihoP2Muc3Ryb2tlKCk6KHI9Yy5nbG9iYWxBbHBoYSxjLmdsb2JhbEFscGhhPTAuMTUsYy5zdHJva2VTdHlsZT1cImJsYWNrXCIsYy5zdHJva2UoKSxjLmdsb2JhbEFscGhhPXIpKSk6XCJ0cmlhbmdsZVwiPT09Yj8oYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhhLWUvMixkK2UvMiksYy5saW5lVG8oYStlLzIsZCtlLzIpLGMubGluZVRvKGEsZC1lLzIpLGMuY2xvc2VQYXRoKCksZiYmYy5maWxsKCkscCYmKGg/Yy5zdHJva2UoKToocj1jLmdsb2JhbEFscGhhLGMuZ2xvYmFsQWxwaGE9MC4xNSxjLnN0cm9rZVN0eWxlPVwiYmxhY2tcIixjLnN0cm9rZSgpLGMuZ2xvYmFsQWxwaGE9cikpLGMuYmVnaW5QYXRoKCkpOlxuXCJjcm9zc1wiPT09YiYmKGMuc3Ryb2tlU3R5bGU9ZixjLmxpbmVXaWR0aD1lLzQsYy5iZWdpblBhdGgoKSxjLm1vdmVUbyhhLWUvMixkLWUvMiksYy5saW5lVG8oYStlLzIsZCtlLzIpLGMuc3Ryb2tlKCksYy5tb3ZlVG8oYStlLzIsZC1lLzIpLGMubGluZVRvKGEtZS8yLGQrZS8yKSxjLnN0cm9rZSgpKX19LGRyYXdNYXJrZXJzOmZ1bmN0aW9uKGEpe2Zvcih2YXIgZD0wO2Q8YS5sZW5ndGg7ZCsrKXt2YXIgYz1hW2RdO1cuZHJhd01hcmtlcihjLngsYy55LGMuY3R4LGMudHlwZSxjLnNpemUsYy5jb2xvcixjLmJvcmRlckNvbG9yLGMuYm9yZGVyVGhpY2tuZXNzKX19fTtyZXR1cm4gcH0oKTtCLnZlcnNpb249XCJ2My43LjMzIEdBXCI7d2luZG93LkNhbnZhc0pTJiYoQiYmIXdpbmRvdy5DYW52YXNKUy5DaGFydCkmJih3aW5kb3cuQ2FudmFzSlMuQ2hhcnQ9Qil9KSgpO1xuXHJcbi8qXG4gIGV4Y2FudmFzIGlzIHVzZWQgdG8gc3VwcG9ydCBJRTY3OCB3aGljaCBkbyBub3QgaW1wbGVtZW50IEhUTUw1IENhbnZhcyBFbGVtZW50LiBZb3UgY2FuIHNhZmVseSByZW1vdmUgdGhlIGZvbGxvd2luZyBleGNhbnZhcyBjb2RlIGlmIHlvdSBkb24ndCBuZWVkIHRvIHN1cHBvcnQgb2xkZXIgYnJvd3NlcnMuXG5cbiAgQ29weXJpZ2h0IDIwMDYgR29vZ2xlIEluYy4gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9leHBsb3JlcmNhbnZhcy9cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMFxuKi9cbmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dHx8ZnVuY3Rpb24oKXtmdW5jdGlvbiBWKCl7cmV0dXJuIHRoaXMuY29udGV4dF98fCh0aGlzLmNvbnRleHRfPW5ldyBDKHRoaXMpKX1mdW5jdGlvbiBXKGEsYixjKXt2YXIgZz1NLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGIsZy5jb25jYXQoTS5jYWxsKGFyZ3VtZW50cykpKX19ZnVuY3Rpb24gTihhKXtyZXR1cm4gU3RyaW5nKGEpLnJlcGxhY2UoLyYvZyxcIiZhbXA7XCIpLnJlcGxhY2UoL1wiL2csXCImcXVvdDtcIil9ZnVuY3Rpb24gTyhhKXthLm5hbWVzcGFjZXMuZ192bWxffHxhLm5hbWVzcGFjZXMuYWRkKFwiZ192bWxfXCIsXCJ1cm46c2NoZW1hcy1taWNyb3NvZnQtY29tOnZtbFwiLFwiI2RlZmF1bHQjVk1MXCIpO2EubmFtZXNwYWNlcy5nX29ffHxhLm5hbWVzcGFjZXMuYWRkKFwiZ19vX1wiLFwidXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTpvZmZpY2U6b2ZmaWNlXCIsXCIjZGVmYXVsdCNWTUxcIik7XG5hLnN0eWxlU2hlZXRzLmV4X2NhbnZhc198fChhPWEuY3JlYXRlU3R5bGVTaGVldCgpLGEub3duaW5nRWxlbWVudC5pZD1cImV4X2NhbnZhc19cIixhLmNzc1RleHQ9XCJjYW52YXN7ZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3RleHQtYWxpZ246bGVmdDt3aWR0aDozMDBweDtoZWlnaHQ6MTUwcHh9XCIpfWZ1bmN0aW9uIFgoYSl7dmFyIGI9YS5zcmNFbGVtZW50O3N3aXRjaChhLnByb3BlcnR5TmFtZSl7Y2FzZSBcIndpZHRoXCI6Yi5nZXRDb250ZXh0KCkuY2xlYXJSZWN0KCk7Yi5zdHlsZS53aWR0aD1iLmF0dHJpYnV0ZXMud2lkdGgubm9kZVZhbHVlK1wicHhcIjtiLmZpcnN0Q2hpbGQuc3R5bGUud2lkdGg9Yi5jbGllbnRXaWR0aCtcInB4XCI7YnJlYWs7Y2FzZSBcImhlaWdodFwiOmIuZ2V0Q29udGV4dCgpLmNsZWFyUmVjdCgpLGIuc3R5bGUuaGVpZ2h0PWIuYXR0cmlidXRlcy5oZWlnaHQubm9kZVZhbHVlK1wicHhcIixiLmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0PWIuY2xpZW50SGVpZ2h0K1xuXCJweFwifX1mdW5jdGlvbiBZKGEpe2E9YS5zcmNFbGVtZW50O2EuZmlyc3RDaGlsZCYmKGEuZmlyc3RDaGlsZC5zdHlsZS53aWR0aD1hLmNsaWVudFdpZHRoK1wicHhcIixhLmZpcnN0Q2hpbGQuc3R5bGUuaGVpZ2h0PWEuY2xpZW50SGVpZ2h0K1wicHhcIil9ZnVuY3Rpb24gRCgpe3JldHVybltbMSwwLDBdLFswLDEsMF0sWzAsMCwxXV19ZnVuY3Rpb24gdChhLGIpe2Zvcih2YXIgYz1EKCksZz0wOzM+ZztnKyspZm9yKHZhciBlPTA7Mz5lO2UrKyl7Zm9yKHZhciBmPTAsZD0wOzM+ZDtkKyspZis9YVtnXVtkXSpiW2RdW2VdO2NbZ11bZV09Zn1yZXR1cm4gY31mdW5jdGlvbiBQKGEsYil7Yi5maWxsU3R5bGU9YS5maWxsU3R5bGU7Yi5saW5lQ2FwPWEubGluZUNhcDtiLmxpbmVKb2luPWEubGluZUpvaW47Yi5saW5lV2lkdGg9YS5saW5lV2lkdGg7Yi5taXRlckxpbWl0PWEubWl0ZXJMaW1pdDtiLnNoYWRvd0JsdXI9YS5zaGFkb3dCbHVyO2Iuc2hhZG93Q29sb3I9YS5zaGFkb3dDb2xvcjtiLnNoYWRvd09mZnNldFg9XG5hLnNoYWRvd09mZnNldFg7Yi5zaGFkb3dPZmZzZXRZPWEuc2hhZG93T2Zmc2V0WTtiLnN0cm9rZVN0eWxlPWEuc3Ryb2tlU3R5bGU7Yi5nbG9iYWxBbHBoYT1hLmdsb2JhbEFscGhhO2IuZm9udD1hLmZvbnQ7Yi50ZXh0QWxpZ249YS50ZXh0QWxpZ247Yi50ZXh0QmFzZWxpbmU9YS50ZXh0QmFzZWxpbmU7Yi5hcmNTY2FsZVhfPWEuYXJjU2NhbGVYXztiLmFyY1NjYWxlWV89YS5hcmNTY2FsZVlfO2IubGluZVNjYWxlXz1hLmxpbmVTY2FsZV99ZnVuY3Rpb24gUShhKXt2YXIgYj1hLmluZGV4T2YoXCIoXCIsMyksYz1hLmluZGV4T2YoXCIpXCIsYisxKSxiPWEuc3Vic3RyaW5nKGIrMSxjKS5zcGxpdChcIixcIik7aWYoNCE9Yi5sZW5ndGh8fFwiYVwiIT1hLmNoYXJBdCgzKSliWzNdPTE7cmV0dXJuIGJ9ZnVuY3Rpb24gRShhLGIsYyl7cmV0dXJuIE1hdGgubWluKGMsTWF0aC5tYXgoYixhKSl9ZnVuY3Rpb24gRihhLGIsYyl7MD5jJiZjKys7MTxjJiZjLS07cmV0dXJuIDE+NipjP2ErNiooYi1hKSpjOlxuMT4yKmM/YjoyPjMqYz9hKzYqKGItYSkqKDIvMy1jKTphfWZ1bmN0aW9uIEcoYSl7aWYoYSBpbiBIKXJldHVybiBIW2FdO3ZhciBiLGM9MTthPVN0cmluZyhhKTtpZihcIiNcIj09YS5jaGFyQXQoMCkpYj1hO2Vsc2UgaWYoL15yZ2IvLnRlc3QoYSkpe2M9UShhKTtiPVwiI1wiO2Zvcih2YXIgZyxlPTA7Mz5lO2UrKylnPS0xIT1jW2VdLmluZGV4T2YoXCIlXCIpP01hdGguZmxvb3IoMjU1KihwYXJzZUZsb2F0KGNbZV0pLzEwMCkpOitjW2VdLGIrPXZbRShnLDAsMjU1KV07Yz0rY1szXX1lbHNlIGlmKC9eaHNsLy50ZXN0KGEpKXtlPWM9UShhKTtiPXBhcnNlRmxvYXQoZVswXSkvMzYwJTM2MDswPmImJmIrKztnPUUocGFyc2VGbG9hdChlWzFdKS8xMDAsMCwxKTtlPUUocGFyc2VGbG9hdChlWzJdKS8xMDAsMCwxKTtpZigwPT1nKWc9ZT1iPWU7ZWxzZXt2YXIgZj0wLjU+ZT9lKigxK2cpOmUrZy1lKmcsZD0yKmUtZjtnPUYoZCxmLGIrMS8zKTtlPUYoZCxmLGIpO2I9RihkLGYsYi0xLzMpfWI9XCIjXCIrXG52W01hdGguZmxvb3IoMjU1KmcpXSt2W01hdGguZmxvb3IoMjU1KmUpXSt2W01hdGguZmxvb3IoMjU1KmIpXTtjPWNbM119ZWxzZSBiPVpbYV18fGE7cmV0dXJuIEhbYV09e2NvbG9yOmIsYWxwaGE6Y319ZnVuY3Rpb24gQyhhKXt0aGlzLm1fPUQoKTt0aGlzLm1TdGFja189W107dGhpcy5hU3RhY2tfPVtdO3RoaXMuY3VycmVudFBhdGhfPVtdO3RoaXMuZmlsbFN0eWxlPXRoaXMuc3Ryb2tlU3R5bGU9XCIjMDAwXCI7dGhpcy5saW5lV2lkdGg9MTt0aGlzLmxpbmVKb2luPVwibWl0ZXJcIjt0aGlzLmxpbmVDYXA9XCJidXR0XCI7dGhpcy5taXRlckxpbWl0PTEqcTt0aGlzLmdsb2JhbEFscGhhPTE7dGhpcy5mb250PVwiMTBweCBzYW5zLXNlcmlmXCI7dGhpcy50ZXh0QWxpZ249XCJsZWZ0XCI7dGhpcy50ZXh0QmFzZWxpbmU9XCJhbHBoYWJldGljXCI7dGhpcy5jYW52YXM9YTt2YXIgYj1cIndpZHRoOlwiK2EuY2xpZW50V2lkdGgrXCJweDtoZWlnaHQ6XCIrYS5jbGllbnRIZWlnaHQrXCJweDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246YWJzb2x1dGVcIixcbmM9YS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Yy5zdHlsZS5jc3NUZXh0PWI7YS5hcHBlbmRDaGlsZChjKTtiPWMuY2xvbmVOb2RlKCExKTtiLnN0eWxlLmJhY2tncm91bmRDb2xvcj1cInJlZFwiO2Iuc3R5bGUuZmlsdGVyPVwiYWxwaGEob3BhY2l0eT0wKVwiO2EuYXBwZW5kQ2hpbGQoYik7dGhpcy5lbGVtZW50Xz1jO3RoaXMubGluZVNjYWxlXz10aGlzLmFyY1NjYWxlWV89dGhpcy5hcmNTY2FsZVhfPTF9ZnVuY3Rpb24gUihhLGIsYyxnKXthLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOlwiYmV6aWVyQ3VydmVUb1wiLGNwMXg6Yi54LGNwMXk6Yi55LGNwMng6Yy54LGNwMnk6Yy55LHg6Zy54LHk6Zy55fSk7YS5jdXJyZW50WF89Zy54O2EuY3VycmVudFlfPWcueX1mdW5jdGlvbiBTKGEsYil7dmFyIGM9RyhhLnN0cm9rZVN0eWxlKSxnPWMuY29sb3IsYz1jLmFscGhhKmEuZ2xvYmFsQWxwaGEsZT1hLmxpbmVTY2FsZV8qYS5saW5lV2lkdGg7MT5lJiYoYyo9ZSk7Yi5wdXNoKFwiPGdfdm1sXzpzdHJva2VcIixcbicgb3BhY2l0eT1cIicsYywnXCInLCcgam9pbnN0eWxlPVwiJyxhLmxpbmVKb2luLCdcIicsJyBtaXRlcmxpbWl0PVwiJyxhLm1pdGVyTGltaXQsJ1wiJywnIGVuZGNhcD1cIicsJFthLmxpbmVDYXBdfHxcInNxdWFyZVwiLCdcIicsJyB3ZWlnaHQ9XCInLGUsJ3B4XCInLCcgY29sb3I9XCInLGcsJ1wiIC8+Jyl9ZnVuY3Rpb24gVChhLGIsYyxnKXt2YXIgZT1hLmZpbGxTdHlsZSxmPWEuYXJjU2NhbGVYXyxkPWEuYXJjU2NhbGVZXyxrPWcueC1jLngsbj1nLnktYy55O2lmKGUgaW5zdGFuY2VvZiB3KXt2YXIgaD0wLGw9Zz0wLHU9MCxtPTE7aWYoXCJncmFkaWVudFwiPT1lLnR5cGVfKXtoPWUueDFfL2Y7Yz1lLnkxXy9kO3ZhciBwPXMoYSxlLngwXy9mLGUueTBfL2QpLGg9cyhhLGgsYyksaD0xODAqTWF0aC5hdGFuMihoLngtcC54LGgueS1wLnkpL01hdGguUEk7MD5oJiYoaCs9MzYwKTsxRS02PmgmJihoPTApfWVsc2UgcD1zKGEsZS54MF8sZS55MF8pLGc9KHAueC1jLngpL2ssbD0ocC55LWMueSkvbixrLz1mKnEsXG5uLz1kKnEsbT14Lm1heChrLG4pLHU9MiplLnIwXy9tLG09MiplLnIxXy9tLXU7Zj1lLmNvbG9yc187Zi5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEub2Zmc2V0LWIub2Zmc2V0fSk7ZD1mLmxlbmd0aDtwPWZbMF0uY29sb3I7Yz1mW2QtMV0uY29sb3I7az1mWzBdLmFscGhhKmEuZ2xvYmFsQWxwaGE7YT1mW2QtMV0uYWxwaGEqYS5nbG9iYWxBbHBoYTtmb3IodmFyIG49W10scj0wO3I8ZDtyKyspe3ZhciB0PWZbcl07bi5wdXNoKHQub2Zmc2V0Km0rdStcIiBcIit0LmNvbG9yKX1iLnB1c2goJzxnX3ZtbF86ZmlsbCB0eXBlPVwiJyxlLnR5cGVfLCdcIicsJyBtZXRob2Q9XCJub25lXCIgZm9jdXM9XCIxMDAlXCInLCcgY29sb3I9XCInLHAsJ1wiJywnIGNvbG9yMj1cIicsYywnXCInLCcgY29sb3JzPVwiJyxuLmpvaW4oXCIsXCIpLCdcIicsJyBvcGFjaXR5PVwiJyxhLCdcIicsJyBnX29fOm9wYWNpdHkyPVwiJyxrLCdcIicsJyBhbmdsZT1cIicsaCwnXCInLCcgZm9jdXNwb3NpdGlvbj1cIicsZyxcIixcIixsLCdcIiAvPicpfWVsc2UgZSBpbnN0YW5jZW9mXG5JP2smJm4mJmIucHVzaChcIjxnX3ZtbF86ZmlsbFwiLCcgcG9zaXRpb249XCInLC1jLngvaypmKmYsXCIsXCIsLWMueS9uKmQqZCwnXCInLCcgdHlwZT1cInRpbGVcIicsJyBzcmM9XCInLGUuc3JjXywnXCIgLz4nKTooZT1HKGEuZmlsbFN0eWxlKSxiLnB1c2goJzxnX3ZtbF86ZmlsbCBjb2xvcj1cIicsZS5jb2xvciwnXCIgb3BhY2l0eT1cIicsZS5hbHBoYSphLmdsb2JhbEFscGhhLCdcIiAvPicpKX1mdW5jdGlvbiBzKGEsYixjKXthPWEubV87cmV0dXJue3g6cSooYiphWzBdWzBdK2MqYVsxXVswXSthWzJdWzBdKS1yLHk6cSooYiphWzBdWzFdK2MqYVsxXVsxXSthWzJdWzFdKS1yfX1mdW5jdGlvbiB6KGEsYixjKXtpc0Zpbml0ZShiWzBdWzBdKSYmKGlzRmluaXRlKGJbMF1bMV0pJiZpc0Zpbml0ZShiWzFdWzBdKSYmaXNGaW5pdGUoYlsxXVsxXSkmJmlzRmluaXRlKGJbMl1bMF0pJiZpc0Zpbml0ZShiWzJdWzFdKSkmJihhLm1fPWIsYyYmKGEubGluZVNjYWxlXz1hYShiYShiWzBdWzBdKmJbMV1bMV0tYlswXVsxXSpcbmJbMV1bMF0pKSkpfWZ1bmN0aW9uIHcoYSl7dGhpcy50eXBlXz1hO3RoaXMucjFfPXRoaXMueTFfPXRoaXMueDFfPXRoaXMucjBfPXRoaXMueTBfPXRoaXMueDBfPTA7dGhpcy5jb2xvcnNfPVtdfWZ1bmN0aW9uIEkoYSxiKXtpZighYXx8MSE9YS5ub2RlVHlwZXx8XCJJTUdcIiE9YS50YWdOYW1lKXRocm93IG5ldyBBKFwiVFlQRV9NSVNNQVRDSF9FUlJcIik7aWYoXCJjb21wbGV0ZVwiIT1hLnJlYWR5U3RhdGUpdGhyb3cgbmV3IEEoXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtzd2l0Y2goYil7Y2FzZSBcInJlcGVhdFwiOmNhc2UgbnVsbDpjYXNlIFwiXCI6dGhpcy5yZXBldGl0aW9uXz1cInJlcGVhdFwiO2JyZWFrO2Nhc2UgXCJyZXBlYXQteFwiOmNhc2UgXCJyZXBlYXQteVwiOmNhc2UgXCJuby1yZXBlYXRcIjp0aGlzLnJlcGV0aXRpb25fPWI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgQShcIlNZTlRBWF9FUlJcIik7fXRoaXMuc3JjXz1hLnNyYzt0aGlzLndpZHRoXz1hLndpZHRoO3RoaXMuaGVpZ2h0Xz1hLmhlaWdodH1cbmZ1bmN0aW9uIEEoYSl7dGhpcy5jb2RlPXRoaXNbYV07dGhpcy5tZXNzYWdlPWErXCI6IERPTSBFeGNlcHRpb24gXCIrdGhpcy5jb2RlfXZhciB4PU1hdGgsaz14LnJvdW5kLEo9eC5zaW4sSz14LmNvcyxiYT14LmFicyxhYT14LnNxcnQscT0xMCxyPXEvMjtuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9NU0lFIChbXFxkLl0rKT8vKTt2YXIgTT1BcnJheS5wcm90b3R5cGUuc2xpY2U7Tyhkb2N1bWVudCk7dmFyIFU9e2luaXQ6ZnVuY3Rpb24oYSl7YT1hfHxkb2N1bWVudDthLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7YS5hdHRhY2hFdmVudChcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiLFcodGhpcy5pbml0Xyx0aGlzLGEpKX0saW5pdF86ZnVuY3Rpb24oYSl7YT1hLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2FudmFzXCIpO2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuaW5pdEVsZW1lbnQoYVtiXSl9LGluaXRFbGVtZW50OmZ1bmN0aW9uKGEpe2lmKCFhLmdldENvbnRleHQpe2EuZ2V0Q29udGV4dD1cblY7TyhhLm93bmVyRG9jdW1lbnQpO2EuaW5uZXJIVE1MPVwiXCI7YS5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixYKTthLmF0dGFjaEV2ZW50KFwib25yZXNpemVcIixZKTt2YXIgYj1hLmF0dHJpYnV0ZXM7Yi53aWR0aCYmYi53aWR0aC5zcGVjaWZpZWQ/YS5zdHlsZS53aWR0aD1iLndpZHRoLm5vZGVWYWx1ZStcInB4XCI6YS53aWR0aD1hLmNsaWVudFdpZHRoO2IuaGVpZ2h0JiZiLmhlaWdodC5zcGVjaWZpZWQ/YS5zdHlsZS5oZWlnaHQ9Yi5oZWlnaHQubm9kZVZhbHVlK1wicHhcIjphLmhlaWdodD1hLmNsaWVudEhlaWdodH1yZXR1cm4gYX19O1UuaW5pdCgpO2Zvcih2YXIgdj1bXSxkPTA7MTY+ZDtkKyspZm9yKHZhciBCPTA7MTY+QjtCKyspdlsxNipkK0JdPWQudG9TdHJpbmcoMTYpK0IudG9TdHJpbmcoMTYpO3ZhciBaPXthbGljZWJsdWU6XCIjRjBGOEZGXCIsYW50aXF1ZXdoaXRlOlwiI0ZBRUJEN1wiLGFxdWFtYXJpbmU6XCIjN0ZGRkQ0XCIsYXp1cmU6XCIjRjBGRkZGXCIsYmVpZ2U6XCIjRjVGNURDXCIsXG5iaXNxdWU6XCIjRkZFNEM0XCIsYmxhY2s6XCIjMDAwMDAwXCIsYmxhbmNoZWRhbG1vbmQ6XCIjRkZFQkNEXCIsYmx1ZXZpb2xldDpcIiM4QTJCRTJcIixicm93bjpcIiNBNTJBMkFcIixidXJseXdvb2Q6XCIjREVCODg3XCIsY2FkZXRibHVlOlwiIzVGOUVBMFwiLGNoYXJ0cmV1c2U6XCIjN0ZGRjAwXCIsY2hvY29sYXRlOlwiI0QyNjkxRVwiLGNvcmFsOlwiI0ZGN0Y1MFwiLGNvcm5mbG93ZXJibHVlOlwiIzY0OTVFRFwiLGNvcm5zaWxrOlwiI0ZGRjhEQ1wiLGNyaW1zb246XCIjREMxNDNDXCIsY3lhbjpcIiMwMEZGRkZcIixkYXJrYmx1ZTpcIiMwMDAwOEJcIixkYXJrY3lhbjpcIiMwMDhCOEJcIixkYXJrZ29sZGVucm9kOlwiI0I4ODYwQlwiLGRhcmtncmF5OlwiI0E5QTlBOVwiLGRhcmtncmVlbjpcIiMwMDY0MDBcIixkYXJrZ3JleTpcIiNBOUE5QTlcIixkYXJra2hha2k6XCIjQkRCNzZCXCIsZGFya21hZ2VudGE6XCIjOEIwMDhCXCIsZGFya29saXZlZ3JlZW46XCIjNTU2QjJGXCIsZGFya29yYW5nZTpcIiNGRjhDMDBcIixkYXJrb3JjaGlkOlwiIzk5MzJDQ1wiLGRhcmtyZWQ6XCIjOEIwMDAwXCIsXG5kYXJrc2FsbW9uOlwiI0U5OTY3QVwiLGRhcmtzZWFncmVlbjpcIiM4RkJDOEZcIixkYXJrc2xhdGVibHVlOlwiIzQ4M0Q4QlwiLGRhcmtzbGF0ZWdyYXk6XCIjMkY0RjRGXCIsZGFya3NsYXRlZ3JleTpcIiMyRjRGNEZcIixkYXJrdHVycXVvaXNlOlwiIzAwQ0VEMVwiLGRhcmt2aW9sZXQ6XCIjOTQwMEQzXCIsZGVlcHBpbms6XCIjRkYxNDkzXCIsZGVlcHNreWJsdWU6XCIjMDBCRkZGXCIsZGltZ3JheTpcIiM2OTY5NjlcIixkaW1ncmV5OlwiIzY5Njk2OVwiLGRvZGdlcmJsdWU6XCIjMUU5MEZGXCIsZmlyZWJyaWNrOlwiI0IyMjIyMlwiLGZsb3JhbHdoaXRlOlwiI0ZGRkFGMFwiLGZvcmVzdGdyZWVuOlwiIzIyOEIyMlwiLGdhaW5zYm9ybzpcIiNEQ0RDRENcIixnaG9zdHdoaXRlOlwiI0Y4RjhGRlwiLGdvbGQ6XCIjRkZENzAwXCIsZ29sZGVucm9kOlwiI0RBQTUyMFwiLGdyZXk6XCIjODA4MDgwXCIsZ3JlZW55ZWxsb3c6XCIjQURGRjJGXCIsaG9uZXlkZXc6XCIjRjBGRkYwXCIsaG90cGluazpcIiNGRjY5QjRcIixpbmRpYW5yZWQ6XCIjQ0Q1QzVDXCIsaW5kaWdvOlwiIzRCMDA4MlwiLFxuaXZvcnk6XCIjRkZGRkYwXCIsa2hha2k6XCIjRjBFNjhDXCIsbGF2ZW5kZXI6XCIjRTZFNkZBXCIsbGF2ZW5kZXJibHVzaDpcIiNGRkYwRjVcIixsYXduZ3JlZW46XCIjN0NGQzAwXCIsbGVtb25jaGlmZm9uOlwiI0ZGRkFDRFwiLGxpZ2h0Ymx1ZTpcIiNBREQ4RTZcIixsaWdodGNvcmFsOlwiI0YwODA4MFwiLGxpZ2h0Y3lhbjpcIiNFMEZGRkZcIixsaWdodGdvbGRlbnJvZHllbGxvdzpcIiNGQUZBRDJcIixsaWdodGdyZWVuOlwiIzkwRUU5MFwiLGxpZ2h0Z3JleTpcIiNEM0QzRDNcIixsaWdodHBpbms6XCIjRkZCNkMxXCIsbGlnaHRzYWxtb246XCIjRkZBMDdBXCIsbGlnaHRzZWFncmVlbjpcIiMyMEIyQUFcIixsaWdodHNreWJsdWU6XCIjODdDRUZBXCIsbGlnaHRzbGF0ZWdyYXk6XCIjNzc4ODk5XCIsbGlnaHRzbGF0ZWdyZXk6XCIjNzc4ODk5XCIsbGlnaHRzdGVlbGJsdWU6XCIjQjBDNERFXCIsbGlnaHR5ZWxsb3c6XCIjRkZGRkUwXCIsbGltZWdyZWVuOlwiIzMyQ0QzMlwiLGxpbmVuOlwiI0ZBRjBFNlwiLG1hZ2VudGE6XCIjRkYwMEZGXCIsbWVkaXVtYXF1YW1hcmluZTpcIiM2NkNEQUFcIixcbm1lZGl1bWJsdWU6XCIjMDAwMENEXCIsbWVkaXVtb3JjaGlkOlwiI0JBNTVEM1wiLG1lZGl1bXB1cnBsZTpcIiM5MzcwREJcIixtZWRpdW1zZWFncmVlbjpcIiMzQ0IzNzFcIixtZWRpdW1zbGF0ZWJsdWU6XCIjN0I2OEVFXCIsbWVkaXVtc3ByaW5nZ3JlZW46XCIjMDBGQTlBXCIsbWVkaXVtdHVycXVvaXNlOlwiIzQ4RDFDQ1wiLG1lZGl1bXZpb2xldHJlZDpcIiNDNzE1ODVcIixtaWRuaWdodGJsdWU6XCIjMTkxOTcwXCIsbWludGNyZWFtOlwiI0Y1RkZGQVwiLG1pc3R5cm9zZTpcIiNGRkU0RTFcIixtb2NjYXNpbjpcIiNGRkU0QjVcIixuYXZham93aGl0ZTpcIiNGRkRFQURcIixvbGRsYWNlOlwiI0ZERjVFNlwiLG9saXZlZHJhYjpcIiM2QjhFMjNcIixvcmFuZ2U6XCIjRkZBNTAwXCIsb3JhbmdlcmVkOlwiI0ZGNDUwMFwiLG9yY2hpZDpcIiNEQTcwRDZcIixwYWxlZ29sZGVucm9kOlwiI0VFRThBQVwiLHBhbGVncmVlbjpcIiM5OEZCOThcIixwYWxldHVycXVvaXNlOlwiI0FGRUVFRVwiLHBhbGV2aW9sZXRyZWQ6XCIjREI3MDkzXCIscGFwYXlhd2hpcDpcIiNGRkVGRDVcIixcbnBlYWNocHVmZjpcIiNGRkRBQjlcIixwZXJ1OlwiI0NEODUzRlwiLHBpbms6XCIjRkZDMENCXCIscGx1bTpcIiNEREEwRERcIixwb3dkZXJibHVlOlwiI0IwRTBFNlwiLHJvc3licm93bjpcIiNCQzhGOEZcIixyb3lhbGJsdWU6XCIjNDE2OUUxXCIsc2FkZGxlYnJvd246XCIjOEI0NTEzXCIsc2FsbW9uOlwiI0ZBODA3MlwiLHNhbmR5YnJvd246XCIjRjRBNDYwXCIsc2VhZ3JlZW46XCIjMkU4QjU3XCIsc2Vhc2hlbGw6XCIjRkZGNUVFXCIsc2llbm5hOlwiI0EwNTIyRFwiLHNreWJsdWU6XCIjODdDRUVCXCIsc2xhdGVibHVlOlwiIzZBNUFDRFwiLHNsYXRlZ3JheTpcIiM3MDgwOTBcIixzbGF0ZWdyZXk6XCIjNzA4MDkwXCIsc25vdzpcIiNGRkZBRkFcIixzcHJpbmdncmVlbjpcIiMwMEZGN0ZcIixzdGVlbGJsdWU6XCIjNDY4MkI0XCIsdGFuOlwiI0QyQjQ4Q1wiLHRoaXN0bGU6XCIjRDhCRkQ4XCIsdG9tYXRvOlwiI0ZGNjM0N1wiLHR1cnF1b2lzZTpcIiM0MEUwRDBcIix2aW9sZXQ6XCIjRUU4MkVFXCIsd2hlYXQ6XCIjRjVERUIzXCIsd2hpdGVzbW9rZTpcIiNGNUY1RjVcIix5ZWxsb3dncmVlbjpcIiM5QUNEMzJcIn0sXG5IPXt9LEw9e30sJD17YnV0dDpcImZsYXRcIixyb3VuZDpcInJvdW5kXCJ9LGQ9Qy5wcm90b3R5cGU7ZC5jbGVhclJlY3Q9ZnVuY3Rpb24oKXt0aGlzLnRleHRNZWFzdXJlRWxfJiYodGhpcy50ZXh0TWVhc3VyZUVsXy5yZW1vdmVOb2RlKCEwKSx0aGlzLnRleHRNZWFzdXJlRWxfPW51bGwpO3RoaXMuZWxlbWVudF8uaW5uZXJIVE1MPVwiXCJ9O2QuYmVnaW5QYXRoPWZ1bmN0aW9uKCl7dGhpcy5jdXJyZW50UGF0aF89W119O2QubW92ZVRvPWZ1bmN0aW9uKGEsYil7dmFyIGM9cyh0aGlzLGEsYik7dGhpcy5jdXJyZW50UGF0aF8ucHVzaCh7dHlwZTpcIm1vdmVUb1wiLHg6Yy54LHk6Yy55fSk7dGhpcy5jdXJyZW50WF89Yy54O3RoaXMuY3VycmVudFlfPWMueX07ZC5saW5lVG89ZnVuY3Rpb24oYSxiKXt2YXIgYz1zKHRoaXMsYSxiKTt0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOlwibGluZVRvXCIseDpjLngseTpjLnl9KTt0aGlzLmN1cnJlbnRYXz1jLng7dGhpcy5jdXJyZW50WV89Yy55fTtkLmJlemllckN1cnZlVG89XG5mdW5jdGlvbihhLGIsYyxnLGUsZil7ZT1zKHRoaXMsZSxmKTthPXModGhpcyxhLGIpO2M9cyh0aGlzLGMsZyk7Uih0aGlzLGEsYyxlKX07ZC5xdWFkcmF0aWNDdXJ2ZVRvPWZ1bmN0aW9uKGEsYixjLGcpe2E9cyh0aGlzLGEsYik7Yz1zKHRoaXMsYyxnKTtnPXt4OnRoaXMuY3VycmVudFhfKzIvMyooYS54LXRoaXMuY3VycmVudFhfKSx5OnRoaXMuY3VycmVudFlfKzIvMyooYS55LXRoaXMuY3VycmVudFlfKX07Uih0aGlzLGcse3g6Zy54KyhjLngtdGhpcy5jdXJyZW50WF8pLzMseTpnLnkrKGMueS10aGlzLmN1cnJlbnRZXykvM30sYyl9O2QuYXJjPWZ1bmN0aW9uKGEsYixjLGcsZSxmKXtjKj1xO3ZhciBkPWY/XCJhdFwiOlwid2FcIixrPWErSyhnKSpjLXIsbj1iK0ooZykqYy1yO2c9YStLKGUpKmMtcjtlPWIrSihlKSpjLXI7ayE9Z3x8Znx8KGsrPTAuMTI1KTthPXModGhpcyxhLGIpO2s9cyh0aGlzLGssbik7Zz1zKHRoaXMsZyxlKTt0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOmQsXG54OmEueCx5OmEueSxyYWRpdXM6Yyx4U3RhcnQ6ay54LHlTdGFydDprLnkseEVuZDpnLngseUVuZDpnLnl9KX07ZC5yZWN0PWZ1bmN0aW9uKGEsYixjLGcpe3RoaXMubW92ZVRvKGEsYik7dGhpcy5saW5lVG8oYStjLGIpO3RoaXMubGluZVRvKGErYyxiK2cpO3RoaXMubGluZVRvKGEsYitnKTt0aGlzLmNsb3NlUGF0aCgpfTtkLnN0cm9rZVJlY3Q9ZnVuY3Rpb24oYSxiLGMsZyl7dmFyIGU9dGhpcy5jdXJyZW50UGF0aF87dGhpcy5iZWdpblBhdGgoKTt0aGlzLm1vdmVUbyhhLGIpO3RoaXMubGluZVRvKGErYyxiKTt0aGlzLmxpbmVUbyhhK2MsYitnKTt0aGlzLmxpbmVUbyhhLGIrZyk7dGhpcy5jbG9zZVBhdGgoKTt0aGlzLnN0cm9rZSgpO3RoaXMuY3VycmVudFBhdGhfPWV9O2QuZmlsbFJlY3Q9ZnVuY3Rpb24oYSxiLGMsZyl7dmFyIGU9dGhpcy5jdXJyZW50UGF0aF87dGhpcy5iZWdpblBhdGgoKTt0aGlzLm1vdmVUbyhhLGIpO3RoaXMubGluZVRvKGErYyxiKTt0aGlzLmxpbmVUbyhhK1xuYyxiK2cpO3RoaXMubGluZVRvKGEsYitnKTt0aGlzLmNsb3NlUGF0aCgpO3RoaXMuZmlsbCgpO3RoaXMuY3VycmVudFBhdGhfPWV9O2QuY3JlYXRlTGluZWFyR3JhZGllbnQ9ZnVuY3Rpb24oYSxiLGMsZyl7dmFyIGU9bmV3IHcoXCJncmFkaWVudFwiKTtlLngwXz1hO2UueTBfPWI7ZS54MV89YztlLnkxXz1nO3JldHVybiBlfTtkLmNyZWF0ZVJhZGlhbEdyYWRpZW50PWZ1bmN0aW9uKGEsYixjLGcsZSxmKXt2YXIgZD1uZXcgdyhcImdyYWRpZW50cmFkaWFsXCIpO2QueDBfPWE7ZC55MF89YjtkLnIwXz1jO2QueDFfPWc7ZC55MV89ZTtkLnIxXz1mO3JldHVybiBkfTtkLmRyYXdJbWFnZT1mdW5jdGlvbihhLGIpe3ZhciBjLGcsZSxkLHIseSxuLGg7ZT1hLnJ1bnRpbWVTdHlsZS53aWR0aDtkPWEucnVudGltZVN0eWxlLmhlaWdodDthLnJ1bnRpbWVTdHlsZS53aWR0aD1cImF1dG9cIjthLnJ1bnRpbWVTdHlsZS5oZWlnaHQ9XCJhdXRvXCI7dmFyIGw9YS53aWR0aCx1PWEuaGVpZ2h0O2EucnVudGltZVN0eWxlLndpZHRoPVxuZTthLnJ1bnRpbWVTdHlsZS5oZWlnaHQ9ZDtpZigzPT1hcmd1bWVudHMubGVuZ3RoKWM9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLHI9eT0wLG49ZT1sLGg9ZD11O2Vsc2UgaWYoNT09YXJndW1lbnRzLmxlbmd0aCljPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxlPWFyZ3VtZW50c1szXSxkPWFyZ3VtZW50c1s0XSxyPXk9MCxuPWwsaD11O2Vsc2UgaWYoOT09YXJndW1lbnRzLmxlbmd0aClyPWFyZ3VtZW50c1sxXSx5PWFyZ3VtZW50c1syXSxuPWFyZ3VtZW50c1szXSxoPWFyZ3VtZW50c1s0XSxjPWFyZ3VtZW50c1s1XSxnPWFyZ3VtZW50c1s2XSxlPWFyZ3VtZW50c1s3XSxkPWFyZ3VtZW50c1s4XTtlbHNlIHRocm93IEVycm9yKFwiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzXCIpO3ZhciBtPXModGhpcyxjLGcpLHA9W107cC5wdXNoKFwiIDxnX3ZtbF86Z3JvdXBcIiwnIGNvb3Jkc2l6ZT1cIicsMTAqcSxcIixcIiwxMCpxLCdcIicsJyBjb29yZG9yaWdpbj1cIjAsMFwiJywnIHN0eWxlPVwid2lkdGg6JyxcbjEwLFwicHg7aGVpZ2h0OlwiLDEwLFwicHg7cG9zaXRpb246YWJzb2x1dGU7XCIpO2lmKDEhPXRoaXMubV9bMF1bMF18fHRoaXMubV9bMF1bMV18fDEhPXRoaXMubV9bMV1bMV18fHRoaXMubV9bMV1bMF0pe3ZhciB0PVtdO3QucHVzaChcIk0xMT1cIix0aGlzLm1fWzBdWzBdLFwiLFwiLFwiTTEyPVwiLHRoaXMubV9bMV1bMF0sXCIsXCIsXCJNMjE9XCIsdGhpcy5tX1swXVsxXSxcIixcIixcIk0yMj1cIix0aGlzLm1fWzFdWzFdLFwiLFwiLFwiRHg9XCIsayhtLngvcSksXCIsXCIsXCJEeT1cIixrKG0ueS9xKSxcIlwiKTt2YXIgdj1zKHRoaXMsYytlLGcpLHc9cyh0aGlzLGMsZytkKTtjPXModGhpcyxjK2UsZytkKTttLng9eC5tYXgobS54LHYueCx3LngsYy54KTttLnk9eC5tYXgobS55LHYueSx3LnksYy55KTtwLnB1c2goXCJwYWRkaW5nOjAgXCIsayhtLngvcSksXCJweCBcIixrKG0ueS9xKSxcInB4IDA7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5NYXRyaXgoXCIsdC5qb2luKFwiXCIpLFwiLCBzaXppbmdtZXRob2Q9J2NsaXAnKTtcIil9ZWxzZSBwLnB1c2goXCJ0b3A6XCIsXG5rKG0ueS9xKSxcInB4O2xlZnQ6XCIsayhtLngvcSksXCJweDtcIik7cC5wdXNoKCcgXCI+JywnPGdfdm1sXzppbWFnZSBzcmM9XCInLGEuc3JjLCdcIicsJyBzdHlsZT1cIndpZHRoOicscSplLFwicHg7XCIsXCIgaGVpZ2h0OlwiLHEqZCwncHhcIicsJyBjcm9wbGVmdD1cIicsci9sLCdcIicsJyBjcm9wdG9wPVwiJyx5L3UsJ1wiJywnIGNyb3ByaWdodD1cIicsKGwtci1uKS9sLCdcIicsJyBjcm9wYm90dG9tPVwiJywodS15LWgpL3UsJ1wiJyxcIiAvPlwiLFwiPC9nX3ZtbF86Z3JvdXA+XCIpO3RoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiQmVmb3JlRW5kXCIscC5qb2luKFwiXCIpKX07ZC5zdHJva2U9ZnVuY3Rpb24oYSl7dmFyIGI9W107Yi5wdXNoKFwiPGdfdm1sXzpzaGFwZVwiLCcgZmlsbGVkPVwiJywhIWEsJ1wiJywnIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7d2lkdGg6JywxMCxcInB4O2hlaWdodDpcIiwxMCwncHg7XCInLCcgY29vcmRvcmlnaW49XCIwLDBcIicsJyBjb29yZHNpemU9XCInLDEwKnEsXCIsXCIsMTAqcSwnXCInLFxuJyBzdHJva2VkPVwiJywhYSwnXCInLCcgcGF0aD1cIicpO2Zvcih2YXIgYz17eDpudWxsLHk6bnVsbH0sZD17eDpudWxsLHk6bnVsbH0sZT0wO2U8dGhpcy5jdXJyZW50UGF0aF8ubGVuZ3RoO2UrKyl7dmFyIGY9dGhpcy5jdXJyZW50UGF0aF9bZV07c3dpdGNoKGYudHlwZSl7Y2FzZSBcIm1vdmVUb1wiOmIucHVzaChcIiBtIFwiLGsoZi54KSxcIixcIixrKGYueSkpO2JyZWFrO2Nhc2UgXCJsaW5lVG9cIjpiLnB1c2goXCIgbCBcIixrKGYueCksXCIsXCIsayhmLnkpKTticmVhaztjYXNlIFwiY2xvc2VcIjpiLnB1c2goXCIgeCBcIik7Zj1udWxsO2JyZWFrO2Nhc2UgXCJiZXppZXJDdXJ2ZVRvXCI6Yi5wdXNoKFwiIGMgXCIsayhmLmNwMXgpLFwiLFwiLGsoZi5jcDF5KSxcIixcIixrKGYuY3AyeCksXCIsXCIsayhmLmNwMnkpLFwiLFwiLGsoZi54KSxcIixcIixrKGYueSkpO2JyZWFrO2Nhc2UgXCJhdFwiOmNhc2UgXCJ3YVwiOmIucHVzaChcIiBcIixmLnR5cGUsXCIgXCIsayhmLngtdGhpcy5hcmNTY2FsZVhfKmYucmFkaXVzKSxcIixcIixrKGYueS10aGlzLmFyY1NjYWxlWV8qXG5mLnJhZGl1cyksXCIgXCIsayhmLngrdGhpcy5hcmNTY2FsZVhfKmYucmFkaXVzKSxcIixcIixrKGYueSt0aGlzLmFyY1NjYWxlWV8qZi5yYWRpdXMpLFwiIFwiLGsoZi54U3RhcnQpLFwiLFwiLGsoZi55U3RhcnQpLFwiIFwiLGsoZi54RW5kKSxcIixcIixrKGYueUVuZCkpfWlmKGYpe2lmKG51bGw9PWMueHx8Zi54PGMueCljLng9Zi54O2lmKG51bGw9PWQueHx8Zi54PmQueClkLng9Zi54O2lmKG51bGw9PWMueXx8Zi55PGMueSljLnk9Zi55O2lmKG51bGw9PWQueXx8Zi55PmQueSlkLnk9Zi55fX1iLnB1c2goJyBcIj4nKTthP1QodGhpcyxiLGMsZCk6Uyh0aGlzLGIpO2IucHVzaChcIjwvZ192bWxfOnNoYXBlPlwiKTt0aGlzLmVsZW1lbnRfLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZUVuZFwiLGIuam9pbihcIlwiKSl9O2QuZmlsbD1mdW5jdGlvbigpe3RoaXMuc3Ryb2tlKCEwKX07ZC5jbG9zZVBhdGg9ZnVuY3Rpb24oKXt0aGlzLmN1cnJlbnRQYXRoXy5wdXNoKHt0eXBlOlwiY2xvc2VcIn0pfTtkLnNhdmU9ZnVuY3Rpb24oKXt2YXIgYT1cbnt9O1AodGhpcyxhKTt0aGlzLmFTdGFja18ucHVzaChhKTt0aGlzLm1TdGFja18ucHVzaCh0aGlzLm1fKTt0aGlzLm1fPXQoRCgpLHRoaXMubV8pfTtkLnJlc3RvcmU9ZnVuY3Rpb24oKXt0aGlzLmFTdGFja18ubGVuZ3RoJiYoUCh0aGlzLmFTdGFja18ucG9wKCksdGhpcyksdGhpcy5tXz10aGlzLm1TdGFja18ucG9wKCkpfTtkLnRyYW5zbGF0ZT1mdW5jdGlvbihhLGIpe3oodGhpcyx0KFtbMSwwLDBdLFswLDEsMF0sW2EsYiwxXV0sdGhpcy5tXyksITEpfTtkLnJvdGF0ZT1mdW5jdGlvbihhKXt2YXIgYj1LKGEpO2E9SihhKTt6KHRoaXMsdChbW2IsYSwwXSxbLWEsYiwwXSxbMCwwLDFdXSx0aGlzLm1fKSwhMSl9O2Quc2NhbGU9ZnVuY3Rpb24oYSxiKXt0aGlzLmFyY1NjYWxlWF8qPWE7dGhpcy5hcmNTY2FsZVlfKj1iO3oodGhpcyx0KFtbYSwwLDBdLFswLGIsMF0sWzAsMCwxXV0sdGhpcy5tXyksITApfTtkLnRyYW5zZm9ybT1mdW5jdGlvbihhLGIsYyxkLGUsZil7eih0aGlzLHQoW1thLFxuYiwwXSxbYyxkLDBdLFtlLGYsMV1dLHRoaXMubV8pLCEwKX07ZC5zZXRUcmFuc2Zvcm09ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3oodGhpcyxbW2EsYiwwXSxbYyxkLDBdLFtlLGYsMV1dLCEwKX07ZC5kcmF3VGV4dF89ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzLm1fO2Q9MDt2YXIgcj0xRTMsdD0wLG49W10saDtoPXRoaXMuZm9udDtpZihMW2hdKWg9TFtoXTtlbHNle3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGU7dHJ5e2wuZm9udD1ofWNhdGNoKHUpe31oPUxbaF09e3N0eWxlOmwuZm9udFN0eWxlfHxcIm5vcm1hbFwiLHZhcmlhbnQ6bC5mb250VmFyaWFudHx8XCJub3JtYWxcIix3ZWlnaHQ6bC5mb250V2VpZ2h0fHxcIm5vcm1hbFwiLHNpemU6bC5mb250U2l6ZXx8MTAsZmFtaWx5OmwuZm9udEZhbWlseXx8XCJzYW5zLXNlcmlmXCJ9fXZhciBsPWgsbT10aGlzLmVsZW1lbnRfO2g9e307Zm9yKHZhciBwIGluIGwpaFtwXT1sW3BdO3A9cGFyc2VGbG9hdChtLmN1cnJlbnRTdHlsZS5mb250U2l6ZSk7XG5tPXBhcnNlRmxvYXQobC5zaXplKTtcIm51bWJlclwiPT10eXBlb2YgbC5zaXplP2guc2l6ZT1sLnNpemU6LTEhPWwuc2l6ZS5pbmRleE9mKFwicHhcIik/aC5zaXplPW06LTEhPWwuc2l6ZS5pbmRleE9mKFwiZW1cIik/aC5zaXplPXAqbTotMSE9bC5zaXplLmluZGV4T2YoXCIlXCIpP2guc2l6ZT1wLzEwMCptOi0xIT1sLnNpemUuaW5kZXhPZihcInB0XCIpP2guc2l6ZT1tLzAuNzU6aC5zaXplPXA7aC5zaXplKj0wLjk4MTtwPWguc3R5bGUrXCIgXCIraC52YXJpYW50K1wiIFwiK2gud2VpZ2h0K1wiIFwiK2guc2l6ZStcInB4IFwiK2guZmFtaWx5O209dGhpcy5lbGVtZW50Xy5jdXJyZW50U3R5bGU7bD10aGlzLnRleHRBbGlnbi50b0xvd2VyQ2FzZSgpO3N3aXRjaChsKXtjYXNlIFwibGVmdFwiOmNhc2UgXCJjZW50ZXJcIjpjYXNlIFwicmlnaHRcIjpicmVhaztjYXNlIFwiZW5kXCI6bD1cImx0clwiPT1tLmRpcmVjdGlvbj9cInJpZ2h0XCI6XCJsZWZ0XCI7YnJlYWs7Y2FzZSBcInN0YXJ0XCI6bD1cInJ0bFwiPT1tLmRpcmVjdGlvbj9cInJpZ2h0XCI6XG5cImxlZnRcIjticmVhaztkZWZhdWx0Omw9XCJsZWZ0XCJ9c3dpdGNoKHRoaXMudGV4dEJhc2VsaW5lKXtjYXNlIFwiaGFuZ2luZ1wiOmNhc2UgXCJ0b3BcIjp0PWguc2l6ZS8xLjc1O2JyZWFrO2Nhc2UgXCJtaWRkbGVcIjpicmVhaztkZWZhdWx0OmNhc2UgbnVsbDpjYXNlIFwiYWxwaGFiZXRpY1wiOmNhc2UgXCJpZGVvZ3JhcGhpY1wiOmNhc2UgXCJib3R0b21cIjp0PS1oLnNpemUvMi4yNX1zd2l0Y2gobCl7Y2FzZSBcInJpZ2h0XCI6ZD0xRTM7cj0wLjA1O2JyZWFrO2Nhc2UgXCJjZW50ZXJcIjpkPXI9NTAwfWI9cyh0aGlzLGIrMCxjK3QpO24ucHVzaCgnPGdfdm1sXzpsaW5lIGZyb209XCInLC1kLCcgMFwiIHRvPVwiJyxyLCcgMC4wNVwiICcsJyBjb29yZHNpemU9XCIxMDAgMTAwXCIgY29vcmRvcmlnaW49XCIwIDBcIicsJyBmaWxsZWQ9XCInLCFlLCdcIiBzdHJva2VkPVwiJywhIWUsJ1wiIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MXB4O2hlaWdodDoxcHg7XCI+Jyk7ZT9TKHRoaXMsbik6VCh0aGlzLG4se3g6LWQseTowfSxcbnt4OnIseTpoLnNpemV9KTtlPWZbMF1bMF0udG9GaXhlZCgzKStcIixcIitmWzFdWzBdLnRvRml4ZWQoMykrXCIsXCIrZlswXVsxXS50b0ZpeGVkKDMpK1wiLFwiK2ZbMV1bMV0udG9GaXhlZCgzKStcIiwwLDBcIjtiPWsoYi54L3EpK1wiLFwiK2soYi55L3EpO24ucHVzaCgnPGdfdm1sXzpza2V3IG9uPVwidFwiIG1hdHJpeD1cIicsZSwnXCIgJywnIG9mZnNldD1cIicsYiwnXCIgb3JpZ2luPVwiJyxkLCcgMFwiIC8+JywnPGdfdm1sXzpwYXRoIHRleHRwYXRob2s9XCJ0cnVlXCIgLz4nLCc8Z192bWxfOnRleHRwYXRoIG9uPVwidHJ1ZVwiIHN0cmluZz1cIicsTihhKSwnXCIgc3R5bGU9XCJ2LXRleHQtYWxpZ246JyxsLFwiO2ZvbnQ6XCIsTihwKSwnXCIgLz48L2dfdm1sXzpsaW5lPicpO3RoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlRW5kXCIsbi5qb2luKFwiXCIpKX07ZC5maWxsVGV4dD1mdW5jdGlvbihhLGIsYyxkKXt0aGlzLmRyYXdUZXh0XyhhLGIsYyxkLCExKX07ZC5zdHJva2VUZXh0PWZ1bmN0aW9uKGEsXG5iLGMsZCl7dGhpcy5kcmF3VGV4dF8oYSxiLGMsZCwhMCl9O2QubWVhc3VyZVRleHQ9ZnVuY3Rpb24oYSl7dGhpcy50ZXh0TWVhc3VyZUVsX3x8KHRoaXMuZWxlbWVudF8uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlRW5kXCIsJzxzcGFuIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7dG9wOi0yMDAwMHB4O2xlZnQ6MDtwYWRkaW5nOjA7bWFyZ2luOjA7Ym9yZGVyOm5vbmU7d2hpdGUtc3BhY2U6cHJlO1wiPjwvc3Bhbj4nKSx0aGlzLnRleHRNZWFzdXJlRWxfPXRoaXMuZWxlbWVudF8ubGFzdENoaWxkKTt2YXIgYj10aGlzLmVsZW1lbnRfLm93bmVyRG9jdW1lbnQ7dGhpcy50ZXh0TWVhc3VyZUVsXy5pbm5lckhUTUw9XCJcIjt0aGlzLnRleHRNZWFzdXJlRWxfLnN0eWxlLmZvbnQ9dGhpcy5mb250O3RoaXMudGV4dE1lYXN1cmVFbF8uYXBwZW5kQ2hpbGQoYi5jcmVhdGVUZXh0Tm9kZShhKSk7cmV0dXJue3dpZHRoOnRoaXMudGV4dE1lYXN1cmVFbF8ub2Zmc2V0V2lkdGh9fTtkLmNsaXA9ZnVuY3Rpb24oKXt9O1xuZC5hcmNUbz1mdW5jdGlvbigpe307ZC5jcmVhdGVQYXR0ZXJuPWZ1bmN0aW9uKGEsYil7cmV0dXJuIG5ldyBJKGEsYil9O3cucHJvdG90eXBlLmFkZENvbG9yU3RvcD1mdW5jdGlvbihhLGIpe2I9RyhiKTt0aGlzLmNvbG9yc18ucHVzaCh7b2Zmc2V0OmEsY29sb3I6Yi5jb2xvcixhbHBoYTpiLmFscGhhfSl9O2Q9QS5wcm90b3R5cGU9RXJyb3IoKTtkLklOREVYX1NJWkVfRVJSPTE7ZC5ET01TVFJJTkdfU0laRV9FUlI9MjtkLkhJRVJBUkNIWV9SRVFVRVNUX0VSUj0zO2QuV1JPTkdfRE9DVU1FTlRfRVJSPTQ7ZC5JTlZBTElEX0NIQVJBQ1RFUl9FUlI9NTtkLk5PX0RBVEFfQUxMT1dFRF9FUlI9NjtkLk5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUj03O2QuTk9UX0ZPVU5EX0VSUj04O2QuTk9UX1NVUFBPUlRFRF9FUlI9OTtkLklOVVNFX0FUVFJJQlVURV9FUlI9MTA7ZC5JTlZBTElEX1NUQVRFX0VSUj0xMTtkLlNZTlRBWF9FUlI9MTI7ZC5JTlZBTElEX01PRElGSUNBVElPTl9FUlI9XG4xMztkLk5BTUVTUEFDRV9FUlI9MTQ7ZC5JTlZBTElEX0FDQ0VTU19FUlI9MTU7ZC5WQUxJREFUSU9OX0VSUj0xNjtkLlRZUEVfTUlTTUFUQ0hfRVJSPTE3O0dfdm1sQ2FudmFzTWFuYWdlcj1VO0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRD1DO0NhbnZhc0dyYWRpZW50PXc7Q2FudmFzUGF0dGVybj1JO0RPTUV4Y2VwdGlvbj1BfSgpO1xuLyp0c2xpbnQ6ZW5hYmxlKi9cclxuLyplc2xpbnQtZW5hYmxlKi9cclxuLypqc2hpbnQgaWdub3JlOmVuZCovIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy4yMSc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIENPUkVfRVJST1JfVEVYVCA9ICdVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC4nLFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nLFxuICAgICAgSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCA9ICdJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYCc7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKiogVXNlZCBhcyB0aGUgaW50ZXJuYWwgYXJndW1lbnQgcGxhY2Vob2xkZXIuICovXG4gIHZhciBQTEFDRUhPTERFUiA9ICdfX2xvZGFzaF9wbGFjZWhvbGRlcl9fJztcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xuICB2YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xuICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsXG4gICAgICBXUkFQX0JJTkRfS0VZX0ZMQUcgPSAyLFxuICAgICAgV1JBUF9DVVJSWV9CT1VORF9GTEFHID0gNCxcbiAgICAgIFdSQVBfQ1VSUllfRkxBRyA9IDgsXG4gICAgICBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcgPSAxNixcbiAgICAgIFdSQVBfUEFSVElBTF9GTEFHID0gMzIsXG4gICAgICBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LFxuICAgICAgV1JBUF9BUllfRkxBRyA9IDEyOCxcbiAgICAgIFdSQVBfUkVBUkdfRkxBRyA9IDI1NixcbiAgICAgIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuXG4gIC8qKiBVc2VkIGFzIGRlZmF1bHQgb3B0aW9ucyBmb3IgYF8udHJ1bmNhdGVgLiAqL1xuICB2YXIgREVGQVVMVF9UUlVOQ19MRU5HVEggPSAzMCxcbiAgICAgIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSAnLi4uJztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG4gIHZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgICBIT1RfU1BBTiA9IDE2O1xuXG4gIC8qKiBVc2VkIHRvIGluZGljYXRlIHRoZSB0eXBlIG9mIGxhenkgaXRlcmF0ZWVzLiAqL1xuICB2YXIgTEFaWV9GSUxURVJfRkxBRyA9IDEsXG4gICAgICBMQVpZX01BUF9GTEFHID0gMixcbiAgICAgIExBWllfV0hJTEVfRkxBRyA9IDM7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgICAgTkFOID0gMCAvIDA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdGhlIG1heGltdW0gbGVuZ3RoIGFuZCBpbmRleCBvZiBhbiBhcnJheS4gKi9cbiAgdmFyIE1BWF9BUlJBWV9MRU5HVEggPSA0Mjk0OTY3Mjk1LFxuICAgICAgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsXG4gICAgICBIQUxGX01BWF9BUlJBWV9MRU5HVEggPSBNQVhfQVJSQVlfTEVOR1RIID4+PiAxO1xuXG4gIC8qKiBVc2VkIHRvIGFzc29jaWF0ZSB3cmFwIG1ldGhvZHMgd2l0aCB0aGVpciBiaXQgZmxhZ3MuICovXG4gIHZhciB3cmFwRmxhZ3MgPSBbXG4gICAgWydhcnknLCBXUkFQX0FSWV9GTEFHXSxcbiAgICBbJ2JpbmQnLCBXUkFQX0JJTkRfRkxBR10sXG4gICAgWydiaW5kS2V5JywgV1JBUF9CSU5EX0tFWV9GTEFHXSxcbiAgICBbJ2N1cnJ5JywgV1JBUF9DVVJSWV9GTEFHXSxcbiAgICBbJ2N1cnJ5UmlnaHQnLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUddLFxuICAgIFsnZmxpcCcsIFdSQVBfRkxJUF9GTEFHXSxcbiAgICBbJ3BhcnRpYWwnLCBXUkFQX1BBUlRJQUxfRkxBR10sXG4gICAgWydwYXJ0aWFsUmlnaHQnLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBR10sXG4gICAgWydyZWFyZycsIFdSQVBfUkVBUkdfRkxBR11cbiAgXTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nLFxuICAgICAgd2Vha1NldFRhZyA9ICdbb2JqZWN0IFdlYWtTZXRdJztcblxuICB2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZyxcbiAgICAgIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgICAgcmVIYXNFc2NhcGVkSHRtbCA9IFJlZ0V4cChyZUVzY2FwZWRIdG1sLnNvdXJjZSksXG4gICAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICAgIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICAgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAgICovXG4gIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csXG4gICAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xuICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKipcbiAgICogVXNlZCB0byB2YWxpZGF0ZSB0aGUgYHZhbGlkYXRlYCBvcHRpb24gaW4gYF8udGVtcGxhdGVgIHZhcmlhYmxlLlxuICAgKlxuICAgKiBGb3JiaWRzIGNoYXJhY3RlcnMgd2hpY2ggY291bGQgcG90ZW50aWFsbHkgY2hhbmdlIHRoZSBtZWFuaW5nIG9mIHRoZSBmdW5jdGlvbiBhcmd1bWVudCBkZWZpbml0aW9uOlxuICAgKiAtIFwiKCksXCIgKG1vZGlmaWNhdGlvbiBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICAgKiAtIFwiPVwiIChkZWZhdWx0IHZhbHVlKVxuICAgKiAtIFwiW117fVwiIChkZXN0cnVjdHVyaW5nIG9mIGZ1bmN0aW9uIHBhcmFtZXRlcnMpXG4gICAqIC0gXCIvXCIgKGJlZ2lubmluZyBvZiBhIGNvbW1lbnQpXG4gICAqIC0gd2hpdGVzcGFjZVxuICAgKi9cbiAgdmFyIHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzID0gL1soKT0se31cXFtcXF1cXC9cXHNdLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmdcbiAgICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgICA6IHN0cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gICAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgKiBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbFxuICAgKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLlxuICAgKi9cbiAgZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGBwbGFjZWhvbGRlcmAgb2NjdXJyZW5jZXMgaW4gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGNvdW50LlxuICAgKi9cbiAgZnVuY3Rpb24gY291bnRIb2xkZXJzKGFycmF5LCBwbGFjZWhvbGRlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICArK3Jlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmRlYnVycmAgdG8gY29udmVydCBMYXRpbi0xIFN1cHBsZW1lbnQgYW5kIExhdGluIEV4dGVuZGVkLUFcbiAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGV0dGVyIFRoZSBtYXRjaGVkIGxldHRlciB0byBkZWJ1cnIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIGxldHRlci5cbiAgICovXG4gIHZhciBkZWJ1cnJMZXR0ZXIgPSBiYXNlUHJvcGVydHlPZihkZWJ1cnJlZExldHRlcnMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLmVzY2FwZWAgdG8gY29udmVydCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAqL1xuICB2YXIgZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sRXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgY29udGFpbnMgYSB3b3JkIGNvbXBvc2VkIG9mIFVuaWNvZGUgc3ltYm9scy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHdvcmQgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGVXb3JkKHN0cmluZykge1xuICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaXRlcmF0b3JgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlcmF0b3IgVGhlIGl0ZXJhdG9yIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgdmFyIGRhdGEsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIGBwbGFjZWhvbGRlcmAgZWxlbWVudHMgaW4gYGFycmF5YCB3aXRoIGFuIGludGVybmFsIHBsYWNlaG9sZGVyXG4gICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZWlyIGluZGV4ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7Kn0gcGxhY2Vob2xkZXIgVGhlIHBsYWNlaG9sZGVyIHRvIHJlcGxhY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZXBsYWNlSG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IFBMQUNFSE9MREVSO1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBmdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc2V0YCB0byBpdHMgdmFsdWUtdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9QYWlycyhzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICAgKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmxhc3RJbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgID8gdW5pY29kZVNpemUoc3RyaW5nKVxuICAgICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZylcbiAgICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy51bmVzY2FwZWAgdG8gY29udmVydCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIHVuZXNjYXBlSHRtbENoYXIgPSBiYXNlUHJvcGVydHlPZihodG1sVW5lc2NhcGVzKTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgKytyZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGEgVW5pY29kZSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIHVuaWNvZGVXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB1c2luZyB0aGUgYGNvbnRleHRgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMS4xLjBcbiAgICogQGNhdGVnb3J5IFV0aWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PXJvb3RdIFRoZSBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgbmV3IGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHsgJ2Zvbyc6IF8uY29uc3RhbnQoJ2ZvbycpIH0pO1xuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ydW5JbkNvbnRleHQoKTtcbiAgICogbG9kYXNoLm1peGluKHsgJ2Jhcic6IGxvZGFzaC5jb25zdGFudCgnYmFyJykgfSk7XG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfLmZvbyk7XG4gICAqIC8vID0+IHRydWVcbiAgICogXy5pc0Z1bmN0aW9uKF8uYmFyKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogbG9kYXNoLmlzRnVuY3Rpb24obG9kYXNoLmZvbyk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5iYXIpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIC8vIENyZWF0ZSBhIHN1cGVkLXVwIGBkZWZlcmAgaW4gTm9kZS5qcy5cbiAgICogdmFyIGRlZmVyID0gXy5ydW5JbkNvbnRleHQoeyAnc2V0VGltZW91dCc6IHNldEltbWVkaWF0ZSB9KS5kZWZlcjtcbiAgICovXG4gIHZhciBydW5JbkNvbnRleHQgPSAoZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuXG4gICAgLyoqIEJ1aWx0LWluIGNvbnN0cnVjdG9yIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEFycmF5ID0gY29udGV4dC5BcnJheSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHQuRGF0ZSxcbiAgICAgICAgRXJyb3IgPSBjb250ZXh0LkVycm9yLFxuICAgICAgICBGdW5jdGlvbiA9IGNvbnRleHQuRnVuY3Rpb24sXG4gICAgICAgIE1hdGggPSBjb250ZXh0Lk1hdGgsXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHQuT2JqZWN0LFxuICAgICAgICBSZWdFeHAgPSBjb250ZXh0LlJlZ0V4cCxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dC5TdHJpbmcsXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHQuVHlwZUVycm9yO1xuXG4gICAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgICAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgICB2YXIgY29yZUpzRGF0YSA9IGNvbnRleHRbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICAgIHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIC8qKiBVc2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuICovXG4gICAgdmFyIGlkQ291bnRlciA9IDA7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICAgIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgICAqIG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbiAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbiAgICAvKiogVXNlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBgX2AgcmVmZXJlbmNlIGluIGBfLm5vQ29uZmxpY3RgLiAqL1xuICAgIHZhciBvbGREYXNoID0gcm9vdC5fO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICAgICk7XG5cbiAgICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IGNvbnRleHQuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbCxcbiAgICAgICAgVWludDhBcnJheSA9IGNvbnRleHQuVWludDhBcnJheSxcbiAgICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQsXG4gICAgICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgICAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgICAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgICAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICAgICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgICAgIHN5bUl0ZXJhdG9yID0gU3ltYm9sID8gU3ltYm9sLml0ZXJhdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9KCkpO1xuXG4gICAgLyoqIE1vY2tlZCBidWlsdC1pbnMuICovXG4gICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCxcbiAgICAgICAgY3R4Tm93ID0gRGF0ZSAmJiBEYXRlLm5vdyAhPT0gcm9vdC5EYXRlLm5vdyAmJiBEYXRlLm5vdyxcbiAgICAgICAgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcblxuICAgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgICB2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbCxcbiAgICAgICAgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICAgICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgICAgIG5hdGl2ZUlzRmluaXRlID0gY29udGV4dC5pc0Zpbml0ZSxcbiAgICAgICAgbmF0aXZlSm9pbiA9IGFycmF5UHJvdG8uam9pbixcbiAgICAgICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgICAgbmF0aXZlTm93ID0gRGF0ZS5ub3csXG4gICAgICAgIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCxcbiAgICAgICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb20sXG4gICAgICAgIG5hdGl2ZVJldmVyc2UgPSBhcnJheVByb3RvLnJldmVyc2U7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gICAgdmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKGNvbnRleHQsICdEYXRhVmlldycpLFxuICAgICAgICBNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ01hcCcpLFxuICAgICAgICBQcm9taXNlID0gZ2V0TmF0aXZlKGNvbnRleHQsICdQcm9taXNlJyksXG4gICAgICAgIFNldCA9IGdldE5hdGl2ZShjb250ZXh0LCAnU2V0JyksXG4gICAgICAgIFdlYWtNYXAgPSBnZXROYXRpdmUoY29udGV4dCwgJ1dlYWtNYXAnKSxcbiAgICAgICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gICAgLyoqIFVzZWQgdG8gc3RvcmUgZnVuY3Rpb24gbWV0YWRhdGEuICovXG4gICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwICYmIG5ldyBXZWFrTWFwO1xuXG4gICAgLyoqIFVzZWQgdG8gbG9va3VwIHVubWluaWZpZWQgZnVuY3Rpb24gbmFtZXMuICovXG4gICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbiAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgICAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICAgICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICAgICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbiAgICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgb2JqZWN0IHdoaWNoIHdyYXBzIGB2YWx1ZWAgdG8gZW5hYmxlIGltcGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcy4gTWV0aG9kcyB0aGF0IG9wZXJhdGUgb24gYW5kIHJldHVybiBhcnJheXMsIGNvbGxlY3Rpb25zLFxuICAgICAqIGFuZCBmdW5jdGlvbnMgY2FuIGJlIGNoYWluZWQgdG9nZXRoZXIuIE1ldGhvZHMgdGhhdCByZXRyaWV2ZSBhIHNpbmdsZSB2YWx1ZVxuICAgICAqIG9yIG1heSByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUgd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgY2hhaW4gc2VxdWVuY2VcbiAgICAgKiBhbmQgcmV0dXJuIHRoZSB1bndyYXBwZWQgdmFsdWUuIE90aGVyd2lzZSwgdGhlIHZhbHVlIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBFeHBsaWNpdCBjaGFpbiBzZXF1ZW5jZXMsIHdoaWNoIG11c3QgYmUgdW53cmFwcGVkIHdpdGggYF8jdmFsdWVgLCBtYXkgYmVcbiAgICAgKiBlbmFibGVkIHVzaW5nIGBfLmNoYWluYC5cbiAgICAgKlxuICAgICAqIFRoZSBleGVjdXRpb24gb2YgY2hhaW5lZCBtZXRob2RzIGlzIGxhenksIHRoYXQgaXMsIGl0J3MgZGVmZXJyZWQgdW50aWxcbiAgICAgKiBgXyN2YWx1ZWAgaXMgaW1wbGljaXRseSBvciBleHBsaWNpdGx5IGNhbGxlZC5cbiAgICAgKlxuICAgICAqIExhenkgZXZhbHVhdGlvbiBhbGxvd3Mgc2V2ZXJhbCBtZXRob2RzIHRvIHN1cHBvcnQgc2hvcnRjdXQgZnVzaW9uLlxuICAgICAqIFNob3J0Y3V0IGZ1c2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gdG8gbWVyZ2UgaXRlcmF0ZWUgY2FsbHM7IHRoaXMgYXZvaWRzXG4gICAgICogdGhlIGNyZWF0aW9uIG9mIGludGVybWVkaWF0ZSBhcnJheXMgYW5kIGNhbiBncmVhdGx5IHJlZHVjZSB0aGUgbnVtYmVyIG9mXG4gICAgICogaXRlcmF0ZWUgZXhlY3V0aW9ucy4gU2VjdGlvbnMgb2YgYSBjaGFpbiBzZXF1ZW5jZSBxdWFsaWZ5IGZvciBzaG9ydGN1dFxuICAgICAqIGZ1c2lvbiBpZiB0aGUgc2VjdGlvbiBpcyBhcHBsaWVkIHRvIGFuIGFycmF5IGFuZCBpdGVyYXRlZXMgYWNjZXB0IG9ubHlcbiAgICAgKiBvbmUgYXJndW1lbnQuIFRoZSBoZXVyaXN0aWMgZm9yIHdoZXRoZXIgYSBzZWN0aW9uIHF1YWxpZmllcyBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaXMgc3ViamVjdCB0byBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBDaGFpbmluZyBpcyBzdXBwb3J0ZWQgaW4gY3VzdG9tIGJ1aWxkcyBhcyBsb25nIGFzIHRoZSBgXyN2YWx1ZWAgbWV0aG9kIGlzXG4gICAgICogZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBpbmNsdWRlZCBpbiB0aGUgYnVpbGQuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiB0byBsb2Rhc2ggbWV0aG9kcywgd3JhcHBlcnMgaGF2ZSBgQXJyYXlgIGFuZCBgU3RyaW5nYCBtZXRob2RzLlxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYEFycmF5YCBtZXRob2RzIGFyZTpcbiAgICAgKiBgY29uY2F0YCwgYGpvaW5gLCBgcG9wYCwgYHB1c2hgLCBgc2hpZnRgLCBgc29ydGAsIGBzcGxpY2VgLCBhbmQgYHVuc2hpZnRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBgU3RyaW5nYCBtZXRob2RzIGFyZTpcbiAgICAgKiBgcmVwbGFjZWAgYW5kIGBzcGxpdGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbiBhcmU6XG4gICAgICogYGF0YCwgYGNvbXBhY3RgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZHJvcFdoaWxlYCwgYGZpbHRlcmAsIGBmaW5kYCxcbiAgICAgKiBgZmluZExhc3RgLCBgaGVhZGAsIGBpbml0aWFsYCwgYGxhc3RgLCBgbWFwYCwgYHJlamVjdGAsIGByZXZlcnNlYCwgYHNsaWNlYCxcbiAgICAgKiBgdGFpbGAsIGB0YWtlYCwgYHRha2VSaWdodGAsIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBhbmQgYHRvQXJyYXlgXG4gICAgICpcbiAgICAgKiBUaGUgY2hhaW5hYmxlIHdyYXBwZXIgbWV0aG9kcyBhcmU6XG4gICAgICogYGFmdGVyYCwgYGFyeWAsIGBhc3NpZ25gLCBgYXNzaWduSW5gLCBgYXNzaWduSW5XaXRoYCwgYGFzc2lnbldpdGhgLCBgYXRgLFxuICAgICAqIGBiZWZvcmVgLCBgYmluZGAsIGBiaW5kQWxsYCwgYGJpbmRLZXlgLCBgY2FzdEFycmF5YCwgYGNoYWluYCwgYGNodW5rYCxcbiAgICAgKiBgY29tbWl0YCwgYGNvbXBhY3RgLCBgY29uY2F0YCwgYGNvbmZvcm1zYCwgYGNvbnN0YW50YCwgYGNvdW50QnlgLCBgY3JlYXRlYCxcbiAgICAgKiBgY3VycnlgLCBgZGVib3VuY2VgLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGRlZmVyYCwgYGRlbGF5YCxcbiAgICAgKiBgZGlmZmVyZW5jZWAsIGBkaWZmZXJlbmNlQnlgLCBgZGlmZmVyZW5jZVdpdGhgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLFxuICAgICAqIGBkcm9wUmlnaHRXaGlsZWAsIGBkcm9wV2hpbGVgLCBgZXh0ZW5kYCwgYGV4dGVuZFdpdGhgLCBgZmlsbGAsIGBmaWx0ZXJgLFxuICAgICAqIGBmbGF0TWFwYCwgYGZsYXRNYXBEZWVwYCwgYGZsYXRNYXBEZXB0aGAsIGBmbGF0dGVuYCwgYGZsYXR0ZW5EZWVwYCxcbiAgICAgKiBgZmxhdHRlbkRlcHRoYCwgYGZsaXBgLCBgZmxvd2AsIGBmbG93UmlnaHRgLCBgZnJvbVBhaXJzYCwgYGZ1bmN0aW9uc2AsXG4gICAgICogYGZ1bmN0aW9uc0luYCwgYGdyb3VwQnlgLCBgaW5pdGlhbGAsIGBpbnRlcnNlY3Rpb25gLCBgaW50ZXJzZWN0aW9uQnlgLFxuICAgICAqIGBpbnRlcnNlY3Rpb25XaXRoYCwgYGludmVydGAsIGBpbnZlcnRCeWAsIGBpbnZva2VNYXBgLCBgaXRlcmF0ZWVgLCBga2V5QnlgLFxuICAgICAqIGBrZXlzYCwgYGtleXNJbmAsIGBtYXBgLCBgbWFwS2V5c2AsIGBtYXBWYWx1ZXNgLCBgbWF0Y2hlc2AsIGBtYXRjaGVzUHJvcGVydHlgLFxuICAgICAqIGBtZW1vaXplYCwgYG1lcmdlYCwgYG1lcmdlV2l0aGAsIGBtZXRob2RgLCBgbWV0aG9kT2ZgLCBgbWl4aW5gLCBgbmVnYXRlYCxcbiAgICAgKiBgbnRoQXJnYCwgYG9taXRgLCBgb21pdEJ5YCwgYG9uY2VgLCBgb3JkZXJCeWAsIGBvdmVyYCwgYG92ZXJBcmdzYCxcbiAgICAgKiBgb3ZlckV2ZXJ5YCwgYG92ZXJTb21lYCwgYHBhcnRpYWxgLCBgcGFydGlhbFJpZ2h0YCwgYHBhcnRpdGlvbmAsIGBwaWNrYCxcbiAgICAgKiBgcGlja0J5YCwgYHBsYW50YCwgYHByb3BlcnR5YCwgYHByb3BlcnR5T2ZgLCBgcHVsbGAsIGBwdWxsQWxsYCwgYHB1bGxBbGxCeWAsXG4gICAgICogYHB1bGxBbGxXaXRoYCwgYHB1bGxBdGAsIGBwdXNoYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVhcmdgLCBgcmVqZWN0YCxcbiAgICAgKiBgcmVtb3ZlYCwgYHJlc3RgLCBgcmV2ZXJzZWAsIGBzYW1wbGVTaXplYCwgYHNldGAsIGBzZXRXaXRoYCwgYHNodWZmbGVgLFxuICAgICAqIGBzbGljZWAsIGBzb3J0YCwgYHNvcnRCeWAsIGBzcGxpY2VgLCBgc3ByZWFkYCwgYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0YWtlUmlnaHRXaGlsZWAsIGB0YWtlV2hpbGVgLCBgdGFwYCwgYHRocm90dGxlYCwgYHRocnVgLCBgdG9BcnJheWAsXG4gICAgICogYHRvUGFpcnNgLCBgdG9QYWlyc0luYCwgYHRvUGF0aGAsIGB0b1BsYWluT2JqZWN0YCwgYHRyYW5zZm9ybWAsIGB1bmFyeWAsXG4gICAgICogYHVuaW9uYCwgYHVuaW9uQnlgLCBgdW5pb25XaXRoYCwgYHVuaXFgLCBgdW5pcUJ5YCwgYHVuaXFXaXRoYCwgYHVuc2V0YCxcbiAgICAgKiBgdW5zaGlmdGAsIGB1bnppcGAsIGB1bnppcFdpdGhgLCBgdXBkYXRlYCwgYHVwZGF0ZVdpdGhgLCBgdmFsdWVzYCxcbiAgICAgKiBgdmFsdWVzSW5gLCBgd2l0aG91dGAsIGB3cmFwYCwgYHhvcmAsIGB4b3JCeWAsIGB4b3JXaXRoYCwgYHppcGAsXG4gICAgICogYHppcE9iamVjdGAsIGB6aXBPYmplY3REZWVwYCwgYW5kIGB6aXBXaXRoYFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgbWV0aG9kcyB0aGF0IGFyZSAqKm5vdCoqIGNoYWluYWJsZSBieSBkZWZhdWx0IGFyZTpcbiAgICAgKiBgYWRkYCwgYGF0dGVtcHRgLCBgY2FtZWxDYXNlYCwgYGNhcGl0YWxpemVgLCBgY2VpbGAsIGBjbGFtcGAsIGBjbG9uZWAsXG4gICAgICogYGNsb25lRGVlcGAsIGBjbG9uZURlZXBXaXRoYCwgYGNsb25lV2l0aGAsIGBjb25mb3Jtc1RvYCwgYGRlYnVycmAsXG4gICAgICogYGRlZmF1bHRUb2AsIGBkaXZpZGVgLCBgZWFjaGAsIGBlYWNoUmlnaHRgLCBgZW5kc1dpdGhgLCBgZXFgLCBgZXNjYXBlYCxcbiAgICAgKiBgZXNjYXBlUmVnRXhwYCwgYGV2ZXJ5YCwgYGZpbmRgLCBgZmluZEluZGV4YCwgYGZpbmRLZXlgLCBgZmluZExhc3RgLFxuICAgICAqIGBmaW5kTGFzdEluZGV4YCwgYGZpbmRMYXN0S2V5YCwgYGZpcnN0YCwgYGZsb29yYCwgYGZvckVhY2hgLCBgZm9yRWFjaFJpZ2h0YCxcbiAgICAgKiBgZm9ySW5gLCBgZm9ySW5SaWdodGAsIGBmb3JPd25gLCBgZm9yT3duUmlnaHRgLCBgZ2V0YCwgYGd0YCwgYGd0ZWAsIGBoYXNgLFxuICAgICAqIGBoYXNJbmAsIGBoZWFkYCwgYGlkZW50aXR5YCwgYGluY2x1ZGVzYCwgYGluZGV4T2ZgLCBgaW5SYW5nZWAsIGBpbnZva2VgLFxuICAgICAqIGBpc0FyZ3VtZW50c2AsIGBpc0FycmF5YCwgYGlzQXJyYXlCdWZmZXJgLCBgaXNBcnJheUxpa2VgLCBgaXNBcnJheUxpa2VPYmplY3RgLFxuICAgICAqIGBpc0Jvb2xlYW5gLCBgaXNCdWZmZXJgLCBgaXNEYXRlYCwgYGlzRWxlbWVudGAsIGBpc0VtcHR5YCwgYGlzRXF1YWxgLFxuICAgICAqIGBpc0VxdWFsV2l0aGAsIGBpc0Vycm9yYCwgYGlzRmluaXRlYCwgYGlzRnVuY3Rpb25gLCBgaXNJbnRlZ2VyYCwgYGlzTGVuZ3RoYCxcbiAgICAgKiBgaXNNYXBgLCBgaXNNYXRjaGAsIGBpc01hdGNoV2l0aGAsIGBpc05hTmAsIGBpc05hdGl2ZWAsIGBpc05pbGAsIGBpc051bGxgLFxuICAgICAqIGBpc051bWJlcmAsIGBpc09iamVjdGAsIGBpc09iamVjdExpa2VgLCBgaXNQbGFpbk9iamVjdGAsIGBpc1JlZ0V4cGAsXG4gICAgICogYGlzU2FmZUludGVnZXJgLCBgaXNTZXRgLCBgaXNTdHJpbmdgLCBgaXNVbmRlZmluZWRgLCBgaXNUeXBlZEFycmF5YCxcbiAgICAgKiBgaXNXZWFrTWFwYCwgYGlzV2Vha1NldGAsIGBqb2luYCwgYGtlYmFiQ2FzZWAsIGBsYXN0YCwgYGxhc3RJbmRleE9mYCxcbiAgICAgKiBgbG93ZXJDYXNlYCwgYGxvd2VyRmlyc3RgLCBgbHRgLCBgbHRlYCwgYG1heGAsIGBtYXhCeWAsIGBtZWFuYCwgYG1lYW5CeWAsXG4gICAgICogYG1pbmAsIGBtaW5CeWAsIGBtdWx0aXBseWAsIGBub0NvbmZsaWN0YCwgYG5vb3BgLCBgbm93YCwgYG50aGAsIGBwYWRgLFxuICAgICAqIGBwYWRFbmRgLCBgcGFkU3RhcnRgLCBgcGFyc2VJbnRgLCBgcG9wYCwgYHJhbmRvbWAsIGByZWR1Y2VgLCBgcmVkdWNlUmlnaHRgLFxuICAgICAqIGByZXBlYXRgLCBgcmVzdWx0YCwgYHJvdW5kYCwgYHJ1bkluQ29udGV4dGAsIGBzYW1wbGVgLCBgc2hpZnRgLCBgc2l6ZWAsXG4gICAgICogYHNuYWtlQ2FzZWAsIGBzb21lYCwgYHNvcnRlZEluZGV4YCwgYHNvcnRlZEluZGV4QnlgLCBgc29ydGVkTGFzdEluZGV4YCxcbiAgICAgKiBgc29ydGVkTGFzdEluZGV4QnlgLCBgc3RhcnRDYXNlYCwgYHN0YXJ0c1dpdGhgLCBgc3R1YkFycmF5YCwgYHN0dWJGYWxzZWAsXG4gICAgICogYHN0dWJPYmplY3RgLCBgc3R1YlN0cmluZ2AsIGBzdHViVHJ1ZWAsIGBzdWJ0cmFjdGAsIGBzdW1gLCBgc3VtQnlgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0aW1lc2AsIGB0b0Zpbml0ZWAsIGB0b0ludGVnZXJgLCBgdG9KU09OYCwgYHRvTGVuZ3RoYCxcbiAgICAgKiBgdG9Mb3dlcmAsIGB0b051bWJlcmAsIGB0b1NhZmVJbnRlZ2VyYCwgYHRvU3RyaW5nYCwgYHRvVXBwZXJgLCBgdHJpbWAsXG4gICAgICogYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYHRydW5jYXRlYCwgYHVuZXNjYXBlYCwgYHVuaXF1ZUlkYCwgYHVwcGVyQ2FzZWAsXG4gICAgICogYHVwcGVyRmlyc3RgLCBgdmFsdWVgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQG5hbWUgX1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyLCAzXSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXR1cm5zIGFuIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiB3cmFwcGVkLnJlZHVjZShfLmFkZCk7XG4gICAgICogLy8gPT4gNlxuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhIHdyYXBwZWQgdmFsdWUuXG4gICAgICogdmFyIHNxdWFyZXMgPSB3cmFwcGVkLm1hcChzcXVhcmUpO1xuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoc3F1YXJlcy52YWx1ZSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMb2Rhc2hXcmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnX193cmFwcGVkX18nKSkge1xuICAgICAgICAgIHJldHVybiB3cmFwcGVyQ2xvbmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAgICAgKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIHdob3NlIHByb3RvdHlwZSBjaGFpbiBzZXF1ZW5jZSB3cmFwcGVycyBpbmhlcml0IGZyb20uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGNvbnN0cnVjdG9yIGZvciBjcmVhdGluZyBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY2hhaW5BbGxdIEVuYWJsZSBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZGFzaFdyYXBwZXIodmFsdWUsIGNoYWluQWxsKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fY2hhaW5fXyA9ICEhY2hhaW5BbGw7XG4gICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICB0aGlzLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAgICAgKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgKi9cbiAgICAgICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgICd2YXJpYWJsZSc6ICcnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICAnaW1wb3J0cyc6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgJ18nOiBsb2Rhc2hcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRW5zdXJlIHdyYXBwZXJzIGFyZSBpbnN0YW5jZXMgb2YgYGJhc2VMb2Rhc2hgLlxuICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbG9kYXNoO1xuXG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvZGFzaFdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGF6eSB3cmFwcGVyIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBsYXp5IGV2YWx1YXRpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGF6eVdyYXBwZXIodmFsdWUpIHtcbiAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX19hY3Rpb25zX18gPSBbXTtcbiAgICAgIHRoaXMuX19kaXJfXyA9IDE7XG4gICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2l0ZXJhdGVlc19fID0gW107XG4gICAgICB0aGlzLl9fdGFrZUNvdW50X18gPSBNQVhfQVJSQVlfTEVOR1RIO1xuICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGxhenkgd3JhcHBlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsb25lXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlDbG9uZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19kaXJfXyA9IHRoaXMuX19kaXJfXztcbiAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fID0gY29weUFycmF5KHRoaXMuX19pdGVyYXRlZXNfXyk7XG4gICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IHRoaXMuX190YWtlQ291bnRfXztcbiAgICAgIHJlc3VsdC5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyB0aGUgZGlyZWN0aW9uIG9mIGxhenkgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHJldmVyc2VkIGBMYXp5V3JhcHBlcmAgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgaWYgKHRoaXMuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIHJlc3VsdC5fX2Rpcl9fID0gLTE7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIHVud3JhcHBlZCB2YWx1ZSBmcm9tIGl0cyBsYXp5IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIExhenlXcmFwcGVyXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5VmFsdWUoKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLl9fd3JhcHBlZF9fLnZhbHVlKCksXG4gICAgICAgICAgZGlyID0gdGhpcy5fX2Rpcl9fLFxuICAgICAgICAgIGlzQXJyID0gaXNBcnJheShhcnJheSksXG4gICAgICAgICAgaXNSaWdodCA9IGRpciA8IDAsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICAgIHZpZXcgPSBnZXRWaWV3KDAsIGFyckxlbmd0aCwgdGhpcy5fX3ZpZXdzX18pLFxuICAgICAgICAgIHN0YXJ0ID0gdmlldy5zdGFydCxcbiAgICAgICAgICBlbmQgPSB2aWV3LmVuZCxcbiAgICAgICAgICBsZW5ndGggPSBlbmQgLSBzdGFydCxcbiAgICAgICAgICBpbmRleCA9IGlzUmlnaHQgPyBlbmQgOiAoc3RhcnQgLSAxKSxcbiAgICAgICAgICBpdGVyYXRlZXMgPSB0aGlzLl9faXRlcmF0ZWVzX18sXG4gICAgICAgICAgaXRlckxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHRha2VDb3VudCA9IG5hdGl2ZU1pbihsZW5ndGgsIHRoaXMuX190YWtlQ291bnRfXyk7XG5cbiAgICAgIGlmICghaXNBcnIgfHwgKCFpc1JpZ2h0ICYmIGFyckxlbmd0aCA9PSBsZW5ndGggJiYgdGFrZUNvdW50ID09IGxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUoYXJyYXksIHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlIChsZW5ndGgtLSAmJiByZXNJbmRleCA8IHRha2VDb3VudCkge1xuICAgICAgICBpbmRleCArPSBkaXI7XG5cbiAgICAgICAgdmFyIGl0ZXJJbmRleCA9IC0xLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cbiAgICAgICAgd2hpbGUgKCsraXRlckluZGV4IDwgaXRlckxlbmd0aCkge1xuICAgICAgICAgIHZhciBkYXRhID0gaXRlcmF0ZWVzW2l0ZXJJbmRleF0sXG4gICAgICAgICAgICAgIGl0ZXJhdGVlID0gZGF0YS5pdGVyYXRlZSxcbiAgICAgICAgICAgICAgdHlwZSA9IGRhdGEudHlwZSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX01BUF9GTEFHKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXB1dGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYExhenlXcmFwcGVyYCBpcyBhbiBpbnN0YW5jZSBvZiBgYmFzZUxvZGFzaGAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF6eVdyYXBwZXI7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIEhhc2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gICAgICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgICBIYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbiAgICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuICAgIEhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG4gICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICBIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIGRhdGEucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICAtLXRoaXMuc2l6ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG4gICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgc2V0XG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBhZGRcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAYWxpYXMgcHVzaFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuICAgIFNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuICAgIFNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbGVhclxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBkZWxldGVcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cbiAgICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuICAgIFN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcbiAgICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG4gICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgIFN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICAgICApKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGUoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbYmFzZVJhbmRvbSgwLCBsZW5ndGggLSAxKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNhbXBsZVNpemVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTYW1wbGVTaXplKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICAgICAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAgICAgKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAgICAgKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAgICogdmFsdWUgY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWwgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUF0KG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIHNraXAgPSBvYmplY3QgPT0gbnVsbDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQgOiBnZXQob2JqZWN0LCBwYXRoc1tpbmRleF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbGFtcGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAobnVtYmVyID09PSBudW1iZXIpIHtcbiAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAgICAgKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gRGVlcCBjbG9uZVxuICAgICAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICAgICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICAgICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgfVxuICAgICAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gICAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9LCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAgICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm50aGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbiArPSBuIDwgMCA/IGxlbmd0aCA6IDA7XG4gICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICAgIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShpdGVyYXRlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gYmFzZUdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaWRlbnRpdHldO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICB2YXIgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgICAgIG90aEluZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBiYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXG4gICAgICogcmVwbGFjZW1lbnQgcGx1Z2lucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BjbGVhclRpbWVvdXRgXShodHRwczovL21kbi5pby9jbGVhclRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IGlkIFRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdCBvZiB0aGUgdGltZXIgdG8gY2xlYXIuXG4gICAgICovXG4gICAgdmFyIGNsZWFyVGltZW91dCA9IGN0eENsZWFyVGltZW91dCB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICAgICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICAgKlxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gICAgICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICAgICAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgICAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcml0eSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlcik7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgIGZ1bmNzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gaW5kZXggOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmXG4gICAgICAgICAgICAgICAgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgICAgID8gd3JhcHBlcltmdW5jTmFtZV0oKVxuICAgICAgICAgICAgICA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAgICAgKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uaW52ZXJ0QnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdG9JdGVyYXRlZSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52ZXJ0ZXIoc2V0dGVyLCB0b0l0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCB0b0l0ZXJhdGVlKGl0ZXJhdGVlKSwge30pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb1N0cmluZyhvdGhlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5vdmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG92ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT3ZlcihhcnJheUZ1bmMpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AgYmFzZWQgb24gYGxlbmd0aGAuIFRoZSBgY2hhcnNgIHN0cmluZ1xuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgY2hhcnMgPSBjaGFycyA9PT0gdW5kZWZpbmVkID8gJyAnIDogYmFzZVRvU3RyaW5nKGNoYXJzKTtcblxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgaWYgKGNoYXJzTGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChsZW5ndGggLyBzdHJpbmdTaXplKGNoYXJzKSkpO1xuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIG90aGVyID0gdG9OdW1iZXIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gY29udGludWUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAgICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgICAgICBuZXdIb2xkZXJzID0gaXNDdXJyeSA/IGhvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXG4gICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBwYXJ0aWFscztcblxuICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICAgICAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xuICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyclN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBhcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBvYmpTdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICAgIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAgICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0RGF0YSA9ICFtZXRhTWFwID8gbm9vcCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmFtZSBvZiBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IChmdW5jLm5hbWUgKyAnJyksXG4gICAgICAgICAgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0XSxcbiAgICAgICAgICBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlYWxOYW1lcywgcmVzdWx0KSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sXG4gICAgICAgICAgICBvdGhlckZ1bmMgPSBkYXRhLmZ1bmM7XG4gICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgIHJldHVybiBkYXRhLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXJndW1lbnQgcGxhY2Vob2xkZXIgdmFsdWUgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKGZ1bmMpIHtcbiAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgJ3BsYWNlaG9sZGVyJykgPyBsb2Rhc2ggOiBmdW5jO1xuICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcHByb3ByaWF0ZSBcIml0ZXJhdGVlXCIgZnVuY3Rpb24uIElmIGBfLml0ZXJhdGVlYCBpcyBjdXN0b21pemVkLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgY3VzdG9tIG1ldGhvZCwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGJhc2VJdGVyYXRlZWAuXG4gICAgICogSWYgYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgdGhlIGNob3NlbiBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGggdGhlbSBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIHRoZSBjcmVhdGVkIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2hvc2VuIGZ1bmN0aW9uIG9yIGl0cyByZXN1bHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoLml0ZXJhdGVlIHx8IGl0ZXJhdGVlO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSBpdGVyYXRlZSA/IGJhc2VJdGVyYXRlZSA6IHJlc3VsdDtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICAgICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAgICAgKi9cbiAgICB2YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbiAgICAvLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG4gICAgaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgICAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAgICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgICAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmlldywgYXBwbHlpbmcgYW55IGB0cmFuc2Zvcm1zYCB0byB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9zaXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm1zIFRoZSB0cmFuc2Zvcm1hdGlvbnMgdG8gYXBwbHkgdG8gdGhlIHZpZXcuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYHN0YXJ0YCBhbmQgYGVuZGBcbiAgICAgKiAgcG9zaXRpb25zIG9mIHRoZSB2aWV3LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdHJhbnNmb3Jtc1tpbmRleF0sXG4gICAgICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnZHJvcCc6ICAgICAgc3RhcnQgKz0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZHJvcFJpZ2h0JzogZW5kIC09IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2UnOiAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZSk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Rha2VSaWdodCc6IHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0LCBlbmQgLSBzaXplKTsgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7ICdzdGFydCc6IHN0YXJ0LCAnZW5kJzogZW5kIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgd3JhcHBlciBkZXRhaWxzIGZyb20gdGhlIGBzb3VyY2VgIGJvZHkgY29tbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3cmFwcGVyIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2gocmVXcmFwRGV0YWlscyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChyZVNwbGl0RGV0YWlscykgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICAgICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIHdyYXBwZXIgYGRldGFpbHNgIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBgc291cmNlYCBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBpbnNlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc291cmNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgZGV0YWlscykge1xuICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgZGV0YWlsc1tsYXN0SW5kZXhdID0gKGxlbmd0aCA+IDEgPyAnJiAnIDogJycpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgZGV0YWlscyA9IGRldGFpbHMuam9pbihsZW5ndGggPiAyID8gJywgJyA6ICcgJyk7XG4gICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgJ3tcXG4vKiBbd3JhcHBlZCB3aXRoICcgKyBkZXRhaWxzICsgJ10gKi9cXG4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgICAgICkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgIG90aGVyID0gbG9kYXNoW2Z1bmNOYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZiBvdGhlciAhPSAnZnVuY3Rpb24nIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgcmV0dXJuICEhZGF0YSAmJiBmdW5jID09PSBkYXRhWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBpcyBjYXBhYmxlIG9mIGJlaW5nIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIHZhciBpc01hc2thYmxlID0gY29yZUpzRGF0YSA/IGlzRnVuY3Rpb24gOiBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAgICAgKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAgICAgKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgdGhlIGZ1bmN0aW9uIG1ldGFkYXRhIG9mIGBzb3VyY2VgIGludG8gYGRhdGFgLlxuICAgICAqXG4gICAgICogTWVyZ2luZyBtZXRhZGF0YSByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygd3JhcHBlcnMgdXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbi5cbiAgICAgKiBUaGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgbWV0aG9kcyBsaWtlIGBfLmJpbmRgLCBgXy5jdXJyeWAsIGFuZCBgXy5wYXJ0aWFsYFxuICAgICAqIG1heSBiZSBhcHBsaWVkIHJlZ2FyZGxlc3Mgb2YgZXhlY3V0aW9uIG9yZGVyLiBNZXRob2RzIGxpa2UgYF8uYXJ5YCBhbmRcbiAgICAgKiBgXy5yZWFyZ2AgbW9kaWZ5IGZ1bmN0aW9uIGFyZ3VtZW50cywgbWFraW5nIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFyZVxuICAgICAqIGV4ZWN1dGVkIGltcG9ydGFudCwgcHJldmVudGluZyB0aGUgbWVyZ2luZyBvZiBtZXRhZGF0YS4gSG93ZXZlciwgd2UgbWFrZVxuICAgICAqIGFuIGV4Y2VwdGlvbiBmb3IgYSBzYWZlIGNvbWJpbmVkIGNhc2Ugd2hlcmUgY3VycmllZCBmdW5jdGlvbnMgaGF2ZSBgXy5hcnlgXG4gICAgICogYW5kIG9yIGBfLnJlYXJnYCBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIFRoZSBkZXN0aW5hdGlvbiBtZXRhZGF0YS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIHNvdXJjZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRhdGFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGF0YShkYXRhLCBzb3VyY2UpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSxcbiAgICAgICAgICBzcmNCaXRtYXNrID0gc291cmNlWzFdLFxuICAgICAgICAgIG5ld0JpdG1hc2sgPSBiaXRtYXNrIHwgc3JjQml0bWFzayxcbiAgICAgICAgICBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcblxuICAgICAgdmFyIGlzQ29tYm8gPVxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfUkVBUkdfRkxBRykgJiYgKGRhdGFbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfUkVBUkdfRkxBRykpICYmIChzb3VyY2VbN10ubGVuZ3RoIDw9IHNvdXJjZVs4XSkgJiYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHKSk7XG5cbiAgICAgIC8vIEV4aXQgZWFybHkgaWYgbWV0YWRhdGEgY2FuJ3QgYmUgbWVyZ2VkLlxuICAgICAgaWYgKCEoaXNDb21tb24gfHwgaXNDb21ibykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGB0aGlzQXJnYCBpZiBhdmFpbGFibGUuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIGRhdGFbMl0gPSBzb3VyY2VbMl07XG4gICAgICAgIC8vIFNldCB3aGVuIGN1cnJ5aW5nIGEgYm91bmQgZnVuY3Rpb24uXG4gICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCBhcmd1bWVudHMuXG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbM107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgZGF0YVszXSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3MocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNF0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNF0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbM10sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs0XTtcbiAgICAgIH1cbiAgICAgIC8vIENvbXBvc2UgcGFydGlhbCByaWdodCBhcmd1bWVudHMuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBwYXJ0aWFscyA9IGRhdGFbNV07XG4gICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgIGRhdGFbNl0gPSBwYXJ0aWFscyA/IHJlcGxhY2VIb2xkZXJzKGRhdGFbNV0sIFBMQUNFSE9MREVSKSA6IHNvdXJjZVs2XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyZ1Bvc2AgaWYgYXZhaWxhYmxlLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbN107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJ5YCBpZiBpdCdzIHNtYWxsZXIuXG4gICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgZGF0YVs4XSA9IGRhdGFbOF0gPT0gbnVsbCA/IHNvdXJjZVs4XSA6IG5hdGl2ZU1pbihkYXRhWzhdLCBzb3VyY2VbOF0pO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJpdHlgIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG4gICAgICBpZiAoZGF0YVs5XSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGFbOV0gPSBzb3VyY2VbOV07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBmdW5jYCBhbmQgbWVyZ2UgYml0bWFza3MuXG4gICAgICBkYXRhWzBdID0gc291cmNlWzBdO1xuICAgICAgZGF0YVsxXSA9IG5ld0JpdG1hc2s7XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICAgICAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gICAgICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVvcmRlciBgYXJyYXlgIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGluZGV4ZXMgd2hlcmUgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgZmlyc3QgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIHNlY29uZCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgc2Vjb25kIGVsZW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHJlb3JkZXIuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJyYXkgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW9yZGVyKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihpbmRleGVzLmxlbmd0aCwgYXJyTGVuZ3RoKSxcbiAgICAgICAgICBvbGRBcnJheSA9IGNvcHlBcnJheShhcnJheSk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB0aGlzIGZ1bmN0aW9uIGJlY29tZXMgaG90LCBpLmUuIGlzIGludm9rZWQgYSBsb3QgaW4gYSBzaG9ydFxuICAgICAqIHBlcmlvZCBvZiB0aW1lLCBpdCB3aWxsIHRyaXAgaXRzIGJyZWFrZXIgYW5kIHRyYW5zaXRpb24gdG8gYW4gaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbiB0byBhdm9pZCBnYXJiYWdlIGNvbGxlY3Rpb24gcGF1c2VzIGluIFY4LiBTZWVcbiAgICAgKiBbVjggaXNzdWUgMjA3MF0oaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjA3MClcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldERhdGEgPSBzaG9ydE91dChiYXNlU2V0RGF0YSk7XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgc2V0VGltZW91dGBdKGh0dHBzOi8vbWRuLmlvL3NldFRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VGltZW91dCA9IGN0eFNldFRpbWVvdXQgfHwgZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgICAgcmV0dXJuIHJvb3Quc2V0VGltZW91dChmdW5jLCB3YWl0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYHdyYXBwZXJgIHRvIG1pbWljIHRoZSBzb3VyY2Ugb2YgYHJlZmVyZW5jZWBcbiAgICAgKiB3aXRoIHdyYXBwZXIgZGV0YWlscyBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgc291cmNlIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHdyYXBwZXIgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgd3JhcHBlcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V3JhcFRvU3RyaW5nKHdyYXBwZXIsIHJlZmVyZW5jZSwgYml0bWFzaykge1xuICAgICAgdmFyIHNvdXJjZSA9IChyZWZlcmVuY2UgKyAnJyk7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcod3JhcHBlciwgaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCB1cGRhdGVXcmFwRGV0YWlscyhnZXRXcmFwRGV0YWlscyhzb3VyY2UpLCBiaXRtYXNrKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICAgICAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICAgICAqIG1pbGxpc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgICAgIHZhciBjb3VudCA9IDAsXG4gICAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgICAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICovXG4gICAgdmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgICAgfVxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgd3JhcHBlciBgZGV0YWlsc2AgYmFzZWQgb24gYGJpdG1hc2tgIGZsYWdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkZXRhaWxzYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXcmFwRGV0YWlscyhkZXRhaWxzLCBiaXRtYXNrKSB7XG4gICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICdfLicgKyBwYWlyWzBdO1xuICAgICAgICBpZiAoKGJpdG1hc2sgJiBwYWlyWzFdKSAmJiAhYXJyYXlJbmNsdWRlcyhkZXRhaWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHdyYXBwZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gd3JhcHBlciBUaGUgd3JhcHBlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgd3JhcHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgaWYgKHdyYXBwZXIgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gd3JhcHBlci5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZXIuX193cmFwcGVkX18sIHdyYXBwZXIuX19jaGFpbl9fKTtcbiAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh3cmFwcGVyLl9fYWN0aW9uc19fKTtcbiAgICAgIHJlc3VsdC5fX2luZGV4X18gID0gd3JhcHBlci5fX2luZGV4X187XG4gICAgICByZXN1bHQuX192YWx1ZXNfXyA9IHdyYXBwZXIuX192YWx1ZXNfXztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIGdyb3VwcyB0aGUgbGVuZ3RoIG9mIGBzaXplYC5cbiAgICAgKiBJZiBgYXJyYXlgIGNhbid0IGJlIHNwbGl0IGV2ZW5seSwgdGhlIGZpbmFsIGNodW5rIHdpbGwgYmUgdGhlIHJlbWFpbmluZ1xuICAgICAqIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTFdIFRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY2h1bmtzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAyKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWydjJywgJ2QnXV1cbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDMpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYicsICdjJ10sIFsnZCddXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNodW5rKGFycmF5LCBzaXplLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplLCBndWFyZCkgOiBzaXplID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IG5hdGl2ZU1heCh0b0ludGVnZXIoc2l6ZSksIDApO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc2l6ZSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobmF0aXZlQ2VpbChsZW5ndGggLyBzaXplKSk7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCAoaW5kZXggKz0gc2l6ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gICAgICogYDBgLCBgXCJcImAsIGB1bmRlZmluZWRgLCBhbmQgYE5hTmAgYXJlIGZhbHNleS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhcnJheSBjb25jYXRlbmF0aW5nIGBhcnJheWAgd2l0aCBhbnkgYWRkaXRpb25hbCBhcnJheXNcbiAgICAgKiBhbmQvb3IgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBjb25jYXRlbmF0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNvbmNhdChhcnJheSwgMiwgWzNdLCBbWzRdXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvdGhlcik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoIC0gMSksXG4gICAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF0sXG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGFyZ3NbaW5kZXggLSAxXSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlQdXNoKGlzQXJyYXkoYXJyYXkpID8gY29weUFycmF5KGFycmF5KSA6IFthcnJheV0sIGJhc2VGbGF0dGVuKGFyZ3MsIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsQnlgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sIFt7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZUJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIG9yZGVyIGFuZFxuICAgICAqIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxXaXRoYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8uZGlmZmVyZW5jZVdpdGgob2JqZWN0cywgW3sgJ3gnOiAxLCAneSc6IDIgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZVdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChjb21wYXJhdG9yKSkge1xuICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsbHMgZWxlbWVudHMgb2YgYGFycmF5YCB3aXRoIGB2YWx1ZWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90XG4gICAgICogaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8uZmlsbChhcnJheSwgJ2EnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2EnLCAnYSddXG4gICAgICpcbiAgICAgKiBfLmZpbGwoQXJyYXkoMyksIDIpO1xuICAgICAqIC8vID0+IFsyLCAyLCAyXVxuICAgICAqXG4gICAgICogXy5maWxsKFs0LCA2LCA4LCAxMF0sICcqJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzQsICcqJywgJyonLCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgdmFsdWUsIHN0YXJ0KSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRJbmRleGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50c1xuICAgICAqIG9mIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAncGViYmxlcyc7IH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggPCAwXG4gICAgICAgICAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApXG4gICAgICAgICAgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbnMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVlcChbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0LCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIElORklOSVRZKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYGFycmF5YCB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgWzIsIFszLCBbNF1dLCA1XV07XG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy50b1BhaXJzYDsgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWRcbiAgICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgIHJlc3VsdFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBmaXJzdFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmhlYWQoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgaW4gYGFycmF5YFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICAgICAqIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbml0aWFsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMCwgLTEpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb24oWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsyXVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5pbnRlcnNlY3Rpb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBpZiAoaXRlcmF0ZWUgPT09IGxhc3QobWFwcGVkKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXNcbiAgICAgKiBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIG1hcHBlZC5wb3AoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYWxsIGVsZW1lbnRzIGluIGBhcnJheWAgaW50byBhIHN0cmluZyBzZXBhcmF0ZWQgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NlcGFyYXRvcj0nLCddIFRoZSBlbGVtZW50IHNlcGFyYXRvci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBqb2luZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmpvaW4oWydhJywgJ2InLCAnYyddLCAnficpO1xuICAgICAqIC8vID0+ICdhfmJ+YydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBqb2luKGFycmF5LCBzZXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gJycgOiBuYXRpdmVKb2luLmNhbGwoYXJyYXksIHNlcGFyYXRvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBhcnJheWAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICAgID8gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleClcbiAgICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGluZGV4LCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbGVtZW50IGF0IGluZGV4IGBuYCBvZiBgYXJyYXlgLiBJZiBgbmAgaXMgbmVnYXRpdmUsIHRoZSBudGhcbiAgICAgKiBlbGVtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjExLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogXy5udGgoYXJyYXksIC0yKTtcbiAgICAgKiAvLyA9PiAnYyc7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoKGFycmF5LCBuKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGdpdmVuIHZhbHVlcyBmcm9tIGBhcnJheWAgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ud2l0aG91dGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnJlbW92ZWBcbiAgICAgKiB0byByZW1vdmUgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSBwcmVkaWNhdGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbChhcnJheSwgJ2EnLCAnYycpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgdmFyIHB1bGwgPSBiYXNlUmVzdChwdWxsQWxsKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnYScsICdiJywgJ2MnXTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbChhcnJheSwgWydhJywgJ2MnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCBhbmQgYHZhbHVlc2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlQnlgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMyB9LCB7ICd4JzogMSB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbEJ5KGFycmF5LCBbeyAneCc6IDEgfSwgeyAneCc6IDMgfV0sICd4Jyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxCeShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YCB0byBgdmFsdWVzYC4gVGhlIGNvbXBhcmF0b3IgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZVdpdGhgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDMsICd5JzogNCB9LCB7ICd4JzogNSwgJ3knOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsV2l0aChhcnJheSwgW3sgJ3gnOiAzLCAneSc6IDQgfV0sIF8uaXNFcXVhbCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiA1LCAneSc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzLCBjb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGBhcnJheWAgY29ycmVzcG9uZGluZyB0byBgaW5kZXhlc2AgYW5kIHJldHVybnMgYW5cbiAgICAgKiBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5hdGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gW2luZGV4ZXNdIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKiB2YXIgcHVsbGVkID0gXy5wdWxsQXQoYXJyYXksIFsxLCAzXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydhJywgJ2MnXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cocHVsbGVkKTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnZCddXG4gICAgICovXG4gICAgdmFyIHB1bGxBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYmFzZUF0KGFycmF5LCBpbmRleGVzKTtcblxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5kZXgoaW5kZXgsIGxlbmd0aCkgPyAraW5kZXggOiBpbmRleDtcbiAgICAgIH0pLnNvcnQoY29tcGFyZUFzY2VuZGluZykpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gICAgICogdG8gcHVsbCBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHZhbHVlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICAgICAqIHZhciBldmVucyA9IF8ucmVtb3ZlKGFycmF5LCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAgICAgKiAvLyA9PiBbMiwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgYGFycmF5YCBzbyB0aGF0IHRoZSBmaXJzdCBlbGVtZW50IGJlY29tZXMgdGhlIGxhc3QsIHRoZSBzZWNvbmRcbiAgICAgKiBlbGVtZW50IGJlY29tZXMgdGhlIHNlY29uZCB0byBsYXN0LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgIGFuZCBpcyBiYXNlZCBvblxuICAgICAqIFtgQXJyYXkjcmV2ZXJzZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3JldmVyc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5yZXZlcnNlKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXZlcnNlKGFycmF5KSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGluc3RlYWQgb2ZcbiAgICAgKiBbYEFycmF5I3NsaWNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvc2xpY2UpIHRvIGVuc3VyZSBkZW5zZSBhcnJheXMgYXJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAmJiB0eXBlb2YgZW5kICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzdGFydCwgZW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSB0aGUgbG93ZXN0IGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleChbMzAsIDUwXSwgNDApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkSW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGhpZ2hlc3RcbiAgICAgKiBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG9cbiAgICAgKiBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4KFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gNFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleChhcnJheSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZExhc3RJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCAneCcpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubGFzdEluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4T2YoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgaWYgKGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXEoWzEsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFCeWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZFVuaXFCeShbMS4xLCAxLjIsIDIuMywgMi40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMSwgMi4zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRhaWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWlsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAxLCBsZW5ndGgpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZShhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGVuZC4gRWxlbWVudHMgYXJlXG4gICAgICogdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGZhbHNlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgYmVnaW5uaW5nLiBFbGVtZW50c1xuICAgICAqIGFyZSB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb20gdGhlIGZpcnN0XG4gICAgICogYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaW9uQnkoWzIuMV0sIFsxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pb25CeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbVxuICAgICAqIHRoZSBmaXJzdCBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlvbldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaCBlbGVtZW50XG4gICAgICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICAgICAqIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXEoWzIsIDEsIDJdKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICAgICAqIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXFCeShbMi4xLCAxLjIsIDIuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjEsIDEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5YC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS5UaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy51bmlxV2l0aChvYmplY3RzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxV2l0aChhcnJheSwgY29tcGFyYXRvcikge1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIHVuZGVmaW5lZCwgY29tcGFyYXRvcikgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhbiBhcnJheSBvZiBncm91cGVkXG4gICAgICogZWxlbWVudHMgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgcmVncm91cGluZyB0aGUgZWxlbWVudHMgdG8gdGhlaXIgcHJlLXppcFxuICAgICAqIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwKHppcHBlZCk7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgIGFycmF5ID0gYXJyYXlGaWx0ZXIoYXJyYXksIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoZ3JvdXAubGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBiYXNlVGltZXMobGVuZ3RoLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgcmVncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIHJlZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSk7XG4gICAgICogLy8gPT4gW1sxLCAxMCwgMTAwXSwgWzIsIDIwLCAyMDBdXVxuICAgICAqXG4gICAgICogXy51bnppcFdpdGgoemlwcGVkLCBfLmFkZCk7XG4gICAgICogLy8gPT4gWzMsIDMwLCAzMDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXBXaXRoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdW56aXAoYXJyYXkpO1xuICAgICAgaWYgKGl0ZXJhdGVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheU1hcChyZXN1bHQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdW5kZWZpbmVkLCBncm91cCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGV4Y2x1ZGluZyBhbGwgZ2l2ZW4gdmFsdWVzIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKi9cbiAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gICAgICogW3N5bW1ldHJpYyBkaWZmZXJlbmNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TeW1tZXRyaWNfZGlmZmVyZW5jZSlcbiAgICAgKiBvZiB0aGUgZ2l2ZW4gYXJyYXlzLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlclxuICAgICAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ud2l0aG91dFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvcihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICovXG4gICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkXG4gICAgICogYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmVcbiAgICAgKiBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnhvckJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjIsIDMuNF1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ueG9yQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHhvckJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgY29tcGFyYXRvciBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy54b3JXaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHhvcldpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpO1xuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMsIHRoZSBmaXJzdCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBmaXJzdCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCB0aGUgc2Vjb25kIG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIHNlY29uZCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXlzLCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKi9cbiAgICB2YXIgemlwID0gYmFzZVJlc3QodW56aXApO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAgICAgKiBvbmUgb2YgcHJvcGVydHkgaWRlbnRpZmllcnMgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYXNzaWduVmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwT2JqZWN0YCBleGNlcHQgdGhhdCBpdCBzdXBwb3J0cyBwcm9wZXJ0eSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wcz1bXV0gVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBPYmplY3REZWVwKFsnYS5iWzBdLmMnLCAnYS5iWzFdLmQnXSwgWzEsIDJdKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IFt7ICdjJzogMSB9LCB7ICdkJzogMiB9XSB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB6aXBPYmplY3REZWVwKHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGJhc2VTZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyBncm91cGVkIHZhbHVlcyBzaG91bGQgYmUgY29tYmluZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhlXG4gICAgICogZWxlbWVudHMgb2YgZWFjaCBncm91cDogKC4uLmdyb3VwKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgZ3JvdXBlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy56aXBXaXRoKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0sIGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBhICsgYiArIGM7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gWzExMSwgMjIyXVxuICAgICAqL1xuICAgIHZhciB6aXBXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBpdGVyYXRlZSA9IGxlbmd0aCA+IDEgPyBhcnJheXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGl0ZXJhdGVlID0gdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgPyAoYXJyYXlzLnBvcCgpLCBpdGVyYXRlZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdW56aXBXaXRoKGFycmF5cywgaXRlcmF0ZWUpO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCB3cmFwcyBgdmFsdWVgIHdpdGggZXhwbGljaXQgbWV0aG9kXG4gICAgICogY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuIFRoZSByZXN1bHQgb2Ygc3VjaCBzZXF1ZW5jZXMgbXVzdCBiZSB1bndyYXBwZWRcbiAgICAgKiB3aXRoIGBfI3ZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiB2YXIgeW91bmdlc3QgPSBfXG4gICAgICogICAuY2hhaW4odXNlcnMpXG4gICAgICogICAuc29ydEJ5KCdhZ2UnKVxuICAgICAqICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICogICAgIHJldHVybiBvLnVzZXIgKyAnIGlzICcgKyBvLmFnZTtcbiAgICAgKiAgIH0pXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcyBpcyAxJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYWluKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoKHZhbHVlKTtcbiAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIGBpbnRlcmNlcHRvcmAgYW5kIHJldHVybnMgYHZhbHVlYC4gVGhlIGludGVyY2VwdG9yXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG9cbiAgICAgKiBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UgaW4gb3JkZXIgdG8gbW9kaWZ5IGludGVybWVkaWF0ZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKVxuICAgICAqICAudGFwKGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICogICAgLy8gTXV0YXRlIGlucHV0IGFycmF5LlxuICAgICAqICAgIGFycmF5LnBvcCgpO1xuICAgICAqICB9KVxuICAgICAqICAucmV2ZXJzZSgpXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnRhcGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJwYXNzIHRocnVcIiB2YWx1ZXMgcmVwbGFjaW5nIGludGVybWVkaWF0ZVxuICAgICAqIHJlc3VsdHMgaW4gYSBtZXRob2QgY2hhaW4gc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKCcgIGFiYyAgJylcbiAgICAgKiAgLmNoYWluKClcbiAgICAgKiAgLnRyaW0oKVxuICAgICAqICAudGhydShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAqICB9KVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhydSh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgIHJldHVybiBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5hdGAuXG4gICAgICpcbiAgICAgKiBAbmFtZSBhdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfKG9iamVjdCkuYXQoWydhWzBdLmIuYycsICdhWzFdJ10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIHdyYXBwZXJBdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gbGVuZ3RoID8gcGF0aHNbMF0gOiAwLFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkgeyByZXR1cm4gYmFzZUF0KG9iamVjdCwgcGF0aHMpOyB9O1xuXG4gICAgICBpZiAobGVuZ3RoID4gMSB8fCB0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCB8fFxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICB2YWx1ZS5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAnYXJncyc6IFtpbnRlcmNlcHRvcl0sXG4gICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSwgdGhpcy5fX2NoYWluX18pLnRocnUoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAmJiAhYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2Ugd2l0aCBleHBsaWNpdCBtZXRob2QgY2hhaW4gc2VxdWVuY2VzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjaGFpblxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGhvdXQgZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycykuaGVhZCgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKVxuICAgICAqICAgLmNoYWluKClcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC5waWNrKCd1c2VyJylcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNoYWluKCkge1xuICAgICAgcmV0dXJuIGNoYWluKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSBhbmQgcmV0dXJucyB0aGUgd3JhcHBlZCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBAbmFtZSBjb21taXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDJdO1xuICAgICAqIHZhciB3cmFwcGVkID0gXyhhcnJheSkucHVzaCgzKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQgPSB3cmFwcGVkLmNvbW1pdCgpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubGFzdCgpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ29tbWl0KCkge1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHRoaXMudmFsdWUoKSwgdGhpcy5fX2NoYWluX18pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5leHQgdmFsdWUgb24gYSB3cmFwcGVkIG9iamVjdCBmb2xsb3dpbmcgdGhlXG4gICAgICogW2l0ZXJhdG9yIHByb3RvY29sXShodHRwczovL21kbi5pby9pdGVyYXRpb25fcHJvdG9jb2xzI2l0ZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBuYW1lIG5leHRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXh0IGl0ZXJhdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMSB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDIgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IHRydWUsICd2YWx1ZSc6IHVuZGVmaW5lZCB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICBpZiAodGhpcy5fX3ZhbHVlc19fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIGRvbmUgPSB0aGlzLl9faW5kZXhfXyA+PSB0aGlzLl9fdmFsdWVzX18ubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZCA6IHRoaXMuX192YWx1ZXNfX1t0aGlzLl9faW5kZXhfXysrXTtcblxuICAgICAgcmV0dXJuIHsgJ2RvbmUnOiBkb25lLCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdyYXBwZXIgdG8gYmUgaXRlcmFibGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBTeW1ib2wuaXRlcmF0b3JcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKSA9PT0gd3JhcHBlZDtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBBcnJheS5mcm9tKHdyYXBwZWQpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJUb0l0ZXJhdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBjaGFpbiBzZXF1ZW5jZSBwbGFudGluZyBgdmFsdWVgIGFzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgcGxhbnRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwbGFudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKS5tYXAoc3F1YXJlKTtcbiAgICAgKiB2YXIgb3RoZXIgPSB3cmFwcGVkLnBsYW50KFszLCA0XSk7XG4gICAgICpcbiAgICAgKiBvdGhlci52YWx1ZSgpO1xuICAgICAqIC8vID0+IFs5LCAxNl1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgNF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKHBhcmVudCBpbnN0YW5jZW9mIGJhc2VMb2Rhc2gpIHtcbiAgICAgICAgdmFyIGNsb25lID0gd3JhcHBlckNsb25lKHBhcmVudCk7XG4gICAgICAgIGNsb25lLl9faW5kZXhfXyA9IDA7XG4gICAgICAgIGNsb25lLl9fdmFsdWVzX18gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGNsb25lO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91cyA9IGNsb25lO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX193cmFwcGVkX187XG4gICAgICB9XG4gICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLnJldmVyc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIHdyYXBwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAbmFtZSByZXZlcnNlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8oYXJyYXkpLnJldmVyc2UoKS52YWx1ZSgpXG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclJldmVyc2UoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgd3JhcHBlZCA9IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgIHdyYXBwZWQuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgJ2Z1bmMnOiB0aHJ1LFxuICAgICAgICAgICdhcmdzJzogW3JldmVyc2VdLFxuICAgICAgICAgICd0aGlzQXJnJzogdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlZCwgdGhpcy5fX2NoYWluX18pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgdmFsdWVcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyB0b0pTT04sIHZhbHVlT2ZcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclZhbHVlKCkge1xuICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUga2V5IHdhcyByZXR1cm5lZCBieSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvdW50QnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogMSwgJzYnOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uY291bnRCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiAyLCAnNSc6IDEgfVxuICAgICAqL1xuICAgIHZhciBjb3VudEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICArK3Jlc3VsdFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBbZW1wdHkgY29sbGVjdGlvbnNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VtcHR5X3NldCkgYmVjYXVzZVxuICAgICAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gICAgICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUV2ZXJ5IDogYmFzZUV2ZXJ5O1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5yZWplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBDb21iaW5pbmcgc2V2ZXJhbCBwcmVkaWNhdGVzIHVzaW5nIGBfLm92ZXJFdmVyeWAgb3IgYF8ub3ZlclNvbWVgLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFt7ICdhZ2UnOiAzNiB9LCBbJ2FnZScsIDQwXV0pKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnLCAnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDMwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDMwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICAgICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xuICAgICAqIGFyZSBhc3NpZ25lZCB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID09IG51bGwgPyByZXN1bHQgOiBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvclJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2InIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgdGhlbiAnYicuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gYW5kIGluaGVyaXRlZFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICAgICAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG90aGVyLCAnYScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGVcbiAgICAgKiBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxuICAgICAqIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGludmVydGVkIHZhbHVlIG9mIGVhY2ggaW52ZXJ0ZWQga2V5IGlzIGFuIGFycmF5IG9mIGtleXNcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdncm91cDEnOiBbJ2EnLCAnYyddLCAnZ3JvdXAyJzogWydiJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRCeSA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgIH1cbiAgICB9LCBnZXRJdGVyYXRlZSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKG9iamVjdCwgJ2FbMF0uYi5jLnNsaWNlJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IGJhc2VSZXN0KGJhc2VJbnZva2UpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwVmFsdWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gICAgICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAgICAgKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9KTtcbiAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgbG9vcCBpcyBlbnRlcmVkIHdoZW4gcGF0aCBpcyBlbXB0eS5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8uc2V0V2l0aChvYmplY3QsICdbMF1bMV0nLCAnYScsIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICAgICAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xuICAgICAqIGZvciBgb2JqZWN0YCB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXBcbiAgICAgKiBvciBzZXQsIGl0cyBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzSW5cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IGNyZWF0ZVRvUGFpcnMoa2V5c0luKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiA3IH0gfV0gfTtcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGFjY2VwdHMgYHVwZGF0ZXJgIHRvIHByb2R1Y2UgdGhlXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAnYVswXS5iLmMnLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy51cGRhdGVXaXRoKG9iamVjdCwgJ1swXVsxXScsIF8uY29uc3RhbnQoJ2EnKSwgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXaXRoKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdmUkVEJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xuICAgICAgICBzdHJpbmcgK1xuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkIHx8IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhhcmdzWzBdKTtcblxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwKHNlcGFyYXRvcikpXG4gICAgICAgICAgKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gICAgICAvLyB0byBub3JtYWxpemUgYWxsIGtpbmRzIG9mIHdoaXRlc3BhY2UsIHNvIGUuZy4gbmV3bGluZXMgKGFuZCB1bmljb2RlIHZlcnNpb25zIG9mIGl0KSBjYW4ndCBzbmVhayBpblxuICAgICAgLy8gYW5kIGVzY2FwZSB0aGUgY29tbWVudCwgdGh1cyBpbmplY3RpbmcgY29kZSB0aGF0IGdldHMgZXZhbGVkLlxuICAgICAgdmFyIHNvdXJjZVVSTCA9ICcvLyMgc291cmNlVVJMPScgK1xuICAgICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICAgICAgICA/IChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9cXHMvZywgJyAnKVxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgYSBmb3JiaWRkZW4gY2hhcmFjdGVyIHdhcyBmb3VuZCBpbiBgdmFyaWFibGVgLCB0byBwcmV2ZW50XG4gICAgICAvLyBwb3RlbnRpYWwgY29tbWFuZCBpbmplY3Rpb24gYXR0YWNrcy5cbiAgICAgIGVsc2UgaWYgKHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzLnRlc3QodmFyaWFibGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9Mb3dlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvTG93ZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICctLWZvby1iYXItLSdcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb2JhcidcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnX19mb29fYmFyX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byB1cHBlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9VcHBlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvVXBwZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1VwcGVyKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICctLUZPTy1CQVItLSdcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPT0JBUidcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnX19GT09fQkFSX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VcHBlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBiYXNlVHJpbShzdHJpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCBfLm1hdGNoZXMoeyAnYSc6IDQgfSldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlc1Byb3BlcnR5KCdhJywgMSksIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgxKSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJ10pKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhcmd1bWVudCBhdCBpbmRleCBgbmAuIElmIGBuYCBpcyBuZWdhdGl2ZSxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKC0yKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2MnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBtYXRjaGVzRnVuYyA9IF8ub3ZlclNvbWUoW3sgJ2EnOiAxIH0sIHsgJ2EnOiAyIH1dKVxuICAgICAqIHZhciBtYXRjaGVzUHJvcGVydHlGdW5jID0gXy5vdmVyU29tZShbWydhJywgMV0sIFsnYScsIDJdXSlcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICByZWFsTmFtZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiaW1wb3J0IHsgRGVmYXVsdFNpbXVsYXRpb25Db25maWcgfSBmcm9tIFwiLi4vY29uZmlnL3NpbXVsYXRpb24uY29uZmlnXCI7XG5pbXBvcnQgR2VuZSBmcm9tIFwiLi4vbW9kZWxzL0dlbmVcIjtcbmltcG9ydCBPcmdhbmlzbSBmcm9tIFwiLi4vbW9kZWxzL09yZ2FuaXNtXCI7XG5pbXBvcnQgeyBldWNsaWRlYW5fZGlzdGFuY2UgfSBmcm9tIFwiLi4vdXRpbHMvZ2VvbWV0cnlcIjtcblxuLyoqXG4gKiBNZXJnZXMgdHdvIHNvcnRlZCBhcnJheXMgb2Ygb3JnYW5pc21zIGludG8gYSBzaW5nbGUgc29ydGVkIGFycmF5LlxuICogQHBhcmFtIGxlZnQgLSB0aGUgbGVmdCBhcnJheSBvZiBvcmdhbmlzbXMuXG4gKiBAcGFyYW0gcmlnaHQgLSB0aGUgcmlnaHQgYXJyYXkgb2Ygb3JnYW5pc21zLlxuICogQHJldHVybnMgLSBBIHNpbmdsZSBzb3J0ZWQgYXJyYXkgb2Ygb3JnYW5pc21zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UobGVmdDogT3JnYW5pc21bXSwgcmlnaHQ6IE9yZ2FuaXNtW10pOiBPcmdhbmlzbVtdIHtcbiAgY29uc3QgcmVzdWx0OiBPcmdhbmlzbVtdID0gW107XG4gIGxldCBsZWZ0X2luZGV4ID0gMDtcbiAgbGV0IHJpZ2h0X2luZGV4ID0gMDtcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggYm90aCBhcnJheXMgYW5kIG1lcmdlIHRoZW0gd2hpbGUgbWFpbnRhaW5pbmcgc29ydGluZy5cbiAgd2hpbGUgKGxlZnRfaW5kZXggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodF9pbmRleCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgIGlmIChsZWZ0W2xlZnRfaW5kZXhdLmZpdG5lc3MhIDwgcmlnaHRbcmlnaHRfaW5kZXhdLmZpdG5lc3MhKSB7XG4gICAgICByZXN1bHQucHVzaChsZWZ0W2xlZnRfaW5kZXhdKTtcbiAgICAgIGxlZnRfaW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gocmlnaHRbcmlnaHRfaW5kZXhdKTtcbiAgICAgIHJpZ2h0X2luZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29uY2F0ZW5hdGUgcmVtYWluaW5nIGVsZW1lbnRzIGZyb20gYm90aCBhcnJheXMgaW50byB0aGUgcmVzdWx0LlxuICByZXR1cm4gcmVzdWx0LmNvbmNhdChsZWZ0LnNsaWNlKGxlZnRfaW5kZXgpKS5jb25jYXQocmlnaHQuc2xpY2UocmlnaHRfaW5kZXgpKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBtZXJnZSBzb3J0IG9uIGFuIGFycmF5IG9mIG9yZ2FuaXNtcy5cbiAqIEBwYXJhbSBhcnIgLSBUaGUgYXJyYXkgb2Ygb3JnYW5pc21zIHRvIGJlIHNvcnRlZC5cbiAqIEByZXR1cm5zIC0gQSBzb3J0ZWQgYXJyYXkgb2Ygb3JnYW5pc21zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2Vfc29ydChhcnI6IE9yZ2FuaXNtW10pOiBPcmdhbmlzbVtdIHtcbiAgaWYgKGFyci5sZW5ndGggPD0gMSkgcmV0dXJuIGFycjtcblxuICAvLyBDYWxjdWxhdGUgdGhlIG1pZGRsZSBpbmRleCBvZiB0aGUgYXJyYXkuXG4gIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IoYXJyLmxlbmd0aCAvIDIpO1xuXG4gIC8vIFJlY3Vyc2l2ZWx5IGRpdmlkZSB0aGUgYXJyYXkgaW50byB0d28gaGFsdmVzIGFuZCBwZXJmb3JtIG1lcmdlIHNvcnQgb24gZWFjaCBoYWxmLlxuICBjb25zdCBsZWZ0ID0gbWVyZ2Vfc29ydChhcnIuc2xpY2UoMCwgbWlkZGxlKSk7XG4gIGNvbnN0IHJpZ2h0ID0gbWVyZ2Vfc29ydChhcnIuc2xpY2UobWlkZGxlKSk7XG5cbiAgLy8gTWVyZ2UgdGhlIHNvcnRlZCBoYWx2ZXMgdXNpbmcgdGhlICdtZXJnZScgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICByZXR1cm4gbWVyZ2UobGVmdCwgcmlnaHQpO1xufVxuXG4vKipcbiAqIFNvcnRzIGFuIGFycmF5IG9mIG9yZ2FuaXNtcyBiYXNlZCBvbiB0aGVpciBmaXRuZXNzIGFuZCBjYWxjdWxhdGVzIHRoZWlyIGZpdG5lc3MgdmFsdWVzLlxuICogQHBhcmFtIHBvcHVsYXRpb24gLSBUaGUgYXJyYXkgb2Ygb3JnYW5pc21zIHRvIGJlIHNvcnRlZC5cbiAqIEBwYXJhbSBnb2FsIC0gVGhlIGdvYWwgb2YgdGhlIHNpbXVsYXRpb24uXG4gKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBjb250YWluaW5nIGdvYWwgY29vcmRpbmF0ZXMgYW5kIG1heGltdW0gZGlzdGFuY2VzIHRvIGdvYWwgZm9yIGZpdG5lc3MgY2FsY3VsYXRpb24uXG4gKiBAcmV0dXJucyAtIEEgc29ydGVkIGFycmF5IG9mIG9yZ2FuaXNtcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZV9hbmRfc29ydF9maXRuZXNzKHBvcHVsYXRpb246IE9yZ2FuaXNtW10sIGdvYWw6IHN0cmluZywgcGFyYW1zPzogYW55KTogT3JnYW5pc21bXSB7XG4gIC8vIENhbGN1bGF0ZSBmaXRuZXNzIHZhbHVlcyBmb3Igb3JnYW5pc21zIGJhc2VkIG9uIHRoZSBzcGVjaWZpZWQgZ29hbC5cbiAgaWYgKGdvYWwgPT09IFwiZm9vZFwiKSB7XG4gICAgZm9yIChjb25zdCBvcmdhbmlzbSBvZiBwb3B1bGF0aW9uKSB7XG4gICAgICBvcmdhbmlzbS5maXRuZXNzID0gY2FsY3VsYXRlX2ZpdG5lc3NfYnlfZm9vZChvcmdhbmlzbSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdvYWwgPT09IFwiY29vcmRcIikge1xuICAgIGZvciAoY29uc3Qgb3JnYW5pc20gb2YgcG9wdWxhdGlvbikge1xuICAgICAgb3JnYW5pc20uZml0bmVzcyA9IGNhbGN1bGF0ZV9maXRuZXNzX2J5X2Nvb3JkKG9yZ2FuaXNtLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNvcnQgdGhlIHBvcHVsYXRpb24gYmFzZWQgb24gZml0bmVzcyB1c2luZyBtZXJnZSBzb3J0IGFsZ29yaXRobSBhbmQgcmV0dXJuIHRoZSBzb3J0ZWQgcG9wdWxhdGlvbi5cbiAgcmV0dXJuIG1lcmdlX3NvcnQocG9wdWxhdGlvbik7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZml0bmVzcyB2YWx1ZSBvZiBhbiBvcmdhbmlzbSBiYXNlZCBvbiBpdHMgZW5lcmd5IGxldmVsLlxuICogQHBhcmFtIG9yZ2FuaXNtIC0gVGhlIG9yZ2FuaXNtIGZvciB3aGljaCBmaXRuZXNzIGlzIGJlaW5nIGNhbGN1bGF0ZWQuXG4gKiBAcmV0dXJucyAtIFRoZSBjYWxjdWxhdGVkIGZpdG5lc3MgdmFsdWUgYmFzZWQgb24gdGhlIG9yZ2FuaXNtJ3MgZW5lcmd5IGxldmVsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlX2ZpdG5lc3NfYnlfZm9vZChvcmdhbmlzbTogYW55KTogbnVtYmVyIHtcbiAgcmV0dXJuIDEgLSBvcmdhbmlzbS5lbmVyZ3kgLyBvcmdhbmlzbS5jb25maWcuTUFYX0VORVJHWTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBmaXRuZXNzIHZhbHVlIG9mIGFuIG9yZ2FuaXNtIGJhc2VkIG9uIGl0cyBwcm94aW1pdHkgdG8gc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIG9yZ2FuaXNtIC0gVGhlIG9yZ2FuaXNtIGZvciB3aGljaCBmaXRuZXNzIGlzIGJlaW5nIGNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBjb250YWluaW5nIGdvYWwgY29vcmRpbmF0ZXMgYW5kIG1heGltdW0gZGlzdGFuY2VzIHRvIGdvYWwgZm9yIGZpdG5lc3MgY2FsY3VsYXRpb24uXG4gKiBAcmV0dXJucyAtIFRoZSBjYWxjdWxhdGVkIGZpdG5lc3MgdmFsdWUgYmFzZWQgb24gdGhlIG9yZ2FuaXNtJ3MgcHJveGltaXR5IHRvIHRoZSBnb2FsIGNvb3JkaW5hdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlX2ZpdG5lc3NfYnlfY29vcmQob3JnYW5pc206IGFueSwgcGFyYW1zOiBhbnkpOiBudW1iZXIge1xuICBjb25zdCByZXN1bHRzOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIENhbGN1bGF0ZSBkaXN0YW5jZXMgYmV0d2VlbiB0aGUgb3JnYW5pc20ncyBjb29yZGluYXRlIGFuZCBlYWNoIGdvYWwgY29vcmRpbmF0ZVxuICBmb3IgKGNvbnN0IGNvb3JkaW5hdGUgb2YgcGFyYW1zLmdvYWxfY29vcmRpbmF0ZXMpIHtcbiAgICByZXN1bHRzLnB1c2goZXVjbGlkZWFuX2Rpc3RhbmNlKG9yZ2FuaXNtLmNvb3JkaW5hdGUsIGNvb3JkaW5hdGUpKTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIG1pbmltdW0gZGlzdGFuY2UgaW5kZXggdG8gZGV0ZXJtaW5lIHRoZSBtYXhpbXVtIGRpc3RhbmNlIHRvIG5vcm1hbGl6ZSBmaXRuZXNzXG4gIGNvbnN0IG1pbl9pbmRleCA9IHJlc3VsdHMuaW5kZXhPZihNYXRoLm1pbiguLi5yZXN1bHRzKSk7XG4gIGNvbnN0IGRpc3RhbmNlID0gcmVzdWx0c1ttaW5faW5kZXhdO1xuICBjb25zdCBtYXhfZGlzdGFuY2UgPSBwYXJhbXMubWF4X2Rpc3RhbmNlc190b19nb2FsW21pbl9pbmRleF07XG5cbiAgLy8gTm9ybWFsaXplIGZpdG5lc3Mgc2NvcmUgYnkgZGl2aWRpbmcgdGhlIGRpc3RhbmNlIGJ5IHRoZSBtYXhpbXVtIGRpc3RhbmNlXG4gIHJldHVybiBkaXN0YW5jZSAvIG1heF9kaXN0YW5jZTtcbn1cblxuLyoqXG4gKiBTZWxlY3RzIG9yZ2FuaXNtcyBmb3IgY3Jvc3NvdmVyIGFuZCBjcmVhdGVzIGEgbmV3IGdlbmVyYXRpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIHBvcHVsYXRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0gcG9wdWxhdGlvbiAtIFRoZSBhcnJheSBvZiBvcmdhbmlzbXMgZnJvbSB3aGljaCBzZWxlY3Rpb24gZm9yIGNyb3Nzb3ZlciBpcyBwZXJmb3JtZWQuXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGRlZmluaW5nIHBhcmFtZXRlcnMgZm9yIHNlbGVjdGlvbiBhbmQgY3Jvc3NvdmVyLlxuICogQHJldHVybnMgLSBBIG5ldyBnZW5lcmF0aW9uIG9mIG9yZ2FuaXNtcyBjcmVhdGVkIHRocm91Z2ggY3Jvc3NvdmVyIGFuZCByZXByb2R1Y3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfYW5kX2Nyb3Nzb3Zlcihwb3B1bGF0aW9uOiBPcmdhbmlzbVtdLCBjb25maWc6IHR5cGVvZiBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZyk6IE9yZ2FuaXNtW10ge1xuICBjb25zdCBuZXdfZ2VuZXJhdGlvbjogT3JnYW5pc21bXSA9IFtdO1xuICBjb25zdCBlbGl0aXNtX3NpemU6IG51bWJlciA9IE1hdGguZmxvb3IoKGNvbmZpZy5FTElUSVNNX1BFUkNFTlQgKiBwb3B1bGF0aW9uLmxlbmd0aCkgLyAxMDApO1xuXG4gIC8vIFBlcmZvcm0gZWxpdGlzbSBieSBzZWxlY3RpbmcgdGhlIHRvcCBvcmdhbmlzbXMgZnJvbSB0aGUgY3VycmVudCBwb3B1bGF0aW9uXG4gIG5ld19nZW5lcmF0aW9uLnB1c2goLi4ucG9wdWxhdGlvbi5zbGljZSgwLCBlbGl0aXNtX3NpemUpKTtcblxuICAvLyBHZW5lcmF0ZSBuZXcgY29vcmRpbmF0ZXMgZm9yIHRoZSBzZWxlY3RlZCBvcmdhbmlzbXNcbiAgZm9yIChjb25zdCBvcmdhbmlzbSBvZiBuZXdfZ2VuZXJhdGlvbikge1xuICAgIGNvbnN0IHJhbmRvbV9jb29yZCA9IG9yZ2FuaXNtLmdyaWQuZmV0Y2hfZW1wdHlfY2VsbCgpO1xuICAgIG9yZ2FuaXNtLmNvb3JkaW5hdGUgPSByYW5kb21fY29vcmQ7XG4gIH1cblxuICBjb25zdCBtYXRpbmdfc2l6ZTogbnVtYmVyID0gTWF0aC5mbG9vcigoKDEwMCAtIGNvbmZpZy5FTElUSVNNX1BFUkNFTlQpICogcG9wdWxhdGlvbi5sZW5ndGgpIC8gMTAwKTtcblxuICAvLyBQZXJmb3JtIGNyb3Nzb3ZlciBieSByYW5kb21seSBzZWxlY3RpbmcgcGFyZW50cyBhbmQgY3JlYXRpbmcgb2Zmc3ByaW5nXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0aW5nX3NpemU7IGkrKykge1xuICAgIGNvbnN0IHBhcmVudDE6IE9yZ2FuaXNtID0gcG9wdWxhdGlvbltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoKGNvbmZpZy5UT1BfUEVSQ0VOVF9UT19SRVBST0RVQ0UgLyAxMDApICogcG9wdWxhdGlvbi5sZW5ndGgpKV07XG4gICAgY29uc3QgcGFyZW50MjogT3JnYW5pc20gPSBwb3B1bGF0aW9uW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgoY29uZmlnLlRPUF9QRVJDRU5UX1RPX1JFUFJPRFVDRSAvIDEwMCkgKiBwb3B1bGF0aW9uLmxlbmd0aCkpXTtcbiAgICBjb25zdCBjaGlsZDogT3JnYW5pc20gPSBtYXRlKHBhcmVudDEsIHBhcmVudDIpO1xuICAgIG5ld19nZW5lcmF0aW9uLnB1c2goY2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIG5ld19nZW5lcmF0aW9uO1xufVxuXG4vKipcbiAqIE1hdGVzIHdpdGggYW5vdGhlciBvcmdhbmlzbSB0byBwcm9kdWNlIGEgY2hpbGQgb3JnYW5pc20uXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIGZpcnN0IHBhcmVudCBvcmdhbmlzbS5cbiAqIEBwYXJhbSBwYXJ0bmVyIC0gVGhlIHNlY29uZCBwYXJlbnQgb3JnYW5pc20uXG4gKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIGNoaWxkIG9yZ2FuaXNtLlxuICogQHJldHVybnMgLSBBIG5ldyBjaGlsZCBvcmdhbmlzbSByZXN1bHRpbmcgZnJvbSB0aGUgbWF0aW5nIHByb2Nlc3Mgb2YgdGhlIHBhcmVudCBvcmdhbmlzbXMuXG4gKi9cbmZ1bmN0aW9uIG1hdGUocGFyZW50LCBwYXJ0bmVyOiBPcmdhbmlzbSk6IE9yZ2FuaXNtIHtcbiAgLy8gQ3JlYXRlIGFuIGFycmF5IHRvIHN0b3JlIHRoZSBjaGlsZCBvcmdhbmlzbSdzIGdlbm9tZVxuICBjb25zdCBjaGlsZF9nZW5vbWU6IEdlbmVbXSA9IG5ldyBBcnJheShwYXJlbnQuZ2Vub21lLmRhdGEubGVuZ3RoKTtcblxuICAvLyBMb29wIHRocm91Z2ggZWFjaCBnZW5lIGluIHRoZSBwYXJlbnQgb3JnYW5pc21zJyBnZW5vbWVzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Lmdlbm9tZS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gUmV0cmlldmUgZ2VuZXMgZnJvbSB0aGUgcGFyZW50IG9yZ2FuaXNtc1xuICAgIGNvbnN0IG9yZ2FuaXNtX2dlbmU6IEdlbmUgPSBwYXJlbnQuZ2Vub21lLmRhdGFbaV07XG4gICAgY29uc3QgcGFydG5lcl9nZW5lOiBHZW5lID0gcGFydG5lci5nZW5vbWUuZGF0YSFbaV07XG5cbiAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBwcm9iYWJpbGl0eSB2YWx1ZVxuICAgIGNvbnN0IHJhbmRvbV9wcm9iYWJpbGl0eTogbnVtYmVyID0gTWF0aC5yYW5kb20oKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc2VsZWN0aW9uIHByb2JhYmlsaXR5IGZvciBjaG9vc2luZyBnZW5lcyBmcm9tIHBhcmVudHNcbiAgICBjb25zdCBzZWxlY3Rpb25fcHJvYmFiaWxpdHkgPSAoMTAwIC0gcGFyZW50LmNvbmZpZy5NVVRBVElPTl9QRVJDRU5UKSAvIDIgLyAxMDA7XG5cbiAgICAvLyBEZWNpZGUgd2hpY2ggZ2VuZSB0byBzZWxlY3QgYmFzZWQgb24gdGhlIHJhbmRvbSBwcm9iYWJpbGl0eVxuICAgIGlmIChyYW5kb21fcHJvYmFiaWxpdHkgPCBzZWxlY3Rpb25fcHJvYmFiaWxpdHkpIHtcbiAgICAgIC8vIFNlbGVjdCB0aGUgZ2VuZSBmcm9tIHRoZSBmaXJzdCBwYXJlbnRcbiAgICAgIGNoaWxkX2dlbm9tZVtpXSA9IG9yZ2FuaXNtX2dlbmU7XG4gICAgfSBlbHNlIGlmIChyYW5kb21fcHJvYmFiaWxpdHkgPCBzZWxlY3Rpb25fcHJvYmFiaWxpdHkgKiAyKSB7XG4gICAgICAvLyBTZWxlY3QgdGhlIGdlbmUgZnJvbSB0aGUgc2Vjb25kIHBhcmVudFxuICAgICAgY2hpbGRfZ2Vub21lW2ldID0gcGFydG5lcl9nZW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBnZW5lIGlzIHNlbGVjdGVkLCBjcmVhdGUgYSBuZXcgZ2VuZVxuICAgICAgY2hpbGRfZ2Vub21lW2ldID0gbmV3IEdlbmUocGFyZW50LmNvbmZpZy5OVU1CRVJfT0ZfSElEREVOX05FVVJPTlMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBhIHJhbmRvbSBlbXB0eSBjZWxsIGNvb3JkaW5hdGUgb24gdGhlIGdyaWRcbiAgY29uc3QgcmFuZG9tX2Nvb3JkID0gcGFyZW50LmdyaWQuZmV0Y2hfZW1wdHlfY2VsbCgpO1xuXG4gIC8vIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IG9yZ2FuaXNtIHdpdGggdGhlIGdlbmVyYXRlZCBnZW5vbWUgYW5kIGEgcmFuZG9tIGVtcHR5IGNlbGwgY29vcmRpbmF0ZVxuICByZXR1cm4gbmV3IE9yZ2FuaXNtKHJhbmRvbV9jb29yZCwgY2hpbGRfZ2Vub21lLCBwYXJlbnQuZ3JpZCwgcGFyZW50LmNvbmZpZyk7XG59XG4iLCJpbXBvcnQgeyBET01FbGVtZW50cyB9IGZyb20gXCIuLi9jb21wb25lbnRzL0RPTUVsZW1lbnRzXCI7XG5pbXBvcnQgeyBJbnB1dE5ldXJvblN5bWJvbHMgfSBmcm9tIFwiLi4vY29uc3RhbnRzL0lucHV0TmV1cm9uc1wiO1xuaW1wb3J0IHsgT3V0cHV0TmV1cm9uU3ltYm9scyB9IGZyb20gXCIuLi9jb25zdGFudHMvT3V0cHV0TmV1cm9uc1wiO1xuaW1wb3J0IEdlbmUgZnJvbSBcIi4uL21vZGVscy9HZW5lXCI7XG5pbXBvcnQgeyBOZXVyb25zIH0gZnJvbSBcIi4uL21vZGVscy9OZXVyb25zXCI7XG5jb25zdCBub2RlX3JhZGl1cyA9IDIwO1xuY29uc3Qgbm9kZV9zcGFjaW5nID0gMTA7XG5jb25zdCBzdmcgPSBET01FbGVtZW50cy5uZXVyYWxfbmV0d29ya19zdmc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBTVkcgZWxlbWVudCB3aXRoIHNwZWNpZmljIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0gZWxlbWVudF90eXBlIC0gVGhlIHR5cGUgb2YgU1ZHIGVsZW1lbnQgdG8gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIFNWRyBlbGVtZW50LlxuICogQHJldHVybnMgLSBUaGUgY3JlYXRlZCBTVkcgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlX2VsZW1lbnRfbnMoZWxlbWVudF90eXBlOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBTVkdFbGVtZW50IHtcbiAgLy8gQ3JlYXRlIGFuIFNWRyBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCBlbGVtZW50IHR5cGUuXG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBlbGVtZW50X3R5cGUpO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUga2V5IHZhbHVlIHBhaXJzIGluIHRoZSBhdHRyaWJ1dGVzIG9iamVjdCBhbmQgc2V0IGVhY2ggYXR0cmlidXRlIHRvIHRoZSBlbGVtZW50LlxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBlbGVtZW50LlxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIFNWRyB0ZXh0IGVsZW1lbnQgd2l0aCBzcGVjaWZpYyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHggLSB4LWNvb3JkaW5hdGUgb2YgdGhlIHRleHQgZWxlbWVudC5cbiAqIEBwYXJhbSB5IC0geS1jb29yZGluYXRlIG9mIHRoZSB0ZXh0IGVsZW1lbnQuXG4gKiBAcGFyYW0gdGV4dCAtIFRleHQgY29udGVudCBvZiB0aGUgdGV4dCBlbGVtZW50LlxuICogQHBhcmFtIGZpbGwgLSBGaWxsIGNvbG91ciBvZiB0aGUgdGV4dCBlbGVtZW50LlxuICogQHJldHVybnMgLSBUaGUgY3JlYXRlZCBTVkcgdGV4dCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVfdGV4dCh4OiBudW1iZXIsIHk6IG51bWJlciwgdGV4dDogc3RyaW5nLCBmaWxsOiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgLy8gQ3JlYXRlIGFuIG9iamVjdCB3aXRoIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgdGV4dCBlbGVtZW50LlxuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIHg6IHgudG9TdHJpbmcoKSxcbiAgICB5OiB5LnRvU3RyaW5nKCksXG4gICAgXCJ0ZXh0LWFuY2hvclwiOiBcIm1pZGRsZVwiLFxuICAgIGR5OiBcIi4zZW1cIixcbiAgICBmaWxsOiBmaWxsLFxuICB9O1xuXG4gIC8vIENyZWF0ZSB0aGUgdGV4dCBlbGVtZW50IGFuZCBzZXQgaXRzIHRleHQgY29udGVudC5cbiAgY29uc3QgdGV4dF9lbGVtZW50ID0gY3JlYXRlX2VsZW1lbnRfbnMoXCJ0ZXh0XCIsIGF0dHJpYnV0ZXMpO1xuICB0ZXh0X2VsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuXG4gIC8vIFJldHVybiB0aGUgdGV4dCBlbGVtZW50LlxuICByZXR1cm4gdGV4dF9lbGVtZW50O1xufVxuXG4vKipcbiAqIENvbm5lY3RzIHR3byBub2RlcyB3aXRoIGEgbGluZS5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgc291cmNlIG5vZGUuXG4gKiBAcGFyYW0gc2luayAtIFRoZSBzaW5rIG5vZGUuXG4gKiBAcGFyYW0gd2VpZ2h0IC0gVGhlIHdlaWdodCBvZiB0aGUgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSBpc19wb3NpdGl2ZSAtIFdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gaXMgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3Rfbm9kZXMoc291cmNlOiBudW1iZXJbXSwgc2luazogbnVtYmVyW10sIHdlaWdodDogbnVtYmVyLCBpc19wb3NpdGl2ZTogYm9vbGVhbik6IHZvaWQge1xuICAvLyBEZWZpbmUgYXR0cmlidXRlcyBmb3IgdGhlIGxpbmUgY29ubmVjdGluZyB0aGUgc291cmNlIGFuZCBzaW5rIG5vZGVzLlxuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIC8vIFgtY29vcmRpbmF0ZSBvZiB0aGUgc291cmNlIG5vZGUuXG4gICAgeDE6IHNvdXJjZVswXS50b1N0cmluZygpLFxuICAgIC8vIFktY29vcmRpbmF0ZSBvZiB0aGUgc291cmNlIG5vZGUuXG4gICAgeTE6IHNvdXJjZVsxXS50b1N0cmluZygpLFxuICAgIC8vIFgtY29vcmRpbmF0ZSBvZiB0aGUgc2luayBub2RlLlxuICAgIHgyOiBzaW5rWzBdLnRvU3RyaW5nKCksXG4gICAgLy8gWS1jb29yZGluYXRlIG9mIHRoZSBzaW5rIG5vZGUuXG4gICAgeTI6IHNpbmtbMV0udG9TdHJpbmcoKSxcbiAgICAvLyBDb2xvdXIgb2YgdGhlIGxpbmUgYmFzZWQgb24gd2VpZ2h0LlxuICAgIHN0cm9rZTogaXNfcG9zaXRpdmUgPyBcImdyZWVuXCIgOiBcInJlZFwiLFxuICAgIC8vIFdpZHRoIG9mIHRoZSBsaW5lIGJhc2VkIG9uIHdlaWdodC5cbiAgICBcInN0cm9rZS13aWR0aFwiOiB3ZWlnaHQudG9TdHJpbmcoKSxcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBsaW5lIFNWRyBlbGVtZW50IHdpdGggdGhlIGRlZmluZWQgYXR0cmlidXRlcy5cbiAgY29uc3QgbGluZSA9IGNyZWF0ZV9lbGVtZW50X25zKFwibGluZVwiLCBhdHRyaWJ1dGVzKTtcblxuICAvLyBBcHBlbmQgdGhlIGxpbmUgdG8gdGhlIFNWRyBjYW52YXMuXG4gIHN2Zy5hcHBlbmRDaGlsZChsaW5lKTtcblxuICAvLyBEZWZpbmUgcHJvcGVydGllcyBmb3IgdGhlIGNpcmNsZXMgcmVwcmVzZW50aW5nIHRoZSBzb3VyY2UgYW5kIHNpbmsgbm9kZXMuXG4gIGNvbnN0IGNpcmNsZV9yYWRpdXMgPSAzO1xuXG4gIC8vIEZpbGwgY29sb3VyIG9mIHRoZSBjaXJjbGVzLlxuICBjb25zdCBjaXJjbGVfZmlsbCA9IGlzX3Bvc2l0aXZlID8gXCJncmVlblwiIDogXCJyZWRcIjtcblxuICAvLyBDcmVhdGUgY2lyY2xlIFNWRyBlbGVtZW50cyByZXByZXNlbnRpbmcgdGhlIHNvdXJjZSBhbmQgc2luayBub2Rlcy5cbiAgY29uc3Qgc291cmNlX25vZGUgPSBjcmVhdGVfY2lyY2xlKHNvdXJjZVswXSwgc291cmNlWzFdLCBjaXJjbGVfcmFkaXVzLCBjaXJjbGVfZmlsbCk7XG4gIGNvbnN0IHNpbmtfbm9kZSA9IGNyZWF0ZV9jaXJjbGUoc2lua1swXSwgc2lua1sxXSwgY2lyY2xlX3JhZGl1cywgY2lyY2xlX2ZpbGwpO1xuXG4gIC8vIEFwcGVuZCB0aGUgc291cmNlIGFuZCBzaW5rIG5vZGUgdG8gdGhlIFNWRy5cbiAgc3ZnLmFwcGVuZENoaWxkKHNvdXJjZV9ub2RlKTtcbiAgc3ZnLmFwcGVuZENoaWxkKHNpbmtfbm9kZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBTVkcgY2lyY2xlIGVsZW1lbnQgd2l0aCBzcGVjaWZpYyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHggLSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZSBvZiB0aGUgY2lyY2xlLlxuICogQHBhcmFtIHkgLSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZSBvZiB0aGUgY2lyY2xlLlxuICogQHBhcmFtIHIgLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAqIEBwYXJhbSBmaWxsIC0gRmlsbCBjb2xvdXIgb2YgdGhlIGNpcmNsZS5cbiAqIEBwYXJhbSBzdHJva2UgLSBXaGV0aGVyIHRoZSBjaXJjbGUgaGFzIGEgc3Ryb2tlLlxuICogQHJldHVybnMgLSBUaGUgY3JlYXRlZCBTVkcgY2lyY2xlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9jaXJjbGUoeDogbnVtYmVyLCB5OiBudW1iZXIsIHI6IG51bWJlciwgZmlsbDogc3RyaW5nLCBzdHJva2UgPSBmYWxzZSk6IFNWR0VsZW1lbnQge1xuICAvLyBEZWZpbmUgYXR0cmlidXRlcyBmb3IgdGhlIGNpcmNsZSBlbGVtZW50LlxuICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgIC8vIFgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudHJlIG9mIHRoZSBjaXJjbGUuXG4gICAgY3g6IHgudG9TdHJpbmcoKSxcbiAgICAvLyBZLWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRyZSBvZiB0aGUgY2lyY2xlLlxuICAgIGN5OiB5LnRvU3RyaW5nKCksXG4gICAgLy8gUmFkaXVzIG9mIHRoZSBjaXJjbGUuXG4gICAgcjogci50b1N0cmluZygpLFxuICAgIC8vIEZpbGwgY29sb3VyIG9mIHRoZSBjaXJjbGUuXG4gICAgZmlsbDogZmlsbCxcbiAgfTtcblxuICBpZiAoc3Ryb2tlKSB7XG4gICAgKGF0dHJpYnV0ZXNbXCJzdHJva2VcIl0gPSBcImJsYWNrXCIpLCAoYXR0cmlidXRlc1tcInN0cm9rZS13aWR0aFwiXSA9IFwiNXB4XCIpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgY2lyY2xlIFNWRyBlbGVtZW50IHdpdGggdGhlIGRlZmluZWQgYXR0cmlidXRlcy5cbiAgY29uc3QgY2lyY2xlID0gY3JlYXRlX2VsZW1lbnRfbnMoXCJjaXJjbGVcIiwgYXR0cmlidXRlcyk7XG5cbiAgLy8gUmV0dXJuIHRoZSBjcmVhdGVkIGNpcmNsZSBlbGVtZW50LlxuICByZXR1cm4gY2lyY2xlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHByZXZpb3VzIG5vZGUuXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBub2RlcyBvZiB0aGUgY3VycmVudCB0eXBlLlxuICogQHBhcmFtIHByZXZpb3VzIC0gVGhlIHByZXZpb3VzIHktY29vcmRpbmF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgcHJldmlvdXMgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZmluZF9wcmV2aW91c19ub2RlX3lfY29vcmQob2JqZWN0LCBwcmV2aW91cyk6IG51bWJlciB7XG4gIC8vIElmIHRoZSBvYmplY3QgaXMgZW1wdHksIHRoZXJlIGlzIG5vIHByZXZpb3VzIG5vZGUsIHNvIHJldHVybiB0aGUgbm9kZSBzcGFjaW5nIHBsdXMgdGhlIG5vZGUgcmFkaXVzIGFzIHRoZSBpbml0aWFsIHktY29vcmRpbmF0ZS5cbiAgaWYgKE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09IDApIHtcbiAgICBwcmV2aW91cyA9IG5vZGVfc3BhY2luZyArIG5vZGVfcmFkaXVzO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSwgZmluZCB0aGUgcHJldmlvdXMgeS1jb29yZGluYXRlIGJ5IGFkZGluZyB0aGUgbm9kZSBzcGFjaW5nIGFuZCB0aGUgbm9kZSByYWRpdXMgdG8gdGhlIHByZXZpb3VzIHktY29vcmRpbmF0ZS5cbiAgICBwcmV2aW91cyA9IHByZXZpb3VzICsgKG5vZGVfc3BhY2luZyArIDIgKiBub2RlX3JhZGl1cyk7XG4gIH1cbiAgcmV0dXJuIHByZXZpb3VzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBub2RlIGZvciB0aGUgbmV1cmFsIG5ldHdvcmsgZGlhZ3JhbS5cbiAqIEBwYXJhbSBub2RlX3R5cGUgLSBUaGUgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGVfaWQgLSBUaGUgSUQgb2YgdGhlIG5vZGUuXG4gKiBAcGFyYW0gaW5wdXRfbmV1cm9ucyAtIFRoZSBpbnB1dCBuZXVyb25zLlxuICogQHBhcmFtIGhpZGRlbl9uZXVyb25zIC0gVGhlIGhpZGRlbiBuZXVyb25zLlxuICogQHBhcmFtIG91dHB1dF9uZXVyb25zIC0gVGhlIG91dHB1dCBuZXVyb25zLlxuICogQHBhcmFtIGxhc3RfaW5wdXRfbmV1cm9uX2Nvb3JkIC0gVGhlIGxhc3QgeS1jb29yZGluYXRlIG9mIHRoZSBpbnB1dCBuZXVyb24uXG4gKiBAcGFyYW0gbGFzdF9oaWRkZW5fbmV1cm9uX2Nvb3JkIC0gVGhlIGxhc3QgeS1jb29yZGluYXRlIG9mIHRoZSBoaWRkZW4gbmV1cm9uLlxuICogQHBhcmFtIGxhc3Rfb3V0cHV0X25ldXJvbl9jb29yZCAtIFRoZSBsYXN0IHktY29vcmRpbmF0ZSBvZiB0aGUgb3V0cHV0IG5ldXJvbi5cbiAqIEByZXR1cm5zIC0gVGhlIHVwZGF0ZWQgaW5wdXQsIGhpZGRlbiwgYW5kIG91dHB1dCBuZXVyb25zIGFuZCB0aGVpciBsYXN0IGNvb3JkaW5hdGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVfbm9kZShcbiAgbm9kZV90eXBlOiBzdHJpbmcsXG4gIG5vZGVfaWQ6IG51bWJlcixcbiAgaW5wdXRfbmV1cm9ucyxcbiAgaGlkZGVuX25ldXJvbnMsXG4gIG91dHB1dF9uZXVyb25zLFxuICBsYXN0X2lucHV0X25ldXJvbl9jb29yZCxcbiAgbGFzdF9oaWRkZW5fbmV1cm9uX2Nvb3JkLFxuICBsYXN0X291dHB1dF9uZXVyb25fY29vcmRcbik6IFtbXSwgW10sIFtdLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIC8vIENyZWF0ZSBhIG5ldyBTVkcgZ3JvdXAgZWxlbWVudC5cbiAgY29uc3QgZ3JvdXAgPSBjcmVhdGVfZWxlbWVudF9ucyhcImdcIiwge30pO1xuXG4gIC8vIERlZmluZSB4IGNvb3JkIHBvc2l0aW9ucyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIG5vZGVzLlxuICBjb25zdCBpbnB1dCA9IDUwO1xuICBjb25zdCBoaWRkZW4gPSAyMDA7XG4gIGNvbnN0IG91dHB1dCA9IDM1MDtcblxuICAvLyBJbml0aWFsaXNlIHZhcmlhYmxlcyBmb3IgcHJldmlvdXMgeS1jb29yZGluYXRlLCB4LWNvb3JkaW5hdGUsIGFuZCBub2RlIHRleHQuXG4gIGxldCBwcmV2aW91c195X2Nvb3JkO1xuICBsZXQgeF9jb29yZDtcbiAgbGV0IG5vZGVfdGV4dDtcblxuICAvLyBEZXRlcm1pbmUgdGhlIHktY29vcmRpbmF0ZSBhbmQgdXBkYXRlIG5ldXJvbiBwb3NpdGlvbnMgYmFzZWQgb24gbm9kZSB0eXBlLlxuICBpZiAobm9kZV90eXBlID09IFwiSU5QVVRcIikge1xuICAgIC8vIEZpbmQgdGhlIHByZXZpb3VzIHktY29vcmRpbmF0ZSBmb3IgdGhlIGlucHV0IG5ldXJvbi5cbiAgICBwcmV2aW91c195X2Nvb3JkID0gZmluZF9wcmV2aW91c19ub2RlX3lfY29vcmQoaW5wdXRfbmV1cm9ucywgbGFzdF9pbnB1dF9uZXVyb25fY29vcmQpO1xuICAgIGlucHV0X25ldXJvbnNbbm9kZV9pZF0gPSBbaW5wdXQsIHByZXZpb3VzX3lfY29vcmRdO1xuICAgIGxhc3RfaW5wdXRfbmV1cm9uX2Nvb3JkID0gcHJldmlvdXNfeV9jb29yZDtcbiAgfSBlbHNlIGlmIChub2RlX3R5cGUgPT0gXCJPVVRQVVRcIikge1xuICAgIC8vIEZpbmQgdGhlIHByZXZpb3VzIHktY29vcmRpbmF0ZSBmb3IgdGhlIG91dHB1dCBuZXVyb24uXG4gICAgcHJldmlvdXNfeV9jb29yZCA9IGZpbmRfcHJldmlvdXNfbm9kZV95X2Nvb3JkKG91dHB1dF9uZXVyb25zLCBsYXN0X291dHB1dF9uZXVyb25fY29vcmQpO1xuICAgIG91dHB1dF9uZXVyb25zW25vZGVfaWRdID0gW291dHB1dCwgcHJldmlvdXNfeV9jb29yZF07XG4gICAgbGFzdF9vdXRwdXRfbmV1cm9uX2Nvb3JkID0gcHJldmlvdXNfeV9jb29yZDtcbiAgfSBlbHNlIGlmIChub2RlX3R5cGUgPT0gXCJISURERU5cIikge1xuICAgIC8vIEZpbmQgdGhlIHByZXZpb3VzIHktY29vcmRpbmF0ZSBmb3IgdGhlIGhpZGRlbiBuZXVyb24uXG4gICAgcHJldmlvdXNfeV9jb29yZCA9IGZpbmRfcHJldmlvdXNfbm9kZV95X2Nvb3JkKGhpZGRlbl9uZXVyb25zLCBsYXN0X2hpZGRlbl9uZXVyb25fY29vcmQpO1xuICAgIGhpZGRlbl9uZXVyb25zW25vZGVfaWRdID0gW2hpZGRlbiwgcHJldmlvdXNfeV9jb29yZF07XG4gICAgbGFzdF9oaWRkZW5fbmV1cm9uX2Nvb3JkID0gcHJldmlvdXNfeV9jb29yZDtcbiAgfVxuXG4gIC8vIERldGVybWluZSB4LWNvb3JkaW5hdGUgYW5kIG5vZGUgdGV4dCBiYXNlZCBvbiB0aGUgbm9kZSB0eXBlLlxuICBpZiAobm9kZV90eXBlID09IFwiSU5QVVRcIikge1xuICAgIHhfY29vcmQgPSBpbnB1dDtcbiAgICBub2RlX3RleHQgPSBJbnB1dE5ldXJvblN5bWJvbHNbbm9kZV9pZF07XG4gIH0gZWxzZSBpZiAobm9kZV90eXBlID09IFwiT1VUUFVUXCIpIHtcbiAgICB4X2Nvb3JkID0gb3V0cHV0O1xuICAgIG5vZGVfdGV4dCA9IE91dHB1dE5ldXJvblN5bWJvbHNbbm9kZV9pZF07XG4gIH0gZWxzZSBpZiAobm9kZV90eXBlID09IFwiSElEREVOXCIpIHtcbiAgICB4X2Nvb3JkID0gaGlkZGVuO1xuICAgIG5vZGVfdGV4dCA9IG5vZGVfaWQudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBjaXJjbGUgYW5kIHRleHQgZWxlbWVudHMgZm9yIHRoZSBub2RlLlxuICBjb25zdCBjaXJjbGUgPSBjcmVhdGVfY2lyY2xlKHhfY29vcmQsIHByZXZpb3VzX3lfY29vcmQsIG5vZGVfcmFkaXVzLCBcIndoaXRlXCIsIHRydWUpO1xuICBjb25zdCB0ZXh0X2VsZW1lbnQgPSBjcmVhdGVfdGV4dCh4X2Nvb3JkLCBwcmV2aW91c195X2Nvb3JkLCBub2RlX3RleHQsIFwiYmxhY2tcIik7XG5cbiAgLy8gQXBwZW5kIHRoZSBjaXJjbGUgYW5kIHRleHQgZWxlbWVudHMgdG8gdGhlIGdyb3VwIGVsZW1lbnQuXG4gIGdyb3VwLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gIGdyb3VwLmFwcGVuZENoaWxkKHRleHRfZWxlbWVudCk7XG5cbiAgLy8gQXBwZW5kIHRoZSBncm91cCBlbGVtZW50IHRvIHRoZSBTVkcuXG4gIHN2Zy5hcHBlbmRDaGlsZChncm91cCk7XG5cbiAgcmV0dXJuIFtpbnB1dF9uZXVyb25zLCBoaWRkZW5fbmV1cm9ucywgb3V0cHV0X25ldXJvbnMsIGxhc3RfaW5wdXRfbmV1cm9uX2Nvb3JkLCBsYXN0X2hpZGRlbl9uZXVyb25fY29vcmQsIGxhc3Rfb3V0cHV0X25ldXJvbl9jb29yZF07XG59XG5cbi8qKlxuICogRHJhd3MgdGhlIG5ldXJhbCBuZXR3b3JrIGRpYWdyYW0gYmFzZWQgb24gdGhlIGdpdmVuIGNvbm5lY3Rpb25zLlxuICogQHBhcmFtIGNvbm5lY3Rpb25zIC0gVGhlIGNvbm5lY3Rpb25zIGJldHdlZW4gbm9kZXMgaW4gdGhlIG5ldXJhbCBuZXR3b3JrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd19uZXVyYWxfbmV0X2JyYWluKGNvbm5lY3Rpb25zOiBHZW5lW10pOiB2b2lkIHtcbiAgLy8gTGlzdHMgdG8gc3RvcmUgdGhlIGlucHV0LCBoaWRkZW4sIGFuZCBvdXRwdXQgbmV1cm9ucy5cbiAgbGV0IGlucHV0X25ldXJvbnMgPSBbXTtcbiAgbGV0IGhpZGRlbl9uZXVyb25zID0gW107XG4gIGxldCBvdXRwdXRfbmV1cm9ucyA9IFtdO1xuICAvLyBWYXJpYWJsZXMgdG8gc3RvcmUgdGhlIGxhc3QgeSBjb29yZGluYXRlcyBvZiB0aGUgaW5wdXQsIGhpZGRlbiwgYW5kIG91dHB1dCBuZXVyb25zLlxuICBsZXQgbGFzdF9pbnB1dF9uZXVyb25fY29vcmQgPSAwO1xuICBsZXQgbGFzdF9oaWRkZW5fbmV1cm9uX2Nvb3JkID0gMDtcbiAgbGV0IGxhc3Rfb3V0cHV0X25ldXJvbl9jb29yZCA9IDA7XG4gIC8vIFZhcmlhYmxlIHRvIHN0b3JlIHRoZSB1cGRhdGVkIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnB1dCwgaGlkZGVuLCBhbmQgb3V0cHV0IG5ldXJvbnMgcGx1cyB0aGVpciBsYXN0IGNvb3JkaW5hdGVzLlxuICBsZXQgdXBkYXRlZF9jb29yZGluYXRlcztcblxuXG4gIC8vIFNldCB0aGUgaW5pdGlhbCBoZWlnaHQgb2YgdGhlIFNWRy5cbiAgbGV0IGhlaWdodCA9IDQwMDtcbiAgc3ZnLmlubmVySFRNTCA9IGA8c3ZnIHdpZHRoPSc0MDBweCcgaGVpZ2h0PScke2hlaWdodH1weCcgaWQ9J25ldXJhbC1uZXR3b3JrLXN2Zyc+PC9zdmc+YDtcbiAgc3ZnLnN0eWxlLmhlaWdodCA9IGhlaWdodC50b1N0cmluZygpOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBjb25uZWN0aW9uIHRvIGRyYXcgbGluZXMgYmV0d2VlbiBjb25uZWN0ZWQgbm9kZXMuXG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggY29ubmVjdGlvbiB0byBkcmF3IGxpbmVzIGJldHdlZW4gY29ubmVjdGVkIG5vZGVzLlxuICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2YgY29ubmVjdGlvbnMpIHtcbiAgICBsZXQgc291cmNlO1xuICAgIGxldCBzaW5rO1xuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzb3VyY2Ugbm9kZSBiYXNlZCBvbiBpdHMgdHlwZS5cbiAgICBpZiAoY29ubmVjdGlvbi5zb3VyY2VfdHlwZSA9PSBOZXVyb25zLklOUFVUIHx8IGNvbm5lY3Rpb24uc291cmNlX3R5cGUgPT0gTmV1cm9ucy5ISURERU4pIHtcbiAgICAgIGlmIChjb25uZWN0aW9uLnNvdXJjZV90eXBlID09IE5ldXJvbnMuSU5QVVQgJiYgaW5wdXRfbmV1cm9uc1tjb25uZWN0aW9uLnNvdXJjZV9pZF0pIHtcbiAgICAgICAgc291cmNlID0gaW5wdXRfbmV1cm9uc1tjb25uZWN0aW9uLnNvdXJjZV9pZF07XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uc291cmNlX3R5cGUgPT0gTmV1cm9ucy5ISURERU4gJiYgaGlkZGVuX25ldXJvbnNbY29ubmVjdGlvbi5zb3VyY2VfaWRdKSB7XG4gICAgICAgIHNvdXJjZSA9IGhpZGRlbl9uZXVyb25zW2Nvbm5lY3Rpb24uc291cmNlX2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBzb3VyY2Ugbm9kZSBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGl0LlxuICAgICAgICB1cGRhdGVkX2Nvb3JkaW5hdGVzID0gY3JlYXRlX25vZGUoXG4gICAgICAgICAgY29ubmVjdGlvbi5zb3VyY2VfdHlwZSA9PSAwID8gXCJISURERU5cIiA6IFwiSU5QVVRcIixcbiAgICAgICAgICBjb25uZWN0aW9uLnNvdXJjZV9pZCxcbiAgICAgICAgICBpbnB1dF9uZXVyb25zLFxuICAgICAgICAgIGhpZGRlbl9uZXVyb25zLFxuICAgICAgICAgIG91dHB1dF9uZXVyb25zLFxuICAgICAgICAgIGxhc3RfaW5wdXRfbmV1cm9uX2Nvb3JkLFxuICAgICAgICAgIGxhc3RfaGlkZGVuX25ldXJvbl9jb29yZCxcbiAgICAgICAgICBsYXN0X291dHB1dF9uZXVyb25fY29vcmRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoY29ubmVjdGlvbi5zb3VyY2VfdHlwZSA9PSBOZXVyb25zLklOUFVUKSB7XG4gICAgICAgICAgc291cmNlID0gaW5wdXRfbmV1cm9uc1tjb25uZWN0aW9uLnNvdXJjZV9pZF07XG4gICAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvbi5zb3VyY2VfdHlwZSA9PSBOZXVyb25zLkhJRERFTikge1xuICAgICAgICAgIHNvdXJjZSA9IGhpZGRlbl9uZXVyb25zW2Nvbm5lY3Rpb24uc291cmNlX2lkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQsIGhpZGRlbiwgYW5kIG91dHB1dCBuZXVyb25zIGFuZCB0aGVpciBsYXN0IGNvb3JkaW5hdGVzLlxuICAgIGlucHV0X25ldXJvbnMgPSB1cGRhdGVkX2Nvb3JkaW5hdGVzWzBdO1xuICAgIGhpZGRlbl9uZXVyb25zID0gdXBkYXRlZF9jb29yZGluYXRlc1sxXTtcbiAgICBvdXRwdXRfbmV1cm9ucyA9IHVwZGF0ZWRfY29vcmRpbmF0ZXNbMl07XG4gICAgbGFzdF9pbnB1dF9uZXVyb25fY29vcmQgPSB1cGRhdGVkX2Nvb3JkaW5hdGVzWzNdO1xuICAgIGxhc3RfaGlkZGVuX25ldXJvbl9jb29yZCA9IHVwZGF0ZWRfY29vcmRpbmF0ZXNbNF07XG4gICAgbGFzdF9vdXRwdXRfbmV1cm9uX2Nvb3JkID0gdXBkYXRlZF9jb29yZGluYXRlc1s1XTtcblxuICAgIC8vIERldGVybWluZSB0aGUgc2luayBub2RlIGJhc2VkIG9uIGl0cyB0eXBlLlxuICAgIGlmIChjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLk9VVFBVVCB8fCBjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLkhJRERFTikge1xuICAgICAgaWYgKGNvbm5lY3Rpb24uc2lua190eXBlID09IE5ldXJvbnMuT1VUUFVUICYmIG91dHB1dF9uZXVyb25zW2Nvbm5lY3Rpb24uc2lua19pZF0pIHtcbiAgICAgICAgc2luayA9IG91dHB1dF9uZXVyb25zW2Nvbm5lY3Rpb24uc2lua19pZF07XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uc2lua190eXBlID09IE5ldXJvbnMuSElEREVOICYmIGhpZGRlbl9uZXVyb25zW2Nvbm5lY3Rpb24uc2lua19pZF0pIHtcbiAgICAgICAgc2luayA9IGhpZGRlbl9uZXVyb25zW2Nvbm5lY3Rpb24uc2lua19pZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgc2luayBub2RlIGRvZXMgbm90IGV4aXN0LCBjcmVhdGUgaXQuXG4gICAgICAgIHVwZGF0ZWRfY29vcmRpbmF0ZXMgPSBjcmVhdGVfbm9kZShcbiAgICAgICAgICBjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSAwID8gXCJISURERU5cIiA6IFwiT1VUUFVUXCIsXG4gICAgICAgICAgY29ubmVjdGlvbi5zaW5rX2lkLFxuICAgICAgICAgIGlucHV0X25ldXJvbnMsXG4gICAgICAgICAgaGlkZGVuX25ldXJvbnMsXG4gICAgICAgICAgb3V0cHV0X25ldXJvbnMsXG4gICAgICAgICAgbGFzdF9pbnB1dF9uZXVyb25fY29vcmQsXG4gICAgICAgICAgbGFzdF9oaWRkZW5fbmV1cm9uX2Nvb3JkLFxuICAgICAgICAgIGxhc3Rfb3V0cHV0X25ldXJvbl9jb29yZFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLk9VVFBVVCkge1xuICAgICAgICAgIHNpbmsgPSBvdXRwdXRfbmV1cm9uc1tjb25uZWN0aW9uLnNpbmtfaWRdO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uc2lua190eXBlID09IE5ldXJvbnMuSElEREVOKSB7XG4gICAgICAgICAgc2luayA9IGhpZGRlbl9uZXVyb25zW2Nvbm5lY3Rpb24uc2lua19pZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGlucHV0LCBoaWRkZW4sIGFuZCBvdXRwdXQgbmV1cm9ucyBhbmQgdGhlaXIgbGFzdCBjb29yZGluYXRlcy5cbiAgICBpbnB1dF9uZXVyb25zID0gdXBkYXRlZF9jb29yZGluYXRlc1swXTtcbiAgICBoaWRkZW5fbmV1cm9ucyA9IHVwZGF0ZWRfY29vcmRpbmF0ZXNbMV07XG4gICAgb3V0cHV0X25ldXJvbnMgPSB1cGRhdGVkX2Nvb3JkaW5hdGVzWzJdO1xuICAgIGxhc3RfaW5wdXRfbmV1cm9uX2Nvb3JkID0gdXBkYXRlZF9jb29yZGluYXRlc1szXTtcbiAgICBsYXN0X2hpZGRlbl9uZXVyb25fY29vcmQgPSB1cGRhdGVkX2Nvb3JkaW5hdGVzWzRdO1xuICAgIGxhc3Rfb3V0cHV0X25ldXJvbl9jb29yZCA9IHVwZGF0ZWRfY29vcmRpbmF0ZXNbNV07XG5cbiAgICAvLyBEZWZpbmUgY29uc3RhbnRzIGZvciBsaW5lIHRoaWNrbmVzcyBjYWxjdWxhdGlvbiBiYXNlZCBvbiB0aGUgd2VpZ2h0IG9mIHRoZSBjb25uZWN0aW9uLlxuICAgIGNvbnN0IG1heF90aGlja25lc3MgPSAyLjU7XG4gICAgY29uc3QgbWluX3RoaWNrbmVzcyA9IDAuNTtcblxuICAgIC8vIFRoZSB0aGlja25lc3MgaXMgY2FsY3VsYXRlZCBieSBjYWxjdWxhdGluZyB0aGUgcmF0aW8gb2YgdGhlIHdlaWdodCB0byB0aGUgbWF4aW11bS9taW5pbXVtIHBvc3NpYmxlIHdlaWdodCBhbmQgbXVsdGlwbHlpbmcgaXQgYnkgdGhlIG1heGltdW0vbWluaW11bSB0aGlja25lc3MuXG4gICAgY29uc3QgdGhpY2tuZXNzID0gTWF0aC5tYXgoXG4gICAgICBjb25uZWN0aW9uLndlaWdodCA+PSAwID8gKGNvbm5lY3Rpb24ud2VpZ2h0IC8gMHg3ZmZmKSAqIG1heF90aGlja25lc3MgOiAoTWF0aC5hYnMoY29ubmVjdGlvbi53ZWlnaHQpIC8gMHg4MDAwKSAqIG1heF90aGlja25lc3MsXG4gICAgICBtaW5fdGhpY2tuZXNzXG4gICAgKTtcblxuICAgIC8vIERyYXcgY29ubmVjdGlvbnMgYmV0d2VlbiBub2RlcyBiYXNlZCBvbiB0aGVpciBjb29yZGluYXRlcyBhbmQgY29ubmVjdGlvbiB3ZWlnaHQuXG4gICAgY29ubmVjdF9ub2Rlcyhzb3VyY2UsIHNpbmssIHRoaWNrbmVzcywgY29ubmVjdGlvbi53ZWlnaHQgPj0gMCk7XG4gIH1cblxuICAvLyBPYnRhaW4gdGhlIG51bWJlciBvZiBpbnB1dCwgaGlkZGVuLCBhbmQgb3V0cHV0IG5ldXJvbnMuXG4gIGNvbnN0IGlucHV0X25ldXJvbnNfc2l6ZSA9IE9iamVjdC5rZXlzKGlucHV0X25ldXJvbnMpLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0X25ldXJvbnNfc2l6ZSA9IE9iamVjdC5rZXlzKG91dHB1dF9uZXVyb25zKS5sZW5ndGg7XG4gIGNvbnN0IGhpZGRlbl9uZXVyb25zX3NpemUgPSBPYmplY3Qua2V5cyhoaWRkZW5fbmV1cm9ucykubGVuZ3RoO1xuXG4gIC8vIERldGVybWluZSB0aGUgaGVpZ2h0IG9mIHRoZSBTVkcgYmFzZWQgb24gdGhlIG51bWJlciBvZiBpbnB1dCwgaGlkZGVuLCBhbmQgb3V0cHV0IG5ldXJvbnMuXG4gIC8vIFRoZSBtYXhpbXVtIG9mIHRoZSB0aHJlZSBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgaGVpZ2h0IG9mIHRoZSBTVkcuXG4gIGlmIChNYXRoLm1heChpbnB1dF9uZXVyb25zX3NpemUsIG91dHB1dF9uZXVyb25zX3NpemUsIGhpZGRlbl9uZXVyb25zX3NpemUpID09IGlucHV0X25ldXJvbnNfc2l6ZSkge1xuICAgIGhlaWdodCA9IGxhc3RfaW5wdXRfbmV1cm9uX2Nvb3JkO1xuICB9IGVsc2UgaWYgKE1hdGgubWF4KGlucHV0X25ldXJvbnNfc2l6ZSwgb3V0cHV0X25ldXJvbnNfc2l6ZSwgaGlkZGVuX25ldXJvbnNfc2l6ZSkgPT0gb3V0cHV0X25ldXJvbnNfc2l6ZSkge1xuICAgIGhlaWdodCA9IGxhc3Rfb3V0cHV0X25ldXJvbl9jb29yZDtcbiAgfSBlbHNlIGlmIChNYXRoLm1heChpbnB1dF9uZXVyb25zX3NpemUsIG91dHB1dF9uZXVyb25zX3NpemUsIGhpZGRlbl9uZXVyb25zX3NpemUpID09IGhpZGRlbl9uZXVyb25zX3NpemUpIHtcbiAgICBoZWlnaHQgPSBsYXN0X2hpZGRlbl9uZXVyb25fY29vcmQ7XG4gIH1cblxuICAvLyBTZXQgdGhlIGhlaWdodCBvZiB0aGUgU1ZHLlxuICBzdmcuc3R5bGUuaGVpZ2h0ID0gKGhlaWdodCArIG5vZGVfcmFkaXVzICsgbm9kZV9zcGFjaW5nKS50b1N0cmluZygpO1xufVxuIiwiaW1wb3J0IFNpbXVsYXRpb24gZnJvbSBcIi4uL2NvbnRyb2xsZXJzL3NpbXVsYXRpb24uY29udHJvbGxlclwiO1xuaW1wb3J0IHsgRE9NRWxlbWVudHMgfSBmcm9tIFwiLi9ET01FbGVtZW50c1wiO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGRvd25sb2FkIG5ldXJhbCBuZXR3b3JrIGJ1dHRvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyX2Rvd25sb2FkX25ldXJhbG5ldF9idXR0b24oKTogdm9pZCB7XG4gIERPTUVsZW1lbnRzLmV4cG9ydF9uZXVyYWxuZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAvLyBHZXQgdGhlIFNWRyBlbGVtZW50IGZyb20gdGhlIERvY3VtZW50IE9iamVjdCBNb2RlbCAoRE9NKVxuICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIik7XG4gICAgaWYgKHN2Zykge1xuICAgICAgLy8gU2VyaWFsaXplIHRoZSBTVkcgZWxlbWVudCB0byBhIHN0cmluZ1xuICAgICAgY29uc3QgYXNfdGV4dCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKTtcbiAgICAgIC8vIENyZWF0ZSBhIEJsb2Igb2JqZWN0IGZyb20gdGhlIHNlcmlhbGl6ZWQgU1ZHIHN0cmluZ1xuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFthc190ZXh0XSwgeyB0eXBlOiBcImltYWdlL3N2Zyt4bWxcIiB9KTtcbiAgICAgIC8vIENyZWF0ZSBhIFVSTCBvYmplY3QgZnJvbSB0aGUgQmxvYiBvYmplY3RcbiAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAvLyBDcmVhdGUgYSBsaW5rIGVsZW1lbnQgYW5kIHNldCBpdHMgYXR0cmlidXRlc1xuICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgbGluay5kb3dubG9hZCA9IFwibmV1cmFsX25ldHdvcmsuc3ZnXCI7XG4gICAgICAvLyBDbGljayB0aGUgbGluayBlbGVtZW50IHRvIGRvd25sb2FkIHRoZSBTVkcgZmlsZVxuICAgICAgbGluay5jbGljaygpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgcmVuZGVyaW5nIGVuYWJsZWQgYnV0dG9uLlxuICogQHBhcmFtIHNpbXVsYXRpb24gLSBUaGUgc2ltdWxhdGlvbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcl9yZW5kZXJpbmdfZW5hYmxlZF9idXR0b24oc2ltdWxhdGlvbjogU2ltdWxhdGlvbik6IHZvaWQge1xuICBET01FbGVtZW50cy5yZW5kZXJpbmdfZW5hYmxlZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgIC8vIFdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLCB0aGUgcmVuZGVyaW5nIGVuYWJsZWQgcHJvcGVydHkgaXMgdG9nZ2xlZC5cbiAgICBzaW11bGF0aW9uLnJlbmRlcmluZ19lbmFibGVkID0gIXNpbXVsYXRpb24ucmVuZGVyaW5nX2VuYWJsZWQ7XG4gICAgLy8gVXBkYXRlIHRoZSBidXR0b24gdGV4dCB0byByZWZsZWN0IHRoZSBjdXJyZW50IHJlbmRlcmluZyBzdGF0ZS5cbiAgICBET01FbGVtZW50cy5yZW5kZXJpbmdfZW5hYmxlZC5pbm5lckhUTUwgPSBcIlJlbmRlcmluZyBcIiArIChzaW11bGF0aW9uLnJlbmRlcmluZ19lbmFibGVkID8gXCJPTlwiIDogXCJPRkZcIik7XG4gICAgLy8gSWYgdGhlIHNpbXVsYXRpb24gaXMgcnVubmluZywgcmVzdGFydCB0aGUgZW5naW5lIHRvIGFwcGx5IHRoZSBjaGFuZ2VzLlxuICAgIGlmIChzaW11bGF0aW9uLmlzX3J1bm5pbmcpIHtcbiAgICAgIHNpbXVsYXRpb24uc3RvcF9lbmdpbmUoKTtcbiAgICAgIHNpbXVsYXRpb24uc3RhcnRfZW5naW5lKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSByZXN0YXJ0IGJ1dHRvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyX3NpbV9yZXN0YXJ0X2J1dHRvbigpOiB2b2lkIHtcbiAgRE9NRWxlbWVudHMuc2ltX3Jlc3RhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAvLyBDcmVhdGVzIGEgY29uZmlybWF0aW9uIGRpYWxvZyBib3ggYXNraW5nIHRoZSB1c2VyIHdoZXRoZXIgdGhleSB3YW50IHRvIHJlc3RhcnQgdGhlIHNpbXVsYXRpb24uXG4gICAgY29uc3QgcmVzdGFydF9jb25maXJtZWQgPSBjb25maXJtKFwiQXJlIHlvdSBzdXJlIHlvdSB3b3VsZCBsaWtlIHRvIHJlc3RhcnQ/XCIpO1xuICAgIC8vIElmIHRoZSB1c2VyIGNvbmZpcm1zLCByZWxvYWQgdGhlIHBhZ2UuXG4gICAgaWYgKHJlc3RhcnRfY29uZmlybWVkKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBzdGFydC9zdG9wIGJ1dHRvbi5cbiAqIEBwYXJhbSBzaW11bGF0aW9uIC0gVGhlIHNpbXVsYXRpb24gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJfc2ltX3N0YXJ0X3N0b3BfYnV0dG9uKHNpbXVsYXRpb246IFNpbXVsYXRpb24pOiB2b2lkIHtcbiAgLy8gV2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQsIHRoZSBzaW11bGF0aW9uIGlzIGVpdGhlciBzdGFydGVkIG9yIHN0b3BwZWQuXG4gIERPTUVsZW1lbnRzLnNpbV9zdGFydF9zdG9wLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgLy8gSWYgdGhlIHNpbXVsYXRpb24gaXMgcnVubmluZywgc3RvcCB0aGUgZW5naW5lIGFuZCB1cGRhdGUgdGhlIGJ1dHRvbiB0ZXh0LlxuICAgIGlmIChzaW11bGF0aW9uLmlzX3J1bm5pbmcpIHtcbiAgICAgIHNpbXVsYXRpb24uc3RvcF9lbmdpbmUoKTtcbiAgICAgIERPTUVsZW1lbnRzLnNpbV9zdGFydF9zdG9wLmlubmVySFRNTCA9IFwiU1RBUlRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHNpbXVsYXRpb24gaXMgbm90IHJ1bm5pbmcsIHN0YXJ0IHRoZSBlbmdpbmUgYW5kIHVwZGF0ZSB0aGUgYnV0dG9uIHRleHQuXG4gICAgICBjb25zdCBlbmdpbmVfc3RhcnRlZCA9IHNpbXVsYXRpb24uc3RhcnRfZW5naW5lKCk7XG4gICAgICBpZiAoZW5naW5lX3N0YXJ0ZWQpIHtcbiAgICAgICAgRE9NRWxlbWVudHMuc2ltX3N0YXJ0X3N0b3AuaW5uZXJIVE1MID0gXCJTVE9QXCI7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHNob3cgY29udHJvbHMgYnV0dG9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyX3Nob3dfY29udHJvbHMoKTogdm9pZCB7XG4gIGxldCBjb250cm9sX3dpbmRvd19zaG93biA9IGZhbHNlO1xuXG4gIC8vIFdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLCB0aGUgY29udHJvbCB3aW5kb3cgaXMgZWl0aGVyIHNob3duIG9yIGhpZGRlbi5cbiAgRE9NRWxlbWVudHMuYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgLy8gVG9nZ2xlIHRoZSBjb250cm9sIHdpbmRvdydzIHZpc2liaWxpdHkuXG4gICAgY29udHJvbF93aW5kb3dfc2hvd24gPSAhY29udHJvbF93aW5kb3dfc2hvd247XG4gICAgLy8gSWYgdGhlIGNvbnRyb2wgd2luZG93IGlzIHNob3duLCBkaXNwbGF5IHRoZSBzaWRlYmFyLCBlbHNlIGhpZGUgaXQuXG4gICAgaWYgKGNvbnRyb2xfd2luZG93X3Nob3duKSB7XG4gICAgICBET01FbGVtZW50cy5zaWRlYmFyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTUVsZW1lbnRzLnNpZGViYXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgRlBTIHNsaWRlci5cbiAqIEBwYXJhbSBzaW11bGF0aW9uIC0gVGhlIHNpbXVsYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIGNvbmZpZyAtIFRoZSBzaW11bGF0aW9uIGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcl9mcHNfc2xpZGVyKHNpbXVsYXRpb24sIGNvbmZpZyk6IHZvaWQge1xuICAvLyBTZXQgdGhlIHNsaWRlcidzIG1pbiwgbWF4LCBhbmQgaW5pdGlhbCB2YWx1ZS5cbiAgRE9NRWxlbWVudHMudGFyZ2V0X3VwZGF0ZV9mcHNfc2xpZGVyLm1heCA9IGNvbmZpZy5UQVJHRVRfVVBEQVRFX01BWF9GUFMudG9TdHJpbmcoKTtcbiAgRE9NRWxlbWVudHMudGFyZ2V0X3VwZGF0ZV9mcHNfc2xpZGVyLnZhbHVlID0gY29uZmlnLlRBUkdFVF9VUERBVEVfRlBTLnRvU3RyaW5nKCk7XG5cbiAgLy8gV2hlbiB0aGUgc2xpZGVyJ3MgdmFsdWUgaXMgY2hhbmdlZCwgdGhlIHRhcmdldCB1cGRhdGUgRlBTIGlzIHVwZGF0ZWQuXG4gIERPTUVsZW1lbnRzLnRhcmdldF91cGRhdGVfZnBzX3NsaWRlci5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgIGlmIChET01FbGVtZW50cy50YXJnZXRfdXBkYXRlX2Zwc19zbGlkZXIudmFsdWUgPT09IERPTUVsZW1lbnRzLnRhcmdldF91cGRhdGVfZnBzX3NsaWRlci5tYXgpIHtcbiAgICAgIC8vIElmIHRoZSBzbGlkZXIgaXMgYXQgaXRzIG1heGltdW0gdmFsdWUsIHNldCB0aGUgdGFyZ2V0IHVwZGF0ZSBGUFMgdG8gdGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIChoaWdoZXN0IHBvc3NpYmxlIEZQUykuXG4gICAgICBET01FbGVtZW50cy5zbGlkZXJfbGFiZWwuaW5uZXJIVE1MID0gXCJNQVhcIjtcbiAgICAgIGNvbmZpZy5UQVJHRVRfVVBEQVRFX0ZQUyA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIH0gZWxzZSBpZiAoRE9NRWxlbWVudHMudGFyZ2V0X3VwZGF0ZV9mcHNfc2xpZGVyLnZhbHVlID09IERPTUVsZW1lbnRzLnRhcmdldF91cGRhdGVfZnBzX3NsaWRlci5taW4pIHtcbiAgICAgIC8vIElmIHRoZSBzbGlkZXIgaXMgYXQgaXRzIG1pbmltdW0gdmFsdWUsIHNldCB0aGUgdGFyZ2V0IHVwZGF0ZSBGUFMgdG8gMS5cbiAgICAgIERPTUVsZW1lbnRzLnNsaWRlcl9sYWJlbC5pbm5lckhUTUwgPSBcIjFcIjtcbiAgICAgIGNvbmZpZy5UQVJHRVRfVVBEQVRFX0ZQUyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgc2V0IHRoZSB0YXJnZXQgdXBkYXRlIEZQUyB0byB0aGUgc2xpZGVyJ3MgdmFsdWUuXG4gICAgICBET01FbGVtZW50cy5zbGlkZXJfbGFiZWwuaW5uZXJIVE1MID0gRE9NRWxlbWVudHMudGFyZ2V0X3VwZGF0ZV9mcHNfc2xpZGVyLnZhbHVlO1xuICAgICAgY29uZmlnLlRBUkdFVF9VUERBVEVfRlBTID0gcGFyc2VJbnQoRE9NRWxlbWVudHMudGFyZ2V0X3VwZGF0ZV9mcHNfc2xpZGVyLnZhbHVlLCAxMCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNpbXVsYXRpb24gaXMgcnVubmluZywgcmVzdGFydCB0aGUgZW5naW5lIHRvIGFwcGx5IHRoZSBjaGFuZ2VzLlxuICAgIGlmIChzaW11bGF0aW9uLmlzX3J1bm5pbmcpIHtcbiAgICAgIHNpbXVsYXRpb24ucmVzdGFydF9lbmdpbmUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGNoYXJ0IHN3aXRjaGVyLlxuICogQHBhcmFtIHNpbXVsYXRpb24gLSBUaGUgc2ltdWxhdGlvbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcl9zd2l0Y2hfY2hhcnQoc2ltdWxhdGlvbjogU2ltdWxhdGlvbik6IHZvaWQge1xuICBET01FbGVtZW50cy5zd2l0Y2hfY2hhcnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBwYXJzZUludChET01FbGVtZW50cy5zd2l0Y2hfY2hhcnQudmFsdWUpO1xuICAgIHNpbXVsYXRpb24uZW52aXJvbm1lbnQuY2hhcnQuc3dpdGNoX2NoYXJ0KGluZGV4KTtcbiAgfSk7XG59XG4iLCIvLyBET00gZWxlbWVudHMgYXJlIHN0b3JlZCBpbiBhIHNpbmdsZSBvYmplY3QgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBnbG9iYWwgbmFtZXNwYWNlLlxuZXhwb3J0IGNvbnN0IERPTUVsZW1lbnRzID0ge1xuICBidXR0b246IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3Blbl9zaWRlYmFyXCIpIGFzIEhUTUxCdXR0b25FbGVtZW50LFxuICBleHBvcnRfbmV1cmFsbmV0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImV4cG9ydF9uZXVyYWxuZXRcIikgYXMgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIHJlbmRlcmluZ19lbmFibGVkOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlbmRlcl9vbl9vZmZcIikgYXMgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIHNpZGViYXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2lkZWJhclwiKSBhcyBIVE1MRGl2RWxlbWVudCxcbiAgc2ltX3Jlc3RhcnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2ltX3Jlc3RhcnRcIikgYXMgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIHNpbV9zdGFydF9zdG9wOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpbV9zdGFydF9zdG9wXCIpIGFzIEhUTUxCdXR0b25FbGVtZW50LFxuICBzbGlkZXJfbGFiZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGFyZ2V0X3VwZGF0ZV9mcHNcIikgYXMgSFRNTFNwYW5FbGVtZW50LFxuXG4gIHRhcmdldF91cGRhdGVfZnBzX3NsaWRlcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0YXJnZXRfdXBkYXRlX2Zwc19zbGlkZXJcIikgYXMgSFRNTElucHV0RWxlbWVudCxcbiAgZXhwb3J0X3BvcHVsYXRpb246IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXhwb3J0X2FsbF9vcmdhbmlzbXNcIikgYXMgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIGV4cG9ydF9jb25maWc6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXhwb3J0X2NvbmZpZ1wiKSBhcyBIVE1MQnV0dG9uRWxlbWVudCxcbiAgZXhwb3J0X3NpbXVsYXRpb246IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZXhwb3J0X3NpbXVsYXRpb25cIikgYXMgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIGV4cG9ydF9lbnZpcm9ubWVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJleHBvcnRfZW52aXJvbm1lbnRcIikgYXMgSFRNTEJ1dHRvbkVsZW1lbnQsXG4gIGltcG9ydF9jb25maWc6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW1wb3J0X2NvbmZpZ1wiKSBhcyBIVE1MSW5wdXRFbGVtZW50LFxuICBpbXBvcnRfb3JnYW5pc21zOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImltcG9ydF9vcmdhbmlzbXNcIikgYXMgSFRNTElucHV0RWxlbWVudCxcbiAgaW1wb3J0X3NpbXVsYXRpb246IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW1wb3J0X3NpbXVsYXRpb25cIikgYXMgSFRNTElucHV0RWxlbWVudCxcbiAgaW1wb3J0X2Vudmlyb25tZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImltcG9ydF9lbnZpcm9ubWVudFwiKSBhcyBIVE1MSW5wdXRFbGVtZW50LFxuICBuZXVyYWxfbmV0d29ya19zdmc6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibmV1cmFsX25ldHdvcmtfc3ZnXCIpIGFzIEhUTUxFbGVtZW50LFxuICBzZXR0aW5nczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZXR0aW5nc1wiKSBhcyBIVE1MRGl2RWxlbWVudCxcbiAgbW9kZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RlXCIpIGFzIEhUTUxTcGFuRWxlbWVudCxcbiAgb3JnYW5pc21fc2VsZWN0ZWQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3JnYW5pc21fc2VsZWN0ZWRcIikgYXMgSFRNTFBhcmFncmFwaEVsZW1lbnQsXG4gIG9yZ2FuaXNtX3NlbGVjdGVkX3RhYmxlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImV4cG9ydF9uZXVyYWxuZXRcIikgYXMgSFRNTFRhYmxlRWxlbWVudCxcblxuICB0YXJnZXRfdXBkYXRlX2ZwczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0YXJnZXRfdXBkYXRlX2Zwc1wiKSBhcyBIVE1MSW5wdXRFbGVtZW50LFxuICB0YXJnZXRfcmVuZGVyX2ZwczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0YXJnZXRfcmVuZGVyX2Zwc1wiKSBhcyBIVE1MSW5wdXRFbGVtZW50LFxuICBjdXJyZW50X3VwZGF0ZV9mcHM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3VycmVudF91cGRhdGVfZnBzXCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQsXG4gIGN1cnJlbnRfcmVuZGVyX2ZwczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJyZW50X3JlbmRlcl9mcHNcIikgYXMgSFRNTElucHV0RWxlbWVudCxcbiAgdGlja19jb3VudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0aWNrX2NvdW50XCIpIGFzIEhUTUxTcGFuRWxlbWVudCxcbiAgZ2VuZXJhdGlvbjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnZW5lcmF0aW9uXCIpIGFzIEhUTUxTcGFuRWxlbWVudCxcbiAgYmVzdF9maXRuZXNzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImJlc3RfZml0bmVzc1wiKSBhcyBIVE1MU3BhbkVsZW1lbnQsXG4gIG92ZXJhbGxfZml0bmVzczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvdmVyYWxsX2ZpdG5lc3NcIikgYXMgSFRNTFNwYW5FbGVtZW50LFxuICBvcmdhbmlzbXNfYWxpdmU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3JnYW5pc21zX2FsaXZlXCIpIGFzIEhUTUxTcGFuRWxlbWVudCxcblxuICBzd2l0Y2hfY2hhcnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3dpdGNoX2NoYXJ0XCIpIGFzIEhUTUxCdXR0b25FbGVtZW50LFxuICBudW1iZXJfb2Zfc3BlY2llczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJudW1iZXJfb2Zfc3BlY2llc1wiKSBhcyBIVE1MU3BhbkVsZW1lbnQsXG59O1xuIiwiaW1wb3J0IHsgRGVmYXVsdFNpbXVsYXRpb25Db25maWcgfSBmcm9tIFwiLi4vY29uZmlnL3NpbXVsYXRpb24uY29uZmlnXCI7XG5pbXBvcnQgU2ltdWxhdGlvbiBmcm9tIFwiLi4vY29udHJvbGxlcnMvc2ltdWxhdGlvbi5jb250cm9sbGVyXCI7XG5pbXBvcnQgeyBDZWxsU3RhdGVzIH0gZnJvbSBcIi4uL2Vudmlyb25tZW50L0dyaWRcIjtcbmltcG9ydCBPcmdhbmlzbSBmcm9tIFwiLi4vbW9kZWxzL09yZ2FuaXNtXCI7XG5pbXBvcnQgZXhwb3J0X29iamVjdCBmcm9tIFwiLi4vdXRpbHMvZXhwb3J0X29iamVjdFwiO1xuaW1wb3J0IHsgcmVhZF9maWxlIH0gZnJvbSBcIi4uL3V0aWxzL3JlYWRfZmlsZVwiO1xuaW1wb3J0IHsgRE9NRWxlbWVudHMgfSBmcm9tIFwiLi9ET01FbGVtZW50c1wiO1xuaW1wb3J0IHsgcmVuZGVyX3NldHRpbmdzIH0gZnJvbSBcIi4vU2V0dGluZ3NcIjtcbmltcG9ydCB7IEdyaWQgfSBmcm9tIFwiLi4vZW52aXJvbm1lbnQvR3JpZFwiO1xuXG4vKipcbiAqIEV4cG9ydHMgYWxsIG9yZ2FuaXNtcyBpbiB0aGUgc2ltdWxhdGlvbi5cbiAqIEBwYXJhbSBwb3B1bGF0aW9uIC0gVGhlIHBvcHVsYXRpb24gdG8gYmUgZXhwb3J0ZWQuXG4gKiBAcGFyYW0gd2l0aF9jb29yZGluYXRlcyAtIFdoZXRoZXIgb3Igbm90IHRvIGV4cG9ydCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG9yZ2FuaXNtcy5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBleHBvcnRlZCBwb3B1bGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0X3BvcHVsYXRpb24ocG9wdWxhdGlvbjogT3JnYW5pc21bXSwgd2l0aF9jb29yZGluYXRlczogYm9vbGVhbik6IG9iamVjdCB7XG4gIC8vIENyZWF0ZSBhbiBhcnJheSB0byBzdG9yZSB0aGUgZXhwb3J0ZWQgcG9wdWxhdGlvbi5cbiAgY29uc3QgcG9wdWxhdGlvbl9leHBvcnQ6IGFueSA9IFtdO1xuICAvLyBJdGVyYXRlIG92ZXIgYWxsIG9yZ2FuaXNtcyBpbiB0aGUgcG9wdWxhdGlvbi5cbiAgZm9yIChjb25zdCBvcmdhbmlzbSBvZiBwb3B1bGF0aW9uKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgd2FudHMgdG8gZXhwb3J0IHRoZSBjb29yZGluYXRlcywgZXhwb3J0IHRoZSBnZW5vbWUgYW5kIHRoZSBjb29yZGluYXRlcy5cbiAgICBpZiAod2l0aF9jb29yZGluYXRlcykge1xuICAgICAgLy8gQ3JlYXRlIGFuIG9iamVjdCB0byBzdG9yZSB0aGUgb3JnYW5pc20ncyBnZW5vbWUgYW5kIGNvb3JkaW5hdGVzLlxuICAgICAgY29uc3Qgb3JnYW5pc21fZXhwb3J0OiBhbnkgPSB7fTtcbiAgICAgIG9yZ2FuaXNtX2V4cG9ydFtcImdlbm9tZVwiXSA9IG9yZ2FuaXNtLmdlbm9tZS5kYXRhO1xuICAgICAgb3JnYW5pc21fZXhwb3J0W1wiY29vcmRpbmF0ZXNcIl0gPSBvcmdhbmlzbS5jb29yZGluYXRlO1xuICAgICAgcG9wdWxhdGlvbl9leHBvcnQucHVzaChvcmdhbmlzbV9leHBvcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIG9ubHkgZXhwb3J0IHRoZSBnZW5vbWUuXG4gICAgICBwb3B1bGF0aW9uX2V4cG9ydC5wdXNoKG9yZ2FuaXNtLmdlbm9tZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIGV4cG9ydGVkIHBvcHVsYXRpb24uXG4gIHJldHVybiBwb3B1bGF0aW9uX2V4cG9ydDtcbn1cblxuLyoqXG4gKiBFeHBvcnRzIHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSBncmlkIC0gVGhlIGdyaWQgdG8gZXhwb3J0LlxuICogQHJldHVybnMgLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBvYnN0YWNsZXMgaW4gdGhlIGdyaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRfZW52aXJvbm1lbnQoZ3JpZDogR3JpZCk6IG51bWJlcltdW10ge1xuICAvLyBDcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgdGhlIG9ic3RhY2xlcy5cbiAgY29uc3Qgb2JzdGFjbGVzOiBudW1iZXJbXVtdID0gW107XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBjZWxscyBpbiB0aGUgZ3JpZC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkLmdyaWRfc2l6ZTsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBncmlkLmdyaWRfc2l6ZTsgaisrKSB7XG4gICAgICAvLyBHZXQgdGhlIHN0YXRlIG9mIHRoZSBjZWxsLlxuICAgICAgY29uc3Qgc3RhdGUgPSBncmlkLmdldF9jZWxsX2F0KHsgeDogaSwgeTogaiB9KS5zdGF0ZTtcbiAgICAgIC8vIElmIHRoZSBjZWxsIGlzIGEgd2FsbCBvciByYWRpb2FjdGl2ZSwgcHVzaCB0aGUgY2VsbCB0byB0aGUgb2JzdGFjbGVzIGFycmF5LlxuICAgICAgaWYgKHN0YXRlID09IENlbGxTdGF0ZXMuV0FMTCB8fCBzdGF0ZSA9PSBDZWxsU3RhdGVzLlJBRElPQUNUSVZFKSB7XG4gICAgICAgIG9ic3RhY2xlcy5wdXNoKFtpLCBqLCBzdGF0ZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYnN0YWNsZXM7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZXhwb3J0IHBvcHVsYXRpb24gYnV0dG9uLlxuICogQHBhcmFtIHNpbXVsYXRpb24gLSBUaGUgc2ltdWxhdGlvbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRfcG9wdWxhdGlvbl9idXR0b24oc2ltdWxhdGlvbjogU2ltdWxhdGlvbik6IHZvaWQge1xuICAvLyBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGV4cG9ydCBwb3B1bGF0aW9uIGJ1dHRvbi5cbiAgRE9NRWxlbWVudHMuZXhwb3J0X3BvcHVsYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAvLyBHZXQgdGhlIHBvcHVsYXRpb24gZnJvbSB0aGUgc2ltdWxhdGlvbi5cbiAgICBjb25zdCBvcmdhbmlzbXMgPSBzaW11bGF0aW9uLmVudmlyb25tZW50LnBvcHVsYXRpb247XG4gICAgLy8gSWYgdGhlIHBvcHVsYXRpb24gZXhpc3RzLCBleHBvcnQgaXQuXG4gICAgaWYgKG9yZ2FuaXNtcykge1xuICAgICAgY29uc3QgcG9wdWxhdGlvbiA9IGV4cG9ydF9wb3B1bGF0aW9uKG9yZ2FuaXNtcywgZmFsc2UpO1xuICAgICAgLy8gRXhwb3J0IHRoZSBwb3B1bGF0aW9uXG4gICAgICBleHBvcnRfb2JqZWN0KHsgZmlsZV90eXBlOiBcIm9yZ2FuaXNtX2V4cG9ydFwiLCBwb3B1bGF0aW9uIH0sIFwicG9wdWxhdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGVydCB0aGUgdXNlciB0aGF0IHRoZXJlIGFyZSBubyBvcmdhbmlzbXMgdG8gZXhwb3J0LlxuICAgICAgYWxlcnQoXCJObyBvcmdhbmlzbXMgYXZhaWxhYmxlIHRvIGV4cG9ydC5cIik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBleHBvcnQgY29uZmlnIGJ1dHRvbi5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgc2ltdWxhdGlvbiBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJfZXhwb3J0X2NvbmZpZ19idXR0b24oY29uZmlnOiB0eXBlb2YgRGVmYXVsdFNpbXVsYXRpb25Db25maWcpOiB2b2lkIHtcbiAgLy8gUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBleHBvcnQgY29uZmlnIGJ1dHRvbi5cbiAgRE9NRWxlbWVudHMuZXhwb3J0X2NvbmZpZy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgIC8vIEV4cG9ydCB0aGUgc2ltdWxhdGlvbiBjb25maWcuXG4gICAgZXhwb3J0X29iamVjdCh7IGZpbGVfdHlwZTogXCJjb25maWdfZXhwb3J0XCIsIGNvbmZpZzogY29uZmlnIH0sIFwiY29uZmlnXCIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBleHBvcnQgc2ltdWxhdGlvbiBidXR0b24uXG4gKiBAcGFyYW0gc2ltdWxhdGlvbiAtIFRoZSBzaW11bGF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgc2ltdWxhdGlvbiBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJfZXhwb3J0X3NpbXVsYXRpb25fYnV0dG9uKHNpbXVsYXRpb246IFNpbXVsYXRpb24sIGNvbmZpZzogdHlwZW9mIERlZmF1bHRTaW11bGF0aW9uQ29uZmlnKTogdm9pZCB7XG4gIC8vIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgZXhwb3J0IHNpbXVsYXRpb24gYnV0dG9uLlxuICBET01FbGVtZW50cy5leHBvcnRfc2ltdWxhdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBhbiBvYmplY3QgdG8gc3RvcmUgdGhlIGV4cG9ydC5cbiAgICBjb25zdCBzaW11bGF0aW9uX2V4cG9ydDogYW55ID0ge307XG5cbiAgICAvLyBBc3NpZ24gdGhlIHNpbXVsYXRpb24gY29uZmlnIHRvIHRoZSBleHBvcnQgb2JqZWN0LlxuICAgIHNpbXVsYXRpb25fZXhwb3J0W1wic2ltdWxhdGlvbl9jb25maWdcIl0gPSBjb25maWc7XG5cbiAgICAvLyBHZXQgdGhlIHBvcHVsYXRpb24gZnJvbSB0aGUgc2ltdWxhdGlvbi5cbiAgICBjb25zdCBwb3B1bGF0aW9uID0gc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5wb3B1bGF0aW9uO1xuXG4gICAgLy8gSWYgdGhlIHBvcHVsYXRpb24gZXhpc3RzLCBleHBvcnQgaXQuXG4gICAgaWYgKHBvcHVsYXRpb24pIHtcbiAgICAgIGNvbnN0IGV4cG9ydGVkX3BvcHVsYXRpb24gPSBleHBvcnRfcG9wdWxhdGlvbihwb3B1bGF0aW9uLCB0cnVlKTtcbiAgICAgIHNpbXVsYXRpb25fZXhwb3J0LnBvcHVsYXRpb24gPSBleHBvcnRlZF9wb3B1bGF0aW9uO1xuICAgIH1cblxuICAgIC8vIEV4cG9ydHMgdGhlIGVudmlyb25tZW50LlxuICAgIGNvbnN0IG9ic3RhY2xlcyA9IGV4cG9ydF9lbnZpcm9ubWVudChzaW11bGF0aW9uLmVudmlyb25tZW50LmdyaWQpO1xuXG4gICAgLy8gUHVzaCB0aGUgZ2VuZXJhdGlvbiwgdGlja3MgYW5kIGZpbGUgdHlwZSB0byB0aGUgZXhwb3J0IG9iamVjdC5cbiAgICBzaW11bGF0aW9uX2V4cG9ydFtcImdlbmVyYXRpb25cIl0gPSBzaW11bGF0aW9uLmVudmlyb25tZW50LmdlbmVyYXRpb247XG4gICAgc2ltdWxhdGlvbl9leHBvcnRbXCJ0aWNrc1wiXSA9IHNpbXVsYXRpb24uZW52aXJvbm1lbnQudGlja3M7XG4gICAgc2ltdWxhdGlvbl9leHBvcnRbXCJmaWxlX3R5cGVcIl0gPSBcInNpbXVsYXRpb25fZXhwb3J0XCI7XG4gICAgc2ltdWxhdGlvbl9leHBvcnRbXCJvYnN0YWNsZXNcIl0gPSBvYnN0YWNsZXM7XG5cbiAgICAvLyBFeHBvcnQgdGhlIHNpbXVsYXRpb24uXG4gICAgZXhwb3J0X29iamVjdChzaW11bGF0aW9uX2V4cG9ydCwgXCJzaW11bGF0aW9uXCIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBleHBvcnQgZW52aXJvbm1lbnQgYnV0dG9uLlxuICogQHBhcmFtIHNpbXVsYXRpb24gLSBUaGUgc2ltdWxhdGlvbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcl9leHBvcnRfZW52aXJvbm1lbnRfYnV0dG9uKHNpbXVsYXRpb246IFNpbXVsYXRpb24pOiB2b2lkIHtcbiAgLy8gUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBleHBvcnQgZW52aXJvbm1lbnQgYnV0dG9uLlxuICBET01FbGVtZW50cy5leHBvcnRfZW52aXJvbm1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAvLyBFeHBvcnRzIHRoZSBlbnZpcm9ubWVudC5cbiAgICBjb25zdCBvYnN0YWNsZXMgPSBleHBvcnRfZW52aXJvbm1lbnQoc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5ncmlkKTtcblxuICAgIC8vIEV4cG9ydCB0aGUgb2JzdGFjbGVzLlxuICAgIGV4cG9ydF9vYmplY3QoeyBmaWxlX3R5cGU6IFwib2JzdGFjbGVzXCIsIG9ic3RhY2xlczogb2JzdGFjbGVzIH0sIFwib2JzdGFjbGVzXCIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBpbXBvcnQgY29uZmlnIGJ1dHRvbi5cbiAqIEBwYXJhbSBzaW11bGF0aW9uIC0gVGhlIHNpbXVsYXRpb24gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJfaW1wb3J0X2NvbmZpZ19idXR0b24oc2ltdWxhdGlvbjogU2ltdWxhdGlvbik6IHZvaWQge1xuICAvLyBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGltcG9ydCBjb25maWcgYnV0dG9uLlxuICBET01FbGVtZW50cy5pbXBvcnRfY29uZmlnLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIC8vIFJlYWQgYW5kIHBhcnNlIHRoZSBqc29uIGZpbGUsIHRoZW4gdXBkYXRlIHRoZSBzaW11bGF0aW9uIGNvbmZpZy5cbiAgICByZWFkX2ZpbGUoZXZlbnQpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIC8vIElmIHRoZSBmaWxlIGlzIHZhbGlkLCB1cGRhdGUgdGhlIHNpbXVsYXRpb24gY29uZmlnLlxuICAgICAgaWYgKGRhdGEuY29uZmlnICYmIGRhdGEuZmlsZV90eXBlID09IFwiY29uZmlnX2V4cG9ydFwiKSB7XG4gICAgICAgIHNpbXVsYXRpb24uY29uZmlnID0gZGF0YS5jb25maWc7XG4gICAgICAgIHNpbXVsYXRpb24uZW52aXJvbm1lbnQuY29uZmlnID0gZGF0YS5jb25maWc7XG4gICAgICAgIHJlbmRlcl9zZXR0aW5ncyhzaW11bGF0aW9uLCBzaW11bGF0aW9uLmNvbmZpZyk7XG4gICAgICAgIGFsZXJ0KFwiU3VjY2Vzc2Z1bGx5IGltcG9ydGVkIGNvbmZpZy5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGFsZXJ0IHRoZSB1c2VyIHRoYXQgdGhlIGZpbGUgaXMgaW52YWxpZC5cbiAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gcmVhZCBjb25maWcgZnJvbSBmaWxlLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgdGhlIGZpbGUgaW5wdXQgZWxlbWVudC5cbiAgICAgIERPTUVsZW1lbnRzLmltcG9ydF9jb25maWcudmFsdWUgPSBcIlwiO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBpbXBvcnQgb3JnYW5pc21zIGJ1dHRvbi5cbiAqIEBwYXJhbSBzaW11bGF0aW9uIC0gVGhlIHNpbXVsYXRpb24gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJfaW1wb3J0X29yZ2FuaXNtc19idXR0b24oc2ltdWxhdGlvbjogU2ltdWxhdGlvbik6IHZvaWQge1xuICAvLyBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGltcG9ydCBvcmdhbmlzbXMgYnV0dG9uLlxuICBET01FbGVtZW50cy5pbXBvcnRfb3JnYW5pc21zLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgIC8vIFJlYWQgYW5kIHBhcnNlIHRoZSBqc29uIGZpbGUsIHRoZW4gYWRkIHRoZSBvcmdhbmlzbXMgdG8gdGhlIHNpbXVsYXRpb24uXG4gICAgcmVhZF9maWxlKGV2ZW50KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgZmlsZSBpcyB2YWxpZCwgYWRkIHRoZSBvcmdhbmlzbXMgdG8gdGhlIHNpbXVsYXRpb24uXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmZpbGVfdHlwZSA9PSBcIm9yZ2FuaXNtX2V4cG9ydFwiKSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgb3JnYW5pc21zIGluIHRoZSBmaWxlLlxuICAgICAgICBmb3IgKGNvbnN0IGdlbm9tZSBvZiBkYXRhLnBvcHVsYXRpb24pIHtcbiAgICAgICAgICAvLyBBZGQgdGhlIG9yZ2FuaXNtIHRvIHRoZSBzaW11bGF0aW9uIHVzaW5nIGl0cyBnZW5vbWUuXG4gICAgICAgICAgY29uc3QgYWRkZWRfb3JnYW5pc20gPSBzaW11bGF0aW9uLmVudmlyb25tZW50LmFkZF9vcmdhbmlzbShnZW5vbWUpO1xuICAgICAgICAgIC8vIElmIHRoZSBvcmdhbmlzbSB3YXMgbm90IGFkZGVkLCBhbGVydCB0aGUgdXNlci5cbiAgICAgICAgICBpZiAoIWFkZGVkX29yZ2FuaXNtKSB7XG4gICAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byBpbXBvcnQgYWxsIG9yZ2FuaXNtcy5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFsZXJ0IHRoZSB1c2VyIHRoYXQgdGhlIG9yZ2FuaXNtcyB3ZXJlIHN1Y2Nlc3NmdWxseSBpbXBvcnRlZC5cbiAgICAgICAgYWxlcnQoXCJTdWNjZXNzZnVsbHkgaW1wb3J0ZWQgb3JnYW5pc21zLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgYWxlcnQgdGhlIHVzZXIgdGhhdCB0aGUgZmlsZSBpcyBpbnZhbGlkLlxuICAgICAgICBhbGVydChcIkludmFsaWQgZmlsZS5cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBmaWxlIGlucHV0IGVsZW1lbnQuXG4gICAgICBET01FbGVtZW50cy5pbXBvcnRfb3JnYW5pc21zLnZhbHVlID0gXCJcIjtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgaW1wb3J0IHNpbXVsYXRpb24gYnV0dG9uLlxuICogQHBhcmFtIHNpbXVsYXRpb24gLSBUaGUgc2ltdWxhdGlvbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcl9pbXBvcnRfc2ltdWxhdGlvbl9idXR0b24oc2ltdWxhdGlvbjogU2ltdWxhdGlvbik6IHZvaWQge1xuICAvLyBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIGltcG9ydCBzaW11bGF0aW9uIGJ1dHRvbi5cbiAgRE9NRWxlbWVudHMuaW1wb3J0X3NpbXVsYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgLy8gUmVhZCBhbmQgcGFyc2UgdGhlIEpTT04gZmlsZS5cbiAgICByZWFkX2ZpbGUoZXZlbnQpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIC8vIElmIHRoZSBmaWxlIGlzIHZhbGlkLCBpbXBvcnQgdGhlIHNpbXVsYXRpb24uXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmZpbGVfdHlwZSA9PSBcInNpbXVsYXRpb25fZXhwb3J0XCIpIHtcbiAgICAgICAgLy8gSWYgc2ltdWxhdGlvbiBjb25maWcgZXhpc3RzLCB1cGRhdGUgdGhlIHNpbXVsYXRpb24gY29uZmlnIGFuZCByZW5kZXIgc2V0dGluZ3MuXG4gICAgICAgIGlmIChkYXRhLnNpbXVsYXRpb25fY29uZmlnKSB7XG4gICAgICAgICAgc2ltdWxhdGlvbi5jb25maWcgPSBkYXRhLnNpbXVsYXRpb25fY29uZmlnO1xuICAgICAgICAgIHJlbmRlcl9zZXR0aW5ncyhzaW11bGF0aW9uLCBzaW11bGF0aW9uLmNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxlcnQgaWYgc2ltdWxhdGlvbiBjb25maWcgaXMgbWlzc2luZy5cbiAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byByZWFkIHNpbXVsYXRpb24gY29uZmlnIGZyb20gZmlsZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBvYnN0YWNsZXMgZGF0YSBleGlzdHMsIGFkZCBvYnN0YWNsZXMgdG8gdGhlIHNpbXVsYXRpb24uXG4gICAgICAgIGlmIChkYXRhLm9ic3RhY2xlcykge1xuICAgICAgICAgIGZvciAoY29uc3Qgb2JzdGFjbGUgb2YgZGF0YS5vYnN0YWNsZXMpIHtcbiAgICAgICAgICAgIHNpbXVsYXRpb24uZW52aXJvbm1lbnQuZ3JpZC5zZXRfY2VsbF9zdGF0ZSh7IHg6IG9ic3RhY2xlWzBdLCB5OiBvYnN0YWNsZVsxXSB9LCBvYnN0YWNsZVsyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsZXJ0IGlmIG9ic3RhY2xlcyBkYXRhIGlzIG1pc3NpbmcuXG4gICAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gcmVhZCBvYnN0YWNsZXMgZnJvbSBmaWxlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHBvcHVsYXRpb24gZGF0YSBleGlzdHMsIGFkZCBvcmdhbmlzbXMgdG8gdGhlIHNpbXVsYXRpb24uXG4gICAgICAgIGlmIChkYXRhLnBvcHVsYXRpb24pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9yZ2FuaXNtIG9mIGRhdGEucG9wdWxhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5hZGRfb3JnYW5pc20ob3JnYW5pc20uZ2Vub21lLCBvcmdhbmlzbS5jb29yZGluYXRlcyk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byBpbXBvcnQgYWxsIG9yZ2FuaXNtcy5cIik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxlcnQgaWYgcG9wdWxhdGlvbiBkYXRhIGlzIG1pc3NpbmcuXG4gICAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gcmVhZCBwb3B1bGF0aW9uIGZyb20gZmlsZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgZ2VuZXJhdGlvbiBjb3VudCBpZiBhdmFpbGFibGUuXG4gICAgICAgIGlmIChkYXRhLmdlbmVyYXRpb24pIHtcbiAgICAgICAgICBzaW11bGF0aW9uLmVudmlyb25tZW50LmdlbmVyYXRpb24gPSBkYXRhLmdlbmVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWxlcnQgaWYgZ2VuZXJhdGlvbiBjb3VudCBpcyBtaXNzaW5nLlxuICAgICAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHJlYWQgZ2VuZXJhdGlvbiBmcm9tIGZpbGUuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRpY2tzIGNvdW50IGlmIGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKGRhdGEudGlja3MpIHtcbiAgICAgICAgICBzaW11bGF0aW9uLmVudmlyb25tZW50LnRpY2tzID0gZGF0YS50aWNrcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbGVydCBpZiB0aWNrcyBjb3VudCBpcyBtaXNzaW5nLlxuICAgICAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHJlYWQgdGlja3MgZnJvbSBmaWxlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsZXJ0IG9uIHN1Y2Nlc3NmdWwgaW1wb3J0IG9mIHRoZSBzaW11bGF0aW9uLlxuICAgICAgICBhbGVydChcIlN1Y2Nlc3NmdWxseSBpbXBvcnRlZCBzaW11bGF0aW9uLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFsZXJ0IGlmIHRoZSBmaWxlIGlzIGludmFsaWQuXG4gICAgICAgIGFsZXJ0KFwiSW52YWxpZCBmaWxlLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgdGhlIGZpbGUgaW5wdXQgZWxlbWVudC5cbiAgICAgIERPTUVsZW1lbnRzLmltcG9ydF9zaW11bGF0aW9uLnZhbHVlID0gXCJcIjtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgaW1wb3J0IGVudmlyb25tZW50IGJ1dHRvbi5cbiAqIEBwYXJhbSBzaW11bGF0aW9uIC0gVGhlIHNpbXVsYXRpb24gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJfaW1wb3J0X2Vudmlyb25tZW50X2J1dHRvbihzaW11bGF0aW9uKTogdm9pZCB7XG4gIC8vIEV2ZW50IGxpc3RlbmVyIGZvciBpbXBvcnQgZW52aXJvbm1lbnQgYnV0dG9uLlxuICBET01FbGVtZW50cy5pbXBvcnRfZW52aXJvbm1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgLy8gUmVhZCBhbmQgcGFyc2UgdGhlIEpTT04gZmlsZS5cbiAgICByZWFkX2ZpbGUoZXZlbnQpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIC8vIENoZWNrIGlmIG9ic3RhY2xlcyBkYXRhIGV4aXN0cyBhbmQgdGhlIGZpbGUgdHlwZSBpcyBvYnN0YWNsZXMuXG4gICAgICBpZiAoZGF0YS5vYnN0YWNsZXMgJiYgZGF0YS5maWxlX3R5cGUgPT0gXCJvYnN0YWNsZXNcIikge1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG9ic3RhY2xlcyBpbiB0aGUgZmlsZS5cbiAgICAgICAgZm9yIChjb25zdCBvYnN0YWNsZSBvZiBkYXRhLm9ic3RhY2xlcykge1xuICAgICAgICAgIC8vIFNldCB0aGUgY2VsbCBzdGF0ZSBvZiB0aGUgb2JzdGFjbGUuXG4gICAgICAgICAgc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5ncmlkLnNldF9jZWxsX3N0YXRlKHsgeDogb2JzdGFjbGVbMF0sIHk6IG9ic3RhY2xlWzFdIH0sIG9ic3RhY2xlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGVydCBvbiBzdWNjZXNzZnVsIGltcG9ydCBvZiBlbnZpcm9ubWVudC5cbiAgICAgICAgYWxlcnQoXCJTdWNjZXNzZnVsbHkgaW1wb3J0ZWQgZW52aXJvbm1lbnQuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWxlcnQgaWYgb2JzdGFjbGVzIGRhdGEgaXMgbWlzc2luZyBvciBmaWxlIHR5cGUgaXMgaW5jb3JyZWN0LlxuICAgICAgICBhbGVydChcIkZhaWxlZCB0byByZWFkIG9ic3RhY2xlcyBmcm9tIGZpbGUuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCB0aGUgZmlsZSBpbnB1dCBlbGVtZW50LlxuICAgICAgRE9NRWxlbWVudHMuaW1wb3J0X2Vudmlyb25tZW50LnZhbHVlID0gXCJcIjtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgUmVuZGVyZXIgZnJvbSBcIi4uL2NvbnRyb2xsZXJzL3JlbmRlcmVyLmNvbnRyb2xsZXJcIjtcbmltcG9ydCBTaW11bGF0aW9uIGZyb20gXCIuLi9jb250cm9sbGVycy9zaW11bGF0aW9uLmNvbnRyb2xsZXJcIjtcbmltcG9ydCB7IEdyaWQgfSBmcm9tIFwiLi4vZW52aXJvbm1lbnQvR3JpZFwiO1xuaW1wb3J0IHsgRE9NRWxlbWVudHMgfSBmcm9tIFwiLi9ET01FbGVtZW50c1wiO1xuXG4vKiogVGhlc2UgYXJlIHRoZSBvbmx5IHBhcmFtZXRlcnMgdGhhdCBjYW4gb25seSBiZSBjaGFuZ2VkIHdoaWxzdCB0aGUgc2ltdWxhdGlvbiBpcyBydW5uaW5nLiAqL1xuY29uc3QgbGl2ZV9wYXJhbXMgPSBbXCJNVVRBVElPTl9QRVJDRU5UXCIsIFwiRUxJVElTTV9QRVJDRU5UXCIsIFwiVElDS1NfUEVSX0dFTkVSQVRJT05cIl07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBsaXZlIHBhcmFtZXRlciBhbmQgYWxlcnRzIHRoZSB1c2VyIGlmIGl0IGlzLlxuICogQHBhcmFtIHN0YXJ0ZWQgLSBXaGV0aGVyIHRoZSBzaW11bGF0aW9uIGhhcyBzdGFydGVkLlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgaW4gdGhlIGNvbmZpZyBvYmplY3QgdGhhdCB3YXMgY2hhbmdlZC5cbiAqIEByZXR1cm5zIC0gV2hldGhlciB0aGUgcGFyYW1ldGVyIGlzIGEgbGl2ZSBwYXJhbWV0ZXIuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrX2lmX2xpdmVfcGFyYW0oc3RhcnRlZDogYm9vbGVhbiwga2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHN0YXJ0ZWQgJiYgIWxpdmVfcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICBhbGVydChgVGhlICR7a2V5fSBwYXJhbWV0ZXIgY2Fubm90IGJlIGNoYW5nZWQgd2hlbiB0aGUgc2ltdWxhdGlvbiBoYXMgYWxyZWFkeSBzdGFydGVkLmApO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBmb3IgY2hhbmdlcyBpbiB0aGUgY29uZmlnIG9iamVjdCBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBzaW11bGF0aW9uLlxuICogQHBhcmFtIHNpbXVsYXRpb24gLSBUaGUgc2ltdWxhdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBpbiB0aGUgY29uZmlnIG9iamVjdCB0aGF0IHdhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBjaGVja19jb25maWdfY2hhbmdlcyhzaW11bGF0aW9uLCBjb25maWcsIGtleSk6IHZvaWQge1xuICAvLyBDaGVjayBpZiB0aGUga2V5IGluIHRoZSBjb25maWcgb2JqZWN0IGlzIFwiR1JJRF9TSVpFXCJcbiAgaWYgKGtleSA9PT0gXCJHUklEX1NJWkVcIikge1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IHBpeGVsIHNpemUgYmFzZWQgb24gdGhlIGdyaWQgc2l6ZS5cbiAgICBzaW11bGF0aW9uLmVudmlyb25tZW50LnBpeGVsX3NpemUgPSAoY29uZmlnW2tleV0gKiAxNSkgLyBjb25maWdba2V5XTtcblxuICAgIC8vIFNldCBjYW52YXMgd2lkdGggYW5kIGhlaWdodCBiYXNlZCBvbiB0aGUgZ3JpZCBzaXplIG11bHRpcGxpZWQgYnkgMTUsXG4gICAgc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5jYW52YXMud2lkdGggPSBzaW11bGF0aW9uLmVudmlyb25tZW50LmNhbnZhcy5oZWlnaHQgPSBjb25maWdba2V5XSAqIDE1O1xuXG4gICAgLy8gQXBwbHkgc2NhbGluZyB0byB0aGUgY2FudmFzIHVzaW5nIHRoZSB6b29tIGxldmVsLlxuICAgIHNpbXVsYXRpb24uZW52aXJvbm1lbnQuY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3NpbXVsYXRpb24uZW52aXJvbm1lbnQuem9vbV9sZXZlbH0pYDtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBSZW5kZXJlciBpbnN0YW5jZSB3aXRoIHVwZGF0ZWQgY2FudmFzLCBjb250ZXh0LCBhbmQgcGl4ZWwgc2l6ZS5cbiAgICBzaW11bGF0aW9uLmVudmlyb25tZW50LnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKFxuICAgICAgc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5jYW52YXMsXG4gICAgICBzaW11bGF0aW9uLmVudmlyb25tZW50LmN0eCxcbiAgICAgIHNpbXVsYXRpb24uZW52aXJvbm1lbnQucGl4ZWxfc2l6ZVxuICAgICk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgR3JpZCBpbnN0YW5jZSB3aXRoIHRoZSB1cGRhdGVkIGdyaWQgc2l6ZSBhbmQgcmVuZGVyZXJcbiAgICBzaW11bGF0aW9uLmVudmlyb25tZW50LmdyaWQgPSBuZXcgR3JpZChjb25maWdba2V5XSwgc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5yZW5kZXJlcik7XG5cbiAgICAvLyBFbnN1cmUgcmVuZGVyZXIncyBwaXhlbCBzaXplIG1hdGNoZXMgdGhlIHVwZGF0ZWQgZW52aXJvbm1lbnQncyBwaXhlbCBzaXplXG4gICAgc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5yZW5kZXJlci5waXhlbF9zaXplID0gc2ltdWxhdGlvbi5lbnZpcm9ubWVudC5waXhlbF9zaXplO1xuXG4gICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyB1c2luZyB0aGUgdXBkYXRlZCByZW5kZXJlci5cbiAgICBzaW11bGF0aW9uLmVudmlyb25tZW50LnJlbmRlcmVyLmNsZWFyX2NhbnZhcygpO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgRlBTIGVsZW1lbnQgb24gdGhlIEhUTUwgcGFnZS5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIEhUTUwgZWxlbWVudCB0byByZW5kZXIgdGhlIEZQUyBlbGVtZW50IGluLlxuICogQHBhcmFtIGZwcyAtIFRoZSBGUFMgdmFsdWUgdG8gZGlzcGxheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcl9mcHNfZWxlbWVudChlbGVtZW50OiBIVE1MRWxlbWVudCwgZnBzOiBudW1iZXIpOiB2b2lkIHtcbiAgLy8gU2V0IHRoZSBpbm5lciBIVE1MIG9mIHRoZSBzcGVjaWZpZWQgSFRNTCBlbGVtZW50IHRvIGRpc3BsYXkgdGhlIHJvdW5kZWQgRlBTIHZhbHVlIGFzIGEgc3RyaW5nXG4gIGVsZW1lbnQuaW5uZXJIVE1MID0gTWF0aC5yb3VuZChmcHMpLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgc2V0dGluZ3MgZWxlbWVudCBvbiB0aGUgSFRNTCBwYWdlLlxuICogQHBhcmFtIHNpbXVsYXRpb24gLSBUaGUgc2ltdWxhdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZyBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJfc2V0dGluZ3Moc2ltdWxhdGlvbjogU2ltdWxhdGlvbiwgY29uZmlnOiBvYmplY3QpOiB2b2lkIHtcbiAgLy8gRnVuY3Rpb24gdG8gaGFuZGxlIGNoYW5nZXMgaW4gdGhlIGlucHV0XG4gIGZ1bmN0aW9uIGhhbmRsZV9jaGFuZ2UoZTogRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGNvbnN0IGtleSA9IHRhcmdldC5pZDtcbiAgICBjb25zdCB2YWx1ZSA9IHRhcmdldC52YWx1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBrZXkgaXMgYSBsaXZlIHBhcmFtZXRlciBiZWZvcmUgdXBkYXRpbmcgc2ltdWxhdGlvbiBjb25maWcuXG4gICAgaWYgKGNoZWNrX2lmX2xpdmVfcGFyYW0oc2ltdWxhdGlvbi5oYXNfc3RhcnRlZCwga2V5KSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBjb25maWcgb2JqZWN0IGJhc2VkIG9uIHRoZSBpbnB1dCB0eXBlXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZ1trZXldID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnW2tleV0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgZnVuY3Rpb24gdG8gY2hlY2sgYW5kIGFwcGx5IGNvbmZpZyBjaGFuZ2VzXG4gICAgICBjaGVja19jb25maWdfY2hhbmdlcyhzaW11bGF0aW9uLCBjb25maWcsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBpbnB1dCB2YWx1ZSB0byB0aGUgY29uZmlnIHZhbHVlXG4gICAgICB0YXJnZXQudmFsdWUgPSBjb25maWdba2V5XS50b1N0cmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIGFsbCBrZXlzIGZyb20gdGhlIGNvbmZpZyBvYmplY3RcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZyk7XG5cbiAgLy8gQ2xlYXIgdGhlIGlubmVySFRNTCBvZiB0aGUgc2V0dGluZ3MgZWxlbWVudFxuICBET01FbGVtZW50cy5zZXR0aW5ncy5pbm5lckhUTUwgPSBcIlwiO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGtleSBpbiB0aGUgY29uZmlnIG9iamVjdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gY29uZmlnW2tleV07XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgcm93LlxuICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyB0YWJsZSBjZWxsIGZvciB0aGUga2V5XG4gICAgY29uc3Qga2V5X2NlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG5cbiAgICAvLyBEaXNwbGF5IHRoZSBrZXkgd2l0aCB1bmRlcnNjb3JlcyByZXBsYWNlZCBieSBzcGFjZXNcbiAgICBrZXlfY2VsbC50ZXh0Q29udGVudCA9IGtleS5yZXBsYWNlQWxsKFwiX1wiLCBcIiBcIik7XG5cbiAgICAvLyBBcHBlbmQgdGhlIGtleSBjZWxsIHRvIHRoZSByb3dcbiAgICByb3cuYXBwZW5kQ2hpbGQoa2V5X2NlbGwpO1xuXG4gICAgLy8gQXBwZW5kIHRoZSByb3cgdG8gdGhlIHNldHRpbmdzIGRpdlxuICAgIERPTUVsZW1lbnRzLnNldHRpbmdzLmFwcGVuZENoaWxkKHJvdyk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgY2VsbCBmb3IgdGhlIGlucHV0XG4gICAgY29uc3QgaW5wdXRfY2VsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblxuICAgIC8vIFNldCB0aGUgaW5wdXQgdHlwZSBiYXNlZCBvbiB0aGUgdmFsdWUgdHlwZSAobnVtYmVyIG9yIGNoZWNrYm94KVxuICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gXCJudW1iZXJcIiA6IFwiY2hlY2tib3hcIik7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiaWRcIiwga2V5KTsgLy8gU2V0IGlucHV0IElEIHRvIHRoZSBrZXlcblxuICAgIC8vIFNldCB0aGUgaW5wdXQgdmFsdWUgb3IgY2hlY2tlZCBhdHRyaWJ1dGUgYmFzZWQgb24gdGhlIHZhbHVlXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImJvb2xlYW5cIiAmJiB2YWx1ZSkge1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciB0byBoYW5kbGUgaW5wdXQgY2hhbmdlc1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlX2NoYW5nZSk7XG5cbiAgICAvLyBBcHBlbmQgdGhlIGlucHV0IGNlbGwgdG8gdGhlIHJvd1xuICAgIHJvdy5hcHBlbmRDaGlsZChpbnB1dF9jZWxsKTtcbiAgICBpbnB1dF9jZWxsLmFwcGVuZENoaWxkKGlucHV0KTtcblxuICAgIC8vIEFwcGVuZCB0aGUgcm93IHRvIHRoZSBzZXR0aW5ncyBkaXZcbiAgICBET01FbGVtZW50cy5zZXR0aW5ncy5hcHBlbmRDaGlsZChyb3cpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGNvbmZpZyBjaGFuZ2VzXG4gICAgY2hlY2tfY29uZmlnX2NoYW5nZXMoc2ltdWxhdGlvbiwgY29uZmlnLCBrZXkpO1xuICB9XG59XG4iLCIvLyBJbXBvcnRpbmcgY29uc3RhbnRzIGZvciBvdXRwdXQgYW5kIGlucHV0IG5ldXJvbnNcbmltcG9ydCB7IE91dHB1dE5ldXJvbnMgfSBmcm9tIFwiLi8uLi9jb25zdGFudHMvT3V0cHV0TmV1cm9uc1wiO1xuaW1wb3J0IHsgSW5wdXROZXVyb25zIH0gZnJvbSBcIi4uL2NvbnN0YW50cy9JbnB1dE5ldXJvbnNcIjtcblxuLy8gRGVmaW5pbmcgVHlwZXMgZm9yIERlZmF1bHRTaW11bGF0aW9uQ29uZmlnXG50eXBlIFR5cGVzID0gUmVjb3JkPHN0cmluZywgYW55PjtcblxuLyoqIERlZmF1bHQgc2ltdWxhdGlvbiBzZXR0aW5ncy4gKi9cbmNvbnN0IERlZmF1bHRTaW11bGF0aW9uQ29uZmlnOiBUeXBlcyA9IHtcbiAgLy8gR3JpZCBzaXplIGZvciB0aGUgc2ltdWxhdGlvblxuICBHUklEX1NJWkU6IDEyOCxcbiAgLy8gTWF4aW11bSBmcmFtZXMgcGVyIHNlY29uZCAoRlBTKSBmb3IgdXBkYXRpbmcgdGhlIHNpbXVsYXRpb25cbiAgVEFSR0VUX1VQREFURV9NQVhfRlBTOiAzMDAsXG4gIC8vIFRhcmdldCBmcmFtZXMgcGVyIHNlY29uZCAoRlBTKSBmb3IgdXBkYXRpbmcgdGhlIHNpbXVsYXRpb25cbiAgVEFSR0VUX1VQREFURV9GUFM6IDMwMCxcbiAgLy8gVGFyZ2V0IGZyYW1lcyBwZXIgc2Vjb25kIChGUFMpIGZvciByZW5kZXJpbmcgdGhlIHNpbXVsYXRpb25cbiAgVEFSR0VUX1JFTkRFUl9GUFM6IDYwLFxuICAvLyBOdW1iZXIgb2Ygb3JnYW5pc21zIGluIHRoZSBwb3B1bGF0aW9uXG4gIFBPUFVMQVRJT046IDE1MDAsXG4gIC8vIE51bWJlciBvZiBzaW11bGF0aW9uIHN0ZXBzIGJlZm9yZSBtb3ZpbmcgdG8gbmV4dCBnZW5lcmF0aW9uLlxuICBUSUNLU19QRVJfR0VORVJBVElPTjogMzAwLFxuICAvLyBQZXJjZW50YWdlIG9mIHRvcCBwZXJmb3JtZXJzIGNvbnNpZGVyZWQgZm9yIGVsaXRpc21cbiAgRUxJVElTTV9QRVJDRU5UOiAxMCxcbiAgLy8gUGVyY2VudGFnZSBvZiB0b3AgcGVyZm9ybWVycyBmb3IgcmVwcm9kdWN0aW9uXG4gIFRPUF9QRVJDRU5UX1RPX1JFUFJPRFVDRTogMyxcbiAgLy8gUGVyY2VudGFnZSBvZiBtdXRhdGlvbiByYXRlXG4gIE1VVEFUSU9OX1BFUkNFTlQ6IDAsXG4gIC8vIEZsYWcgZm9yIGVuYWJsaW5nIHNleHVhbCByZXByb2R1Y3Rpb25cbiAgU0VYVUFMX1JFUFJPRFVDVElPTjogdHJ1ZSxcbiAgLy8gVG90YWwgbnVtYmVyIG9mIG5ldXJvbnMgaW4gdGhlIHNpbXVsYXRpb24uXG4gIE5VTUJFUl9PRl9ISURERU5fTkVVUk9OUzogMTUsIC8vIDEyN1xuICAvLyBNYXhpbXVtIGVuZXJneSBlYWNoIG9yZ2FuaXNtIGNhbiBoYXZlLlxuICBNQVhfRU5FUkdZOiAxLFxuICAvLyBUb3RhbCBudW1iZXIgb2YgZ2VuZXMgZm9yIG9yZ2FuaXNtc1xuICBOVU1CRVJfT0ZfR0VORVM6IDUwLFxuICAvLyBGbGFncyBpbmRpY2F0aW5nIHdoZXRoZXIgZ29hbCBpcyBmb29kIG9yIGNvb3JkaW5hdGVkLlxuICBHT0FMX0ZPT0Q6IGZhbHNlLFxuICBHT0FMX0NPT1JEOiB0cnVlLFxuXG4gIC8vIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0IG5ldXJvbnMgYmFzZWQgb24gaW1wb3J0ZWQgY29uc3RhbnRzLlxuICBOVU1CRVJfT0ZfSU5QVVRTOiBPYmplY3Qua2V5cyhJbnB1dE5ldXJvbnMpLmxlbmd0aCxcbiAgTlVNQkVSX09GX09VVFBVVFM6IE9iamVjdC5rZXlzKE91dHB1dE5ldXJvbnMpLmxlbmd0aCxcbn07XG5cbmV4cG9ydCB7IERlZmF1bHRTaW11bGF0aW9uQ29uZmlnIH07XG4iLCIvLyBEZWZpbmluZyBUaGVtZUNvbmZpZyB0eXBlcy5cbnR5cGUgVHlwZXMgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4vKiogVGhlbWUgcGFsZXR0ZSBmb3Igc2ltdWxhdGlvbiwgY2VsbHMgYXJlIGNvbG91cmVkIHdpdGggaGV4IHZhbHVlcy4gKi9cbmNvbnN0IFRoZW1lQ29uZmlnOiBUeXBlcyA9IHtcbiAgRU1QVFk6IFwiIzI4MmEzNlwiLFxuICBXQUxMOiBcIiM0NDQ3NWFcIixcbiAgRk9PRDogXCIjNDQ0NzVhXCIsXG4gIFJBRElPQUNUSVZFOiBcIiNmZjU1NTVcIixcbiAgSElHSExJR0hURUQ6IFwiI2YxZmE4Y1wiLFxuICBTRUxFQ1RFRDogXCIjZmZmZmZmXCIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBUaGVtZUNvbmZpZztcbiIsImltcG9ydCB7IENvb3JkaW5hdGUgfSBmcm9tIFwiLi4vdHlwZXMvQ29vcmRpbmF0ZVwiO1xuaW1wb3J0IHsgbWFrZV92ZWN0b3IsIHJvdGF0ZV9wb2ludCB9IGZyb20gXCIuLi91dGlscy9nZW9tZXRyeVwiO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgYSBjb2xsZWN0aW9uIG9mIHN0YXRpYyB2ZWN0b3JzIHJlcHJlc2VudGluZyBkaWZmZXJlbnQgZGlyZWN0aW9ucy4gSXQgYWxzb1xuICogY29udGFpbnMgbWV0aG9kcyB0byBjYWxjdWxhdGUgdGhlIGZvcndhcmQsIGJhY2t3YXJkLCBsZWZ0IGFuZCByaWdodCBkaXJlY3Rpb25zIGJhc2VkIG9uXG4gKiB0aGUgZ2l2ZW4gYW5nbGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpcmVjdGlvbnMge1xuICAvLyBObyBtb3ZlbWVudCB2ZWN0b3JcbiAgcHVibGljIHN0YXRpYyBJRExFID0gbWFrZV92ZWN0b3IoMCwgMCk7XG4gIC8vIFZlY3RvciBwb2ludGluZyBub3J0aFxuICBwdWJsaWMgc3RhdGljIE5PUlRIID0gbWFrZV92ZWN0b3IoMCwgMSk7XG4gIC8vIFZlY3RvciBwb2ludGluZyBlYXN0XG4gIHB1YmxpYyBzdGF0aWMgRUFTVCA9IG1ha2VfdmVjdG9yKDEsIDApO1xuICAvLyBWZWN0b3IgcG9pbnRpbmcgc291dGhcbiAgcHVibGljIHN0YXRpYyBTT1VUSCA9IG1ha2VfdmVjdG9yKDAsIC0xKTtcbiAgLy8gVmVjdG9yIHBvaW50aW5nIHdlc3RcbiAgcHVibGljIHN0YXRpYyBXRVNUID0gbWFrZV92ZWN0b3IoLTEsIDApO1xuICAvLyBWZWN0b3IgcG9pbnRpbmcgbm9ydGhlYXN0XG4gIHB1YmxpYyBzdGF0aWMgTk9SVEhfRUFTVCA9IG1ha2VfdmVjdG9yKDEsIDEpO1xuICAvLyBWZWN0b3IgcG9pbnRpbmcgbm9ydGh3ZXN0XG4gIHB1YmxpYyBzdGF0aWMgTk9SVEhfV0VTVCA9IG1ha2VfdmVjdG9yKC0xLCAxKTtcbiAgLy8gVmVjdG9yIHBvaW50aW5nIHNvdXRoZWFzdFxuICBwdWJsaWMgc3RhdGljIFNPVVRIX0VBU1QgPSBtYWtlX3ZlY3RvcigtMSwgMSk7XG4gIC8vIFZlY3RvciBwb2ludGluZyBzb3V0aHdlc3RcbiAgcHVibGljIHN0YXRpYyBTT1VUSF9XRVNUID0gbWFrZV92ZWN0b3IoLTEsIC0xKTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZm9yd2FyZCBkaXJlY3Rpb24gYmFzZWQgb24gdGhlIGdpdmVuIGFuZ2xlLlxuICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUgYW5nbGUgdG8gY2FsY3VsYXRlIHRoZSBmb3J3YXJkIGRpcmVjdGlvbiBmcm9tIC5cbiAgICogQHJldHVybnMgVGhlIGZvcndhcmQgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBnaXZlbiBhbmdsZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZm9yd2FyZChhbmdsZSk6IENvb3JkaW5hdGUge1xuICAgIC8vIFJvdGF0ZSBOb3J0aCB2ZWN0b3IgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gICAgcmV0dXJuIHJvdGF0ZV9wb2ludCh0aGlzLk5PUlRILCBtYWtlX3ZlY3RvcigwLCAwKSwgYW5nbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAqIEBwYXJhbSBhbmdsZSAtIFRoZSBhbmdsZSB0byBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiBmcm9tLlxuICAgKiBAcmV0dXJucyBUaGUgYmFja3dhcmQgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBnaXZlbiBhbmdsZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYmFja3dhcmQoYW5nbGUpOiBDb29yZGluYXRlIHtcbiAgICAvLyBSb3RhdGUgU291dGggdmVjdG9yIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICAgIHJldHVybiByb3RhdGVfcG9pbnQodGhpcy5TT1VUSCwgbWFrZV92ZWN0b3IoMCwgMCksIGFuZ2xlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsZWZ0IGRpcmVjdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAqIEBwYXJhbSBhbmdsZSAtIFRoZSBhbmdsZSB0byBjYWxjdWxhdGUgdGhlIGxlZnQgZGlyZWN0aW9uIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSBsZWZ0IGRpcmVjdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gYW5nbGUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGxlZnQoYW5nbGUpOiBDb29yZGluYXRlIHtcbiAgICAvLyBSb3RhdGUgTGVmdCB2ZWN0b3IgYnkgOTAgZGVncmVlcyBmcm9tIE5vcnRoXG4gICAgcmV0dXJuIHJvdGF0ZV9wb2ludCh0aGlzLk5PUlRILCBtYWtlX3ZlY3RvcigwLCAwKSwgYW5nbGUgLSBNYXRoLlBJIC8gMik7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgcmlnaHQgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBnaXZlbiBhbmdsZS5cbiAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIHRvIGNhbGN1bGF0ZSB0aGUgcmlnaHQgZGlyZWN0aW9uIGZyb20uXG4gICAqIEByZXR1cm5zIFRoZSByaWdodCBkaXJlY3Rpb24gYmFzZWQgb24gdGhlIGdpdmVuIGFuZ2xlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByaWdodChhbmdsZSk6IENvb3JkaW5hdGUge1xuICAgIC8vIFJvdGF0ZSBSaWdodCB2ZWN0b3IgYnkgOTAgZGVncmVlcyBmcm9tIE5vcnRoXG4gICAgcmV0dXJuIHJvdGF0ZV9wb2ludCh0aGlzLk5PUlRILCBtYWtlX3ZlY3RvcigwLCAwKSwgYW5nbGUgKyBNYXRoLlBJIC8gMik7XG4gIH1cbn1cblxuLyoqIENvbnN0YW50IGFuZ2xlcyBmb3IgZWFjaCBjYXJkaW5hbCBkaXJlY3Rpb24uICovXG5leHBvcnQgY29uc3QgQW5nbGVzID0ge1xuICAvLyBBbmdsZSBmb3IgZmFjaW5nIE5vcnRoXG4gIE5PUlRIOiAwLFxuICAvLyBBbmdsZSBmb3IgZmFjaW5nIEVhc3RcbiAgRUFTVDogOTAsXG4gIC8vIEFuZ2xlIGZvciBmYWNpbmcgU291dGhcbiAgU09VVEg6IDE4MCxcbiAgLy8gQW5nbGUgZm9yIGZhY2luZyBXZXN0XG4gIFdFU1Q6IDI3MCxcbn07XG4iLCIvKiogQ29uc3RhbnQgb2JqZWN0IGRlZmluaW5nIGFsbCB0aGUgYXZhaWxhYmxlIGlucHV0IG5ldXJvbnMuICovXG5leHBvcnQgY29uc3QgSW5wdXROZXVyb25zID0ge1xuICAvLyBJbnB1dCBuZXVyb24gZm9yIFgtY29vcmRpbmF0ZVxuICBYX0NPT1JESU5BVEU6IDEsXG4gIC8vIElucHV0IG5ldXJvbiBmb3IgWS1jb29yZGluYXRlXG4gIFlfQ09PUkRJTkFURTogMixcbiAgLy8gSW5wdXQgbmV1cm9uIGZvciBib3VuZGFyeSAtIE5vcnRoXG4gIEJPVU5EQVJZX05PUlRIOiAzLFxuICAvLyBJbnB1dCBuZXVyb24gZm9yIGJvdW5kYXJ5IC0gRWFzdFxuICBCT1VOREFSWV9FQVNUOiA0LFxuICAvLyBJbnB1dCBuZXVyb24gZm9yIGJvdW5kYXJ5IC0gU291dGhcbiAgQk9VTkRBUllfU09VVEg6IDUsXG4gIC8vIElucHV0IG5ldXJvbiBmb3IgYm91bmRhcnkgLSBXZXN0XG4gIEJPVU5EQVJZX1dFU1Q6IDYsXG4gIC8vIElucHV0IG5ldXJvbiBmb3IgbG9va2luZyBkaXJlY3Rpb24gLSBOb3J0aFxuICBMT09LX05PUlRIOiA3LFxuICAvLyBJbnB1dCBuZXVyb24gZm9yIGxvb2tpbmcgZGlyZWN0aW9uIC0gRWFzdFxuICBMT09LX0VBU1Q6IDgsXG4gIC8vIElucHV0IG5ldXJvbiBmb3IgbG9va2luZyBkaXJlY3Rpb24gLSBTb3V0aFxuICBMT09LX1NPVVRIOiA5LFxuICAvLyBJbnB1dCBuZXVyb24gZm9yIGxvb2tpbmcgZGlyZWN0aW9uIC0gV2VzdFxuICBMT09LX1dFU1Q6IDEwLFxufTtcblxuLyoqIEFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIGFiYnJldmlhdGVkIHN5bWJvbHMgZm9yIElucHV0IE5ldXJvbnMuICovXG5leHBvcnQgY29uc3QgSW5wdXROZXVyb25TeW1ib2xzID0gW1wiWENcIiwgXCJZQ1wiLCBcIkJOXCIsIFwiQkVcIiwgXCJCU1wiLCBcIkJXXCIsIFwiTE5cIiwgXCJMRVwiLCBcIkxTXCIsIFwiTFdcIl07XG4iLCIvKiogQ29uc3RhbnQgb2JqZWN0IGRlZmluaW5nIGFsbCB0aGUgYXZhaWxhYmxlIG91dHB1dCBuZXVyb25zLiAqL1xuZXhwb3J0IGNvbnN0IE91dHB1dE5ldXJvbnMgPSB7XG4gIC8vIFJlcHJlc2VudHMgdGhlIG91dHB1dCBuZXVyb24gZm9yIG1vdmluZyBhbG9uZyB0aGUgWC1heGlzXG4gIE1PVkVfWDogMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgb3V0cHV0IG5ldXJvbiBmb3IgbW92aW5nIGFsb25nIHRoZSBZLWF4aXNcbiAgTU9WRV9ZOiAxLFxuICAvLyBSZXByZXNlbnRzIHRoZSBvdXRwdXQgbmV1cm9uIGZvciBtb3ZpbmcgdG93YXJkcyB0aGUgTm9ydGggZGlyZWN0aW9uXG4gIE1PVkVfTk9SVEg6IDIsXG4gIC8vIFJlcHJlc2VudHMgdGhlIG91dHB1dCBuZXVyb24gZm9yIG1vdmluZyB0b3dhcmRzIHRoZSBFYXN0IGRpcmVjdGlvblxuICBNT1ZFX0VBU1Q6IDMsXG4gIC8vIFJlcHJlc2VudHMgdGhlIG91dHB1dCBuZXVyb24gZm9yIG1vdmluZyB0b3dhcmRzIHRoZSBTb3V0aCBkaXJlY3Rpb25cbiAgTU9WRV9TT1VUSDogNCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgb3V0cHV0IG5ldXJvbiBmb3IgbW92aW5nIHRvd2FyZHMgdGhlIFdlc3QgZGlyZWN0aW9uXG4gIE1PVkVfV0VTVDogNSxcbn07XG5cbi8qKiBBcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgYWJicmV2aWF0aW9ucyBmb3IgZWFjaCBvdXRwdXQgbmV1cm9uLiAqL1xuZXhwb3J0IGNvbnN0IE91dHB1dE5ldXJvblN5bWJvbHMgPSBbXCJNWFwiLCBcIk1ZXCIsIFwiTU5cIiwgXCJNRVwiLCBcIk1TXCIsIFwiTVdcIl07XG4iLCJpbXBvcnQgeyBkcmF3X25ldXJhbF9uZXRfYnJhaW4gfSBmcm9tIFwiLi4vYWxnb3JpdGhtcy9OZXVyYWxOZXREaWFncmFtXCI7XG5pbXBvcnQgeyBET01FbGVtZW50cyB9IGZyb20gXCIuLi9jb21wb25lbnRzL0RPTUVsZW1lbnRzXCI7XG5pbXBvcnQgeyBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZyB9IGZyb20gXCIuLi9jb25maWcvc2ltdWxhdGlvbi5jb25maWdcIjtcbmltcG9ydCB7IENlbGxTdGF0ZXMsIEdyaWQgfSBmcm9tIFwiLi4vZW52aXJvbm1lbnQvR3JpZFwiO1xuaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCIuLi90eXBlcy9Db29yZGluYXRlXCI7XG5pbXBvcnQgeyBtYXhfZGlzdGFuY2VfdG9fcG9pbnQgfSBmcm9tIFwiLi4vdXRpbHMvZ2V0X21heF9kaXN0YW5jZVwiO1xuaW1wb3J0IGdldF9zdHlsZSBmcm9tIFwiLi4vdXRpbHMvZ2V0X3N0eWxlXCI7XG5pbXBvcnQgeyBNb3VzZSwgTW91c2VNb2RlU3ltYm9scywgTW91c2VNb2RlcyB9IGZyb20gXCIuL21vdXNlLmNvbnRyb2xsZXJcIjtcbmltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlci5jb250cm9sbGVyXCI7XG5cbi8qKiBDbGFzcyB0byBoYW5kbGUgY2FudmFzLXJlbGF0ZWQgZXZlbnRzLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FudmFzIHtcbiAgcHVibGljIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XG4gIHB1YmxpYyBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgcHVibGljIGdyaWRfc2l6ZTogbnVtYmVyO1xuICBwdWJsaWMgcGl4ZWxfc2l6ZTogbnVtYmVyO1xuICBwdWJsaWMgem9vbV9sZXZlbDogbnVtYmVyO1xuICBwdWJsaWMgem9vbV9zcGVlZDogbnVtYmVyO1xuICBwdWJsaWMgbWluX3pvb206IG51bWJlcjtcbiAgcHVibGljIHBhbl9hbW91bnQ6IG51bWJlcjtcbiAgcHVibGljIG1vdXNlOiBNb3VzZTtcbiAgcHVibGljIHJlbmRlcmVyOiBSZW5kZXJlcjtcbiAgcHVibGljIGdyaWQ6IEdyaWQ7XG4gIHB1YmxpYyBjb25maWc6IHR5cGVvZiBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZztcbiAgcHVibGljIGdvYWxfY29vcmRpbmF0ZXM6IENvb3JkaW5hdGVbXTtcbiAgcHVibGljIG1heF9kaXN0YW5jZXNfdG9fZ29hbDogbnVtYmVyW107XG5cbiAgY29uc3RydWN0b3IoY2FudmFzX2lkOiBzdHJpbmcsIGNvbmZpZzogdHlwZW9mIERlZmF1bHRTaW11bGF0aW9uQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgLy8gR2V0IHRoZSBjYW52YXMgZWxlbWVudCBhbmQgaXRzIDJEIHJlbmRlcmluZyBjb250ZXh0XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNfaWQpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICAvLyBTZXQgdGhlIGNhbnZhcyBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSBncmlkIHNpemVcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuY29uZmlnLkdSSURfU0laRSAqIDE1O1xuICAgIHRoaXMuZ3JpZF9zaXplID0gdGhpcy5jb25maWcuR1JJRF9TSVpFO1xuICAgIHRoaXMucGl4ZWxfc2l6ZSA9ICh0aGlzLmNvbmZpZy5HUklEX1NJWkUgKiAxNSkgLyB0aGlzLmdyaWRfc2l6ZTtcbiAgICB0aGlzLnpvb21fbGV2ZWwgPSAwLjQ7XG4gICAgdGhpcy56b29tX3NwZWVkID0gMC4wMTtcbiAgICB0aGlzLm1pbl96b29tID0gMC4xO1xuICAgIHRoaXMucGFuX2Ftb3VudCA9IDUwO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcy5waXhlbF9zaXplLCB0aGlzLmdyaWRfc2l6ZSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcih0aGlzLmNhbnZhcywgdGhpcy5jdHgsIHRoaXMucGl4ZWxfc2l6ZSk7XG4gICAgdGhpcy5ncmlkID0gbmV3IEdyaWQodGhpcy5ncmlkX3NpemUsIHRoaXMucmVuZGVyZXIpO1xuICAgIHRoaXMuZ29hbF9jb29yZGluYXRlcyA9IFtdO1xuICAgIHRoaXMubWF4X2Rpc3RhbmNlc190b19nb2FsID0gW107XG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHpvb20gbGV2ZWwgYW5kIHRyYW5zZm9ybSB0aGUgY2FudmFzIGFjY29yZGluZ2x5XG4gICAgdGhpcy5jYW52YXMuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7dGhpcy56b29tX2xldmVsfSlgO1xuICAgIC8vIFJlZ2lzdGVyIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHNcbiAgICB0aGlzLnJlZ2lzdGVyX21vdXNlX2V2ZW50cygpO1xuICAgIHRoaXMucmVnaXN0ZXJfa2V5Ym9hcmRfZXZlbnRzKCk7XG4gICAgdGhpcy5yZW5kZXJlci5jbGVhcl9jYW52YXMoKTtcbiAgfVxuXG4gIC8qKiBSZWdpc3RlcnMgbW91c2UgZXZlbnRzIG9uIHRoZSBjYW52YXMuICovXG4gIHByaXZhdGUgcmVnaXN0ZXJfbW91c2VfZXZlbnRzKCk6IHZvaWQge1xuICAgIC8vIFJlZ2lzdGVyIG1vdXNlIGV2ZW50cyBvbiB0aGUgY2FudmFzLlxuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgKGUpID0+IHRoaXMubW91c2VfbW92ZShlKSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgKGUpID0+IHRoaXMubW91c2VfdXAoZSkpO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHRoaXMubW91c2VfZG93bihlKSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKGUpID0+IHRoaXMubW91c2VfZW50ZXIoZSkpO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHRoaXMubW91c2VfbGVhdmUoKSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIChlKSA9PiB0aGlzLndoZWVsKGUpKTtcbiAgfVxuXG4gIC8qKiBSZWdpc3RlcnMga2V5Ym9hcmQgZXZlbnRzIG9uIHRoZSB3aW5kb3cuICovXG4gIHByaXZhdGUgcmVnaXN0ZXJfa2V5Ym9hcmRfZXZlbnRzKCk6IHZvaWQge1xuICAgIC8vIFJlZ2lzdGVyIGtleWJvYXJkIGV2ZW50cyBvbiB0aGUgd2luZG93XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZV9rZXlfZG93bihlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG1vdXNlIG1vdmUgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBtb3ZlIGV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBtb3VzZV9tb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIG1vdXNlIG1vdmUgZXZlbnRcbiAgICB0aGlzLm1vdXNlLm1vdXNlX21vdmUoZXZlbnQpO1xuICAgIHRoaXMuaGFuZGxlX21vdXNlX21vdmUoKTtcbiAgICB0aGlzLmNoZWNrX21vdXNlX2V2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgbW91c2UgdXAgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSB1cCBldmVudC5cbiAgICovXG4gIHByaXZhdGUgbW91c2VfdXAoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgbW91c2UgdXAgZXZlbnRcbiAgICB0aGlzLm1vdXNlLm1vdXNlX3VwKGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG1vdXNlIGRvd24gZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBkb3duIGV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBtb3VzZV9kb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5tb3VzZS5tb3VzZV9kb3duKGV2ZW50KTtcbiAgICB0aGlzLmNoZWNrX21vdXNlX2V2ZW50cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgbW91c2UgZW50ZXIgZXZlbnQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBlbnRlciBldmVudC5cbiAgICovXG4gIHByaXZhdGUgbW91c2VfZW50ZXIoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAvLyBIYW5kbGUgbW91c2UgZW50ZXIgZXZlbnRcbiAgICB0aGlzLm1vdXNlLm1vdXNlX2VudGVyKGV2ZW50KTtcbiAgICB0aGlzLmhhbmRsZV9tb3VzZV9tb3ZlKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBtb3VzZSBsZWF2ZSBldmVudC5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG1vdXNlIGxlYXZlIGV2ZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBtb3VzZV9sZWF2ZSgpOiB2b2lkIHtcbiAgICB0aGlzLm1vdXNlLm1vdXNlX2xlYXZlKCk7XG4gICAgdGhpcy5oYW5kbGVfbW91c2VfbGVhdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG1vdXNlIHdoZWVsIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAqL1xuICBwcml2YXRlIHdoZWVsKGV2ZW50OiBXaGVlbEV2ZW50KTogdm9pZCB7XG4gICAgLy8gSGFuZGxlIG1vdXNlIHdoZWVsIGV2ZW50XG4gICAgdGhpcy5oYW5kbGVfbW91c2Vfd2hlZWwoZXZlbnQpO1xuICB9XG5cbiAgLyoqIENoZWNrcyBhbmQgcGVyZm9ybXMgbW91c2UtcmVsYXRlZCBhY3Rpb25zIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1vZGUgKi9cbiAgcHJpdmF0ZSBjaGVja19tb3VzZV9ldmVudHMoKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICBpZiAodGhpcy5tb3VzZS5sZWZ0X2NsaWNrKSB7XG4gICAgICAvLyBHZXQgdGhlIGNlbGwgYXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdyaWQuZ2V0X2NlbGxfYXQodGhpcy5tb3VzZS5ncmlkX2Nvb3JkKTtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IG1vZGUgaXMgZ29hbCwgY2hlY2sgaWYgdGhlIGNlbGwgaXMgc2VsZWN0ZWQsIGFuZCBhZGQgb3IgcmVtb3ZlIGl0IGZyb20gdGhlIGdvYWwgY29vcmRpbmF0ZXMuXG4gICAgICBpZiAodGhpcy5tb3VzZS5tb2RlID09IE1vdXNlTW9kZXMuR09BTCkge1xuICAgICAgICBpZiAoY2VsbC5pc19zZWxlY3RlZCkge1xuICAgICAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBnb2FsIGNvb3JkaW5hdGUgYW5kIGl0cyBtYXggZGlzdGFuY2VcbiAgICAgICAgICB0aGlzLmdvYWxfY29vcmRpbmF0ZXMuc3BsaWNlKHRoaXMuZ29hbF9jb29yZGluYXRlcy5pbmRleE9mKGNlbGwuY29vcmRpbmF0ZSksIDEpO1xuICAgICAgICAgIHRoaXMubWF4X2Rpc3RhbmNlc190b19nb2FsLnNwbGljZSh0aGlzLmdvYWxfY29vcmRpbmF0ZXMuaW5kZXhPZihjZWxsLmNvb3JkaW5hdGUpLCAxKTtcbiAgICAgICAgICB0aGlzLmdyaWQuc2V0X2NlbGxfc2VsZWN0ZWQoY2VsbC5jb29yZGluYXRlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRkIHNlbGVjdGVkIGdvYWwgY29vcmRpbmF0ZSBhbmQgaXRzIG1heCBkaXN0YW5jZVxuICAgICAgICAgIHRoaXMuZ29hbF9jb29yZGluYXRlcy5wdXNoKGNlbGwuY29vcmRpbmF0ZSk7XG4gICAgICAgICAgdGhpcy5tYXhfZGlzdGFuY2VzX3RvX2dvYWwucHVzaChtYXhfZGlzdGFuY2VfdG9fcG9pbnQodGhpcy5jb25maWcuR1JJRF9TSVpFLCBjZWxsLmNvb3JkaW5hdGUueCwgY2VsbC5jb29yZGluYXRlLnkpKTtcbiAgICAgICAgICB0aGlzLmdyaWQuc2V0X2NlbGxfc2VsZWN0ZWQoY2VsbC5jb29yZGluYXRlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vdXNlLm1vZGUgPT0gTW91c2VNb2Rlcy5JRExFKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG1vZGUgaXMgaWRsZSwgY2hlY2sgaWYgdGhlIGNlbGwgaXMgYW4gb3JnYW5pc20sIGFuZCBjcmVhdGUgaXRzIG5ldXJhbCBuZXR3b3JrIGRpYWdyYW0uXG4gICAgICAgIGlmIChjZWxsLnN0YXRlID09IENlbGxTdGF0ZXMuT1JHQU5JU00gJiYgY2VsbC5vd25lcj8uYnJhaW4uY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAvLyBEaXNwbGF5IHNlbGVjdGVkIG9yZ2FuaXNtJ3MgbmV1cmFsIG5ldHdvcmsgZGlhZ3JhbVxuICAgICAgICAgIERPTUVsZW1lbnRzLm9yZ2FuaXNtX3NlbGVjdGVkLmlubmVySFRNTCA9IFwiT3JnYW5pc20gc2VsZWN0ZWRcIjtcbiAgICAgICAgICBET01FbGVtZW50cy5vcmdhbmlzbV9zZWxlY3RlZF90YWJsZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgICAgICAgZHJhd19uZXVyYWxfbmV0X2JyYWluKGNlbGwub3duZXIuYnJhaW4uY29ubmVjdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENsZWFyIG9yZ2FuaXNtIHNlbGVjdGVkIG1lc3NhZ2UgYW5kIGhpZGUgbmV1cmFsIG5ldHdvcmsgZGlhZ3JhbSBkb3dubG9hZCBidXR0b24uXG4gICAgICAgICAgRE9NRWxlbWVudHMub3JnYW5pc21fc2VsZWN0ZWQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICBET01FbGVtZW50cy5vcmdhbmlzbV9zZWxlY3RlZF90YWJsZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3VzZS5tb2RlID09IE1vdXNlTW9kZXMuUEFOKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG1vZGUgaXMgcGFuLCBtb3ZlIHRoZSBjYW52YXMgYmFzZWQgb24gdGhlIG1vdXNlIG1vdmVtZW50LlxuICAgICAgICBjb25zdCBjYW52YXNfdG9wID0gcGFyc2VJbnQoZ2V0X3N0eWxlKFwiY2FudmFzXCIsIFwidG9wXCIpKTtcbiAgICAgICAgY29uc3QgY2FudmFzX2xlZnQgPSBwYXJzZUludChnZXRfc3R5bGUoXCJjYW52YXNcIiwgXCJsZWZ0XCIpKTtcbiAgICAgICAgLy8gQWRkIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24gYW5kIHRoZSBjbGlja2VkIG1vdXNlIHBvc2l0aW9uIHRvIHRoZSBjYW52YXMgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IGNhbnZhc190b3AgKyAodGhpcy5tb3VzZS5jYW52YXNfY29vcmQueSAtIHRoaXMubW91c2UuY2xpY2tlZF9jb29yZC55KSAqIHRoaXMuem9vbV9sZXZlbCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IGNhbnZhc19sZWZ0ICsgKHRoaXMubW91c2UuY2FudmFzX2Nvb3JkLnggLSB0aGlzLm1vdXNlLmNsaWNrZWRfY29vcmQueCkgKiB0aGlzLnpvb21fbGV2ZWwgKyBcInB4XCI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW91c2UubW9kZSA9PSBNb3VzZU1vZGVzLldBTEwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgbW9kZSBpcyB3YWxsIGFuZCB0aGVyZSBpcyBubyBvd25lciBpbiB0aGUgc2VsZWN0ZWQgY2VsbCwgc2V0IHRoZSBjZWxsIHN0YXRlIHRvIHdhbGwuXG4gICAgICAgIGlmICghY2VsbC5vd25lcikge1xuICAgICAgICAgIHRoaXMuZ3JpZC5zZXRfY2VsbF9zdGF0ZSh0aGlzLm1vdXNlLmdyaWRfY29vcmQsIENlbGxTdGF0ZXMuV0FMTCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3VzZS5tb2RlID09IE1vdXNlTW9kZXMuUkFESU9BQ1RJVkUpIHtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgbW9kZSBpcyByYWRpb2FjdGl2ZSBhbmQgdGhlcmUgaXMgbm8gb3duZXIgaW4gdGhlIHNlbGVjdGVkIGNlbGwsIHNldCB0aGUgY2VsbCBzdGF0ZSB0byByYWRpb2FjdGl2ZS5cbiAgICAgICAgaWYgKCFjZWxsLm93bmVyKSB7XG4gICAgICAgICAgdGhpcy5ncmlkLnNldF9jZWxsX3N0YXRlKHRoaXMubW91c2UuZ3JpZF9jb29yZCwgQ2VsbFN0YXRlcy5SQURJT0FDVElWRSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3VzZS5tb2RlID09IE1vdXNlTW9kZXMuUkVNT1ZFKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG1vZGUgaXMgcmVtb3ZlIGFuZCB0aGVyZSBpcyBubyBvd25lciBpbiB0aGUgc2VsZWN0ZWQgY2VsbCwgY2xlYXIgdGhlIGNlbGwgc3RhdGUuXG4gICAgICAgIGlmICghY2VsbC5vd25lcikge1xuICAgICAgICAgIHRoaXMuZ3JpZC5jbGVhcl9jZWxsX3N0YXRlKHRoaXMubW91c2UuZ3JpZF9jb29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBrZXlib2FyZCBrZXkgZG93biBldmVudHMuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudC5cbiAgICovXG4gIHByaXZhdGUgaGFuZGxlX2tleV9kb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgLy8gT2J0YWluIGNhbnZhcyB0b3AgYW5kIGxlZnQgc3R5bGUgdmFsdWVzXG4gICAgY29uc3QgY2FudmFzX3RvcCA9IHBhcnNlSW50KGdldF9zdHlsZShcImNhbnZhc1wiLCBcInRvcFwiKSk7XG4gICAgY29uc3QgY2FudmFzX2xlZnQgPSBwYXJzZUludChnZXRfc3R5bGUoXCJjYW52YXNcIiwgXCJsZWZ0XCIpKTtcblxuICAgIC8vIElmIHRoZSBXQVNEIGtleXMgYXJlIHByZXNzZWQsIHBhbiB0aGUgY2FudmFzIGJ5IGFkZGluZyBvciBzdWJ0cmFjdGluZyB0aGUgcGFuIGFtb3VudCBmcm9tIHRoZSBjYW52YXMgdG9wIG9yIGxlZnQgc3R5bGUgdmFsdWVzLlxuICAgIGlmIChldmVudC5jb2RlID09IFwiS2V5RFwiKSB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gY2FudmFzX2xlZnQgLSB0aGlzLnBhbl9hbW91bnQgKyBcInB4XCI7XG4gICAgZWxzZSBpZiAoZXZlbnQuY29kZSA9PSBcIktleUFcIikgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IGNhbnZhc19sZWZ0ICsgdGhpcy5wYW5fYW1vdW50ICsgXCJweFwiO1xuICAgIGVsc2UgaWYgKGV2ZW50LmNvZGUgPT0gXCJLZXlTXCIpIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IGNhbnZhc190b3AgLSB0aGlzLnBhbl9hbW91bnQgKyBcInB4XCI7XG4gICAgZWxzZSBpZiAoZXZlbnQuY29kZSA9PSBcIktleVdcIikgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gY2FudmFzX3RvcCArIHRoaXMucGFuX2Ftb3VudCArIFwicHhcIjtcbiAgICAvLyBJZiB0aGUgMS02IGtleXMgYXJlIHByZXNzZWQsIGNoYW5nZSB0aGUgY3VycmVudCBtb2RlLlxuICAgIGVsc2UgaWYgKGV2ZW50LmNvZGUgPT0gXCJEaWdpdDFcIikgdGhpcy5tb3VzZS5tb2RlID0gTW91c2VNb2Rlcy5JRExFO1xuICAgIGVsc2UgaWYgKGV2ZW50LmNvZGUgPT0gXCJEaWdpdDJcIikgdGhpcy5tb3VzZS5tb2RlID0gTW91c2VNb2Rlcy5QQU47XG4gICAgZWxzZSBpZiAoZXZlbnQuY29kZSA9PSBcIkRpZ2l0M1wiKSB0aGlzLm1vdXNlLm1vZGUgPSBNb3VzZU1vZGVzLkdPQUw7XG4gICAgZWxzZSBpZiAoZXZlbnQuY29kZSA9PSBcIkRpZ2l0NFwiKSB0aGlzLm1vdXNlLm1vZGUgPSBNb3VzZU1vZGVzLldBTEw7XG4gICAgZWxzZSBpZiAoZXZlbnQuY29kZSA9PSBcIkRpZ2l0NVwiKSB0aGlzLm1vdXNlLm1vZGUgPSBNb3VzZU1vZGVzLlJBRElPQUNUSVZFO1xuICAgIGVsc2UgaWYgKGV2ZW50LmNvZGUgPT0gXCJEaWdpdDZcIikgdGhpcy5tb3VzZS5tb2RlID0gTW91c2VNb2Rlcy5SRU1PVkU7XG5cbiAgICAvLyBEaXNwbGF5IHRoZSBjdXJyZW50IG1vZGUgb24gdGhlIERPTVxuICAgIERPTUVsZW1lbnRzLm1vZGUuaW5uZXJIVE1MID0gTW91c2VNb2RlU3ltYm9sc1t0aGlzLm1vdXNlLm1vZGVdO1xuICB9XG5cbiAgLy8gSGFuZGxlcyBtb3VzZSB3aGVlbCBldmVudCBmb3Igem9vbWluZyBhbmQgcGFubmluZ1xuICBwcml2YXRlIGhhbmRsZV9tb3VzZV93aGVlbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuICAgIC8vIERldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIG1vdXNlIHdoZWVsIHNjcm9sbFxuICAgIGNvbnN0IHNpZ24gPSAtTWF0aC5zaWduKGV2ZW50LmRlbHRhWSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlIGJ5IHRha2luZyB0aGUgbWF4aW11bSBiZXR3ZWVuIHRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgYW5kIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgcGx1cyB0aGUgc2lnbiBvZiB0aGUgbW91c2Ugd2hlZWwgc2Nyb2xsIG11bHRpcGxpZWQgYnkgdGhlIHpvb20gc3BlZWQuXG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heCh0aGlzLm1pbl96b29tLCB0aGlzLnpvb21fbGV2ZWwgKyBzaWduICogdGhpcy56b29tX3NwZWVkKTtcblxuICAgIC8vIE9idGFpbiB0aGUgY3VycmVudCB0b3AgYW5kIGxlZnQgc3R5bGUgdmFsdWVzIGZvciB0aGUgY2FudmFzXG4gICAgY29uc3QgY2FudmFzX3RvcCA9IHBhcnNlSW50KGdldF9zdHlsZShcImNhbnZhc1wiLCBcInRvcFwiKSk7XG4gICAgY29uc3QgY2FudmFzX2xlZnQgPSBwYXJzZUludChnZXRfc3R5bGUoXCJjYW52YXNcIiwgXCJsZWZ0XCIpKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzcGxhY2VtZW50IGluIFggYW5kIFkgZnJvbSB6b29taW5nXG4gICAgY29uc3QgZHggPSAodGhpcy5jYW52YXMud2lkdGggLyAyIC0gdGhpcy5tb3VzZS5jYW52YXNfY29vcmQueCkgKiAoc2NhbGUgLSB0aGlzLnpvb21fbGV2ZWwpO1xuICAgIGNvbnN0IGR5ID0gKHRoaXMuY2FudmFzLmhlaWdodCAvIDIgLSB0aGlzLm1vdXNlLmNhbnZhc19jb29yZC55KSAqIChzY2FsZSAtIHRoaXMuem9vbV9sZXZlbCk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHRvcCBhbmQgbGVmdCBzdHlsZXMgZm9yIGNhbnZhcyBiYXNlZCBvbiB0aGUgem9vbSBsZXZlbCBhbmQgbW91c2UgcG9zaXRpb25cbiAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSBjYW52YXNfdG9wICsgZHkgKyBcInB4XCI7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IGNhbnZhc19sZWZ0ICsgZHggKyBcInB4XCI7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHpvb20gbGV2ZWwgYW5kIGFwcGx5IHRoZSBDU1Mgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGNhbnZhc1xuICAgIHRoaXMuem9vbV9sZXZlbCA9IHNjYWxlO1xuICAgIHRoaXMuY2FudmFzLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3RoaXMuem9vbV9sZXZlbH0pYDtcbiAgfVxuXG4gIC8vIEhhbmRsZXMgdGhlIGFjdGlvbiB0byBoaWdobGlnaHQgY2VsbHMgdXBvbiBtb3VzZSBtb3ZlLlxuICBwcml2YXRlIGhhbmRsZV9tb3VzZV9tb3ZlKCk6IHZvaWQge1xuICAgIC8vIENsZWFyIHRoZSBoaWdobGlnaHQgZnJvbSB0aGUgcHJldmlvdXNseSBoaWdobGlnaHRlZCBjZWxsXG4gICAgdGhpcy5ncmlkLnNldF9jZWxsX2hpZ2hsaWdodGVkKHRoaXMubW91c2UucHJldl9ncmlkX2Nvb3JkLCBmYWxzZSk7XG4gICAgLy8gU2V0IHRoZSBjdXJyZW50IGNlbGwgdW5kZXIgdGhlIG1vdXNlIHBvaW50ZXIgYXMgaGlnaGxpZ2h0ZWRcbiAgICB0aGlzLmdyaWQuc2V0X2NlbGxfaGlnaGxpZ2h0ZWQodGhpcy5tb3VzZS5ncmlkX2Nvb3JkLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBtb3VzZSBsZWF2ZSBjYW52YXMuXG4gIHByaXZhdGUgaGFuZGxlX21vdXNlX2xlYXZlKCk6IHZvaWQge1xuICAgIC8vIEhhbmRsZSBtb3VzZSBsZWF2ZSBldmVudFxuICAgIC8vIGNvbnN0IGNlbGwgPSB0aGlzLmdyaWQuZ2V0X2NlbGxfYXQodGhpcy5tb3VzZS5ncmlkX2Nvb3JkKTtcbiAgICAvLyBpZiAoY2VsbC5pc19oaWdobGlnaHRlZCkge1xuICAgIC8vICAgdGhpcy5ncmlkLnNldF9jZWxsX2hpZ2hsaWdodGVkKHRoaXMubW91c2UuZ3JpZF9jb29yZCwgZmFsc2UpO1xuICAgIC8vIH1cbiAgfVxufVxuIiwiaW1wb3J0IENhbnZhc0pTIGZyb20gXCJAY2FudmFzanMvY2hhcnRzXCI7XG5cbi8qKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGEgY2hhcnQgY29udHJvbGxlciB0aGF0IGNhbiBiZSB1c2VkIHRvIHN3aXRjaCBiZXR3ZWVuIGNoYXJ0cy4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJ0Q29udHJvbGxlciB7XG4gIHB1YmxpYyBjaGFydDogQ2FudmFzSlMuQ2hhcnQ7XG4gIHB1YmxpYyBjb25maWdzOiBvYmplY3RbXTtcbiAgcHVibGljIGNoYXJ0X2lkOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0X2lkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmNvbmZpZ3MgPSBbXTtcbiAgICB0aGlzLmNoYXJ0X2lkID0gY2hhcnRfaWQ7XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIHRoZSBjaGFydCB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGNoYXJ0IHRvIHN3aXRjaCB0by5cbiAgICovXG4gIHB1YmxpYyBzd2l0Y2hfY2hhcnQoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2FudmFzSlMuQ2hhcnQodGhpcy5jaGFydF9pZCwgdGhpcy5jb25maWdzW2luZGV4XSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFydCBjb25maWd1cmF0aW9uIHRvIHRoZSBjaGFydCBjb250cm9sbGVyLlxuICAgKiBAcGFyYW0gdGl0bGUgLSBUaGUgdGl0bGUgb2YgdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0geF9heGlzIC0gVGhlIHRpdGxlIG9mIHRoZSB4LWF4aXMuXG4gICAqIEBwYXJhbSB5X2F4aXMgLSBUaGUgdGl0bGUgb2YgdGhlIHktYXhpcy5cbiAgICogQHBhcmFtIGRhdGFfcG9pbnRzIC0gVGhlIGRhdGEgcG9pbnRzIHRvIGRpc3BsYXkgb24gdGhlIGNoYXJ0LlxuICAgKiBAcGFyYW0gbWF4IC0gVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIHktYXhpcy5cbiAgICovXG4gIHB1YmxpYyBhZGRfY29uZmlnKHRpdGxlLCB4X2F4aXMsIHlfYXhpcywgZGF0YV9wb2ludHMsIG1heDogbnVtYmVyIHwgbnVsbCA9IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZ3MucHVzaCh7XG4gICAgICB0aXRsZToge1xuICAgICAgICB0ZXh0OiB0aXRsZSxcbiAgICAgIH0sXG4gICAgICBheGlzWToge1xuICAgICAgICB0aXRsZTogeV9heGlzLFxuICAgICAgICBtYXhpbXVtOiBtYXgsXG4gICAgICB9LFxuICAgICAgYXhpc1g6IHtcbiAgICAgICAgdGl0bGU6IHhfYXhpcyxcbiAgICAgICAgbWluaW11bTogMCxcbiAgICAgIH0sXG4gICAgICB6b29tRW5hYmxlZDogdHJ1ZSxcblxuICAgICAgZGF0YTogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJEYXRhXCIsXG4gICAgICAgICAgdHlwZTogXCJhcmVhXCIsXG4gICAgICAgICAgY29sb3I6IFwicmdiYSg2OSw2NSw4OCwwLjUpXCIsXG4gICAgICAgICAgbWFya2VyU2l6ZTogMCxcbiAgICAgICAgICBkYXRhUG9pbnRzOiBkYXRhX3BvaW50cyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERlZmF1bHRTaW11bGF0aW9uQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZy9zaW11bGF0aW9uLmNvbmZpZ1wiO1xuXG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgYSBzaW5nbGV0b24gY29uZmlndXJhdGlvbiBjb250cm9sbGVyIHRoYXRcbiAqIGNhbiBiZSB1c2VkIHRvIHN0b3JlIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25maWdDb250cm9sbGVyIHtcbiAgLy8gU2luZ2xldG9uIGluc3RhbmNlXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBDb25maWdDb250cm9sbGVyO1xuICAvLyBDb25maWd1cmF0aW9uIG9iamVjdFxuICBwcml2YXRlIF9jb25maWc6IHR5cGVvZiBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZztcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NvbmZpZyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBDb25maWdDb250cm9sbGVyXG4gICAqIEByZXR1cm5zIFRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgQ29uZmlnQ29udHJvbGxlclxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRfaW5zdGFuY2UoKTogQ29uZmlnQ29udHJvbGxlciB7XG4gICAgLy8gSWYgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKCFDb25maWdDb250cm9sbGVyLmluc3RhbmNlKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZVxuICAgICAgQ29uZmlnQ29udHJvbGxlci5pbnN0YW5jZSA9IG5ldyBDb25maWdDb250cm9sbGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBDb25maWdDb250cm9sbGVyLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgKiBAcmV0dXJucyBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbmZpZygpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICAvLyBSZXR1cm4gdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICogQHBhcmFtIG5ld192YWx1ZSAtIFRoZSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAqL1xuICBwdWJsaWMgc2V0IGNvbmZpZyhuZXdfdmFsdWU6IHR5cGVvZiBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IG5ld192YWx1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCIuLi90eXBlcy9Db29yZGluYXRlXCI7XG5pbXBvcnQgeyBtYWtlX3ZlY3RvciB9IGZyb20gXCIuLi91dGlscy9nZW9tZXRyeVwiO1xuXG4vLyBEZWZpbmUgdGhlIGRpZmZlcmVudCBtb2RlcyBmb3IgbW91c2UgaW50ZXJhY3Rpb24uXG5leHBvcnQgY29uc3QgTW91c2VNb2RlU3ltYm9scyA9IFtcIklETEVcIiwgXCJQQU5cIiwgXCJHT0FMXCIsIFwiV0FMTFwiLCBcIlJBRElPQUNUSVZFXCIsIFwiUkVNT1ZFXCJdO1xuXG4vLyBNb2Rlc0VudW0gaXMgdXNlZCB0byBhY2Nlc3MgdGhlIGRpZmZlcmVudCBtb2RlcyBieSBpbmRleC5cbmV4cG9ydCBjb25zdCBNb3VzZU1vZGVzID0ge1xuICBJRExFOiAwLFxuICBQQU46IDEsXG4gIEdPQUw6IDIsXG4gIFdBTEw6IDMsXG4gIFJBRElPQUNUSVZFOiA0LFxuICBSRU1PVkU6IDUsXG59O1xuXG4vKiogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1vdXNlIGNvbnRyb2xsZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBtYW5hZ2UgbW91c2UgZXZlbnRzLiAqL1xuZXhwb3J0IGNsYXNzIE1vdXNlIHtcbiAgcHVibGljIGdyaWRfc2l6ZTogbnVtYmVyO1xuICBwdWJsaWMgbWlkZGxlX2NsaWNrOiBib29sZWFuO1xuICBwdWJsaWMgbGVmdF9jbGljazogYm9vbGVhbjtcbiAgcHVibGljIHJpZ2h0X2NsaWNrOiBib29sZWFuO1xuICBwdWJsaWMgcGl4ZWxfc2l6ZTogbnVtYmVyO1xuICBwdWJsaWMgbW9kZTogbnVtYmVyO1xuICBwdWJsaWMgZ3JpZF9jb29yZDogQ29vcmRpbmF0ZTtcbiAgcHVibGljIHByZXZfZ3JpZF9jb29yZDogQ29vcmRpbmF0ZTtcbiAgcHVibGljIGNhbnZhc19jb29yZDogQ29vcmRpbmF0ZTtcbiAgcHVibGljIGNsaWNrZWRfY29vcmQ6IENvb3JkaW5hdGU7XG5cbiAgY29uc3RydWN0b3IocGl4ZWxfc2l6ZTogbnVtYmVyLCBncmlkX3NpemU6IG51bWJlcikge1xuICAgIHRoaXMuZ3JpZF9zaXplID0gZ3JpZF9zaXplO1xuICAgIHRoaXMuZ3JpZF9jb29yZCA9IG1ha2VfdmVjdG9yKDAsIDApO1xuICAgIHRoaXMucHJldl9ncmlkX2Nvb3JkID0gbWFrZV92ZWN0b3IoMCwgMCk7XG4gICAgdGhpcy5jYW52YXNfY29vcmQgPSBtYWtlX3ZlY3RvcigwLCAwKTtcbiAgICB0aGlzLmNsaWNrZWRfY29vcmQgPSBtYWtlX3ZlY3RvcigwLCAwKTtcbiAgICB0aGlzLm1pZGRsZV9jbGljayA9IGZhbHNlO1xuICAgIHRoaXMubGVmdF9jbGljayA9IGZhbHNlO1xuICAgIHRoaXMucmlnaHRfY2xpY2sgPSBmYWxzZTtcbiAgICB0aGlzLnBpeGVsX3NpemUgPSBwaXhlbF9zaXplO1xuICAgIHRoaXMubW9kZSA9IE1vdXNlTW9kZXMuSURMRTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgaW4gdGhlIGNhbnZhcy5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIG1vdXNlIG1vdmUgZXZlbnQuXG4gICAqL1xuICBwdWJsaWMgbW91c2VfbW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIGNvb3JkaW5hdGVzIGJhc2VkIG9uIG1vdXNlIHBvc2l0aW9uLlxuICAgIHRoaXMuY2FudmFzX2Nvb3JkLnggPSBldmVudC5vZmZzZXRYO1xuICAgIHRoaXMuY2FudmFzX2Nvb3JkLnkgPSBldmVudC5vZmZzZXRZO1xuXG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGdyaWQgY29vcmRpbmF0ZXMuXG4gICAgdGhpcy5wcmV2X2dyaWRfY29vcmQueCA9IHRoaXMuZ3JpZF9jb29yZC54O1xuICAgIHRoaXMucHJldl9ncmlkX2Nvb3JkLnkgPSB0aGlzLmdyaWRfY29vcmQueTtcblxuICAgIC8vIENhbGN1bGF0ZSBuZXcgZ3JpZCBjb29yZGluYXRlcyBiYXNlZCBvbiB0aGUgY2FudmFzIGFuZCBwaXhlbCBzaXplLlxuICAgIHRoaXMuZ3JpZF9jb29yZC54ID0gTWF0aC5mbG9vcih0aGlzLmNhbnZhc19jb29yZC54IC8gdGhpcy5waXhlbF9zaXplKTtcbiAgICB0aGlzLmdyaWRfY29vcmQueSA9IE1hdGguZmxvb3IodGhpcy5jYW52YXNfY29vcmQueSAvIHRoaXMucGl4ZWxfc2l6ZSk7XG5cbiAgICAvLyBGaXggZ3JpZCBjb29yZGluYXRlcyB3aXRoaW4gY2FudmFzIGJvdW5kYXJpZXMuXG4gICAgaWYgKHRoaXMuZ3JpZF9jb29yZC54ID49IHRoaXMuZ3JpZF9zaXplKSB0aGlzLmdyaWRfY29vcmQueCAtPSAxO1xuICAgIGlmICh0aGlzLmdyaWRfY29vcmQueSA+PSB0aGlzLmdyaWRfc2l6ZSkgdGhpcy5ncmlkX2Nvb3JkLnkgLT0gMTtcbiAgICBpZiAodGhpcy5ncmlkX2Nvb3JkLnggPD0gMCkgdGhpcy5ncmlkX2Nvb3JkLnggPSAwO1xuICAgIGlmICh0aGlzLmdyaWRfY29vcmQueSA8PSAwKSB0aGlzLmdyaWRfY29vcmQueSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIG1vdXNlIGNsaWNrIGlzIHJlbGVhc2VkLlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbW91c2UgdXAgZXZlbnQuXG4gICAqL1xuICBwdWJsaWMgbW91c2VfdXAoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gSWRlbnRpZnkgYW5kIGhhbmRsZSBkaWZmZXJlbnQgbW91c2UgYnV0dG9ucyB1cG9uIHJlbGVhc2UuXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMCkgdGhpcy5sZWZ0X2NsaWNrID0gZmFsc2U7IC8vIExlZnQgbW91c2UgYnV0dG9uIHJlbGVhc2VkXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSkgdGhpcy5taWRkbGVfY2xpY2sgPSBmYWxzZTsgLy8gTWlkZGxlIG1vdXNlIGJ1dHRvbiByZWxlYXNlZFxuICAgIGlmIChldmVudC5idXR0b24gPT09IDIpIHRoaXMucmlnaHRfY2xpY2sgPSBmYWxzZTsgLy8gUmlnaHQgbW91c2UgYnV0dG9uIHJlbGVhc2VkXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIG1vdXNlIGlzIGNsaWNrZWQuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBkb3duIGV2ZW50LlxuICAgKi9cbiAgcHVibGljIG1vdXNlX2Rvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gSWRlbnRpZnkgYW5kIHNldCBmbGFncyBmb3IgZGlmZmVyZW50IG1vdXNlIGJ1dHRvbnMgdXBvbiBjbGljay5cbiAgICB0aGlzLmxlZnRfY2xpY2sgPSBldmVudC5idXR0b24gPT09IDA7IC8vIExlZnQgbW91c2UgYnV0dG9uIGNsaWNrZWRcbiAgICB0aGlzLm1pZGRsZV9jbGljayA9IGV2ZW50LmJ1dHRvbiA9PT0gMTsgLy8gTWlkZGxlIG1vdXNlIGJ1dHRvbiBjbGlja2VkXG4gICAgdGhpcy5yaWdodF9jbGljayA9IGV2ZW50LmJ1dHRvbiA9PT0gMjsgLy8gUmlnaHQgbW91c2UgYnV0dG9uIGNsaWNrZWRcblxuICAgIC8vIFN0b3JlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY2xpY2suXG4gICAgdGhpcy5jbGlja2VkX2Nvb3JkLnggPSB0aGlzLmNhbnZhc19jb29yZC54O1xuICAgIHRoaXMuY2xpY2tlZF9jb29yZC55ID0gdGhpcy5jYW52YXNfY29vcmQueTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgbW91c2UgZW50ZXJzIHRoZSBjYW52YXMuXG4gICAqIEBwYXJhbSBldmVudCAtIFRoZSBtb3VzZSBlbnRlciBldmVudC5cbiAgICovXG4gIHB1YmxpYyBtb3VzZV9lbnRlcihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIC8vIElkZW50aWZ5IGFuZCBzZXQgZmxhZ3MgZm9yIGRpZmZlcmVudCBtb3VzZSBidXR0b25zIHVwb24gZW50ZXJpbmcgdGhlIGNhbnZhcy5cbiAgICB0aGlzLmxlZnRfY2xpY2sgPSAhIShldmVudC5idXR0b25zICYgMSk7IC8vIExlZnQgbW91c2UgYnV0dG9uIGNsaWNrZWRcbiAgICB0aGlzLnJpZ2h0X2NsaWNrID0gISEoZXZlbnQuYnV0dG9ucyAmIDIpOyAvLyBSaWdodCBtb3VzZSBidXR0b24gY2xpY2tlZFxuICAgIHRoaXMubWlkZGxlX2NsaWNrID0gISEoZXZlbnQuYnV0dG9ucyAmIDQpOyAvLyBNaWRkbGUgbW91c2UgYnV0dG9uIGNsaWNrZWRcblxuICAgIC8vIFN0b3JlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbW91c2UgcG9pbnRlciB1cG9uIGVudGVyaW5nIHRoZSBjYW52YXMuXG4gICAgdGhpcy5jbGlja2VkX2Nvb3JkLnggPSB0aGlzLmNhbnZhc19jb29yZC54O1xuICAgIHRoaXMuY2xpY2tlZF9jb29yZC55ID0gdGhpcy5jYW52YXNfY29vcmQueTtcbiAgfVxuXG4gIC8qKiBUaGlzIG1ldGhvZCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgbW91c2UgbGVhdmVzIHRoZSBjYW52YXMuICovXG4gIHB1YmxpYyBtb3VzZV9sZWF2ZSgpOiB2b2lkIHtcbiAgICAvLyBMZWZ0IG1vdXNlIGJ1dHRvbiByZWxlYXNlZFxuICAgIHRoaXMubGVmdF9jbGljayA9IGZhbHNlO1xuICAgIC8vIE1pZGRsZSBtb3VzZSBidXR0b24gcmVsZWFzZWRcbiAgICB0aGlzLm1pZGRsZV9jbGljayA9IGZhbHNlO1xuICAgIC8vIFJpZ2h0IG1vdXNlIGJ1dHRvbiByZWxlYXNlZFxuICAgIHRoaXMucmlnaHRfY2xpY2sgPSBmYWxzZTtcbiAgfVxufVxuIiwiaW1wb3J0IFRoZW1lQ29uZmlnIGZyb20gXCIuLi9jb25maWcvdGhlbWUuY29uZmlnXCI7XG5pbXBvcnQgeyBDZWxsU3RhdGVzLCBHcmlkQ2VsbCB9IGZyb20gXCIuLi9lbnZpcm9ubWVudC9HcmlkXCI7XG5pbXBvcnQgUXVldWUgZnJvbSBcIi4uL3N0cnVjdHVyZXMvUXVldWVcIjtcbmltcG9ydCB7IHRvX2FuZ2xlIH0gZnJvbSBcIi4uL3V0aWxzL2dlb21ldHJ5XCI7XG5cbi8qKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGEgcmVuZGVyZXIgdGhhdCBjYW4gYmUgdXNlZCB0byByZW5kZXIgdGhlIHNpbXVsYXRpb24uICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJlciB7XG4gIHB1YmxpYyBjYW52YXM7XG4gIHB1YmxpYyBjdHg7XG4gIHB1YmxpYyBwaXhlbF9zaXplO1xuICBwdWJsaWMgdG9fZmlsbDogUXVldWU7XG4gIHB1YmxpYyB0b19jbGVhcjogUXVldWU7XG5cbiAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHBpeGVsX3NpemU6IG51bWJlcikge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMucGl4ZWxfc2l6ZSA9IHBpeGVsX3NpemU7XG4gICAgdGhpcy50b19maWxsID0gbmV3IFF1ZXVlKCk7XG4gICAgdGhpcy50b19jbGVhciA9IG5ldyBRdWV1ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIGEgcmVjdGFuZ2xlIG9uIHRoZSBjYW52YXMuXG4gICAqIEBwYXJhbSBjZWxsIC0gVGhlIGNlbGwgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0geCAtIFRoZSB4LWNvb3JkaW5hdGUgdG8gc3RhcnQgZHJhd2luZyBmcm9tLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgdG8gc3RhcnQgZHJhd2luZyBmcm9tLlxuICAgKiBAcGFyYW0gd2lkdGggLSBUaGUgd2lkdGggdGhlIGNvbXBvbmVudCB0byBkcmF3LlxuICAgKiBAcGFyYW0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IHRvIGRyYXcuXG4gICAqIEBwYXJhbSBjb2xvdXIgLSBUaGUgY29sb3VyIG9mIHRoZSBjb21wb25lbnQgdG8gZHJhdy5cbiAgICovXG4gIHByaXZhdGUgZHJhd19yZWN0KGNlbGw6IEdyaWRDZWxsLCB4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGNvbG91cjogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gU2V0IHRoZSBmaWxsIHN0eWxlIHRvIHRoZSBzcGVjaWZpZWQgY29sb3VyLlxuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG91cjtcblxuICAgIC8vIEZpbGwgYSByZWN0YW5nbGUgb24gdGhlIGNhbnZhcyByZXByZXNlbnRpbmcgdGhlIGNlbGwuXG4gICAgdGhpcy5jdHguZmlsbFJlY3QoY2VsbC5jb29yZGluYXRlLnggKiAxNSArIHgsIGNlbGwuY29vcmRpbmF0ZS55ICogMTUgKyB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGFuIG9yZ2FuaXNtIHdpdGggcm90YXRpb24gZGVncmVlcyBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSBjZWxsIC0gVGhlIGNlbGwgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0gZGVncmVlc190b19yb3RhdGUgLSBUaGUgcm90YXRpb24gZGVncmVlcyBvZiB0aGUgb3JnYW5pc20uXG4gICAqL1xuICBwcml2YXRlIHJlbmRlcl9vcmdhbmlzbV9jZWxsKGNlbGwsIGRlZ3JlZXNfdG9fcm90YXRlKTogdm9pZCB7XG4gICAgY29uc3QgY2VsbF94ID0gY2VsbC5jb29yZGluYXRlLnggKiB0aGlzLnBpeGVsX3NpemU7XG4gICAgY29uc3QgY2VsbF95ID0gY2VsbC5jb29yZGluYXRlLnkgKiB0aGlzLnBpeGVsX3NpemU7XG5cbiAgICB0aGlzLmN0eC5zYXZlKCk7XG5cbiAgICAvLyBUcmFuc2xhdGUgdG8gdGhlIGNlbnRlciBvZiB0aGUgY2VsbC5cbiAgICB0aGlzLmN0eC50cmFuc2xhdGUoY2VsbF94ICsgdGhpcy5waXhlbF9zaXplIC8gMiwgY2VsbF95ICsgdGhpcy5waXhlbF9zaXplIC8gMik7XG4gICAgLy8gUm90YXRlIHRoZSBlbnRpcmUgY2VsbCBieSByb3RhdGlvbkRlZ3JlZXMuXG4gICAgdGhpcy5jdHgucm90YXRlKChkZWdyZWVzX3RvX3JvdGF0ZSAqIE1hdGguUEkpIC8gMTgwKTtcbiAgICAvLyBEcmF3IGEgcmVjdGFuZ2xlIGNlbnRlcmVkIGF0ICgwLCAwKSB0byByZXByZXNlbnQgdGhlIG9yZ2FuaXNtLlxuXG4gICAgdGhpcy5jdHguZmlsbFJlY3QoLXRoaXMucGl4ZWxfc2l6ZSAvIDIsIC10aGlzLnBpeGVsX3NpemUgLyAyLCB0aGlzLnBpeGVsX3NpemUsIHRoaXMucGl4ZWxfc2l6ZSk7IC8vIERyYXcgYSByZWN0YW5nbGUgY2VudGVyZWQgYXQgKDAsIDApXG4gICAgLy8gQ29sb3VycyB1c2VkIGZvciBkcmF3aW5nIHNoYXBlcy5cblxuICAgIGNvbnN0IGNvbG91ciA9IGNlbGwub3duZXIuZ2Vub21lLmNvbG91cjtcbiAgICBjb25zdCB0cmFuc3BhcmVudCA9IFwiIzI4MmEzNlwiO1xuICAgIGNvbnN0IGJsYWNrID0gXCIjMDAwXCI7XG4gICAgLy8gRHJhd2luZyB2YXJpb3VzIHNoYXBlcyB0byByZXByZXNlbnQgdGhlIG9yZ2FuaXNtLlxuXG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSgwLCAwLCAxNSwgMTUsIGJsYWNrKTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDAsIDAsIDMsIDMsIHRyYW5zcGFyZW50KTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDYsIDAsIDMsIDIsIHRyYW5zcGFyZW50KTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDEyLCAwLCAzLCAzLCB0cmFuc3BhcmVudCk7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSgyLCAyLCAyLCAyLCB0cmFuc3BhcmVudCk7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSgxMSwgMiwgMiwgMiwgdHJhbnNwYXJlbnQpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoNCwgMSwgMSwgMSwgY29sb3VyKTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDEwLCAxLCAxLCAxLCBjb2xvdXIpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoNSwgMiwgMSwgMSwgY29sb3VyKTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDksIDIsIDEsIDEsIGNvbG91cik7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSg1LCAzLCA1LCAxLCBjb2xvdXIpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoNCwgNCwgNywgMSwgY29sb3VyKTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDMsIDUsIDksIDEsIGNvbG91cik7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSgyLCA2LCAzLCA1LCBjb2xvdXIpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoMTAsIDYsIDMsIDUsIGNvbG91cik7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSg2LCA2LCAzLCA1LCBjb2xvdXIpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoMiwgOSwgMTEsIDIsIGNvbG91cik7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSg0LCAxMSwgMiwgMiwgY29sb3VyKTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDksIDExLCAyLCAyLCBjb2xvdXIpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoNywgMTIsIDEsIDEsIHRyYW5zcGFyZW50KTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDMsIDEzLCAxLCAxLCBjb2xvdXIpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoMTEsIDEzLCAxLCAxLCBjb2xvdXIpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoNiwgMTMsIDMsIDEsIHRyYW5zcGFyZW50KTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDQsIDE0LCA3LCAxLCB0cmFuc3BhcmVudCk7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSgwLCA3LCAxLCA0LCB0cmFuc3BhcmVudCk7XG4gICAgdGhpcy5kcmF3X3N1Yl9zaGFwZSgwLCAxMSwgMiwgNCwgdHJhbnNwYXJlbnQpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoMTQsIDcsIDEsIDQsIHRyYW5zcGFyZW50KTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDEzLCAxMSwgMiwgNCwgdHJhbnNwYXJlbnQpO1xuICAgIHRoaXMuZHJhd19zdWJfc2hhcGUoMSwgNCwgMSwgMywgY29sb3VyKTtcbiAgICB0aGlzLmRyYXdfc3ViX3NoYXBlKDEzLCA0LCAxLCAzLCBjb2xvdXIpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyBhIHN1Yi1zaGFwZSB3aXRoaW4gYSBncmlkIGNlbGwuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgc3ViLXNoYXBlLlxuICAgKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHN1Yi1zaGFwZS5cbiAgICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBzdWItc2hhcGUuXG4gICAqIEBwYXJhbSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSBzdWItc2hhcGUuXG4gICAqIEBwYXJhbSBjb2xvdXIgLSBUaGUgY29sb3VyIG9mIHRoZSBzdWItc2hhcGUuXG4gICAqL1xuICBwcml2YXRlIGRyYXdfc3ViX3NoYXBlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNvbG91cik6IHZvaWQge1xuICAgIC8vIFNldCB0aGUgZmlsbCBjb2xvdXIgZm9yIHRoZSBzdWItc2hhcGVcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvdXI7XG4gICAgLy8gRHJhdyB0aGUgc3ViLXNoYXBlIHN0YXJ0aW5nIGZyb20gdGhlIHRvcC1sZWZ0IGNvcm5lclxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KHggLSB0aGlzLnBpeGVsX3NpemUgLyAyLCB5IC0gdGhpcy5waXhlbF9zaXplIC8gMiwgd2lkdGgsIGhlaWdodCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyBhIGZvb2QgY2VsbC5cbiAgICogQHBhcmFtIGNlbGwgLSBUaGUgY2VsbCB0byByZW5kZXIuXG4gICAqL1xuICBwcml2YXRlIHJlbmRlcl9mb29kX2NlbGwoY2VsbDogR3JpZENlbGwpOiB2b2lkIHtcbiAgICBjb25zdCB0cmFuc3BhcmVudCA9IFwiIzI4MmEzNlwiO1xuICAgIGNvbnN0IGZvb2QgPSBcIiM0NDQ3NWFcIjtcblxuICAgIC8vIFJlbmRlciB0aGUgZm9vZCBjZWxsIHdpdGggc3BlY2lmaWMgc2hhcGVzIGFuZCBjb2xvdXJzIGF0IHZhcmlvdXMgcG9zaXRpb25zIHdpdGhpbiB0aGUgY2VsbFxuICAgIHRoaXMuZHJhd19yZWN0KGNlbGwsIDAsIDAsIDE1LCAxNSwgdHJhbnNwYXJlbnQpO1xuICAgIHRoaXMuZHJhd19yZWN0KGNlbGwsIDYsIDMsIDMsIDksIGZvb2QpO1xuICAgIHRoaXMuZHJhd19yZWN0KGNlbGwsIDQsIDQsIDIsIDcsIGZvb2QpO1xuICAgIHRoaXMuZHJhd19yZWN0KGNlbGwsIDksIDQsIDIsIDcsIGZvb2QpO1xuICAgIHRoaXMuZHJhd19yZWN0KGNlbGwsIDMsIDYsIDEsIDMsIGZvb2QpO1xuICAgIHRoaXMuZHJhd19yZWN0KGNlbGwsIDExLCA2LCAxLCAzLCBmb29kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgY2VsbC5cbiAgICogQHBhcmFtIGNlbGwgLSBUaGUgY2VsbCB0byByZW5kZXIuXG4gICAqL1xuICBwdWJsaWMgcmVuZGVyX2NlbGwoY2VsbDogR3JpZENlbGwpOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgY2VsbCBpcyBoaWdobGlnaHRlZCBhbmQsIGlmIHNvLCBjYWxsIHRoZSAnaGlnaGxpZ2h0X2NlbGwnIG1ldGhvZCBhbmQgcmV0dXJuXG4gICAgaWYgKGNlbGwuaXNfaGlnaGxpZ2h0ZWQpIHRoaXMuZHJhd19jZWxsKGNlbGwsIFRoZW1lQ29uZmlnLkhJR0hMSUdIVEVEKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgY2VsbCBpcyBzZWxlY3RlZCBhbmQsIGlmIHNvLCBjYWxsIHRoZSAnc2VsZWN0X2NlbGwnIG1ldGhvZCBhbmQgcmV0dXJuXG4gICAgZWxzZSBpZiAoY2VsbC5pc19zZWxlY3RlZCkgdGhpcy5kcmF3X2NlbGwoY2VsbCwgVGhlbWVDb25maWcuU0VMRUNURUQpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBjZWxsIGNvbnRhaW5zIGFuIG9yZ2FuaXNtXG4gICAgZWxzZSBpZiAoY2VsbC5zdGF0ZSA9PSBDZWxsU3RhdGVzLk9SR0FOSVNNKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgb3JnYW5pc20ncyBvd25lciBpcyBhbGl2ZSBiZWZvcmUgcmVuZGVyaW5nIHRoZSBvcmdhbmlzbSBjZWxsXG4gICAgICBpZiAoY2VsbC5vd25lciAmJiBjZWxsLm93bmVyLmFsaXZlKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcm90YXRpb24gYW5nbGUgYmFzZWQgb24gdGhlIG93bmVyJ3MgZGlyZWN0aW9uXG4gICAgICAgIGxldCByb3RhdGlvbiA9IHRvX2FuZ2xlKGNlbGwub3duZXIuZGlyZWN0aW9uKTtcblxuICAgICAgICAvLyBBZGp1c3Qgcm90YXRpb24gdG8gaGFuZGxlIHNwZWNpZmljIGFuZ2xlcyAobmVlZHMgaW1wcm92ZW1lbnQpXG4gICAgICAgIGlmIChyb3RhdGlvbiA9PSAzMTUgfHwgcm90YXRpb24gPT0gMCB8fCByb3RhdGlvbiA9PSA0NSkgcm90YXRpb24gPSAwO1xuICAgICAgICBlbHNlIGlmIChyb3RhdGlvbiA9PSA5MCkgcm90YXRpb24gPSA5MDtcbiAgICAgICAgZWxzZSBpZiAocm90YXRpb24gPT0gMTM1IHx8IHJvdGF0aW9uID09IDE4MCB8fCByb3RhdGlvbiA9PSAyMjUpIHJvdGF0aW9uID0gMTgwO1xuICAgICAgICBlbHNlIGlmIChyb3RhdGlvbiA9PSAyNzApIHJvdGF0aW9uID09IDI3MDtcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIG9yZ2FuaXNtIGNlbGwgd2l0aCB0aGUgYWRqdXN0ZWQgcm90YXRpb25cbiAgICAgICAgdGhpcy5yZW5kZXJfb3JnYW5pc21fY2VsbChjZWxsLCByb3RhdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjZWxsLnN0YXRlID09IENlbGxTdGF0ZXMuRU1QVFkpIHtcbiAgICAgIC8vIFJlbmRlciBhbiBlbXB0eSBjZWxsIGlmIHRoZSBjZWxsIHN0YXRlIGlzICdFTVBUWSdcbiAgICAgIHRoaXMuZHJhd19jZWxsKGNlbGwsIFRoZW1lQ29uZmlnLkVNUFRZKTtcbiAgICB9IGVsc2UgaWYgKGNlbGwuc3RhdGUgPT0gQ2VsbFN0YXRlcy5GT09EKSB7XG4gICAgICAvLyBSZW5kZXIgYSBmb29kIGNlbGwgaWYgdGhlIGNlbGwgc3RhdGUgaXMgJ0ZPT0QnXG4gICAgICB0aGlzLnJlbmRlcl9mb29kX2NlbGwoY2VsbCk7XG4gICAgfSBlbHNlIGlmIChjZWxsLnN0YXRlID09IENlbGxTdGF0ZXMuUkFESU9BQ1RJVkUpIHtcbiAgICAgIC8vIFJlbmRlciBhIHJhZGlvYWN0aXZlIGNlbGwgaWYgdGhlIGNlbGwgc3RhdGUgaXMgJ1JBRElPQUNUSVZFJ1xuICAgICAgdGhpcy5kcmF3X2NlbGwoY2VsbCwgVGhlbWVDb25maWcuUkFESU9BQ1RJVkUpO1xuICAgIH0gZWxzZSBpZiAoY2VsbC5zdGF0ZSA9PSBDZWxsU3RhdGVzLldBTEwpIHtcbiAgICAgIC8vIFJlbmRlciBhIHdhbGwgY2VsbCBpZiB0aGUgY2VsbCBzdGF0ZSBpcyAnV0FMTCdcbiAgICAgIHRoaXMuZHJhd19jZWxsKGNlbGwsIFRoZW1lQ29uZmlnLldBTEwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyBhIGNlbGwgb24gdGhlIGNhbnZhcy5cbiAgICogQHBhcmFtIGNlbGwgLSBUaGUgY2VsbCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSBjb2xvdXIgLSBUaGUgY29sb3VyIHRvIHJlbmRlciB0aGUgY2VsbCB3aXRoLlxuICAgKi9cbiAgcHJpdmF0ZSBkcmF3X2NlbGwoY2VsbDogR3JpZENlbGwsIGNvbG91cik6IHZvaWQge1xuICAgIC8vIFNldCB0aGUgZmlsbCBzdHlsZSB0byBhIHllbGxvdyBjb2xvdXJcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBjb2xvdXI7XG4gICAgLy8gRmlsbCB0aGUgY2VsbCB3aXRoIHRoZSBzcGVjaWZpZWQgY29sb3VyIGF0IHRoZSBjZWxsJ3MgY29vcmRpbmF0ZXMgdXNpbmcgdGhlIHBpeGVsIHNpemVcbiAgICB0aGlzLmN0eC5maWxsUmVjdChjZWxsLmNvb3JkaW5hdGUueCAqIHRoaXMucGl4ZWxfc2l6ZSwgY2VsbC5jb29yZGluYXRlLnkgKiB0aGlzLnBpeGVsX3NpemUsIHRoaXMucGl4ZWxfc2l6ZSwgdGhpcy5waXhlbF9zaXplKTtcbiAgfVxuXG4gIC8qKiBDbGVhcnMgdGhlIGNhbnZhcy4gKi9cbiAgcHVibGljIGNsZWFyX2NhbnZhcygpOiB2b2lkIHtcbiAgICAvLyBTZXQgdGhlIGZpbGwgc3R5bGUgdG8gYSBkYXJrIGNvbG91clxuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IFwiIzI4MmEzNlwiO1xuICAgIC8vIEZpbGwgdGhlIGVudGlyZSBjYW52YXMgd2l0aCB0aGUgc3BlY2lmaWVkIGNvbG91clxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhIGNlbGwgb24gdGhlIGNhbnZhcy5cbiAgICogQHBhcmFtIGNlbGwgLSBUaGUgY2VsbCB0byBjbGVhci5cbiAgICovXG4gIHB1YmxpYyBjbGVhcl9jZWxsKGNlbGw6IEdyaWRDZWxsKTogdm9pZCB7XG4gICAgdGhpcy5kcmF3X2NlbGwoY2VsbCwgVGhlbWVDb25maWcuRU1QVFkpO1xuICB9XG59XG4iLCJpbXBvcnQgeyByZW5kZXJfZnBzX2VsZW1lbnQgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9TZXR0aW5nc1wiO1xuaW1wb3J0IHsgRGVmYXVsdFNpbXVsYXRpb25Db25maWcgfSBmcm9tIFwiLi4vY29uZmlnL3NpbXVsYXRpb24uY29uZmlnXCI7XG5pbXBvcnQgeyBFbnZpcm9ubWVudCB9IGZyb20gXCIuLi9lbnZpcm9ubWVudFwiO1xuaW1wb3J0IHsgRE9NRWxlbWVudHMgfSBmcm9tIFwiLi4vY29tcG9uZW50cy9ET01FbGVtZW50c1wiO1xuXG4vKiogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNyZWF0ZSBhIHNpbXVsYXRpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSB0aGUgZW52aXJvbm1lbnQuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW11bGF0aW9uIHtcbiAgLy8gRGVmaW5lIHByb3BlcnRpZXMgZm9yIHVwZGF0ZSBsb29wXG4gIHB1YmxpYyBjdXJyZW50X3VwZGF0ZV9mcHM6IG51bWJlcjtcbiAgcHVibGljIGxhc3RfdXBkYXRlX3RpbWU6IG51bWJlcjtcbiAgcHVibGljIGxhc3RfdXBkYXRlX2R0OiBudW1iZXI7XG5cbiAgLy8gRGVmaW5lIHByb3BlcnRpZXMgZm9yIHJlbmRlciBsb29wXG4gIHB1YmxpYyBjdXJyZW50X3JlbmRlcl9mcHM6IG51bWJlcjtcbiAgcHVibGljIGxhc3RfcmVuZGVyX3RpbWU6IG51bWJlcjtcbiAgcHVibGljIGxhc3RfcmVuZGVyX2R0OiBudW1iZXI7XG5cbiAgLy8gRGVmaW5lIG90aGVyIHByb3BlcnRpZXNcbiAgcHVibGljIGlzX3J1bm5pbmc6IGJvb2xlYW47XG4gIHB1YmxpYyByZW5kZXJpbmdfZW5hYmxlZDogYm9vbGVhbjtcbiAgcHVibGljIGhhc19zdGFydGVkOiBib29sZWFuO1xuXG4gIC8vIERlZmluZSBjb25maWd1cmF0aW9uIGFuZCBsb29wIHZhcmlhYmxlc1xuICBwdWJsaWMgY29uZmlnOiB0eXBlb2YgRGVmYXVsdFNpbXVsYXRpb25Db25maWc7XG4gIHB1YmxpYyB1cGRhdGVfbG9vcDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIHB1YmxpYyByZW5kZXJfbG9vcDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG5cbiAgLy8gRGVmaW5lIGVudmlyb25tZW50IGFuZCBwb3B1bGF0aW9uIHZhcmlhYmxlc1xuICBwdWJsaWMgZW52aXJvbm1lbnQ6IEVudmlyb25tZW50O1xuXG4gIC8vIENvbnN0cnVjdG9yIGZvciB0aGUgU2ltdWxhdGlvbiBjbGFzc1xuICBjb25zdHJ1Y3Rvcihjb25maWc6IHR5cGVvZiBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZykge1xuICAgIC8vIFNldCB0aGUgY29uZmlndXJhdGlvblxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB1cGRhdGUgbG9vcCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5jdXJyZW50X3VwZGF0ZV9mcHMgPSAwO1xuICAgIHRoaXMubGFzdF91cGRhdGVfdGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmxhc3RfdXBkYXRlX2R0ID0gMDtcblxuICAgIC8vIEluaXRpYWxpemUgcmVuZGVyIGxvb3AgcHJvcGVydGllc1xuICAgIHRoaXMuY3VycmVudF9yZW5kZXJfZnBzID0gMDtcbiAgICB0aGlzLmxhc3RfcmVuZGVyX3RpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdGhpcy5sYXN0X3JlbmRlcl9kdCA9IDA7XG5cbiAgICAvLyBJbml0aWFsaXplIG90aGVyIHByb3BlcnRpZXNcbiAgICB0aGlzLmlzX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmluZ19lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmhhc19zdGFydGVkID0gZmFsc2U7XG5cbiAgICAvLyBJbml0aWFsaXplIGxvb3AgdmFyaWFibGVzXG4gICAgdGhpcy51cGRhdGVfbG9vcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlbmRlcl9sb29wID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBwb3B1bGF0aW9uIGFuZCBlbnZpcm9ubWVudFxuICAgIHRoaXMuZW52aXJvbm1lbnQgPSBuZXcgRW52aXJvbm1lbnQoXCJjYW52YXNcIiwgdGhpcy5jb25maWcpO1xuXG4gICAgLy8gU2V0dXAgcmVuZGVyIGxvb3BcbiAgICB0aGlzLnNldHVwX3JlbmRlcl9sb29wKCk7XG5cbiAgICAvLyBSZW5kZXIgdGFyZ2V0IHVwZGF0ZSBhbmQgcmVuZGVyIEZQUyBlbGVtZW50c1xuICAgIHJlbmRlcl9mcHNfZWxlbWVudChET01FbGVtZW50cy50YXJnZXRfdXBkYXRlX2ZwcywgdGhpcy5jb25maWcuVEFSR0VUX1VQREFURV9GUFMpO1xuICAgIHJlbmRlcl9mcHNfZWxlbWVudChET01FbGVtZW50cy50YXJnZXRfcmVuZGVyX2ZwcywgdGhpcy5jb25maWcuVEFSR0VUX1JFTkRFUl9GUFMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgcHJlY2hlY2tzIHRvIHZhbGlkYXRlIHRoZSBjb25maWd1cmF0aW9uIGJlZm9yZSBleGVjdXRpb24uXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHByZWNoZWNrcyBoYXZlIHBhc3NlZC5cbiAgICovXG4gIHByaXZhdGUgcnVuX3ByZWNoZWNrcygpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgcG9wdWxhdGlvbiBzaXplIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBncmlkIHNpemVcbiAgICBpZiAodGhpcy5jb25maWcuUE9QVUxBVElPTiA+IHRoaXMuY29uZmlnLkdSSURfU0laRSAqKiAyKSB7XG4gICAgICBjb25zdCBlcnJvciA9IFwiUG9wdWxhdGlvbiBzaXplIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gR3JpZCBzaXplIHNxdWFyZWQuXCI7XG4gICAgICBhbGVydChlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgbm8gZ29hbCBoYXMgYmVlbiBzZXQuXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5HT0FMX0NPT1JEICYmICF0aGlzLmNvbmZpZy5HT0FMX0ZPT0QpIHtcbiAgICAgIGFsZXJ0KFwiTm8gZ29hbCBoYXMgYmVlbiBzZXQuXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGUgZ29hbCBhbmQgZm9vZCBnb2FsIGFyZSBib3RoIGVuYWJsZWQuXG4gICAgaWYgKHRoaXMuY29uZmlnLkdPQUxfQ09PUkQgJiYgdGhpcy5jb25maWcuR09BTF9GT09EKSB7XG4gICAgICBhbGVydChcIkNhbm5vdCBoYXZlIGJvdGggY29vcmRpbmF0ZSBhbmQgZm9vZCBnb2FsIGVuYWJsZWQuXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNvb3JkaW5hdGUgZ29hbCBpcyBlbmFibGVkIGFuZCBubyBnb2FsIGNvb3JkaW5hdGVzIGhhdmUgYmVlbiBzZXQuXG4gICAgaWYgKHRoaXMuY29uZmlnLkdPQUxfQ09PUkQgJiYgdGhpcy5lbnZpcm9ubWVudC5nb2FsX2Nvb3JkaW5hdGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICBhbGVydChcIk5vIGdvYWwgY29vcmRpbmF0ZXMgaGF2ZSBiZWVuIHNldC5cIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2tzIGhhdmUgcGFzc2VkLCBzbyByZXR1cm4gdHJ1ZS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgc2ltdWxhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgaW5pdCgpOiB2b2lkIHtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBlbnZpcm9ubWVudFxuICAgIHRoaXMuZW52aXJvbm1lbnQuaW5pdCgpO1xuICAgIC8vIFNldCB0aGUgc3RhcnRlZF9zaW11bGF0aW9uIGZsYWcgdG8gdHJ1ZS5cbiAgICB0aGlzLmhhc19zdGFydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBTZXRzIHVwIHRoZSByZW5kZXIgbG9vcC4gKi9cbiAgcHJpdmF0ZSBzZXR1cF9yZW5kZXJfbG9vcCgpOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiByZW5kZXJpbmcgaXMgZW5hYmxlZFxuICAgIGlmICh0aGlzLnJlbmRlcmluZ19lbmFibGVkKSB7XG4gICAgICAvLyBTZXR1cCB0aGUgcmVuZGVyIGxvb3BcbiAgICAgIHRoaXMucmVuZGVyX2xvb3AgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyX3NpbXVsYXRpb24oKTtcbiAgICAgIH0sIDEwMDAgLyB0aGlzLmNvbmZpZy5UQVJHRVRfUkVOREVSX0ZQUyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgc2ltdWxhdGlvbiBlbmdpbmUuXG4gICAqIEByZXR1cm5zIEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNpbXVsYXRpb24gZW5naW5lIGhhcyBzdGFydGVkLlxuICAgKi9cbiAgcHVibGljIHN0YXJ0X2VuZ2luZSgpOiBib29sZWFuIHtcbiAgICAvLyBSdW4gcHJlY2hlY2tzIHRvIHZhbGlkYXRlIHRoZSBjb25maWd1cmF0aW9uIGJlZm9yZSBleGVjdXRpb24uXG4gICAgaWYgKCF0aGlzLnJ1bl9wcmVjaGVja3MoKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIENoZWNrIGlmIHNpbXVsYXRpb24gaGFzIGJlZW4gc3RhcnRlZCBiZWZvcmUuXG4gICAgaWYgKCF0aGlzLmhhc19zdGFydGVkKSB0aGlzLmluaXQoKTtcbiAgICAvLyBDaGVjayBpZiByZW5kZXIgbG9vcCBpcyBydW5uaW5nIGFuZCBzdG9wIGl0IGlmIGl0IGlzLlxuICAgIGlmICh0aGlzLnJlbmRlcl9sb29wICE9IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlbmRlcl9sb29wKTtcbiAgICAgIHRoaXMucmVuZGVyX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHNpbXVsYXRpb24gaXMgbm90IHJ1bm5pbmcuXG4gICAgaWYgKCF0aGlzLmlzX3J1bm5pbmcpIHtcbiAgICAgIC8vIFNldCB0aGUgaXNfcnVubmluZyBmbGFnIHRvIHRydWUuXG4gICAgICB0aGlzLmlzX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgLy8gU3RhcnQgdGhlIHVwZGF0ZSBsb29wXG4gICAgICB0aGlzLnVwZGF0ZV9sb29wID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNpbXVsYXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVfc2ltdWxhdGlvbigpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBIVE1MIGVsZW1lbnRzIHdpdGggc2ltdWxhdGlvbiBkYXRhXG4gICAgICAgIERPTUVsZW1lbnRzLmdlbmVyYXRpb24uaW5uZXJIVE1MID0gdGhpcy5lbnZpcm9ubWVudC5nZW5lcmF0aW9uLnRvU3RyaW5nKCk7XG4gICAgICAgIERPTUVsZW1lbnRzLnRpY2tfY291bnQuaW5uZXJIVE1MID0gdGhpcy5lbnZpcm9ubWVudC50aWNrcy50b1N0cmluZygpO1xuICAgICAgICBET01FbGVtZW50cy5vcmdhbmlzbXNfYWxpdmUuaW5uZXJIVE1MID0gdGhpcy5lbnZpcm9ubWVudC5hbGl2ZS50b1N0cmluZygpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHVwZGF0ZSBGUFMgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0YXJnZXQgdXBkYXRlIEZQUy5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudF91cGRhdGVfZnBzID49IHRoaXMuY29uZmlnLlRBUkdFVF9SRU5ERVJfRlBTICYmIHRoaXMucmVuZGVyX2xvb3AgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gU3RvcCB0aGUgcmVuZGVyIGxvb3BcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucmVuZGVyX2xvb3ApO1xuICAgICAgICAgIHRoaXMucmVuZGVyX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgcmVuZGVyIEZQUyBpcyBsZXNzIHRoYW4gdGhlIHRhcmdldCByZW5kZXIgRlBTIGFuZCB0aGUgcmVuZGVyIGxvb3AgaXMgbm90IHJ1bm5pbmcuXG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9yZW5kZXJfZnBzIDwgdGhpcy5jb25maWcuVEFSR0VUX1JFTkRFUl9GUFMgJiYgdGhpcy5yZW5kZXJfbG9vcCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZW5kZXIgbG9vcC5cbiAgICAgICAgICAgIHRoaXMuc2V0dXBfcmVuZGVyX2xvb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDAgLyB0aGlzLmNvbmZpZy5UQVJHRVRfVVBEQVRFX0ZQUyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIFN0b3BzIHRoZSBzaW11bGF0aW9uIGVuZ2luZS4gKi9cbiAgcHVibGljIHN0b3BfZW5naW5lKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzX3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuaXNfcnVubmluZyA9IGZhbHNlO1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnVwZGF0ZV9sb29wKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZW5kZXJfbG9vcCk7XG4gICAgICB0aGlzLnNldHVwX3JlbmRlcl9sb29wKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFJlc3RhcnRzIHRoZSBzaW11bGF0aW9uIGVuZ2luZS4gKi9cbiAgcHVibGljIHJlc3RhcnRfZW5naW5lKCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcF9lbmdpbmUoKTtcbiAgICB0aGlzLnN0YXJ0X2VuZ2luZSgpO1xuICB9XG5cbiAgLyoqIFVwZGF0ZXMgdGhlIHNpbXVsYXRpb24uICovXG4gIHByaXZhdGUgdXBkYXRlX3NpbXVsYXRpb24oKTogdm9pZCB7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSBieSBzdWJ0cmFjdGluZyB0aGUgY3VycmVudCB0aW1lIGZyb20gdGhlIGxhc3QgdXBkYXRlIHRpbWUuXG4gICAgdGhpcy5sYXN0X3VwZGF0ZV9kdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMubGFzdF91cGRhdGVfdGltZTtcbiAgICAvLyBTZXQgdGhlIGxhc3QgdXBkYXRlIHRpbWUgdG8gdGhlIGN1cnJlbnQgdGltZS5cbiAgICB0aGlzLmxhc3RfdXBkYXRlX3RpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBjdXJyZW50IHVwZGF0ZSBGUFMgYnkgZGl2aWRpbmcgMTAwMCBieSB0aGUgbGFzdCB1cGRhdGUgZGVsdGEgdGltZS5cbiAgICB0aGlzLmN1cnJlbnRfdXBkYXRlX2ZwcyA9IDEwMDAgLyB0aGlzLmxhc3RfdXBkYXRlX2R0O1xuICAgIC8vIFVwZGF0ZSB0aGUgZW52aXJvbm1lbnQuXG4gICAgdGhpcy5lbnZpcm9ubWVudC51cGRhdGUoKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSByZW5kZXIgbG9vcCBpcyBub3QgcnVubmluZyBhbmQgcmVuZGVyaW5nIGlzIGVuYWJsZWQuXG4gICAgaWYgKHRoaXMucmVuZGVyX2xvb3AgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlbmRlcmluZ19lbmFibGVkKSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIHNpbXVsYXRpb25cbiAgICAgIHRoaXMucmVuZGVyX3NpbXVsYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgRlBTXG4gICAgICByZW5kZXJfZnBzX2VsZW1lbnQoRE9NRWxlbWVudHMuY3VycmVudF91cGRhdGVfZnBzLCB0aGlzLmN1cnJlbnRfdXBkYXRlX2Zwcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFJlbmRlcnMgdGhlIHNpbXVsYXRpb24uICovXG4gIHByaXZhdGUgcmVuZGVyX3NpbXVsYXRpb24oKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbmRlciBsb29wIGlzIHJ1bm5pbmcuXG4gICAgaWYgKHRoaXMucmVuZGVyX2xvb3ApIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdGltZSBzaW5jZSB0aGUgbGFzdCByZW5kZXIgYnkgc3VidHJhY3RpbmcgdGhlIGN1cnJlbnQgdGltZSBmcm9tIHRoZSBsYXN0IHJlbmRlciB0aW1lLlxuICAgICAgdGhpcy5sYXN0X3JlbmRlcl9kdCA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMubGFzdF9yZW5kZXJfdGltZTtcbiAgICAgIC8vIFNldCB0aGUgbGFzdCByZW5kZXIgdGltZSB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgdGhpcy5sYXN0X3JlbmRlcl90aW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgdGhlIGxhc3QgcmVuZGVyIHRpbWUgdG8gbWF0Y2ggdGhlIGxhc3QgdXBkYXRlIHRpbWUuXG4gICAgICB0aGlzLmxhc3RfcmVuZGVyX2R0ID0gdGhpcy5sYXN0X3VwZGF0ZV9kdDtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGN1cnJlbnQgcmVuZGVyIEZQUyBieSBkaXZpZGluZyAxMDAwIGJ5IHRoZSBsYXN0IHJlbmRlciBkZWx0YSB0aW1lLlxuICAgIHRoaXMuY3VycmVudF9yZW5kZXJfZnBzID0gMTAwMCAvIHRoaXMubGFzdF9yZW5kZXJfZHQ7XG5cbiAgICAvLyBSZW5kZXIgdGhlIGVudmlyb25tZW50LlxuICAgIHRoaXMuZW52aXJvbm1lbnQucmVuZGVyKCk7XG5cbiAgICAvLyBVcGRhdGUgRlBTIGVsZW1lbnRzLlxuICAgIHJlbmRlcl9mcHNfZWxlbWVudChET01FbGVtZW50cy5jdXJyZW50X3VwZGF0ZV9mcHMsIHRoaXMuY3VycmVudF91cGRhdGVfZnBzKTtcbiAgICByZW5kZXJfZnBzX2VsZW1lbnQoRE9NRWxlbWVudHMuY3VycmVudF9yZW5kZXJfZnBzLCB0aGlzLmN1cnJlbnRfcmVuZGVyX2Zwcyk7XG4gIH1cbn1cbiIsImltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi4vY29udHJvbGxlcnMvcmVuZGVyZXIuY29udHJvbGxlclwiO1xuaW1wb3J0IE9yZ2FuaXNtIGZyb20gXCIuLi9tb2RlbHMvT3JnYW5pc21cIjtcbmltcG9ydCB7IENvb3JkaW5hdGUgfSBmcm9tIFwiLi4vdHlwZXMvQ29vcmRpbmF0ZVwiO1xuaW1wb3J0IGdldF9yYW5kb21fdmVjdG9yIGZyb20gXCIuLi91dGlscy9nZXRfcmFuZG9tX3ZlY3RvclwiO1xuXG4vLyBWYXJpb3VzIENlbGwgU3RhdGVzIHRoYXQgYSBHcmlkQ2VsbCBjYW4gdGFrZS5cbmV4cG9ydCBjb25zdCBDZWxsU3RhdGVzID0ge1xuICBFTVBUWTogMCxcbiAgT1JHQU5JU006IDEsXG4gIFdBTEw6IDIsXG4gIEZPT0Q6IDMsXG4gIFJBRElPQUNUSVZFOiA0LFxufTtcblxuLy8gQ3JlYXRlIGFuIGFycmF5IG9mIHRoZSBrZXlzIG9mIHRoZSBDZWxsU3RhdGVzLlxuZXhwb3J0IGNvbnN0IEFsbENlbGxTdGF0ZXMgPSBPYmplY3Qua2V5cyhDZWxsU3RhdGVzKTtcblxuLyoqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgYSBncmlkIGNlbGwgdGhhdCBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYSBjZWxsIGluIHRoZSBncmlkLiAqL1xuZXhwb3J0IGNsYXNzIEdyaWRDZWxsIHtcbiAgcHVibGljIGNvb3JkaW5hdGU6IENvb3JkaW5hdGU7XG4gIHByaXZhdGUgX293bmVyOiBPcmdhbmlzbSB8IG51bGw7XG4gIHByaXZhdGUgX3N0YXRlOiBudW1iZXI7XG4gIHB1YmxpYyBpc19zZWxlY3RlZDogYm9vbGVhbjtcbiAgcHVibGljIGlzX2hpZ2hsaWdodGVkOiBib29sZWFuO1xuICBwdWJsaWMgZW5lcmd5OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIG5ldyBncmlkIGNlbGwuXG4gICAqIEBwYXJhbSB4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VsbC5cbiAgICogQHBhcmFtIHkgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZWxsLlxuICAgKiBAcGFyYW0gc3RhdGUgLSBUaGUgc3RhdGUgb2YgdGhlIGNlbGwuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4OiBudW1iZXIsIHk6IG51bWJlciwgc3RhdGUgPSBDZWxsU3RhdGVzLkVNUFRZKSB7XG4gICAgdGhpcy5jb29yZGluYXRlID0geyB4LCB5IH07XG4gICAgdGhpcy5fb3duZXIgPSBudWxsO1xuICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5pc19zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNfaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVuZXJneSA9IDA7XG4gIH1cblxuICAvKiogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjbGVhciB0aGUgZ3JpZCBjZWxsLiAqL1xuICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgLy8gUmVzZXQgdGhlIG93bmVyIG9mIHRoZSBjZWxsIHRvIG51bGxcbiAgICB0aGlzLl9vd25lciA9IG51bGw7XG5cbiAgICAvLyBTZXQgdGhlIHN0YXRlIG9mIHRoZSBjZWxsIHRvIEVNUFRZXG4gICAgdGhpcy5fc3RhdGUgPSBDZWxsU3RhdGVzLkVNUFRZO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gZ2V0IHRoZSBvd25lciBvZiB0aGUgZ3JpZCBjZWxsLlxuICAgKiBAcmV0dXJucyBUaGUgb3duZXIgb2YgdGhlIGdyaWQgY2VsbC5cbiAgICovXG4gIHB1YmxpYyBnZXQgb3duZXIoKTogT3JnYW5pc20gfCBudWxsIHtcbiAgICAvLyBSZXRyaWV2ZSBhbmQgcmV0dXJuIHRoZSBvd25lciBvZiB0aGUgR3JpZENlbGxcbiAgICByZXR1cm4gdGhpcy5fb3duZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgdGhlIG93bmVyIG9mIHRoZSBncmlkIGNlbGwuXG4gICAqIEBwYXJhbSBvd25lciAtIFRoZSBvd25lciBvZiB0aGUgZ3JpZCBjZWxsLlxuICAgKi9cbiAgcHVibGljIHNldCBvd25lcihvd25lcjogT3JnYW5pc20gfCBudWxsKSB7XG4gICAgLy8gQ2hlY2sgaWYgYW4gb3duZXIgaXMgcHJvdmlkZWRcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIC8vIElmIGFuIG93bmVyIGlzIHByb3ZpZGVkLCBzZXQgdGhlIG93bmVyIG9mIHRoZSBHcmlkQ2VsbFxuICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgR3JpZENlbGwgdG8gaW5kaWNhdGUgaXQncyBvY2N1cGllZCBieSBhbiBvcmdhbmlzbVxuICAgICAgdGhpcy5fc3RhdGUgPSBDZWxsU3RhdGVzLk9SR0FOSVNNO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyBvd25lciBpcyBwcm92aWRlZCwgcmVzZXQgdGhlIG93bmVyIHRvIG51bGxcbiAgICAgIHRoaXMuX293bmVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBnZXQgdGhlIHN0YXRlIG9mIHRoZSBncmlkIGNlbGwuXG4gICAqIEByZXR1cm5zIFRoZSBzdGF0ZSBvZiB0aGUgZ3JpZCBjZWxsLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBudW1iZXIge1xuICAgIC8vIFJldHJpZXZlIGFuZCByZXR1cm4gdGhlIHN0YXRlIG9mIHRoZSBHcmlkQ2VsbFxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldCB0aGUgc3RhdGUgb2YgdGhlIGdyaWQgY2VsbC5cbiAgICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIG9mIHRoZSBncmlkIGNlbGwuXG4gICAqL1xuICBwdWJsaWMgc2V0IHN0YXRlKHN0YXRlOiBudW1iZXIpIHtcbiAgICAvLyBTZXQgdGhlIHN0YXRlIG9mIHRoZSBHcmlkQ2VsbCB0byB0aGUgcHJvdmlkZWQgc3RhdGUgdmFsdWVcbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICB9XG59XG5cbi8qKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGEgZ3JpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZW52aXJvbm1lbnQuICovXG5leHBvcnQgY2xhc3MgR3JpZCB7XG4gIHByaXZhdGUgX2RhdGE6IEdyaWRDZWxsW11bXTtcbiAgcHVibGljIGdyaWRfc2l6ZTogbnVtYmVyO1xuICBwdWJsaWMgcmVuZGVyZXI6IFJlbmRlcmVyO1xuICBwdWJsaWMgb2NjdXBpZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogQnVpbGRzIGEgbmV3IGdyaWQuXG4gICAqIEBwYXJhbSBncmlkX3NpemUgLSBUaGUgc2l6ZSBvZiB0aGUgZ3JpZC5cbiAgICogQHBhcmFtIHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyIHRvIHVzZSBmb3IgcmVuZGVyaW5nIHRoZSBncmlkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ3JpZF9zaXplOiBudW1iZXIsIHJlbmRlcmVyOiBSZW5kZXJlcikge1xuICAgIHRoaXMuX2RhdGEgPSBuZXcgQXJyYXkoZ3JpZF9zaXplKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5ncmlkX3NpemUgPSBncmlkX3NpemU7XG4gICAgdGhpcy5vY2N1cGllZCA9IDA7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKiogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBpbml0aWFsaXplIHRoZSBncmlkLiAqL1xuICBwdWJsaWMgaW5pdCgpOiB2b2lkIHtcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCByb3cgKHgtYXhpcykgb2YgdGhlIGdyaWRcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZ3JpZF9zaXplOyB4KyspIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBhcnJheSB0byByZXByZXNlbnQgYSBjb2x1bW4gb2YgZ3JpZCBjZWxsc1xuICAgICAgY29uc3QgY29sdW1uOiBHcmlkQ2VsbFtdID0gbmV3IEFycmF5KHRoaXMuZ3JpZF9zaXplKTtcblxuICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggY29sdW1uICh5LWF4aXMpIG9mIHRoZSBncmlkXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuZ3JpZF9zaXplOyB5KyspIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IEdyaWRDZWxsIGluc3RhbmNlIHdpdGggdGhlIGN1cnJlbnQgeCBhbmQgeSBjb29yZGluYXRlc1xuICAgICAgICBjb25zdCBjZWxsID0gbmV3IEdyaWRDZWxsKHgsIHkpO1xuXG4gICAgICAgIC8vIEFzc2lnbiB0aGUgY2VsbCB0byB0aGUgY3VycmVudCBjb2x1bW4gaW4gdGhlIGdyaWRcbiAgICAgICAgY29sdW1uW3ldID0gY2VsbDtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzaWduIHRoZSBjb2x1bW4gdG8gdGhlIGdyaWQgZGF0YSBhdCB0aGUgY3VycmVudCB4IHBvc2l0aW9uXG4gICAgICB0aGlzLl9kYXRhW3hdID0gY29sdW1uO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNsZWFyIHRoZSBncmlkLiAqL1xuICBwdWJsaWMgY2xlYXJfZ3JpZCgpOiB2b2lkIHtcbiAgICAvLyBSZXNldCB0aGUgZ3JpZCBkYXRhIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgdGhpcy5fZGF0YSA9IFtdO1xuXG4gICAgLy8gUmUtaW5pdGlhbGl6ZSB0aGUgZ3JpZCB0byBjbGVhciBhbGwgZ3JpZCBjZWxsc1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHNwZWNpZmllZCBjZWxsIGlzIHZhbGlkLlxuICAgKiBAcGFyYW0gY29vcmRpbmF0ZSAtIFRoZSBjb29yZGluYXRlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgY2VsbCBpcyB2YWxpZC5cbiAgICovXG4gIHB1YmxpYyBpc192YWxpZF9jZWxsX2F0KGNvb3JkaW5hdGU6IENvb3JkaW5hdGUpOiBib29sZWFuIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUgaXMgd2l0aGluIHRoZSBncmlkIGJvdW5kYXJpZXNcbiAgICByZXR1cm4gY29vcmRpbmF0ZS54ID49IDAgJiYgY29vcmRpbmF0ZS55ID49IDAgJiYgY29vcmRpbmF0ZS54IDwgdGhpcy5ncmlkX3NpemUgJiYgY29vcmRpbmF0ZS55IDwgdGhpcy5ncmlkX3NpemU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgc3BlY2lmaWVkIGNlbGwgaXMgZW1wdHkuXG4gICAqIEBwYXJhbSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHNwZWNpZmllZCBjZWxsIGlzIGVtcHR5LlxuICAgKi9cbiAgcHVibGljIGlzX2NlbGxfZW1wdHkoY29vcmRpbmF0ZTogQ29vcmRpbmF0ZSk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwcm92aWRlZCBjZWxsIGNvb3JkaW5hdGUgaXMgdmFsaWQgd2l0aGluIHRoZSBncmlkXG4gICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9hdChjb29yZGluYXRlKSkge1xuICAgICAgLy8gUmV0cmlldmUgdGhlIHN0YXRlIG9mIHRoZSBjZWxsIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZSBhbmQgY2hlY2sgaWYgaXQncyBlbXB0eVxuICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbY29vcmRpbmF0ZS54XVtjb29yZGluYXRlLnldLnN0YXRlID09IENlbGxTdGF0ZXMuRU1QVFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBjZWxsIGNvb3JkaW5hdGUgaXMgbm90IHZhbGlkXG4gICAgICB0aHJvdyBFcnJvcihgTm90IGEgdmFsaWQgY2VsbC4gJHtjb29yZGluYXRlLnh9ICR7Y29vcmRpbmF0ZS55fWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGdldCB0aGUgY2VsbCBhdCB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIFRoZSBjZWxsIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZS5cbiAgICovXG4gIHB1YmxpYyBnZXRfY2VsbF9hdChjb29yZGluYXRlOiBDb29yZGluYXRlKTogR3JpZENlbGwge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwcm92aWRlZCBjZWxsIGNvb3JkaW5hdGUgaXMgd2l0aGluIHRoZSBncmlkXG4gICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9hdChjb29yZGluYXRlKSkge1xuICAgICAgLy8gUmV0cmlldmUgYW5kIHJldHVybiB0aGUgR3JpZENlbGwgYXQgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlXG4gICAgICByZXR1cm4gdGhpcy5fZGF0YVtjb29yZGluYXRlLnhdW2Nvb3JkaW5hdGUueV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBjZWxsIGNvb3JkaW5hdGUgaXMgbm90IHZhbGlkXG4gICAgICB0aHJvdyBFcnJvcihgTm90IGEgdmFsaWQgY2VsbC4gJHtjb29yZGluYXRlLnh9ICR7Y29vcmRpbmF0ZS55fWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvd25lciBvZiBhIGNlbGwuXG4gICAqIEBwYXJhbSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgdG8gc2V0IHRoZSBvd25lciBvZi5cbiAgICogQHBhcmFtIG93bmVyIC0gVGhlIG93bmVyIHRvIHNldC5cbiAgICovXG4gIHB1YmxpYyBzZXRfY2VsbF9vd25lcihjb29yZGluYXRlOiBDb29yZGluYXRlLCBvd25lcjogT3JnYW5pc20pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgcHJvdmlkZWQgY2VsbCBjb29yZGluYXRlIGlzIHdpdGhpbiB0aGUgZ3JpZFxuICAgIGlmICh0aGlzLmlzX3ZhbGlkX2NlbGxfYXQoY29vcmRpbmF0ZSkpIHtcbiAgICAgIC8vIFJldHJpZXZlIHRoZSBjZWxsIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZVxuICAgICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0X2NlbGxfYXQoY29vcmRpbmF0ZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgb3duZXIgb2YgdGhlIGNlbGwgdG8gdGhlIHNwZWNpZmllZCBvcmdhbmlzbVxuICAgICAgY2VsbC5vd25lciA9IG93bmVyO1xuXG4gICAgICAvLyBBZGQgdGhlIGNlbGwgdG8gdGhlICd0b19maWxsJyBzZXQgaW4gdGhlIHJlbmRlcmVyXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvX2ZpbGwuZW5xdWV1ZShjZWxsKTtcblxuICAgICAgLy8gSW5jcmVtZW50IHRoZSBjb3VudCBvZiBvY2N1cGllZCBjZWxsc1xuICAgICAgdGhpcy5vY2N1cGllZCArPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiBhIGNlbGwuXG4gICAqIEBwYXJhbSBjb29yZGluYXRlIFRoZSBjb29yZGluYXRlIG9mIHRoZSBjZWxsIHRvIHNldCB0aGUgc3RhdGUgb2YuXG4gICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdG8gc2V0LlxuICAgKi9cbiAgcHVibGljIHNldF9jZWxsX3N0YXRlKGNvb3JkaW5hdGU6IENvb3JkaW5hdGUsIHN0YXRlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgcHJvdmlkZWQgY2VsbCBjb29yZGluYXRlIGlzIHdpdGhpbiB0aGUgZ3JpZFxuICAgIGlmICh0aGlzLmlzX3ZhbGlkX2NlbGxfYXQoY29vcmRpbmF0ZSkpIHtcbiAgICAgIC8vIFJldHJpZXZlIHRoZSBjZWxsIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZVxuICAgICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0X2NlbGxfYXQoY29vcmRpbmF0ZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgc3RhdGUgb2YgdGhlIGNlbGwgdG8gdGhlIHByb3ZpZGVkIHN0YXRlXG4gICAgICBjZWxsLnN0YXRlID0gc3RhdGU7XG5cbiAgICAgIC8vIElmIHRoZSBjZWxsIHN0YXRlIGlzICdGT09EJywgc2V0IGl0cyBlbmVyZ3kgdG8gMSBhbmQgY2xlYXIgaXRzIG93bmVyXG4gICAgICBpZiAoY2VsbC5zdGF0ZSA9PSBDZWxsU3RhdGVzLkZPT0QpIHtcbiAgICAgICAgY2VsbC5lbmVyZ3kgPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgb3duZXIgb2YgdGhlIGNlbGxcbiAgICAgIGNlbGwub3duZXIgPSBudWxsO1xuXG4gICAgICAvLyBBZGQgdGhlIGNlbGwgdG8gdGhlICd0b19maWxsJyBzZXQgaW4gdGhlIHJlbmRlcmVyXG4gICAgICB0aGlzLnJlbmRlcmVyLnRvX2ZpbGwuZW5xdWV1ZShjZWxsKTtcblxuICAgICAgLy8gSW5jcmVtZW50IHRoZSBjb3VudCBvZiBvY2N1cGllZCBjZWxsc1xuICAgICAgdGhpcy5vY2N1cGllZCArPSAxO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiBhIGNlbGwuXG4gICAqIEBwYXJhbSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgdG8gc2V0IHRoZSBzZWxlY3RlZCBzdGF0ZSBvZi5cbiAgICogQHBhcmFtIHNlbGVjdGVkIC0gVGhlIHNlbGVjdGVkIHN0YXRlIHRvIHNldC5cbiAgICovXG4gIHB1YmxpYyBzZXRfY2VsbF9zZWxlY3RlZChjb29yZGluYXRlOiBDb29yZGluYXRlLCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwcm92aWRlZCBjZWxsIGNvb3JkaW5hdGUgaXMgd2l0aGluIHRoZSBncmlkXG4gICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9hdChjb29yZGluYXRlKSkge1xuICAgICAgLy8gUmV0cmlldmUgdGhlIGNlbGwgYXQgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlXG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRfY2VsbF9hdChjb29yZGluYXRlKTtcblxuICAgICAgLy8gU2V0IHRoZSAnaXNfc2VsZWN0ZWQnIHByb3BlcnR5IG9mIHRoZSBjZWxsIHRvIHRoZSBwcm92aWRlZCB2YWx1ZVxuICAgICAgY2VsbC5pc19zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXG4gICAgICAvLyBBZGQgdGhlIGNlbGwgdG8gdGhlICd0b19maWxsJyBzZXQgaW4gdGhlIHJlbmRlcmVyIGZvciByZW5kZXJpbmcgcHVycG9zZXNcbiAgICAgIHRoaXMucmVuZGVyZXIudG9fZmlsbC5lbnF1ZXVlKGNlbGwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoaWdobGlnaHRlZCBzdGF0ZSBvZiBhIGNlbGwuXG4gICAqIEBwYXJhbSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgdG8gc2V0IHRoZSBoaWdobGlnaHRlZCBzdGF0ZSBvZi5cbiAgICogQHBhcmFtIGhpZ2hsaWdodGVkIC0gVGhlIGhpZ2hsaWdodGVkIHN0YXRlIHRvIHNldC5cbiAgICovXG4gIHB1YmxpYyBzZXRfY2VsbF9oaWdobGlnaHRlZChjb29yZGluYXRlOiBDb29yZGluYXRlLCBoaWdobGlnaHRlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwcm92aWRlZCBjZWxsIGNvb3JkaW5hdGUgaXMgd2l0aGluIHRoZSBncmlkXG4gICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9hdChjb29yZGluYXRlKSkge1xuICAgICAgLy8gUmV0cmlldmUgdGhlIGNlbGwgYXQgdGhlIHNwZWNpZmllZCBjb29yZGluYXRlXG4gICAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRfY2VsbF9hdChjb29yZGluYXRlKTtcblxuICAgICAgLy8gU2V0IHRoZSAnaXNfaGlnaGxpZ2h0ZWQnIHByb3BlcnR5IG9mIHRoZSBjZWxsIHRvIHRoZSBwcm92aWRlZCB2YWx1ZVxuICAgICAgY2VsbC5pc19oaWdobGlnaHRlZCA9IGhpZ2hsaWdodGVkO1xuXG4gICAgICAvLyBBZGQgdGhlIGNlbGwgdG8gdGhlICd0b19maWxsJyBzZXQgaW4gdGhlIHJlbmRlcmVyIGZvciByZW5kZXJpbmcgcHVycG9zZXNcbiAgICAgIHRoaXMucmVuZGVyZXIudG9fZmlsbC5lbnF1ZXVlKGNlbGwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHN0YXRlIG9mIGEgY2VsbC5cbiAgICogQHBhcmFtIGNvb3JkaW5hdGUgLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCB0byBjbGVhciB0aGUgc3RhdGUgb2YuXG4gICAqL1xuICBwdWJsaWMgY2xlYXJfY2VsbF9zdGF0ZShjb29yZGluYXRlOiBDb29yZGluYXRlKTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHByb3ZpZGVkIGNlbGwgY29vcmRpbmF0ZSBpcyB3aXRoaW4gdGhlIGdyaWRcbiAgICBpZiAodGhpcy5pc192YWxpZF9jZWxsX2F0KGNvb3JkaW5hdGUpKSB7XG4gICAgICAvLyBSZXRyaWV2ZSB0aGUgY2VsbCBhdCB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVcbiAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldF9jZWxsX2F0KGNvb3JkaW5hdGUpO1xuXG4gICAgICAvLyBSZW1vdmUgb3duZXIgb2YgdGhlIGNlbGxcbiAgICAgIGNlbGwub3duZXIgPSBudWxsO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY2VsbCdzIGVuZXJneSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVyb1xuICAgICAgaWYgKGNlbGwuZW5lcmd5IDw9IDApIHtcbiAgICAgICAgLy8gU2V0IGNlbGwgc3RhdGUgdG8gRU1QVFkgYW5kIGFkZCBpdCB0byB0aGUgJ3RvX2NsZWFyJyBzZXQgaW4gdGhlIHJlbmRlcmVyIGZvciBjbGVhcmluZ1xuICAgICAgICBjZWxsLnN0YXRlID0gQ2VsbFN0YXRlcy5FTVBUWTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci50b19jbGVhci5lbnF1ZXVlKGNlbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IGNlbGwgc3RhdGUgdG8gRk9PRCBhbmQgYWRkIGl0IHRvIGJvdGggJ3RvX2NsZWFyJyBhbmQgJ3RvX2ZpbGwnIHNldHMgaW4gdGhlIHJlbmRlcmVyXG4gICAgICAgIGNlbGwuc3RhdGUgPSBDZWxsU3RhdGVzLkZPT0Q7XG4gICAgICAgIHRoaXMucmVuZGVyZXIudG9fY2xlYXIuZW5xdWV1ZShjZWxsKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci50b19maWxsLmVucXVldWUoY2VsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlZHVjZSB0aGUgY291bnQgb2Ygb2NjdXBpZWQgY2VsbHNcbiAgICAgIHRoaXMub2NjdXBpZWQgLT0gMTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBmZXRjaCBhIHJhbmRvbSBlbXB0eSBjZWxsIGZyb20gdGhlIGdyaWQuXG4gICAqIEByZXR1cm5zIEEgcmFuZG9tIGVtcHR5IGNlbGwgZnJvbSB0aGUgZ3JpZC5cbiAgICovXG4gIHB1YmxpYyBmZXRjaF9lbXB0eV9jZWxsKCk6IENvb3JkaW5hdGUge1xuICAgIC8vIENoZWNrIGlmIHRoZSBncmlkIGlzIGZ1bGx5IG9jY3VwaWVkLCB0aHJvdyBhbiBlcnJvciBpZiBubyBlbXB0eSBjZWxscyBhcmUgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMub2NjdXBpZWQgPT09IHRoaXMuZ3JpZF9zaXplICoqIDIpIHtcbiAgICAgIGFsZXJ0KFwiTm8gZW1wdHkgY2VsbHMgbGVmdCFcIik7XG4gICAgICB0aHJvdyBFcnJvcihcIk5vIGVtcHR5IGNlbGxzIGxlZnQhXCIpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIGNvb3JkaW5hdGUgd2l0aGluIHRoZSBncmlkXG4gICAgbGV0IHJhbmRvbV9jb29yZCA9IGdldF9yYW5kb21fdmVjdG9yKDAsIDAsIHRoaXMuZ3JpZF9zaXplIC0gMSwgdGhpcy5ncmlkX3NpemUgLSAxKTtcblxuICAgIC8vIExvb3AgdW50aWwgYW4gZW1wdHkgY2VsbCBpcyBmb3VuZCB1c2luZyB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBjb29yZGluYXRlc1xuICAgIHdoaWxlICghdGhpcy5pc19jZWxsX2VtcHR5KHJhbmRvbV9jb29yZCkpIHtcbiAgICAgIHJhbmRvbV9jb29yZCA9IGdldF9yYW5kb21fdmVjdG9yKDAsIDAsIHRoaXMuZ3JpZF9zaXplIC0gMSwgdGhpcy5ncmlkX3NpemUgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZG9tX2Nvb3JkOyAvLyBSZXR1cm4gdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBmb3VuZCBlbXB0eSBjZWxsXG4gIH1cbn1cbiIsImltcG9ydCB7IGNhbGN1bGF0ZV9hbmRfc29ydF9maXRuZXNzLCBzZWxlY3RfYW5kX2Nyb3Nzb3ZlciB9IGZyb20gXCIuLi9hbGdvcml0aG1zL0dlbmV0aWNBbGdvcml0aG1cIjtcbmltcG9ydCB7IERPTUVsZW1lbnRzIH0gZnJvbSBcIi4uL2NvbXBvbmVudHMvRE9NRWxlbWVudHNcIjtcbmltcG9ydCB7IERlZmF1bHRTaW11bGF0aW9uQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZy9zaW11bGF0aW9uLmNvbmZpZ1wiO1xuaW1wb3J0IENhbnZhcyBmcm9tIFwiLi4vY29udHJvbGxlcnMvY2FudmFzLmNvbnRyb2xsZXJcIjtcbmltcG9ydCBDaGFydENvbnRyb2xsZXIgZnJvbSBcIi4uL2NvbnRyb2xsZXJzL2NoYXJ0LmNvbnRyb2xsZXJcIjtcbmltcG9ydCBHZW5lIGZyb20gXCIuLi9tb2RlbHMvR2VuZVwiO1xuaW1wb3J0IE9yZ2FuaXNtIGZyb20gXCIuLi9tb2RlbHMvT3JnYW5pc21cIjtcbmltcG9ydCB7IENvb3JkaW5hdGUgfSBmcm9tIFwiLi4vdHlwZXMvQ29vcmRpbmF0ZVwiO1xuaW1wb3J0IHsgYWRkX3ZlY3RvciB9IGZyb20gXCIuLi91dGlscy9nZW9tZXRyeVwiO1xuaW1wb3J0IGdldF9yYW5kb21fdmVjdG9yIGZyb20gXCIuLi91dGlscy9nZXRfcmFuZG9tX3ZlY3RvclwiO1xuaW1wb3J0IHsgQ2VsbFN0YXRlcyB9IGZyb20gXCIuL0dyaWRcIjtcblxuLy8gRW52aXJvbm1lbnQgY2xhc3MuXG5leHBvcnQgY2xhc3MgRW52aXJvbm1lbnQgZXh0ZW5kcyBDYW52YXMge1xuICBwdWJsaWMgcG9wdWxhdGlvbjogT3JnYW5pc21bXTtcbiAgcHVibGljIHRpY2tzOiBudW1iZXI7XG4gIHB1YmxpYyBnZW5lcmF0aW9uOiBudW1iZXI7XG4gIHB1YmxpYyBvdmVyYWxsX2ZpdG5lc3M6IG51bWJlcjtcbiAgcHVibGljIGJlc3RfZml0bmVzczogbnVtYmVyO1xuICBwdWJsaWMgc3BlY2llc19jb3VudDogbnVtYmVyO1xuICBwdWJsaWMgYWxpdmU6IG51bWJlcjtcbiAgcHVibGljIGJlc3RfZml0bmVzc19kYXRhX3BvaW50czogQ29vcmRpbmF0ZVtdO1xuICBwdWJsaWMgb3ZlcmFsbF9maXRuZXNzX2RhdGFfcG9pbnRzOiBDb29yZGluYXRlW107XG4gIHB1YmxpYyBudW1iZXJfb2Zfc3BlY2llc19kYXRhX3BvaW50czogQ29vcmRpbmF0ZVtdO1xuICBwdWJsaWMgc3BlY2llc19kYXRhX3BvaW50czogYW55O1xuICBwdWJsaWMgc3BlY2llczogU2V0PHN0cmluZz47XG4gIHB1YmxpYyBjaGFydDogQ2hhcnRDb250cm9sbGVyO1xuXG4gIC8vIEJ1aWxkcyBhIG5ldyBFbnZpcm9ubWVudCBpbnN0YW5jZS5cbiAgY29uc3RydWN0b3IoY2FudmFzX2lkOiBzdHJpbmcsIGNvbmZpZzogdHlwZW9mIERlZmF1bHRTaW11bGF0aW9uQ29uZmlnKSB7XG4gICAgc3VwZXIoY2FudmFzX2lkLCBjb25maWcpO1xuICAgIHRoaXMucG9wdWxhdGlvbiA9IFtdO1xuICAgIHRoaXMudGlja3MgPSAwO1xuICAgIHRoaXMuZ2VuZXJhdGlvbiA9IDA7XG4gICAgdGhpcy5iZXN0X2ZpdG5lc3MgPSAxO1xuICAgIHRoaXMub3ZlcmFsbF9maXRuZXNzID0gMTtcbiAgICB0aGlzLnNwZWNpZXNfY291bnQgPSBJbmZpbml0eTtcbiAgICB0aGlzLmFsaXZlID0gMDtcbiAgICB0aGlzLmJlc3RfZml0bmVzc19kYXRhX3BvaW50cyA9IFtdO1xuICAgIHRoaXMub3ZlcmFsbF9maXRuZXNzX2RhdGFfcG9pbnRzID0gW107XG4gICAgdGhpcy5udW1iZXJfb2Zfc3BlY2llc19kYXRhX3BvaW50cyA9IFtdO1xuICAgIHRoaXMuc3BlY2llcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmNoYXJ0ID0gbmV3IENoYXJ0Q29udHJvbGxlcihcImNoYXJ0XCIpO1xuICAgIHRoaXMuY2hhcnQuYWRkX2NvbmZpZyhcIkJlc3QgRml0bmVzc1wiLCBcIkdlbmVyYXRpb25cIiwgXCJCZXN0IEZpdG5lc3NcIiwgdGhpcy5iZXN0X2ZpdG5lc3NfZGF0YV9wb2ludHMsIDEpO1xuICAgIHRoaXMuY2hhcnQuYWRkX2NvbmZpZyhcIk92ZXJhbGwgRml0bmVzc1wiLCBcIkdlbmVyYXRpb25cIiwgXCJPdmVyYWxsIEZpdG5lc3NcIiwgdGhpcy5vdmVyYWxsX2ZpdG5lc3NfZGF0YV9wb2ludHMsIDEpO1xuICAgIHRoaXMuY2hhcnQuYWRkX2NvbmZpZyhcIk51bWJlciBvZiBTcGVjaWVzXCIsIFwiR2VuZXJhdGlvblwiLCBcIk51bWJlciBvZiBTcGVjaWVzXCIsIHRoaXMubnVtYmVyX29mX3NwZWNpZXNfZGF0YV9wb2ludHMpO1xuICAgIHRoaXMuY2hhcnQuc3dpdGNoX2NoYXJ0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gT3JnYW5pc20gdG8gdGhlIGVudmlyb25tZW50IGFuZCBjb25maWd1cmVzIGtub3dsZWRnZS5cbiAgICogQHBhcmFtIGdlbmVfZGF0YSAtIFRoZSBnZW5lIGRhdGEgdG8gYmUgdXNlZCB0byBjcmVhdGUgdGhlIG9yZ2FuaXNtLlxuICAgKiBAcGFyYW0gY29vcmRpbmF0ZSAtIFRoZSBjb29yZGluYXRlIHRvIHBsYWNlIHRoZSBvcmdhbmlzbSBhdC5cbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgYWRkaXRpb24gd2FzIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBwdWJsaWMgYWRkX29yZ2FuaXNtKGdlbmVfZGF0YTogR2VuZVtdLCBjb29yZGluYXRlPzogQ29vcmRpbmF0ZSk6IGJvb2xlYW4ge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwb3B1bGF0aW9uIHNpemUgaGFzIGV4Y2VlZGVkIHRoZSBjb25maWd1cmVkIGxpbWl0LlxuICAgIGlmICh0aGlzLnBvcHVsYXRpb24ubGVuZ3RoID4gdGhpcy5jb25maWcuUE9QVUxBVElPTikge1xuICAgICAgLy8gRGlzcGxheSBhbiBhbGVydCBpZiB0aGUgcG9wdWxhdGlvbiBzaXplIGxpbWl0IGlzIGV4Y2VlZGVkLlxuICAgICAgYWxlcnQoXCJQb3B1bGF0aW9uIHNpemUgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiBHcmlkIHNpemUgc3F1YXJlZC5cIik7XG4gICAgICAvLyBSZXR1cm4gZmFsc2UgYXMgdGhlIGFkZGl0aW9uIGlzIG5vdCBwZXJtaXR0ZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gY29vcmRpbmF0ZSBpcyBwcm92aWRlZCwgZmV0Y2ggYW4gZW1wdHkgY2VsbCBmcm9tIHRoZSBncmlkLlxuICAgIGlmICghY29vcmRpbmF0ZSkgY29vcmRpbmF0ZSA9IHRoaXMuZ3JpZC5mZXRjaF9lbXB0eV9jZWxsKCk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgT3JnYW5pc20gaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgZ2VuZSBkYXRhLCBncmlkLCBjb25maWd1cmF0aW9uLCBhbmQgcG9wdWxhdGlvbiBpbmRleC5cbiAgICBjb25zdCBvcmdhbmlzbSA9IG5ldyBPcmdhbmlzbShjb29yZGluYXRlLCBnZW5lX2RhdGEsIHRoaXMuZ3JpZCwgdGhpcy5jb25maWcpO1xuXG4gICAgLy8gU2V0IHRoZSBjZWxsIG93bmVyIGFzIHRoZSBuZXdseSBjcmVhdGVkIG9yZ2FuaXNtLlxuICAgIHRoaXMuZ3JpZC5zZXRfY2VsbF9vd25lcihjb29yZGluYXRlLCBvcmdhbmlzbSk7XG5cbiAgICAvLyBBZGQgdGhlIG5ldyBvcmdhbmlzbSB0byB0aGUgcG9wdWxhdGlvbiBhcnJheS5cbiAgICB0aGlzLnBvcHVsYXRpb24ucHVzaChvcmdhbmlzbSk7XG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSB0byBpbmRpY2F0ZSBzdWNjZXNzZnVsIGFkZGl0aW9uIG9mIHRoZSBvcmdhbmlzbS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBEcm9wcyBmb29kIHJhbmRvbWx5IHdpdGhpbiBhIGRlZmluZWQgYXJlYSBpbiB0aGUgZ3JpZC4gKi9cbiAgcHVibGljIGRyb3BfZm9vZCgpOiB2b2lkIHtcbiAgICAvLyBMb29wIHRvIGRyb3AgZm9vZCAxMDAwIHRpbWVzLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGNlbnRlciBvZiB0aGUgZ3JpZC5cbiAgICAgIGNvbnN0IGNlbnRlciA9IE1hdGguZmxvb3IodGhpcy5jb25maWcuR1JJRF9TSVpFIC8gMik7XG4gICAgICAvLyBTZXQgYSBjZWxsIHN0YXRlIHRvIEZPT0QgYXQgYSByYW5kb21seSBnZW5lcmF0ZWQgY29vcmRpbmF0ZSB3aXRoaW4gYSBzcGVjaWZpZWQgcmFuZ2UgYXJvdW5kIHRoZSBjZW50ZXIuXG4gICAgICB0aGlzLmdyaWQuc2V0X2NlbGxfc3RhdGUoZ2V0X3JhbmRvbV92ZWN0b3IoY2VudGVyIC0gMTAsIGNlbnRlciAtIDEwLCBjZW50ZXIgKyAxMCwgY2VudGVyICsgMTApLCBDZWxsU3RhdGVzLkZPT0QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBVcGRhdGVzIHRoZSBzaW11bGF0aW9uIGNoYXJ0LiAqL1xuICBwdWJsaWMgdXBkYXRlX2NoYXJ0cygpOiB2b2lkIHtcbiAgICAvLyBBZGRzIGRhdGEgcG9pbnRzIHRvIHRoZSBjaGFydC5cbiAgICB0aGlzLmJlc3RfZml0bmVzc19kYXRhX3BvaW50cy5wdXNoKHtcbiAgICAgIHg6IHRoaXMuZ2VuZXJhdGlvbixcbiAgICAgIHk6IHRoaXMuYmVzdF9maXRuZXNzLFxuICAgIH0pO1xuICAgIHRoaXMub3ZlcmFsbF9maXRuZXNzX2RhdGFfcG9pbnRzLnB1c2goe1xuICAgICAgeDogdGhpcy5nZW5lcmF0aW9uLFxuICAgICAgeTogdGhpcy5vdmVyYWxsX2ZpdG5lc3MsXG4gICAgfSk7XG4gICAgdGhpcy5udW1iZXJfb2Zfc3BlY2llc19kYXRhX3BvaW50cy5wdXNoKHtcbiAgICAgIHg6IHRoaXMuZ2VuZXJhdGlvbixcbiAgICAgIHk6IHRoaXMuc3BlY2llc19jb3VudCxcbiAgICB9KTtcbiAgICAvLyBVcGRhdGVzIGFuZCByZW5kZXJzIHRoZSBjaGFydC5cbiAgICB0aGlzLmNoYXJ0LmNoYXJ0LnJlbmRlcigpO1xuICB9XG5cbiAgLyoqIEluaXRpYWxpemVzIHRoZSBlbnZpcm9ubWVudC4gKi9cbiAgcHVibGljIGluaXQoKTogdm9pZCB7XG4gICAgLy8gUG9wdWxhdGUgdGhlIGVudmlyb25tZW50IHVudGlsIHRoZSBkZXNpcmVkIHBvcHVsYXRpb24gc2l6ZSBpcyByZWFjaGVkLlxuICAgIHdoaWxlICh0aGlzLnBvcHVsYXRpb24ubGVuZ3RoICE9IHRoaXMuY29uZmlnLlBPUFVMQVRJT04pIHtcbiAgICAgIGNvbnN0IGRhdGE6IEdlbmVbXSA9IFtdO1xuICAgICAgLy8gR2VuZXJhdGUgZ2VuZXMgZm9yIGVhY2ggb3JnYW5pc20uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLk5VTUJFUl9PRl9HRU5FUzsgaSsrKSB7XG4gICAgICAgIGRhdGEucHVzaChuZXcgR2VuZSh0aGlzLmNvbmZpZy5OVU1CRVJfT0ZfSElEREVOX05FVVJPTlMpKTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBhbiBvcmdhbmlzbSB3aXRoIGdlbmVyYXRlZCBnZW5lcyB0byB0aGUgZW52aXJvbm1lbnQuXG4gICAgICB0aGlzLmFkZF9vcmdhbmlzbShkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgY29uZmlndXJhdGlvbiBzcGVjaWZpZXMgdG8gZHJvcCBmb29kLCBkaXN0cmlidXRlIGZvb2Qgd2l0aGluIHRoZSBlbnZpcm9ubWVudC5cbiAgICBpZiAodGhpcy5jb25maWcuR09BTF9GT09EKSB7XG4gICAgICB0aGlzLmRyb3BfZm9vZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBSZXNldHMgdGhlIGVudmlyb25tZW50IGZvciB0aGUgbmV4dCBnZW5lcmF0aW9uLiAqL1xuICBwdWJsaWMgbmV4dF9nZW5lcmF0aW9uKCk6IHZvaWQge1xuICAgIC8vIENhbGN1bGF0ZSBmaXRuZXNzIG9mIGFsbCBpbmRpdmlkdWFscyBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBnb2Fscy5cbiAgICBpZiAodGhpcy5jb25maWcuR09BTF9DT09SRCkge1xuICAgICAgdGhpcy5wb3B1bGF0aW9uID0gY2FsY3VsYXRlX2FuZF9zb3J0X2ZpdG5lc3ModGhpcy5wb3B1bGF0aW9uLCBcImNvb3JkXCIsIHtcbiAgICAgICAgZ29hbF9jb29yZGluYXRlczogdGhpcy5nb2FsX2Nvb3JkaW5hdGVzLFxuICAgICAgICBtYXhfZGlzdGFuY2VzX3RvX2dvYWw6IHRoaXMubWF4X2Rpc3RhbmNlc190b19nb2FsLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5HT0FMX0ZPT0QpIHtcbiAgICAgIHRoaXMucG9wdWxhdGlvbiA9IGNhbGN1bGF0ZV9hbmRfc29ydF9maXRuZXNzKHRoaXMucG9wdWxhdGlvbiwgXCJmb29kXCIpO1xuICAgIH1cblxuICAgIGxldCBiZXN0X2ZvdW5kID0gZmFsc2U7XG4gICAgbGV0IGZpdG5lc3Nfc3VtID0gMDtcblxuICAgIC8vIEZpbmQgdGhlIGJlc3QgaW5kaXZpZHVhbCBhbmQgY2FsY3VsYXRlIHRoZSBmaXRuZXNzIHN1bSwgd2hpY2ggaXMgdG8gYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG92ZXJhbGwgZml0bmVzcy5cbiAgICBmb3IgKGNvbnN0IG9yZ2FuaXNtIG9mIHRoaXMucG9wdWxhdGlvbikge1xuICAgICAgLy8gQWRkIHRoZSBvcmdhbmlzbSdzIGNvbG91ciB0byB0aGUgc3BlY2llcyBzZXQuXG4gICAgICBpZiAob3JnYW5pc20uZ2Vub21lLmNvbG91cikgdGhpcy5zcGVjaWVzLmFkZChvcmdhbmlzbS5nZW5vbWUuY29sb3VyKTtcbiAgICAgIGlmIChvcmdhbmlzbS5hbGl2ZSkgZml0bmVzc19zdW0gKz0gb3JnYW5pc20uZml0bmVzcyE7XG4gICAgICBpZiAoIWJlc3RfZm91bmQgJiYgb3JnYW5pc20uYWxpdmUpIHtcbiAgICAgICAgdGhpcy5iZXN0X2ZpdG5lc3MgPSBvcmdhbmlzbS5maXRuZXNzITtcbiAgICAgICAgYmVzdF9mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmdyaWQuY2xlYXJfY2VsbF9zdGF0ZShvcmdhbmlzbS5jb29yZGluYXRlKTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVyYWxsIGZpdG5lc3Mgb2YgdGhlIHBvcHVsYXRpb24uXG4gICAgdGhpcy5vdmVyYWxsX2ZpdG5lc3MgPSB0aGlzLmFsaXZlID4gMCA/IGZpdG5lc3Nfc3VtIC8gdGhpcy5hbGl2ZSA6IDA7XG5cbiAgICAvLyBTZWxlY3QgYW5kIGNyb3Nzb3ZlciBpbmRpdmlkdWFscyBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBnZW5ldGljIGFsZ29yaXRobS5cbiAgICB0aGlzLnBvcHVsYXRpb24gPSBzZWxlY3RfYW5kX2Nyb3Nzb3Zlcih0aGlzLnBvcHVsYXRpb24sIHRoaXMuY29uZmlnKTtcblxuICAgIC8vIFJlc2V0IHRpY2sgY291bnQgYW5kIGluY3JlbWVudCBnZW5lcmF0aW9uIGNvdW50LlxuICAgIHRoaXMuc3BlY2llc19jb3VudCA9IHRoaXMuc3BlY2llcy5zaXplO1xuICAgIHRoaXMudXBkYXRlX2NoYXJ0cygpO1xuICAgIHRoaXMudGlja3MgPSAwO1xuICAgIHRoaXMuZ2VuZXJhdGlvbisrO1xuXG4gICAgLy8gVXBkYXRlIEhUTUwgZWxlbWVudHMgd2l0aCBzaW11bGF0aW9uIGRhdGEuXG4gICAgRE9NRWxlbWVudHMuYmVzdF9maXRuZXNzLmlubmVySFRNTCA9IHRoaXMuYmVzdF9maXRuZXNzLnRvUHJlY2lzaW9uKDMpLnRvU3RyaW5nKCk7XG4gICAgRE9NRWxlbWVudHMub3ZlcmFsbF9maXRuZXNzLmlubmVySFRNTCA9IHRoaXMub3ZlcmFsbF9maXRuZXNzLnRvUHJlY2lzaW9uKDMpLnRvU3RyaW5nKCk7XG4gICAgRE9NRWxlbWVudHMubnVtYmVyX29mX3NwZWNpZXMuaW5uZXJIVE1MID0gdGhpcy5zcGVjaWVzX2NvdW50LnRvU3RyaW5nKCk7XG5cbiAgICB0aGlzLnNwZWNpZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBJZiB0aGUgZ29hbCBpcyB0byBkaXN0cmlidXRlIGZvb2QsIGRvIHNvIHdpdGhpbiB0aGUgZW52aXJvbm1lbnQuXG4gICAgaWYgKHRoaXMuY29uZmlnLkdPQUxfRk9PRCkge1xuICAgICAgdGhpcy5kcm9wX2Zvb2QoKTtcbiAgICB9XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgZW52aXJvbm1lbnQgYmFzZWQgb24gdGhlIGNvbmZpZ3VyZWQgZ29hbHMgYW5kIGNvbmRpdGlvbnMuICovXG4gIHB1YmxpYyB1cGRhdGUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudGlja3MgPiB0aGlzLmNvbmZpZy5USUNLU19QRVJfR0VORVJBVElPTikge1xuICAgICAgdGhpcy5uZXh0X2dlbmVyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbGl2ZSA9IDA7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiBvcmdhbmlzbXMgYW5kIHBlcmZvcm0gYWN0aW9ucyBiYXNlZCBvbiB0aGUgZW52aXJvbm1lbnQncyBydWxlcy5cbiAgICAgIGZvciAoY29uc3Qgb3JnYW5pc20gb2YgdGhpcy5wb3B1bGF0aW9uKSB7XG4gICAgICAgIGlmIChvcmdhbmlzbS5hbGl2ZSkge1xuICAgICAgICAgIHRoaXMuYWxpdmUrKztcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBvcmdhbmlzbS5hY3Rpb24oKTtcbiAgICAgICAgICBjb25zdCBuZXdfY29vcmRpbmF0ZSA9IGFkZF92ZWN0b3Iob3JnYW5pc20uY29vcmRpbmF0ZSwgb2Zmc2V0KTtcblxuICAgICAgICAgIGlmICh0aGlzLmdyaWQuaXNfdmFsaWRfY2VsbF9hdChuZXdfY29vcmRpbmF0ZSkgJiYgdGhpcy5ncmlkLmlzX2NlbGxfZW1wdHkobmV3X2Nvb3JkaW5hdGUpKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgY29vcmRpbmF0ZXMgaWYgdGhlIG5ldyBjZWxsIGlzIGVtcHR5LlxuICAgICAgICAgICAgb3JnYW5pc20uZGlyZWN0aW9uID0gb2Zmc2V0O1xuICAgICAgICAgICAgb3JnYW5pc20uY29vcmRpbmF0ZSA9IG5ld19jb29yZGluYXRlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ncmlkLmlzX3ZhbGlkX2NlbGxfYXQobmV3X2Nvb3JkaW5hdGUpICYmIHRoaXMuZ3JpZC5nZXRfY2VsbF9hdChuZXdfY29vcmRpbmF0ZSkuc3RhdGUgPT0gQ2VsbFN0YXRlcy5SQURJT0FDVElWRSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgY2VsbCBpZiBpdCdzIHJhZGlvYWN0aXZlLCBtYXJraW5nIG9yZ2FuaXNtIGFzIGRlYWQuXG4gICAgICAgICAgICB0aGlzLmdyaWQuY2xlYXJfY2VsbF9zdGF0ZShvcmdhbmlzbS5jb29yZGluYXRlKTtcbiAgICAgICAgICAgIG9yZ2FuaXNtLmFsaXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFsaXZlLS07XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdyaWQuaXNfdmFsaWRfY2VsbF9hdChuZXdfY29vcmRpbmF0ZSkgJiYgdGhpcy5ncmlkLmdldF9jZWxsX2F0KG5ld19jb29yZGluYXRlKS5zdGF0ZSA9PSBDZWxsU3RhdGVzLkZPT0QpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIGNlbGwsIGNvbnN1bWUgZm9vZCwgYW5kIHVwZGF0ZSBjb29yZGluYXRlcyBpZiBpdCdzIGZvb2QuXG4gICAgICAgICAgICB0aGlzLmdyaWQuY2xlYXJfY2VsbF9zdGF0ZShvcmdhbmlzbS5jb29yZGluYXRlKTtcblxuICAgICAgICAgICAgaWYgKG9yZ2FuaXNtLmVuZXJneSA9PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuZ3JpZC5nZXRfY2VsbF9hdChuZXdfY29vcmRpbmF0ZSkuZW5lcmd5IC09IDE7XG4gICAgICAgICAgICAgIG9yZ2FuaXNtLmVuZXJneSA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9yZ2FuaXNtLmRpcmVjdGlvbiA9IG9mZnNldDtcbiAgICAgICAgICAgIG9yZ2FuaXNtLmNvb3JkaW5hdGUgPSBuZXdfY29vcmRpbmF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50aWNrcysrO1xuICB9XG5cbiAgLyoqIFJlbmRlcnMgdGhlIGVudmlyb25tZW50IG9uIHRoZSBjYW52YXMuICovXG4gIHB1YmxpYyByZW5kZXIoKTogdm9pZCB7XG4gICAgLy8gQ2xlYXIgY2VsbHMgdGhhdCBhcmUgbm90IHNlbGVjdGVkIGFuZCBmaWxsIG90aGVycyBiYXNlZCBvbiB0b19jbGVhciBhbmQgdG9fZmlsbCBsaXN0cy5cbiAgICBsZXQgY2VsbCA9IHRoaXMucmVuZGVyZXIudG9fY2xlYXIuZGVxdWV1ZSgpO1xuICAgIHdoaWxlIChjZWxsICE9IG51bGwpIHtcbiAgICAgIGlmICghY2VsbC5pc19zZWxlY3RlZCkgdGhpcy5yZW5kZXJlci5jbGVhcl9jZWxsKGNlbGwpO1xuICAgICAgZWxzZSB0aGlzLnJlbmRlcmVyLnJlbmRlcl9jZWxsKGNlbGwpO1xuICAgICAgY2VsbCA9IHRoaXMucmVuZGVyZXIudG9fY2xlYXIuZGVxdWV1ZSgpO1xuICAgIH1cblxuICAgIGNlbGwgPSB0aGlzLnJlbmRlcmVyLnRvX2ZpbGwuZGVxdWV1ZSgpO1xuICAgIC8vIEZpbGwgY2VsbHMgYmFzZWQgb24gdGhlIHRvX2ZpbGwgbGlzdC5cbiAgICB3aGlsZSAoY2VsbCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcl9jZWxsKGNlbGwpO1xuICAgICAgY2VsbCA9IHRoaXMucmVuZGVyZXIudG9fZmlsbC5kZXF1ZXVlKCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgRGlyZWN0aW9ucyBmcm9tIFwiLi4vY29uc3RhbnRzL0RpcmVjdGlvbnNcIjtcbmltcG9ydCB7IElucHV0TmV1cm9ucyB9IGZyb20gXCIuLi9jb25zdGFudHMvSW5wdXROZXVyb25zXCI7XG5pbXBvcnQgeyBBbGxDZWxsU3RhdGVzLCBHcmlkIH0gZnJvbSBcIi4uL2Vudmlyb25tZW50L0dyaWRcIjtcbmltcG9ydCB3ZWlnaHRfYXNfZmxvYXQgZnJvbSBcIi4uL3V0aWxzL3dlaWdodF9hc19mbG9hdFwiO1xuaW1wb3J0IHsgYWRkX3ZlY3RvciwgZXVjbGlkZWFuX2Rpc3RhbmNlIH0gZnJvbSBcIi4uL3V0aWxzL2dlb21ldHJ5XCI7XG5pbXBvcnQgR2VuZSBmcm9tIFwiLi9HZW5lXCI7XG5pbXBvcnQgeyBOZXVyb24sIE5ldXJvbnMgfSBmcm9tIFwiLi9OZXVyb25zXCI7XG5pbXBvcnQgeyBDb29yZGluYXRlIH0gZnJvbSBcIi4uL3R5cGVzL0Nvb3JkaW5hdGVcIjtcblxudHlwZSBDb25uZWN0aW9uQXJyYXkgPSBBcnJheTxHZW5lPjtcbnR5cGUgSGlkZGVuTmV1cm9uTWFwID0gTWFwPG51bWJlciwgSGlkZGVuTmV1cm9uPjtcblxuLyoqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgYSBoaWRkZW4gbmV1cm9uIGluIGEgbmV1cmFsIG5ldHdvcmsuICovXG5leHBvcnQgY2xhc3MgSGlkZGVuTmV1cm9uIHtcbiAgLy8gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBoaWRkZW4gbmV1cm9uLlxuICBwdWJsaWMgaWRlbnRpZmVyO1xuICAvLyBOdW1iZXIgb2YgaW5jb21pbmcgY29ubmVjdGlvbnMgdGhhdCBhcmUgZnJvbSBlaXRoZXIgc2Vuc29ycyBvciBvdGhlciBuZXVyb25zLlxuICBwdWJsaWMgaW5wdXRzO1xuICAvLyBOdW1iZXIgb2Ygb3V0Y29taW5nIGNvbm5lY3Rpb25zIGZyb20gdGhlIG5ldXJvbi5cbiAgcHVibGljIG91dHB1dHM7XG4gIC8vIE51bWJlciBvZiBpbnB1dCBjb25uZWN0aW9ucyB0aGF0IGdvIGJhY2sgaW50byB0aGUgbmV1cm9uLlxuICBwdWJsaWMgc2VsZl9pbnB1dHM7XG59XG5cbi8qKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGEgYnJhaW4gZm9yIGFuIG9yZ2FuaXNtLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJhaW4ge1xuICBwdWJsaWMgY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTtcbiAgcHVibGljIGdyaWQ6IEdyaWQ7XG4gIHB1YmxpYyBnZW5vbWVfZGF0YTogR2VuZVtdO1xuICAvLyBVc2VkIHRlbXBvcmFyaWx5IHRvIHN0b3JlIHRoZSBuZXVyYWwgbmV0d29yaydzIGlucHV0cywgb3V0cHV0cywgYW5kIGhpZGRlbiBuZXVyb25zLlxuICBwdWJsaWMgaW5wdXRzOiBvYmplY3Q7XG4gIHB1YmxpYyBvdXRwdXRzOiBvYmplY3Q7XG4gIHB1YmxpYyBoaWRkZW46IG9iamVjdDtcbiAgLy8gQ29tcGxldGUgbGlzdCBvZiBoaWRkZW4gbmV1cm9ucy5cbiAgcHVibGljIGhpZGRlbl9uZXVyb25zOiBOZXVyb25bXTtcbiAgLy8gQWxsIG5ldXJhbCBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICBwdWJsaWMgY29ubmVjdGlvbnM6IEdlbmVbXTtcbiAgLy8gTnVtYmVyIG9mIHNlbnNvcnMsIG5ldXJvbnMgYW5kIGFjdGlvbnMuXG4gIHB1YmxpYyBudW1faW5wdXRfbmV1cm9uczogbnVtYmVyO1xuICBwdWJsaWMgbnVtX2hpZGRlbl9uZXVyb25zOiBudW1iZXI7XG4gIHB1YmxpYyBudW1fb3V0cHV0X25ldXJvbnM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb29yZGluYXRlLCBncmlkLCBnZW5vbWVfZGF0YSwgbnVtX2lucHV0X25ldXJvbnM6IG51bWJlciwgbnVtX2hpZGRlbl9uZXVyb25zOiBudW1iZXIsIG51bV9vdXRwdXRfbmV1cm9uczogbnVtYmVyKSB7XG4gICAgLy8gUmVmZXJlbmNlcyB0byB0aGUgb3JnYW5pc20ncyBjb29yZGluYXRlIGFuZCB0aGUgZ3JpZC5cbiAgICB0aGlzLmNvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgdGhpcy5nZW5vbWVfZGF0YSA9IGdlbm9tZV9kYXRhO1xuICAgIHRoaXMuaW5wdXRzID0ge307XG4gICAgdGhpcy5vdXRwdXRzID0ge307XG4gICAgdGhpcy5oaWRkZW4gPSB7fTtcbiAgICB0aGlzLmhpZGRlbl9uZXVyb25zID0gW107XG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgIHRoaXMubnVtX2lucHV0X25ldXJvbnMgPSBudW1faW5wdXRfbmV1cm9ucztcbiAgICB0aGlzLm51bV9oaWRkZW5fbmV1cm9ucyA9IG51bV9oaWRkZW5fbmV1cm9ucztcbiAgICB0aGlzLm51bV9vdXRwdXRfbmV1cm9ucyA9IG51bV9vdXRwdXRfbmV1cm9ucztcbiAgICB0aGlzLndpcmVfYnJhaW4oKTtcbiAgfVxuXG4gIC8qKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIGNvbnZlcnQgYW4gb3JnYW5pc20ncyBnZW5vbWUgaW50byBhIG5ldXJhbCBuZXR3b3JrIGJyYWluLiAqL1xuICBwdWJsaWMgd2lyZV9icmFpbigpOiB2b2lkIHtcbiAgICAvLyBMaXN0IHRvIHN0b3JlIG5ldXJhbCBuZXR3b3JrIGNvbm5lY3Rpb25zLlxuICAgIGNvbnN0IGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uQXJyYXkgPSB0aGlzLm9idGFpbl9jb25uZWN0aW9ucygpO1xuXG4gICAgLy8gTWFwIG9mIHRoZSBoaWRkZW4gbmV1cm9ucyBhbmQgdGhlaXIgbnVtYmVyIG9mIGlucHV0cyBhbmQgb3V0cHV0cy5cbiAgICBjb25zdCBoaWRkZW5fbmV1cm9uX21hcDogSGlkZGVuTmV1cm9uTWFwID0gdGhpcy5jcmVhdGVfaGlkZGVuX25ldXJvbl9tYXAoY29ubmVjdGlvbnMpO1xuXG4gICAgLy8gUmVtb3ZlIGNvbm5lY3Rpb25zIHRvIG5ldXJvbnMgd2l0aCBubyBvdXRwdXRzIG9yIG5ldXJvbnMgdGhhdCBmZWVkIHRoZW1zZWx2ZXMuXG4gICAgdGhpcy5wcnVuZV9jb25uZWN0aW9ucyhjb25uZWN0aW9ucywgaGlkZGVuX25ldXJvbl9tYXApO1xuXG4gICAgLy8gQ3JlYXRlIGEgcmVudW1iZXJlZCBjb25uZWN0aW9uIGFycmF5IGJhc2VkIG9uIHRoZSBub2RlIG1hcC5cbiAgICB0aGlzLmNyZWF0ZV9jb25uZWN0aW9ucyhjb25uZWN0aW9ucywgaGlkZGVuX25ldXJvbl9tYXApO1xuICAgIHRoaXMuY3JlYXRlX2hpZGRlbl9uZXVyb25fYXJyYXkoaGlkZGVuX25ldXJvbl9tYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgb3JnYW5pc20gdG8gbG9vayBpbiBhIHNwZWNpZmljIGRpcmVjdGlvbiBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgY2VsbC5cbiAgICogQHBhcmFtIGRpcmVjdGlvbiAtIFRoZSBkaXJlY3Rpb24gdG8gbG9vayBpbi5cbiAgICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgc3RhdGUgb2YgdGhlIGNlbGwuXG4gICAqL1xuICBwdWJsaWMgb2JzZXJ2YXRpb25fc2Vuc29yKGRpcmVjdGlvbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBsZXQgY3VycmVudF92ZWN0b3IgPSB7IHg6IHRoaXMuY29vcmRpbmF0ZS54LCB5OiB0aGlzLmNvb3JkaW5hdGUueSB9O1xuICAgIGxldCB2ZWN0b3I6IENvb3JkaW5hdGU7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHZlY3RvciBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIHBhcmFtZXRlci5cbiAgICBpZiAoZGlyZWN0aW9uID09IElucHV0TmV1cm9ucy5MT09LX05PUlRIKSB2ZWN0b3IgPSBEaXJlY3Rpb25zLk5PUlRIO1xuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBJbnB1dE5ldXJvbnMuTE9PS19FQVNUKSB2ZWN0b3IgPSBEaXJlY3Rpb25zLkVBU1Q7XG4gICAgZWxzZSBpZiAoZGlyZWN0aW9uID09IElucHV0TmV1cm9ucy5MT09LX1NPVVRIKSB2ZWN0b3IgPSBEaXJlY3Rpb25zLlNPVVRIO1xuICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBJbnB1dE5ldXJvbnMuTE9PS19XRVNUKSB2ZWN0b3IgPSBEaXJlY3Rpb25zLldFU1Q7XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkRpcmVjdGlvbiBub3QgY29ycmVjdC5cIik7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHZlY3RvciBiYXNlZCBvbiB0aGUgZGV0ZXJtaW5lZCBkaXJlY3Rpb24uXG4gICAgY3VycmVudF92ZWN0b3IgPSBhZGRfdmVjdG9yKGN1cnJlbnRfdmVjdG9yLCB2ZWN0b3IpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHVwZGF0ZWQgdmVjdG9yIHJlcHJlc2VudHMgYSB2YWxpZCBjZWxsIGluIHRoZSBncmlkLlxuICAgIGlmICh0aGlzLmdyaWQuaXNfdmFsaWRfY2VsbF9hdChjdXJyZW50X3ZlY3RvcikpIHtcbiAgICAgIC8vIFJldHJpZXZlIHRoZSBjZWxsIGF0IHRoZSB1cGRhdGVkIHZlY3Rvci5cbiAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdyaWQuZ2V0X2NlbGxfYXQoY3VycmVudF92ZWN0b3IpO1xuICAgICAgLy8gUmV0dXJuIHRoZSBub3JtYWxpemVkIHN0YXRlIG9mIHRoZSBjZWxsLlxuICAgICAgcmV0dXJuIGNlbGwuc3RhdGUgLyBBbGxDZWxsU3RhdGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBJZiBubyB2YWxpZCBvYnNlcnZhdGlvbiBpcyBmb3VuZCwgcmV0dXJuIDAuXG4gICAgcmV0dXJuIDAuMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG9yZ2FuaXNtIHRvIG9idGFpbiBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY3VycmVudCBjb29yZGluYXRlcy5cbiAgICogQHBhcmFtIHNlbnNvciAtIFRoZSBzZW5zb3IgdG8gdXNlLlxuICAgKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgc2Vuc29yLlxuICAgKi9cbiAgcHVibGljIGNvb3JkaW5hdGVfc2Vuc29yKHNlbnNvcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoc2Vuc29yID09IElucHV0TmV1cm9ucy5YX0NPT1JESU5BVEUgJiYgdGhpcy5ncmlkLmdyaWRfc2l6ZSkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGFuZCByZXR1cm4gdGhlIG5vcm1hbGl6ZWQgeC1jb29yZGluYXRlLlxuICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZS54IC8gdGhpcy5ncmlkLmdyaWRfc2l6ZTtcbiAgICB9IGVsc2UgaWYgKHNlbnNvciA9PSBJbnB1dE5ldXJvbnMuWV9DT09SRElOQVRFICYmIHRoaXMuZ3JpZC5ncmlkX3NpemUpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSBub3JtYWxpemVkIHktY29vcmRpbmF0ZS5cbiAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGUueSAvIHRoaXMuZ3JpZC5ncmlkX3NpemU7XG4gICAgfSBlbHNlIGlmIChzZW5zb3IgPT0gSW5wdXROZXVyb25zLkJPVU5EQVJZX05PUlRIKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgbm9ybWFsaXplZCBkaXN0YW5jZSB0byB0aGUgbm9ydGhlcm4gYm91bmRhcnkuXG4gICAgICByZXR1cm4gZXVjbGlkZWFuX2Rpc3RhbmNlKHRoaXMuY29vcmRpbmF0ZSwgeyB4OiB0aGlzLmNvb3JkaW5hdGUueCwgeTogMCB9KSAvIHRoaXMuZ3JpZC5ncmlkX3NpemU7XG4gICAgfSBlbHNlIGlmIChzZW5zb3IgPT0gSW5wdXROZXVyb25zLkJPVU5EQVJZX1dFU1QpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSBub3JtYWxpemVkIGRpc3RhbmNlIHRvIHRoZSB3ZXN0ZXJuIGJvdW5kYXJ5LlxuICAgICAgcmV0dXJuIGV1Y2xpZGVhbl9kaXN0YW5jZSh0aGlzLmNvb3JkaW5hdGUsIHsgeDogMCwgeTogdGhpcy5jb29yZGluYXRlLnkgfSkgLyB0aGlzLmdyaWQuZ3JpZF9zaXplO1xuICAgIH0gZWxzZSBpZiAoc2Vuc29yID09IElucHV0TmV1cm9ucy5CT1VOREFSWV9FQVNUKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgYW5kIHJldHVybiB0aGUgbm9ybWFsaXplZCBkaXN0YW5jZSB0byB0aGUgZWFzdGVybiBib3VuZGFyeS5cbiAgICAgIHJldHVybiBldWNsaWRlYW5fZGlzdGFuY2UodGhpcy5jb29yZGluYXRlLCB7IHg6IHRoaXMuZ3JpZC5ncmlkX3NpemUsIHk6IHRoaXMuY29vcmRpbmF0ZS55IH0pIC8gdGhpcy5ncmlkLmdyaWRfc2l6ZTtcbiAgICB9IGVsc2UgaWYgKHNlbnNvciA9PSBJbnB1dE5ldXJvbnMuQk9VTkRBUllfU09VVEgpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBhbmQgcmV0dXJuIHRoZSBub3JtYWxpemVkIGRpc3RhbmNlIHRvIHRoZSBzb3V0aGVybiBib3VuZGFyeS5cbiAgICAgIHJldHVybiBldWNsaWRlYW5fZGlzdGFuY2UodGhpcy5jb29yZGluYXRlLCB7IHg6IHRoaXMuY29vcmRpbmF0ZS54LCB5OiB0aGlzLmdyaWQuZ3JpZF9zaXplIH0pIC8gdGhpcy5ncmlkLmdyaWRfc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0dXJuIDAuMCBpZiB0aGUgc2Vuc29yIGRvZXNuJ3QgbWF0Y2ggYW55IHByZWRlZmluZWQgc2Vuc29yIHR5cGUuXG4gICAgICByZXR1cm4gMC4wO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG9yZ2FuaXNtIHRvIG9idGFpbiBpbmZvcm1hdGlvbiBmcm9tIGEgc3BlY2lmaWMgc2Vuc29yLlxuICAgKiBAcGFyYW0gc2Vuc29yX2lkIC0gVGhlIHNlbnNvciBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJucyAtIFRoZSB2YWx1ZSBvZiB0aGUgc2Vuc29yLlxuICAgKi9cbiAgcHVibGljIGdldF9zZW5zb3Ioc2Vuc29yX2lkOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChcbiAgICAgIFtcbiAgICAgICAgSW5wdXROZXVyb25zLlhfQ09PUkRJTkFURSxcbiAgICAgICAgSW5wdXROZXVyb25zLllfQ09PUkRJTkFURSxcbiAgICAgICAgSW5wdXROZXVyb25zLkJPVU5EQVJZX05PUlRILFxuICAgICAgICBJbnB1dE5ldXJvbnMuQk9VTkRBUllfRUFTVCxcbiAgICAgICAgSW5wdXROZXVyb25zLkJPVU5EQVJZX1NPVVRILFxuICAgICAgICBJbnB1dE5ldXJvbnMuQk9VTkRBUllfV0VTVCxcbiAgICAgIF0uaW5jbHVkZXMoc2Vuc29yX2lkKVxuICAgICkge1xuICAgICAgLy8gQ2FsbCBjb29yZGluYXRlX3NlbnNvciBtZXRob2QgZm9yIGNvb3JkaW5hdGUtcmVsYXRlZCBzZW5zb3JzIGFuZCByZXR1cm4gdGhlIG9idGFpbmVkIHZhbHVlLlxuICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZV9zZW5zb3Ioc2Vuc29yX2lkKTtcbiAgICB9IGVsc2UgaWYgKFtJbnB1dE5ldXJvbnMuTE9PS19OT1JUSCwgSW5wdXROZXVyb25zLkxPT0tfRUFTVCwgSW5wdXROZXVyb25zLkxPT0tfU09VVEgsIElucHV0TmV1cm9ucy5MT09LX1dFU1RdLmluY2x1ZGVzKHNlbnNvcl9pZCkpIHtcbiAgICAgIC8vIENhbGwgb2JzZXJ2YXRpb25fc2Vuc29yIG1ldGhvZCBmb3IgZGlyZWN0aW9uIG9ic2VydmF0aW9uIHNlbnNvcnMgYW5kIHJldHVybiB0aGUgb2J0YWluZWQgdmFsdWUuXG4gICAgICByZXR1cm4gdGhpcy5vYnNlcnZhdGlvbl9zZW5zb3Ioc2Vuc29yX2lkKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIDAuMCBmb3Igc2Vuc29ycyB0aGF0IGRvbid0IG1hdGNoIGFueSBwcmVkZWZpbmVkIHR5cGUuXG4gICAgcmV0dXJuIDAuMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGZlZWQtZm9yd2FyZCBjb21wdXRhdGlvbiBpbiB0aGUgbmV1cmFsIG5ldHdvcmsuXG4gICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG91dHB1dCBsZXZlbHMgZm9yIGFsbCBhY3Rpb24gbmV1cm9ucy5cbiAgICovXG4gIHB1YmxpYyBmZWVkX2ZvcndhcmQoKTogbnVtYmVyW10ge1xuICAgIC8vIFRoaXMgYXJyYXkgc3RvcmVzIHRoZSBvdXRwdXQgbGV2ZWxzIGZvciBhbGwgb2YgdGhlIGFjdGlvbiBuZXVyb25zLlxuICAgIGNvbnN0IGFjdGlvbl9sZXZlbHMgPSBuZXcgQXJyYXkodGhpcy5udW1fb3V0cHV0X25ldXJvbnMpLmZpbGwoMC4wKTtcblxuICAgIC8vIFRoZSB3ZWlnaHRlZCBpbnB1dHMgdG8gZWFjaCBuZXVyb24gYXJlIGFjY3VtdWxhdGVkIGluIG5ldXJvbl9hY2N1bXVsYXRvcnMuXG4gICAgY29uc3QgbmV1cm9uX2FjY3VtdWxhdG9ycyA9IG5ldyBBcnJheSh0aGlzLmhpZGRlbl9uZXVyb25zLmxlbmd0aCkuZmlsbCgwLjApO1xuXG4gICAgbGV0IG5ldXJvbl9vdXRwdXRzX2NvbXB1dGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIHRoaXMuY29ubmVjdGlvbnMpIHtcbiAgICAgIGlmIChjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLk9VVFBVVCAmJiAhbmV1cm9uX291dHB1dHNfY29tcHV0ZWQpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgb3V0cHV0IG9mIG5ldXJvbnMgaW4gdGhlIHJhbmdlICgtMS4wLi4xLjApIHVzaW5nIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgZnVuY3Rpb24uXG4gICAgICAgIGZvciAobGV0IG5ldXJvbl9pbmRleCA9IDA7IG5ldXJvbl9pbmRleCA8IHRoaXMuaGlkZGVuX25ldXJvbnMubGVuZ3RoOyBuZXVyb25faW5kZXgrKykge1xuICAgICAgICAgIGlmICh0aGlzLmhpZGRlbl9uZXVyb25zW25ldXJvbl9pbmRleF0uZHJpdmVuKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGRlbl9uZXVyb25zW25ldXJvbl9pbmRleF0ub3V0cHV0ID0gTWF0aC50YW5oKG5ldXJvbl9hY2N1bXVsYXRvcnNbbmV1cm9uX2luZGV4XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ldXJvbl9vdXRwdXRzX2NvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gT2J0YWluIHRoZSBpbnB1dCB2YWx1ZSBvZiB0aGUgY29ubmVjdGlvbiBmcm9tIGEgc2Vuc29yIG5ldXJvbiBvciBhbm90aGVyIG5ldXJvbi5cbiAgICAgIC8vIFRoZSB2YWx1ZXMgYXJlIHN1bW1lZCBhbmQgbGF0ZXIgcGFzc2VkIHRocm91Z2ggYSB0cmFuc2ZlciBmdW5jdGlvbiAoaHlwZXJib2xpYyB0YW5nZW50IGZ1bmN0aW9uKS5cbiAgICAgIGxldCBpbnB1dF92YWwgPSAwLjA7XG4gICAgICBpZiAoY29ubmVjdGlvbi5zb3VyY2VfdHlwZSA9PSBOZXVyb25zLklOUFVUKSB7XG4gICAgICAgIC8vIFJlYWQgdGhlIHNlbnNvciBkYXRhIHVzaW5nIHRoZSBzZW5zb3IgaWRlbnRpZmllci5cbiAgICAgICAgaW5wdXRfdmFsID0gdGhpcy5nZXRfc2Vuc29yKGNvbm5lY3Rpb24uc291cmNlX2lkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0X3ZhbCA9IHRoaXMuaGlkZGVuX25ldXJvbnNbY29ubmVjdGlvbi5zb3VyY2VfaWRdLm91dHB1dDtcbiAgICAgIH1cblxuICAgICAgLy8gV2VpZ2h0IHRoZSBjb25uZWN0aW9uJ3MgdmFsdWUgYW5kIGFkZCBpdCB0byB0aGUgYWNjdW11bGF0b3Igb2YgdGhlIGNvcnJlc3BvbmRpbmcgbmV1cm9uIG9yIGFjdGlvbi5cbiAgICAgIGlmIChjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLk9VVFBVVCkge1xuICAgICAgICBhY3Rpb25fbGV2ZWxzW2Nvbm5lY3Rpb24uc2lua19pZF0gKz0gaW5wdXRfdmFsICogd2VpZ2h0X2FzX2Zsb2F0KGNvbm5lY3Rpb24ud2VpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldXJvbl9hY2N1bXVsYXRvcnNbY29ubmVjdGlvbi5zaW5rX2lkXSArPSBpbnB1dF92YWwgKiB3ZWlnaHRfYXNfZmxvYXQoY29ubmVjdGlvbi53ZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uX2xldmVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnRhaW5zIGEgbGlzdCBvZiBjb25uZWN0aW9ucyBmcm9tIHRoZSBnZW5vbWUuXG4gICAqIEByZXR1cm5zIEEgbGlzdCBvZiBjb25uZWN0aW9ucyBmcm9tIHRoZSBnZW5vbWUuXG4gICAqL1xuICBwdWJsaWMgb2J0YWluX2Nvbm5lY3Rpb25zKCk6IGFueVtdIHtcbiAgICAvLyBJbml0aWFsaXplIGFuIGFycmF5IHRvIHN0b3JlIGNvbm5lY3Rpb25zLlxuICAgIGNvbnN0IGNvbm5lY3Rpb25fYXJyYXk6IENvbm5lY3Rpb25BcnJheSA9IFtdO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGdlbm9tZSBkYXRhIGV4aXN0cy5cbiAgICBpZiAodGhpcy5nZW5vbWVfZGF0YSkge1xuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBnZW5vbWUgZGF0YSB0byBwcm9jZXNzIGVhY2ggZ2VuZS5cbiAgICAgIGZvciAoY29uc3QgZ2VuZSBvZiB0aGlzLmdlbm9tZV9kYXRhKSB7XG4gICAgICAgIC8vIFJlbnVtYmVyIHRoZSBzb3VyY2UgbmV1cm9uIG9yIHNlbnNvciB1c2luZyBtb2R1bG8gb3BlcmF0b3IgYmFzZWQgb24gdGhlIHRvdGFsIG51bWJlciBvZiBpbnB1dCBvciBoaWRkZW4gbmV1cm9ucy5cbiAgICAgICAgaWYgKGdlbmUuc291cmNlX3R5cGUgPT09IE5ldXJvbnMuSElEREVOKSB7XG4gICAgICAgICAgZ2VuZS5zb3VyY2VfaWQgJT0gdGhpcy5udW1faGlkZGVuX25ldXJvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuZS5zb3VyY2VfaWQgJT0gdGhpcy5udW1faW5wdXRfbmV1cm9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbnVtYmVyIHRoZSBzaW5rIG5ldXJvbiBvciBhY3Rpb24gdXNpbmcgbW9kdWxvIG9wZXJhdG9yIGJhc2VkIG9uIHRoZSB0b3RhbCBudW1iZXIgb2Ygb3V0cHV0IG9yIGhpZGRlbiBuZXVyb25zLlxuICAgICAgICBpZiAoZ2VuZS5zaW5rX3R5cGUgPT09IE5ldXJvbnMuSElEREVOKSB7XG4gICAgICAgICAgZ2VuZS5zaW5rX2lkICU9IHRoaXMubnVtX2hpZGRlbl9uZXVyb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmUuc2lua19pZCAlPSB0aGlzLm51bV9vdXRwdXRfbmV1cm9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgcmVudW1iZXJlZCBnZW5lIHRvIHRoZSBjb25uZWN0aW9uIGxpc3QuXG4gICAgICAgIGNvbm5lY3Rpb25fYXJyYXkucHVzaChnZW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gdGhlIG9idGFpbmVkIGxpc3Qgb2YgY29ubmVjdGlvbnMuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb25fYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcCBvZiBoaWRkZW4gbmV1cm9ucyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBpbnB1dCBhbmQgb3V0cHV0IGNvdW50cy5cbiAgICogQHBhcmFtIGNvbm5lY3Rpb25fYXJyYXkgLSBUaGUgY29ubmVjdGlvbiBhcnJheSB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyBBIG1hcCBvZiBoaWRkZW4gbmV1cm9ucyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBpbnB1dCBhbmQgb3V0cHV0IGNvdW50cy5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVfaGlkZGVuX25ldXJvbl9tYXAoY29ubmVjdGlvbl9hcnJheTogQ29ubmVjdGlvbkFycmF5KTogSGlkZGVuTmV1cm9uTWFwIHtcbiAgICAvLyBJbml0aWFsaXplIGEgbWFwIHRvIHN0b3JlIGhpZGRlbiBuZXVyb25zIGFuZCB0aGVpciBpbnB1dC9vdXRwdXQgY291bnRzLlxuICAgIGNvbnN0IGhpZGRlbl9uZXVyb25fbWFwOiBIaWRkZW5OZXVyb25NYXAgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGNvbm5lY3Rpb24gYXJyYXkgdG8gcHJvY2VzcyBlYWNoIGNvbm5lY3Rpb24uXG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25fYXJyYXkpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzaW5rIHR5cGUgaXMgYSBoaWRkZW4gbmV1cm9uLlxuICAgICAgaWYgKGNvbm5lY3Rpb24uc2lua190eXBlID09PSBOZXVyb25zLkhJRERFTikge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29ubmVjdGlvbiBpcyBhIHNlbGYtaW5wdXQgdG8gdGhlIGhpZGRlbiBuZXVyb24uXG4gICAgICAgIGNvbnN0IHNlbGZfaW5wdXQgPSBjb25uZWN0aW9uLnNvdXJjZV90eXBlID09IE5ldXJvbnMuSElEREVOICYmIGNvbm5lY3Rpb24uc291cmNlX2lkID09IGNvbm5lY3Rpb24uc2lua19pZDtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaGlkZGVuIG5ldXJvbiBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICAgICBpZiAoaGlkZGVuX25ldXJvbl9tYXAuaGFzKGNvbm5lY3Rpb24uc2lua19pZCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gaGlkZGVuX25ldXJvbl9tYXAuZ2V0KGNvbm5lY3Rpb24uc2lua19pZCk7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQvb3V0cHV0IGNvdW50cyBmb3IgdGhlIGV4aXN0aW5nIGhpZGRlbiBuZXVyb24uXG4gICAgICAgICAgICBpZiAoc2VsZl9pbnB1dCkgbm9kZS5zZWxmX2lucHV0cysrO1xuICAgICAgICAgICAgZWxzZSBub2RlLmlucHV0cysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV1cm9uIGlzIG5vdCBpbiB0aGUgbm9kZSBtYXAsIGFkZCBpdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBpbnB1dC9vdXRwdXQgdmFsdWVzLlxuICAgICAgICAgICAgaGlkZGVuX25ldXJvbl9tYXAuc2V0KGNvbm5lY3Rpb24uc2lua19pZCwge1xuICAgICAgICAgICAgICBpZGVudGlmZXI6IDAsXG4gICAgICAgICAgICAgIG91dHB1dHM6IDAsXG4gICAgICAgICAgICAgIHNlbGZfaW5wdXRzOiBzZWxmX2lucHV0ID8gMSA6IDAsXG4gICAgICAgICAgICAgIGlucHV0czogc2VsZl9pbnB1dCA/IDAgOiAxLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBzb3VyY2UgdHlwZSBpcyBhIGhpZGRlbiBuZXVyb24uXG4gICAgICBpZiAoY29ubmVjdGlvbi5zb3VyY2VfdHlwZSA9PT0gTmV1cm9ucy5ISURERU4pIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGhpZGRlbiBuZXVyb24gYWxyZWFkeSBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICAgICAgaWYgKGhpZGRlbl9uZXVyb25fbWFwLmhhcyhjb25uZWN0aW9uLnNvdXJjZV9pZCkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gaGlkZGVuX25ldXJvbl9tYXAuZ2V0KGNvbm5lY3Rpb24uc291cmNlX2lkKTtcbiAgICAgICAgICBpZiAobm9kZSkgbm9kZS5vdXRwdXRzKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlIG5ldXJvbiBpcyBub3QgaW4gdGhlIG5vZGUgbWFwLCBhZGQgaXQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgaW5wdXQvb3V0cHV0IHZhbHVlcy5cbiAgICAgICAgICBoaWRkZW5fbmV1cm9uX21hcC5zZXQoY29ubmVjdGlvbi5zb3VyY2VfaWQsIHtcbiAgICAgICAgICAgIGlkZW50aWZlcjogMCxcbiAgICAgICAgICAgIG91dHB1dHM6IDEsXG4gICAgICAgICAgICBzZWxmX2lucHV0czogMCxcbiAgICAgICAgICAgIGlucHV0czogMCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIGNyZWF0ZWQgbWFwIG9mIG5ldXJvbnMgd2l0aCB0aGVpciBpbnB1dC9vdXRwdXQgY291bnRzLlxuICAgIHJldHVybiBoaWRkZW5fbmV1cm9uX21hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGNvbm5lY3Rpb25zIHRvIGEgc3BlY2lmaWMgbmV1cm9uIGZyb20gdGhlIGNvbm5lY3Rpb24gbGlzdCBhbmQgdXBkYXRlcyB0aGUgbm9kZSBtYXAgYWNjb3JkaW5nbHkuXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uX2FycmF5IC0gVGhlIGNvbm5lY3Rpb24gYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIGhpZGRlbl9uZXVyb25fbWFwIC0gVGhlIGhpZGRlbiBuZXVyb24gbWFwIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIG5ldXJvbl9udW1iZXIgLSBUaGUgbmV1cm9uIG51bWJlciB0byByZW1vdmUgY29ubmVjdGlvbnMgdG8uXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlX2Nvbm5lY3Rpb25zX3RvX25ldXJvbihjb25uZWN0aW9uX2FycmF5OiBDb25uZWN0aW9uQXJyYXksIGhpZGRlbl9uZXVyb25fbWFwOiBIaWRkZW5OZXVyb25NYXAsIG5ldXJvbl9udW1iZXI6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgY29ubmVjdGlvbiBhcnJheS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3Rpb25fYXJyYXkubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IG5ldXJvbiA9IGNvbm5lY3Rpb25fYXJyYXlbaV07XG4gICAgICAvLyBDaGVjayBpZiB0aGUgY3VycmVudCBjb25uZWN0aW9uJ3Mgc2luayBpcyB0aGUgc3BlY2lmaWVkIG5ldXJvbi5cbiAgICAgIGlmIChuZXVyb24uc2lua190eXBlID09IE5ldXJvbnMuSElEREVOICYmIG5ldXJvbi5zaW5rX2lkID09PSBuZXVyb25fbnVtYmVyKSB7XG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uJ3Mgc2luayBpcyB0aGUgc3BlY2lmaWVkIG5ldXJvbiwgaGFuZGxlIHRoZSByZW1vdmFsIHByb2Nlc3MuXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNvdXJjZSBvZiB0aGUgY29ubmVjdGlvbiBpcyBhbHNvIGEgaGlkZGVuIG5ldXJvbi5cbiAgICAgICAgaWYgKG5ldXJvbi5zb3VyY2VfdHlwZSA9PSBOZXVyb25zLkhJRERFTikge1xuICAgICAgICAgIC8vIElmIHRoZSBzb3VyY2UgaXMgYSBoaWRkZW4gbmV1cm9uLCBkZWNyZW1lbnQgdGhlIG91dHB1dHMgb2YgdGhhdCBuZXVyb24gaW4gdGhlIG1hcC5cbiAgICAgICAgICBjb25zdCBub2RlID0gaGlkZGVuX25ldXJvbl9tYXAuZ2V0KG5ldXJvbi5zb3VyY2VfaWQpO1xuICAgICAgICAgIGlmIChub2RlKSBub2RlLm91dHB1dHMtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY29ubmVjdGlvbiBmcm9tIHRoZSBjb25uZWN0aW9uIGxpc3QuXG4gICAgICAgIGNvbm5lY3Rpb25fYXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBjb25uZWN0aW9uIGluIHRoZSBsaXN0LlxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdXNlbGVzcyBjb25uZWN0aW9ucyBmcm9tIHRoZSBjb25uZWN0aW9uIGxpc3QgYW5kIHVwZGF0ZXMgdGhlIG5vZGUgbWFwIGFjY29yZGluZ2x5LlxuICAgKiBAcGFyYW0gY29ubmVjdGlvbnMgLSBUaGUgY29ubmVjdGlvbiBhcnJheSB0byBwcm9jZXNzLlxuICAgKiBAcGFyYW0gaGlkZGVuX25ldXJvbl9tYXAgLSBUaGUgaGlkZGVuIG5ldXJvbiBtYXAgdG8gdXBkYXRlLlxuICAgKi9cbiAgcHVibGljIHBydW5lX2Nvbm5lY3Rpb25zKGNvbm5lY3Rpb25zOiBDb25uZWN0aW9uQXJyYXksIGhpZGRlbl9uZXVyb25fbWFwOiBIaWRkZW5OZXVyb25NYXApOiB2b2lkIHtcbiAgICAvLyBGbGFnIHRvIHRyYWNrIGlmIGNvbm5lY3Rpb25zIGFyZSBwcnVuZWQuXG4gICAgbGV0IGNvbm5lY3Rpb25zX3BydW5lZCA9IGZhbHNlO1xuXG4gICAgLy8gTG9vcCB1bnRpbCBubyBtb3JlIGNvbm5lY3Rpb25zIGFyZSBwcnVuZWQuXG4gICAgd2hpbGUgKCFjb25uZWN0aW9uc19wcnVuZWQpIHtcbiAgICAgIGNvbm5lY3Rpb25zX3BydW5lZCA9IHRydWU7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBoaWRkZW4gbmV1cm9ucyBpbiB0aGUgbWFwLlxuICAgICAgZm9yIChjb25zdCBub2RlX251bWJlciBvZiBoaWRkZW5fbmV1cm9uX21hcC5rZXlzKCkpIHtcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgbm9kZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgIGNvbnN0IG5vZGUgPSBoaWRkZW5fbmV1cm9uX21hcC5nZXQobm9kZV9udW1iZXIpO1xuXG4gICAgICAgIC8vIExvb2sgZm9yIG5ldXJvbnMgd2l0aCB6ZXJvIG91dHB1dHMgb3IgbmV1cm9ucyB0aGF0IGZlZWQgdGhlbXNlbHZlcy5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5vdXRwdXRzID09PSBub2RlLnNlbGZfaW5wdXRzKSB7XG4gICAgICAgICAgLy8gSWYgZm91bmQsIHNldCB0aGUgZmxhZyB0byBmYWxzZSB0byBjb250aW51ZSBwcnVuaW5nLlxuICAgICAgICAgIGNvbm5lY3Rpb25zX3BydW5lZCA9IGZhbHNlO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIGNvbm5lY3Rpb25zIGxlYWRpbmcgdG8gdGhlIGlkZW50aWZpZWQgbmV1cm9uIGFuZCBkZWxldGUgaXQgZnJvbSB0aGUgbWFwLlxuICAgICAgICAgIHRoaXMucmVtb3ZlX2Nvbm5lY3Rpb25zX3RvX25ldXJvbihjb25uZWN0aW9ucywgaGlkZGVuX25ldXJvbl9tYXAsIG5vZGVfbnVtYmVyKTtcbiAgICAgICAgICBoaWRkZW5fbmV1cm9uX21hcC5kZWxldGUobm9kZV9udW1iZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZW51bWJlcmVkIGNvbm5lY3Rpb24gbGlzdCBiYXNlZCBvbiB0aGUgbm9kZSBtYXAuXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uX2FycmF5IC0gVGhlIGNvbm5lY3Rpb24gYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIGhpZGRlbl9uZXVyb25fbWFwIC0gVGhlIGhpZGRlbiBuZXVyb24gbWFwIHRvIHVwZGF0ZS5cbiAgICovXG4gIHB1YmxpYyBjcmVhdGVfY29ubmVjdGlvbnMoY29ubmVjdGlvbl9hcnJheTogQ29ubmVjdGlvbkFycmF5LCBoaWRkZW5fbmV1cm9uX21hcDogSGlkZGVuTmV1cm9uTWFwKTogdm9pZCB7XG4gICAgbGV0IG5ld19udW1iZXIgPSAwO1xuXG4gICAgLy8gUmVudW1iZXIgbmV1cm9ucyBpbiB0aGUgaGlkZGVuX25ldXJvbl9tYXAuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIGhpZGRlbl9uZXVyb25fbWFwLnZhbHVlcygpKSB7XG4gICAgICBub2RlLmlkZW50aWZlciA9IG5ld19udW1iZXIrKztcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggY29ubmVjdGlvbl9hcnJheSB0byB1cGRhdGUgY29ubmVjdGlvbnMgd2l0aCByZW51bWJlcmVkIG5ldXJvbiBJRHMuXG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25fYXJyYXkpIHtcbiAgICAgIGlmIChjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLkhJRERFTikge1xuICAgICAgICBjb25zdCBuZXdfY29ubmVjdGlvbiA9IGNsb25lRGVlcChjb25uZWN0aW9uKTtcblxuICAgICAgICAvLyBGaXggdGhlIGRlc3RpbmF0aW9uIG5ldXJvbiBudW1iZXIgdXNpbmcgdGhlIHVwZGF0ZWQgbm9kZSBtYXAuXG4gICAgICAgIGNvbnN0IG5vZGUgPSBoaWRkZW5fbmV1cm9uX21hcC5nZXQobmV3X2Nvbm5lY3Rpb24uc2lua19pZCk7XG4gICAgICAgIGlmIChub2RlKSBuZXdfY29ubmVjdGlvbi5zaW5rX2lkID0gbm9kZS5pZGVudGlmZXI7XG5cbiAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBpcyBhIG5ldXJvbiwgZml4IGl0cyBudW1iZXIgdG9vIHVzaW5nIHRoZSB1cGRhdGVkIG5vZGUgbWFwLlxuICAgICAgICBpZiAobmV3X2Nvbm5lY3Rpb24uc291cmNlX3R5cGUgPT09IE5ldXJvbnMuSElEREVOKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGhpZGRlbl9uZXVyb25fbWFwLmdldChuZXdfY29ubmVjdGlvbi5zb3VyY2VfaWQpO1xuICAgICAgICAgIGlmIChub2RlKSBuZXdfY29ubmVjdGlvbi5zb3VyY2VfaWQgPSBub2RlLmlkZW50aWZlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGUgbW9kaWZpZWQgY29ubmVjdGlvbiB0byB0aGUgdXBkYXRlZCBjb25uZWN0aW9ucyBhcnJheS5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucy5wdXNoKG5ld19jb25uZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGNvbm5lY3Rpb25zIGZyb20gc2Vuc29yL25ldXJvbiB0byBhbiBhY3Rpb24uXG4gICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25fYXJyYXkpIHtcbiAgICAgIGlmIChjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLk9VVFBVVCkge1xuICAgICAgICBjb25zdCBuZXdfY29ubiA9IGNsb25lRGVlcChjb25uZWN0aW9uKTtcblxuICAgICAgICAvLyBJZiB0aGUgc291cmNlIGlzIGEgaGlkZGVuIG5ldXJvbiwgZml4IGl0cyBudW1iZXIgdXNpbmcgdGhlIHVwZGF0ZWQgbm9kZSBtYXAuXG4gICAgICAgIGlmIChuZXdfY29ubi5zb3VyY2VfdHlwZSA9PT0gTmV1cm9ucy5ISURERU4pIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gaGlkZGVuX25ldXJvbl9tYXAuZ2V0KG5ld19jb25uLnNvdXJjZV9pZCk7XG4gICAgICAgICAgaWYgKG5vZGUpIG5ld19jb25uLnNvdXJjZV9pZCA9IG5vZGUuaWRlbnRpZmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZSBtb2RpZmllZCBjb25uZWN0aW9uIHRvIHRoZSB1cGRhdGVkIGNvbm5lY3Rpb25zIGFycmF5LlxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2gobmV3X2Nvbm4pO1xuICAgICAgfVxuXG4gICAgICAvLyBHcm91cCBpbnB1dCBuZXVyb25zLCBoaWRkZW4gbmV1cm9ucywgYW5kIG91dHB1dCBuZXVyb25zIGludG8gdGhlaXIgcmVzcGVjdGl2ZSBzZXRzLlxuICAgICAgaWYgKGNvbm5lY3Rpb24uc291cmNlX3R5cGUgPT0gTmV1cm9ucy5JTlBVVCkgdGhpcy5pbnB1dHNbY29ubmVjdGlvbi5zb3VyY2VfaWRdID0gdW5kZWZpbmVkO1xuICAgICAgZWxzZSB0aGlzLmhpZGRlbltjb25uZWN0aW9uLnNvdXJjZV9pZF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChjb25uZWN0aW9uLnNpbmtfdHlwZSA9PSBOZXVyb25zLk9VVFBVVCkgdGhpcy5vdXRwdXRzW2Nvbm5lY3Rpb24uc2lua19pZF0gPSB1bmRlZmluZWQ7XG4gICAgICBlbHNlIHRoaXMuaGlkZGVuW2Nvbm5lY3Rpb24uc2lua19pZF0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoaWRkZW4gbmV1cm9uIGFycmF5IGJhc2VkIG9uIHRoZSBub2RlIG1hcC5cbiAgICogQHBhcmFtIGhpZGRlbl9uZXVyb25fbWFwIC0gVGhlIGhpZGRlbiBuZXVyb24gbWFwIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIEEgaGlkZGVuIG5ldXJvbiBhcnJheSBiYXNlZCBvbiB0aGUgbm9kZSBtYXAuXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlX2hpZGRlbl9uZXVyb25fYXJyYXkoaGlkZGVuX25ldXJvbl9tYXA6IEhpZGRlbk5ldXJvbk1hcCk6IE5ldXJvbltdIHtcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBub2RlIGluIHRoZSBoaWRkZW5fbmV1cm9uX21hcC5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGlkZGVuX25ldXJvbl9tYXAudmFsdWVzKCkpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBOZXVyb24gaW5zdGFuY2UuXG4gICAgICBjb25zdCBuZXVyb24gPSBuZXcgTmV1cm9uKCk7XG4gICAgICAvLyBTZXQgdGhlIGluaXRpYWwgb3V0cHV0IHRvIDAuNS5cbiAgICAgIG5ldXJvbi5vdXRwdXQgPSAwLjU7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbmV1cm9uIGhhcyBpbnB1dHMgdG8gZHJpdmUgaXRzIG91dHB1dC5cbiAgICAgIG5ldXJvbi5kcml2ZW4gPSBub2RlLmlucHV0cyAhPT0gMDtcbiAgICAgIC8vIEFkZCB0aGUgbmV3bHkgY3JlYXRlZCBuZXVyb24gdG8gdGhlIGhpZGRlbl9uZXVyb25zIGFycmF5LlxuICAgICAgdGhpcy5oaWRkZW5fbmV1cm9ucy5wdXNoKG5ldXJvbik7XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgdXBkYXRlZCBoaWRkZW5fbmV1cm9ucyBhcnJheS5cbiAgICByZXR1cm4gdGhpcy5oaWRkZW5fbmV1cm9ucztcbiAgfVxufVxuIiwiaW1wb3J0IGdldF9yYW5kb21fbnVtYmVyIGZyb20gXCIuLi91dGlscy9nZXRfcmFuZG9tX251bWJlclwiO1xuXG4vKiogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNyZWF0ZSBhIGdlbmUgdGhhdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBpbmZvcm1hdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VuZSB7XG4gIC8vIFNvdXJjZSBvZiB0aGUgY29ubmVjdGlvbiBpcyBlaXRoZXIgYW4gaW5wdXQgbmV1cm9uL2hpZGRlbiBuZXVyb24uXG4gIHB1YmxpYyBzb3VyY2VfdHlwZTogbnVtYmVyO1xuICAvLyBJZGVudGlmZXIgb2Ygd2hpY2ggaW5wdXQgbmV1cm9uL2hpZGRlbiBuZXVyb24uXG4gIHB1YmxpYyBzb3VyY2VfaWQ6IG51bWJlcjtcbiAgLy8gU2luayBvZiB0aGUgY29ubmVjdGlvbiBpcyBlaXRoZXIgYW4gb3V0cHV0IG5ldXJvbi9oaWRkZW4gbmV1cm9uXG4gIHB1YmxpYyBzaW5rX3R5cGU6IG51bWJlcjtcbiAgLy8gSWRlbnRpZmllciBvZiB3aGljaCBvdXRwdXQgbmV1cm9uL2hpZGRlbiBuZXVyb24uXG4gIHB1YmxpYyBzaW5rX2lkOiBudW1iZXI7XG4gIC8vIFRoZSB3ZWlnaHQgb2YgdGhlIGNvbm5lY3Rpb24uXG4gIHB1YmxpYyB3ZWlnaHQ6IG51bWJlcjtcblxuICAvLyBCdWlsZHMgYSBuZXcgZ2VuZS5cbiAgY29uc3RydWN0b3IoTlVNQkVSX09GX0hJRERFTl9ORVVST05TOiBudW1iZXIpIHtcbiAgICB0aGlzLnNvdXJjZV90eXBlID0gZ2V0X3JhbmRvbV9udW1iZXIoMCwgMSk7XG4gICAgdGhpcy5zb3VyY2VfaWQgPSBnZXRfcmFuZG9tX251bWJlcigwLCAweDdmZmYpICUgTlVNQkVSX09GX0hJRERFTl9ORVVST05TO1xuICAgIHRoaXMuc2lua190eXBlID0gZ2V0X3JhbmRvbV9udW1iZXIoMCwgMSk7XG4gICAgdGhpcy5zaW5rX2lkID0gZ2V0X3JhbmRvbV9udW1iZXIoMCwgMHg3ZmZmKSAlIE5VTUJFUl9PRl9ISURERU5fTkVVUk9OUztcbiAgICB0aGlzLndlaWdodCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZikgLSAweDgwMDA7XG4gIH1cbn1cbiIsImltcG9ydCBHZW5lIGZyb20gXCIuL0dlbmVcIjtcblxuLyoqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgYSBnZW5vbWUgdGhhdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBpbmZvcm1hdGlvbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2Vub21lIHtcbiAgcHVibGljIGRhdGE6IEdlbmVbXSB8IG51bGw7XG4gIHB1YmxpYyBjb2xvdXI6IHN0cmluZyB8IG51bGw7XG5cbiAgLyoqIEJ1aWxkcyBhIG5ldyBnZW5vbWUgZnJvbSBhIGdpdmVuIHNldCBvZiBnZW5lcy4gKi9cbiAgY29uc3RydWN0b3IoZ2Vub21lOiBHZW5lW10pIHtcbiAgICB0aGlzLmRhdGEgPSBnZW5vbWU7XG4gICAgdGhpcy5jb2xvdXIgPSB0aGlzLmdldF9jb2xvdXIoZ2Vub21lKTtcbiAgfVxuXG4gIC8vIE9idGFpbnMgYSBjb2xvdXIgZm9yIHRoZSBvcmdhbmlzbSBiYXNlZCBvbiBpdHMgZ2Vub21lLlxuICBwdWJsaWMgZ2V0X2NvbG91cihnZW5vbWUpOiBzdHJpbmcge1xuICAgIGxldCBnZW5vbWVfc3RyaW5nID0gXCJcIjtcblxuICAgIC8vIENvbnZlcnQgZWFjaCBpbmRpdmlkdWFsIGdlbmUgaW50byBhIGdlbm9tZSBzdHJpbmcuXG4gICAgZm9yIChjb25zdCBnZW5lIG9mIGdlbm9tZSkge1xuICAgICAgZ2Vub21lX3N0cmluZyArPSBgJHtnZW5lLnNvdXJjZV90eXBlfSwke2dlbmUuc291cmNlX2lkfSwke2dlbmUuc2lua190eXBlfSwke2dlbmUuc2lua19pZH0sJHtnZW5lLndlaWdodH1gO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBoYXNoIGZyb20gdGhlIGdlbm9tZSBzdHJpbmcuXG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2Vub21lX3N0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGdlbm9tZV9zdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHJnYiBjb2RlcyB1c2luZyB0aGUgaGFzaC5cbiAgICBsZXQgciA9IChoYXNoICYgMHhmZjAwMDApID4+IDE2O1xuICAgIGxldCBnID0gKGhhc2ggJiAweDAwZmYwMCkgPj4gODtcbiAgICBsZXQgYiA9IGhhc2ggJiAweDAwMDBmZjtcblxuICAgIC8vIE5vcm1hbGl6ZSBSR0IgdmFsdWVzIHRvIGZpdCB3aXRoaW4gdGhlIHJhbmdlIG9mIDAtMjU1LlxuICAgIHIgPSBNYXRoLmZsb29yKHIgJSAyNTYpO1xuICAgIGcgPSBNYXRoLmZsb29yKGcgJSAyNTYpO1xuICAgIGIgPSBNYXRoLmZsb29yKGIgJSAyNTYpO1xuXG4gICAgcmV0dXJuIGByZ2IoJHtyfSwgJHtnfSwgJHtifSlgO1xuICB9XG59XG4iLCIvLyBJZGVudGlmaWVycyBmb3IgZWFjaCB0eXBlIG9mIG5ldXJvbi5cbmV4cG9ydCBjb25zdCBOZXVyb25zID0ge1xuICBJTlBVVDogMSxcbiAgT1VUUFVUOiAxLFxuICBISURERU46IDAsXG59O1xuXG4vKiogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNyZWF0ZSBhIG5ldXJvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGluZm9ybWF0aW9uLiAqL1xuZXhwb3J0IGNsYXNzIE5ldXJvbiB7XG4gIC8vIE91dHB1dCB2YWx1ZSBvZiB0aGUgbmV1cm9uLlxuICBwdWJsaWMgb3V0cHV0OiBudW1iZXI7XG4gIC8vIFVuZHJpdmVuIG5ldXJvbnMgaGF2ZSBmaXhlZCBvdXRwdXQgdmFsdWVzLlxuICBwdWJsaWMgZHJpdmVuOiBib29sZWFuO1xuICAvLyBCdWlsZHMgYSBuZXcgbmV1cm9uLlxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm91dHB1dCA9IDAuMDtcbiAgICB0aGlzLmRyaXZlbiA9IGZhbHNlO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZyB9IGZyb20gXCIuLi9jb25maWcvc2ltdWxhdGlvbi5jb25maWdcIjtcbmltcG9ydCBEaXJlY3Rpb25zIGZyb20gXCIuLi9jb25zdGFudHMvRGlyZWN0aW9uc1wiO1xuaW1wb3J0IHsgT3V0cHV0TmV1cm9ucyB9IGZyb20gXCIuLi9jb25zdGFudHMvT3V0cHV0TmV1cm9uc1wiO1xuaW1wb3J0IHsgR3JpZCB9IGZyb20gXCIuLi9lbnZpcm9ubWVudC9HcmlkXCI7XG5pbXBvcnQgeyBtYWtlX3ZlY3RvciB9IGZyb20gXCIuLi91dGlscy9nZW9tZXRyeVwiO1xuaW1wb3J0IHByb2JhYmlsaXR5X3RvX2Jvb2xlYW4gZnJvbSBcIi4uL3V0aWxzL3Byb2JhYmlsaXR5X3RvX2Jvb2xlYW5cIjtcbmltcG9ydCBCcmFpbiBmcm9tIFwiLi9CcmFpblwiO1xuaW1wb3J0IEdlbmUgZnJvbSBcIi4vR2VuZVwiO1xuaW1wb3J0IEdlbm9tZSBmcm9tIFwiLi9HZW5vbWVcIjtcbmltcG9ydCB7IENvb3JkaW5hdGUgfSBmcm9tIFwiLi4vdHlwZXMvQ29vcmRpbmF0ZVwiO1xuXG4vKiogVGhpcyBjbGFzcyBpcyB1c2VkIHRvIHJlcHJlc2VudCBhbiBvcmdhbmlzbSBpbiB0aGUgc2ltdWxhdGlvbi4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9yZ2FuaXNtIHtcbiAgcHJpdmF0ZSBfY29vcmRpbmF0ZTogQ29vcmRpbmF0ZTtcbiAgcHVibGljIGdlbm9tZTogR2Vub21lO1xuICBwdWJsaWMgYnJhaW46IEJyYWluO1xuICBwdWJsaWMgZml0bmVzczogbnVtYmVyIHwgbnVsbDtcbiAgcHVibGljIGFsaXZlOiBib29sZWFuO1xuICBwdWJsaWMgZW5lcmd5OiBudW1iZXI7XG4gIHB1YmxpYyBkaXJlY3Rpb246IENvb3JkaW5hdGU7XG4gIHB1YmxpYyBjb25maWc6IHR5cGVvZiBEZWZhdWx0U2ltdWxhdGlvbkNvbmZpZztcbiAgcHVibGljIGdyaWQ6IEdyaWQ7XG5cbiAgLy8gQ29uc3RydWN0cyBhIG5ldyBPcmdhbmlzbSBvYmplY3QuXG4gIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGUsIGdlbm9tZTogR2VuZVtdLCBncmlkOiBHcmlkLCBjb25maWcpIHtcbiAgICB0aGlzLmdyaWQgPSBncmlkO1xuICAgIHRoaXMuX2Nvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuICAgIC8vIElmIGEgZ2Vub21lIGhhcyBiZWVuIGdpdmVuLCB1c2UgdGhpcyBnZW5vbWUsIGVsc2UgY3JlYXRlIGEgbmV3IHJhbmRvbSBnZW5vbWUuXG4gICAgdGhpcy5nZW5vbWUgPSBuZXcgR2Vub21lKGdlbm9tZSk7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5icmFpbiA9IG5ldyBCcmFpbihcbiAgICAgIHRoaXMuY29vcmRpbmF0ZSxcbiAgICAgIHRoaXMuZ3JpZCxcbiAgICAgIHRoaXMuZ2Vub21lLmRhdGEsXG4gICAgICB0aGlzLmNvbmZpZy5OVU1CRVJfT0ZfSU5QVVRTLFxuICAgICAgdGhpcy5jb25maWcuTlVNQkVSX09GX0hJRERFTl9ORVVST05TLFxuICAgICAgdGhpcy5jb25maWcuTlVNQkVSX09GX09VVFBVVFNcbiAgICApO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gRGlyZWN0aW9ucy5OT1JUSDtcbiAgICB0aGlzLmZpdG5lc3MgPSBudWxsO1xuICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgIHRoaXMuZW5lcmd5ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjb29yZGluYXRlIG9mIHRoZSBvcmdhbmlzbS5cbiAgICogQHBhcmFtIGNvb3JkaW5hdGUgLSBUaGUgbmV3IGNvb3JkaW5hdGUgb2YgdGhlIG9yZ2FuaXNtLlxuICAgKi9cbiAgcHVibGljIHNldCBjb29yZGluYXRlKGNvb3JkaW5hdGU6IENvb3JkaW5hdGUpIHtcbiAgICAvLyBDbGVhcnMgdGhlIGN1cnJlbnQgY2VsbCBzdGF0ZSBvZiB0aGUgb3JnYW5pc20ncyBwcmV2aW91cyBjb29yZGluYXRlLlxuICAgIHRoaXMuZ3JpZC5jbGVhcl9jZWxsX3N0YXRlKHRoaXMuY29vcmRpbmF0ZSk7XG4gICAgLy8gU2V0cyB0aGUgY2VsbCBvd25lciB0byB0aGUgY3VycmVudCBvcmdhbmlzbSBhdCB0aGUgbmV3IHNwZWNpZmllZCBjb29yZGluYXRlLlxuICAgIHRoaXMuZ3JpZC5zZXRfY2VsbF9vd25lcihjb29yZGluYXRlLCB0aGlzKTtcbiAgICAvLyBVcGRhdGVzIHRoZSBvcmdhbmlzbSdzIF9jb29yZGluYXRlIHByb3BlcnR5IHdpdGggdGhlIG5ldyBjb29yZGluYXRlIHZhbHVlLlxuICAgIHRoaXMuX2Nvb3JkaW5hdGUgPSBjb29yZGluYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9yZ2FuaXNtLlxuICAgKiBAcmV0dXJucyBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb3JnYW5pc20uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvb3JkaW5hdGUoKTogQ29vcmRpbmF0ZSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGU7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYW4gYWN0aW9uIGJhc2VkIG9uIHRoZSBvcmdhbmlzbSdzIGJyYWluLlxuICAgKiBAcmV0dXJucyBUaGUgY29vcmRpbmF0ZSBvZmZzZXQgb2YgdGhlIGFjdGlvbi5cbiAgICovXG4gIHB1YmxpYyBhY3Rpb24oKTogQ29vcmRpbmF0ZSB7XG4gICAgLy8gUGVyZm9ybSBOZXVyYWwgTmV0d29yayBGZWVkIEZvcndhcmQgdG8gb2J0YWluIGFjdGlvbiBsZXZlbHMuXG4gICAgY29uc3QgYWN0aW9uX2xldmVscyA9IHRoaXMuYnJhaW4uZmVlZF9mb3J3YXJkKCk7XG4gICAgLy8gQ29tcHV0ZSB0aGUgYWN0aW9uIHRvIHRha2UgYmFzZWQgb24gdGhlIGFjdGlvbiBsZXZlbHMuXG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZV9tb3ZlbWVudF9vZmZzZXQoYWN0aW9uX2xldmVscyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGFjdGlvbiBiYXNlZCBvbiB0aGUgYWN0aW9uIGxldmVscy5cbiAgICogQHBhcmFtIGFjdGlvbl9sZXZlbHMgLSBUaGUgYWN0aW9uIGxldmVscyB0byBjb21wdXRlIHRoZSBhY3Rpb24gZnJvbS5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHB1YmxpYyBjb21wdXRlX21vdmVtZW50X29mZnNldChhY3Rpb25fbGV2ZWxzOiBudW1iZXJbXSk6IENvb3JkaW5hdGUge1xuICAgIC8vICdtb3ZlX3gnIGFuZCAnbW92ZV95JyByZXByZXNlbnQgdGhlIHVyZ2UgdG8gbW92ZSBpbiB0aGUgWCBhbmQgWSBkaXJlY3Rpb24gcmVzcGVjdGl2ZWx5LlxuICAgIGxldCBtb3ZlX3ggPSBhY3Rpb25fbGV2ZWxzW091dHB1dE5ldXJvbnMuTU9WRV9YXTtcbiAgICBsZXQgbW92ZV95ID0gYWN0aW9uX2xldmVsc1tPdXRwdXROZXVyb25zLk1PVkVfWV07XG5cbiAgICAvLyBBY2N1bXVsYXRlIHRoZSB1cmdlIHRvIG1vdmUgYmFzZWQgb24gc3BlY2lmaWMgb3V0cHV0IG5ldXJvbnMgcmVwcmVzZW50aW5nIGRpcmVjdGlvbnMuXG4gICAgbW92ZV94ICs9IGFjdGlvbl9sZXZlbHNbT3V0cHV0TmV1cm9ucy5NT1ZFX0VBU1RdO1xuICAgIG1vdmVfeCAtPSBhY3Rpb25fbGV2ZWxzW091dHB1dE5ldXJvbnMuTU9WRV9XRVNUXTtcbiAgICBtb3ZlX3kgKz0gYWN0aW9uX2xldmVsc1tPdXRwdXROZXVyb25zLk1PVkVfTk9SVEhdO1xuICAgIG1vdmVfeSAtPSBhY3Rpb25fbGV2ZWxzW091dHB1dE5ldXJvbnMuTU9WRV9TT1VUSF07XG5cbiAgICAvLyBUaGUgaHlwZXJib2xpYyB0YW5nZW50IGZ1bmN0aW9uIGNvbmZpbmVzIG1vdmVtZW50IHZhbHVlcyBiZXR3ZWVuIC0xLjAgYW5kIDEuMC5cbiAgICBtb3ZlX3ggPSBNYXRoLnRhbmgobW92ZV94KTtcbiAgICBtb3ZlX3kgPSBNYXRoLnRhbmgobW92ZV95KTtcblxuICAgIC8vIENhbGN1bGF0ZSBwcm9iYWJpbGl0aWVzIGJhc2VkIG9uIGFic29sdXRlIHZhbHVlcy5cbiAgICBjb25zdCBwcm9iX3ggPSArcHJvYmFiaWxpdHlfdG9fYm9vbGVhbihNYXRoLmFicyhtb3ZlX3gpKTtcbiAgICBjb25zdCBwcm9iX3kgPSArcHJvYmFiaWxpdHlfdG9fYm9vbGVhbihNYXRoLmFicyhtb3ZlX3kpKTtcblxuICAgIC8vIERldGVybWluZSBkaXJlY3Rpb24gb2YgbW92ZW1lbnQgYmFzZWQgb24gdGhlIHNpZ24gb2YgdGhlIHZhbHVlcy4gKHNpZ251bSBmdW5jdGlvbilcbiAgICBjb25zdCBzaWdudW1feCA9IG1vdmVfeCA8IDAuMCA/IC0xIDogMTtcbiAgICBjb25zdCBzaWdudW1feSA9IG1vdmVfeSA8IDAuMCA/IC0xIDogMTtcblxuICAgIC8vIENyZWF0ZSBhIHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGNhbGN1bGF0ZWQgbW92ZW1lbnQgYmFzZWQgb24gcHJvYmFiaWxpdGllcyBhbmQgZGlyZWN0aW9ucy5cbiAgICBjb25zdCBvZmZzZXQgPSBtYWtlX3ZlY3Rvcihwcm9iX3ggKiBzaWdudW1feCwgcHJvYl95ICogc2lnbnVtX3kpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cbn1cbiIsIi8qKiBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIHF1ZXVlLiAqL1xuY2xhc3MgUXVldWVOb2RlIHtcbiAgcHVibGljIHZhbHVlOiBhbnk7XG4gIHB1YmxpYyBuZXh0OiBRdWV1ZU5vZGUgfCBudWxsO1xuXG4gIC8qKiBCdWlsZHMgYSBuZXcgUXVldWVOb2RlIGluc3RhbmNlLiAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIC8vIEFzc2lnbiB0aGUgcHJvdmlkZWQgdmFsdWUgdG8gdGhlIG5vZGUuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIC8vIFNldCB0aGUgbmV4dCBub2RlIHRvIG51bGwuXG4gICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgfVxufVxuXG4vKiogQ2xhc3MgZm9yIGNyZWF0aW5nIGEgcXVldWUuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWV1ZSB7XG4gIHB1YmxpYyBmcm9udDogUXVldWVOb2RlIHwgbnVsbDtcbiAgcHVibGljIHJlYXI6IFF1ZXVlTm9kZSB8IG51bGw7XG5cbiAgLyoqIEJ1aWxkcyBhIG5ldyBRdWV1ZSBpbnN0YW5jZS4gKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gU2V0IHRoZSBmcm9udCBhbmQgcmVhciBub2RlcyB0byBudWxsLlxuICAgIHRoaXMuZnJvbnQgPSBudWxsO1xuICAgIC8vIFNldCB0aGUgcmVhciBub2RlIHRvIG51bGwuXG4gICAgdGhpcy5yZWFyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIHF1ZXVlLlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5xdWV1ZS5cbiAgICovXG4gIHB1YmxpYyBlbnF1ZXVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlID0gbmV3IFF1ZXVlTm9kZSh2YWx1ZSk7XG5cbiAgICBpZiAodGhpcy5yZWFyID09PSBudWxsKSB7XG4gICAgICB0aGlzLmZyb250ID0gbm9kZTtcbiAgICAgIHRoaXMucmVhciA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVhci5uZXh0ID0gbm9kZTtcbiAgICAgIHRoaXMucmVhciA9IG5vZGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBxdWV1ZS5cbiAgICogQHJldHVybnMgVGhlIHZhbHVlIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWUuXG4gICAqL1xuICBwdWJsaWMgZGVxdWV1ZSgpOiBhbnkge1xuICAgIGlmICh0aGlzLmZyb250ID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJlYXIgPSBudWxsO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZyb250O1xuICAgICAgdGhpcy5mcm9udCA9IHRoaXMuZnJvbnQubmV4dDtcbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBFeHBvcnQgYW4gb2JqZWN0IGFzIGEgSlNPTiBmaWxlLlxuICogQHBhcmFtIG9iamVjdCAtIFRoZSBvYmplY3QgdG8gZXhwb3J0LlxuICogQHBhcmFtIGV4cG9ydF9uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV4cG9ydGVkIGZpbGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cG9ydF9vYmplY3Qob2JqZWN0LCBleHBvcnRfbmFtZSk6IHZvaWQge1xuICAvLyBDcmVhdGUgYSBkYXRhIHN0cmluZyBmcm9tIHRoZSBvYmplY3QuXG4gIGNvbnN0IGRhdGFfc3RyaW5nID0gXCJkYXRhOnRleHQvanNvbjtjaGFyc2V0PXV0Zi04LFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG9iamVjdCkpO1xuICAvLyBDcmVhdGUgYSBsaW5rIGVsZW1lbnQgYW5kIHNldCBpdHMgYXR0cmlidXRlcy5cbiAgY29uc3QgZG93bmxvYWRfYW5jaG9yX25vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgZG93bmxvYWRfYW5jaG9yX25vZGUuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBkYXRhX3N0cmluZyk7XG4gIGRvd25sb2FkX2FuY2hvcl9ub2RlLnNldEF0dHJpYnV0ZShcImRvd25sb2FkXCIsIGV4cG9ydF9uYW1lICsgXCIuanNvblwiKTtcbiAgLy8gQXBwZW5kIHRoZSBsaW5rIGVsZW1lbnQgdG8gdGhlIGRvY3VtZW50IGJvZHkuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZG93bmxvYWRfYW5jaG9yX25vZGUpO1xuICAvLyBDbGljayB0aGUgbGluayBlbGVtZW50IHRvIGRvd25sb2FkIHRoZSBKU09OIGZpbGUuXG4gIGRvd25sb2FkX2FuY2hvcl9ub2RlLmNsaWNrKCk7XG4gIC8vIFJlbW92ZSB0aGUgbGluayBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50IGJvZHkuXG4gIGRvd25sb2FkX2FuY2hvcl9ub2RlLnJlbW92ZSgpO1xufVxuIiwiaW1wb3J0IHsgQ29vcmRpbmF0ZSB9IGZyb20gXCIuLi90eXBlcy9Db29yZGluYXRlXCI7XG5cbi8qKlxuICogQ29udmVydHMgYW4gYW5nbGUgdG8gcmFkaWFucy5cbiAqIEBwYXJhbSBhbmdsZSAtIFRoZSBhbmdsZSB0byBjb252ZXJ0IHRvIHJhZGlhbnMuXG4gKiBAcmV0dXJucyBUaGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX3JhZGlhbnMoYW5nbGUpOiBudW1iZXIge1xuICByZXR1cm4gKE1hdGguUEkgLyAxODApICogYW5nbGU7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIGZpcnN0X2Nvb3JkIC0gVGhlIGZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0gc2Vjb25kX2Nvb3JkIC0gVGhlIHNlY29uZCBjb29yZGluYXRlLlxuICogQHJldHVybnMgVGhlIEV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gY29vcmRpbmF0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldWNsaWRlYW5fZGlzdGFuY2UoZmlyc3RfY29vcmQ6IENvb3JkaW5hdGUsIHNlY29uZF9jb29yZDogQ29vcmRpbmF0ZSk6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coc2Vjb25kX2Nvb3JkLnkgLSBmaXJzdF9jb29yZC55LCAyKSArIE1hdGgucG93KHNlY29uZF9jb29yZC54IC0gZmlyc3RfY29vcmQueCwgMikpO1xufVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBwb2ludCBhYm91dCBhIHBpdm90IGJ5IGEgc3BlY2lmaWVkIGFuZ2xlLlxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHJvdGF0ZS5cbiAqIEBwYXJhbSBwaXZvdCAtIFRoZSBwaXZvdCB0byByb3RhdGUgdGhlIHBvaW50IGFib3V0LlxuICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgcG9pbnQgYnkuXG4gKiBAcmV0dXJucyBUaGUgcm90YXRlZCBwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZV9wb2ludChwb2ludDogQ29vcmRpbmF0ZSwgcGl2b3Q6IENvb3JkaW5hdGUsIGFuZ2xlOiBudW1iZXIpOiBDb29yZGluYXRlIHtcbiAgaWYgKHR5cGVvZiBwb2ludC54ID09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHBvaW50LnkgPT0gXCJudW1iZXJcIikge1xuICAgIGNvbnN0IHJhZGlhbnMgPSB0b19yYWRpYW5zKGFuZ2xlKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihyYWRpYW5zKTtcbiAgICBjb25zdCBueCA9IE1hdGgucm91bmQoY29zICogKHBvaW50LnggLSBwaXZvdC54KSArIHNpbiAqIChwb2ludC55IC0gcGl2b3QueSkgKyBwaXZvdC54KTtcbiAgICBjb25zdCBueSA9IE1hdGgucm91bmQoY29zICogKHBvaW50LnkgLSBwaXZvdC55KSAtIHNpbiAqIChwb2ludC54IC0gcGl2b3QueCkgKyBwaXZvdC55KTtcbiAgICByZXR1cm4geyB4OiBueCwgeTogbnkgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCByb3RhdGUgcG9pbnQgYXMgY29vcmRpbmF0ZXMgYXJlIG5vdCBvZiB0eXBlIG51bWJlci5cIik7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhZGRpdGlvbiBvZiB0d28gdmVjdG9ycy5cbiAqIEBwYXJhbSBmaXJzdF9jb29yZFxuICogQHBhcmFtIHNlY29uZF9jb29yZFxuICogQHJldHVybnMgVGhlIHN1bSBvZiB0aGUgdHdvIHZlY3RvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfdmVjdG9yKGZpcnN0X2Nvb3JkLCBzZWNvbmRfY29vcmQpOiBDb29yZGluYXRlIHtcbiAgcmV0dXJuIHsgeDogZmlyc3RfY29vcmQueCArIHNlY29uZF9jb29yZC54LCB5OiBmaXJzdF9jb29yZC55ICsgc2Vjb25kX2Nvb3JkLnkgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29vcmRpbmF0ZSBvYmplY3QsIHRyZWF0aW5nIGFzIGEgdmVjdG9yLlxuICogQHBhcmFtIHggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0geSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIHZlY3Rvci5cbiAqIEByZXR1cm5zIFRoZSBjb29yZGluYXRlIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IG1ha2VfdmVjdG9yID0gKHg6IG51bWJlciwgeTogbnVtYmVyKTogQ29vcmRpbmF0ZSA9PiB7XG4gIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwb2ludCB0byBhbiBhbmdsZSBpbiBkZWdyZWVzLlxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIGNvbnZlcnQgdG8gYW4gYW5nbGUuXG4gKiBAcmV0dXJucyBUaGUgYW5nbGUgaW4gZGVncmVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX2FuZ2xlKHBvaW50OiBDb29yZGluYXRlKTogbnVtYmVyIHtcbiAgY29uc3QgZmlyc3RBbmdsZSA9IE1hdGguYXRhbjIoMSwgMCk7XG4gIGNvbnN0IHNlY29uZEFuZ2xlID0gTWF0aC5hdGFuMihwb2ludC55LCBwb2ludC54KTtcblxuICBjb25zdCBhbmdsZSA9IHNlY29uZEFuZ2xlIC0gZmlyc3RBbmdsZTtcblxuICByZXR1cm4gTWF0aC5hYnMoKGFuZ2xlICogMTgwKSAvIE1hdGguUEkpO1xufVxuIiwiLy8gRnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGJldHdlZW4gYSBwb2ludCBhbmQgYW55IG90aGVyIHBvaW50IGluIGEgZ3JpZCBvZiBhIGdpdmVuIHNpemUuXG5leHBvcnQgZnVuY3Rpb24gbWF4X2Rpc3RhbmNlX3RvX3BvaW50KHNpemUsIHhfY29vcmQsIHlfY29vcmQpOiBudW1iZXIge1xuICBsZXQgbWF4X2Rpc3RhbmNlID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgaisrKSB7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCgoaSAtIHhfY29vcmQpICoqIDIgKyAoaiAtIHlfY29vcmQpICoqIDIpO1xuICAgICAgbWF4X2Rpc3RhbmNlID0gTWF0aC5tYXgobWF4X2Rpc3RhbmNlLCBkaXN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heF9kaXN0YW5jZTtcbn1cbiIsIi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIG1pbiBpbmNsdXNpdmUgYW5kIG1heCBpbmNsdXNpdmUuXG4gKiBAcGFyYW0gbWluIC0gVGhlIG1pbmltdW0gbnVtYmVyLlxuICogQHBhcmFtIG1heCAtIFRoZSBtYXhpbXVtIG51bWJlci5cbiAqIEByZXR1cm5zIC0gQSByYW5kb20gbnVtYmVyIGJldHdlZW4gbWluIGFuZCBtYXguXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldF9yYW5kb21fbnVtYmVyKG1pbiwgbWF4KTogbnVtYmVyIHtcbiAgbWluID0gTWF0aC5jZWlsKG1pbik7XG4gIG1heCA9IE1hdGguZmxvb3IobWF4KTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSArIG1pbik7XG59XG4iLCJpbXBvcnQgeyBDb29yZGluYXRlIH0gZnJvbSBcIi4uL3R5cGVzL0Nvb3JkaW5hdGVcIjtcbmltcG9ydCB7IG1ha2VfdmVjdG9yIH0gZnJvbSBcIi4vZ2VvbWV0cnlcIjtcbmltcG9ydCBnZXRfcmFuZG9tX251bWJlciBmcm9tIFwiLi9nZXRfcmFuZG9tX251bWJlclwiO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3IgYmV0d2VlbiBtaW5pbXVtIGFuZCBtYXhpbXVtIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSBtaW5feCAtIFRoZSBtaW5pbXVtIHgtY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSBtaW5feSAtIFRoZSBtaW5pbXVtIHktY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSBtYXhfeCAtIFRoZSBtYXhpbXVtIHgtY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSBtYXhfeSAtICBUaGUgbWF4aW11bSB5LWNvb3JkaW5hdGUuXG4gKiBAcmV0dXJucyAtIEEgcmFuZG9tIHZlY3RvciBiZXR3ZWVuIG1pbmltdW0gYW5kIG1heGltdW0gaW5jbHVzaXZlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRfcmFuZG9tX3ZlY3RvcihtaW5feCwgbWluX3ksIG1heF94LCBtYXhfeSk6IENvb3JkaW5hdGUge1xuICBjb25zdCByYW5kX3ggPSBnZXRfcmFuZG9tX251bWJlcihtaW5feCwgbWF4X3gpO1xuICBjb25zdCByYW5kX3kgPSBnZXRfcmFuZG9tX251bWJlcihtaW5feSwgbWF4X3kpO1xuICByZXR1cm4gbWFrZV92ZWN0b3IocmFuZF94LCByYW5kX3kpO1xufVxuIiwiLyoqXG4gKiBPYnRhaW5zIGFuIGVsZW1lbnQncyBzcGVjaWZpYyBzdHlsZS5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gb2J0YWluIHRoZSBzdHlsZSBmcm9tLlxuICogQHBhcmFtIHByb3BlcnR5LSAgVGhlIHN0eWxlIHByb3BlcnR5IHRvIG9idGFpbi5cbiAqIEByZXR1cm5zIC0gVGhlIHZhbHVlIG9mIHRoZSBzdHlsZSBwcm9wZXJ0eS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0X3N0eWxlKGVsZW1lbnQ6IHN0cmluZywgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGh0bWxfZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpIGFzIEhUTUxFbGVtZW50O1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShodG1sX2VsZW1lbnQpO1xuICBjb25zdCB2YWx1ZSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuIiwiLyoqXG4gKiBDb252ZXJ0cyBhIHByb2JhYmlsaXR5IGZhY3RvciB0byBhIGJvb2xlYW4gdmFsdWUuXG4gKiBAcGFyYW0gZmFjdG9yIC0gVGhlIHByb2JhYmlsaXR5IGZhY3Rvci5cbiAqIEByZXR1cm5zIC0gQSBib29sZWFuIHZhbHVlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcm9iYWJpbGl0eV90b19ib29sZWFuKGZhY3RvcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpIDwgZmFjdG9yO1xufVxuIiwiLyoqXG4gKiBGdW5jdGlvbiB0byByZWFkIGEgZmlsZS5cbiAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyAtIFRoZSBkYXRhIGZyb20gdGhlIGZpbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkX2ZpbGUoZXZlbnQ6IEV2ZW50KTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgZmlsZSA9IHRhcmdldC5maWxlcyFbMF07XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlLCBcIlVURi04XCIpO1xuICAgIHJlYWRlci5vbmxvYWQgPSAoZXZlbnQ6IEV2ZW50KTogYW55ID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IChldmVudC50YXJnZXQgYXMgRmlsZVJlYWRlcikucmVzdWx0IGFzIHN0cmluZztcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICByZXNvbHZlKGRhdGEpO1xuICAgIH07XG4gIH0pO1xufVxuIiwiLy8gUmV0dXJucyB0aGUgd2VpZ2h0IGFzIGEgZmxvYXQuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3ZWlnaHRfYXNfZmxvYXQod2VpZ2h0KTogbnVtYmVyIHtcbiAgLy8gV2VpZ2h0IHJhbmdlID0gLTMyNzY4IHRvIDMyNzY3LlxuICAvLyBEaXZpZGluZyBieSA2NTUzLjYgc2NhbGVzIHRoZSB3ZWlnaHQgYmV0d2VlbiAtNSBhbmQgNS5cbiAgcmV0dXJuIHdlaWdodCAvIDY1NTMuNjtcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsImltcG9ydCB7XG4gIHJlZ2lzdGVyX2Rvd25sb2FkX25ldXJhbG5ldF9idXR0b24sXG4gIHJlZ2lzdGVyX2Zwc19zbGlkZXIsXG4gIHJlZ2lzdGVyX3JlbmRlcmluZ19lbmFibGVkX2J1dHRvbixcbiAgcmVnaXN0ZXJfc2hvd19jb250cm9scyxcbiAgcmVnaXN0ZXJfc2ltX3Jlc3RhcnRfYnV0dG9uLFxuICByZWdpc3Rlcl9zaW1fc3RhcnRfc3RvcF9idXR0b24sXG4gIHJlZ2lzdGVyX3N3aXRjaF9jaGFydCxcbn0gZnJvbSBcIi4vY29tcG9uZW50cy9CdXR0b25zXCI7XG5pbXBvcnQge1xuICBleHBvcnRfcG9wdWxhdGlvbl9idXR0b24sXG4gIHJlZ2lzdGVyX2V4cG9ydF9jb25maWdfYnV0dG9uLFxuICByZWdpc3Rlcl9leHBvcnRfZW52aXJvbm1lbnRfYnV0dG9uLFxuICByZWdpc3Rlcl9leHBvcnRfc2ltdWxhdGlvbl9idXR0b24sXG4gIHJlZ2lzdGVyX2ltcG9ydF9jb25maWdfYnV0dG9uLFxuICByZWdpc3Rlcl9pbXBvcnRfZW52aXJvbm1lbnRfYnV0dG9uLFxuICByZWdpc3Rlcl9pbXBvcnRfb3JnYW5pc21zX2J1dHRvbixcbiAgcmVnaXN0ZXJfaW1wb3J0X3NpbXVsYXRpb25fYnV0dG9uLFxufSBmcm9tIFwiLi9jb21wb25lbnRzL0ltcG9ydEV4cG9ydFwiO1xuaW1wb3J0IHsgcmVuZGVyX3NldHRpbmdzIH0gZnJvbSBcIi4vY29tcG9uZW50cy9TZXR0aW5nc1wiO1xuaW1wb3J0IFNpbXVsYXRpb24gZnJvbSBcIi4vY29udHJvbGxlcnMvc2ltdWxhdGlvbi5jb250cm9sbGVyXCI7XG5pbXBvcnQgeyBDb25maWdDb250cm9sbGVyIH0gZnJvbSBcIi4vY29udHJvbGxlcnMvY29uZmlnLmNvbnRyb2xsZXJcIjtcbmltcG9ydCB7IERlZmF1bHRTaW11bGF0aW9uQ29uZmlnIH0gZnJvbSBcIi4vY29uZmlnL3NpbXVsYXRpb24uY29uZmlnXCI7XG5cbmNvbnN0IGNvbmZpZyA9IENvbmZpZ0NvbnRyb2xsZXIuZ2V0X2luc3RhbmNlKCk7XG5cbi8vIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxuY29uZmlnLmNvbmZpZyA9IERlZmF1bHRTaW11bGF0aW9uQ29uZmlnO1xuY29uc3Qgc2ltdWxhdGlvbiA9IG5ldyBTaW11bGF0aW9uKGNvbmZpZy5jb25maWcpO1xuXG4vLyBSZW5kZXIgc2V0dGluZ3NcbnJlbmRlcl9zZXR0aW5ncyhzaW11bGF0aW9uLCBjb25maWcuY29uZmlnKTtcblxuLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgZm91ciBtYWluIGJ1dHRvbnMuXG5yZWdpc3Rlcl9zaG93X2NvbnRyb2xzKCk7XG5yZWdpc3Rlcl9yZW5kZXJpbmdfZW5hYmxlZF9idXR0b24oc2ltdWxhdGlvbik7XG5yZWdpc3Rlcl9zaW1fcmVzdGFydF9idXR0b24oKTtcbnJlZ2lzdGVyX3NpbV9zdGFydF9zdG9wX2J1dHRvbihzaW11bGF0aW9uKTtcblxuLy8gT3RoZXIgYnV0dG9ucyBpbiB0aGUgY29udHJvbCBtZW51LlxucmVnaXN0ZXJfZG93bmxvYWRfbmV1cmFsbmV0X2J1dHRvbigpO1xucmVnaXN0ZXJfZnBzX3NsaWRlcihzaW11bGF0aW9uLCBjb25maWcuY29uZmlnKTtcbnJlZ2lzdGVyX3N3aXRjaF9jaGFydChzaW11bGF0aW9uKTtcblxuLy8gSW1wb3J0IEJ1dHRvbnNcbnJlZ2lzdGVyX2ltcG9ydF9vcmdhbmlzbXNfYnV0dG9uKHNpbXVsYXRpb24pO1xucmVnaXN0ZXJfaW1wb3J0X3NpbXVsYXRpb25fYnV0dG9uKHNpbXVsYXRpb24pO1xucmVnaXN0ZXJfaW1wb3J0X2NvbmZpZ19idXR0b24oc2ltdWxhdGlvbik7XG5yZWdpc3Rlcl9pbXBvcnRfZW52aXJvbm1lbnRfYnV0dG9uKHNpbXVsYXRpb24pO1xuXG4vLyBFeHBvcnQgQnV0dG9uc1xucmVnaXN0ZXJfZXhwb3J0X2NvbmZpZ19idXR0b24oY29uZmlnLmNvbmZpZyk7XG5yZWdpc3Rlcl9leHBvcnRfZW52aXJvbm1lbnRfYnV0dG9uKHNpbXVsYXRpb24pO1xuZXhwb3J0X3BvcHVsYXRpb25fYnV0dG9uKHNpbXVsYXRpb24pO1xucmVnaXN0ZXJfZXhwb3J0X3NpbXVsYXRpb25fYnV0dG9uKHNpbXVsYXRpb24sIGNvbmZpZy5jb25maWcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9